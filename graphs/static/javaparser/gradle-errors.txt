Method 'getProject' cannot be resolved in context getProject() (line: 38) MethodCallExprContext{wrapped=getProject()}. Parameter types: []
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve field access PathSensitivity.NONE
Cannot solve method call excludePattern.substring(0, excludePattern.length() - 3) java.lang.RuntimeException: Method 'length' cannot be resolved in context excludePattern.length() (line: 112) MethodCallExprContext{wrapped=excludePattern.length()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/source/GenerateDefaultImportsTask.java
Cannot solve method call System.out.println(String.format("Multiple DSL types have short name '%s'", entry.getKey())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/source/GenerateDefaultImportsTask.java
Method 'asMap' cannot be resolved in context simpleNames.asMap() (line: 145) MethodCallExprContext{wrapped=simpleNames.asMap()}. Parameter types: []
Cannot solve name expression Pattern
Cannot solve name expression Pattern
Cannot solve name expression Pattern
Cannot solve name expression OPENING_VISIT
Cannot solve name expression OPENING_VISIT
Cannot solve name expression MetaType
Cannot solve field access MetaType.CLASS
Cannot solve name expression MetaType
Cannot solve field access MetaType.INTERFACE
Cannot solve name expression MetaType
Cannot solve field access MetaType.ENUM
Cannot solve name expression MetaType
Cannot solve field access MetaType.ANNOTATION
Cannot solve name expression OPENING_VISIT
Cannot solve name expression OPENING_VISIT
Cannot solve name expression OPENING_VISIT
Cannot solve name expression OPENING_VISIT
Cannot solve name expression OPENING_VISIT
Cannot solve name expression MODIFIERS
Cannot solve method call children.skip(MODIFIERS) UnsolvedSymbolException{context='unknown', name='org.codehaus.groovy.antlr.parser.GroovyTokenTypes', typeSolver=null} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/source/SourceMetaDataVisitor.java
Cannot solve name expression TYPE_PARAMETERS
Cannot solve method call children.skip(TYPE_PARAMETERS) UnsolvedSymbolException{context='unknown', name='org.codehaus.groovy.antlr.parser.GroovyTokenTypes', typeSolver=null} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/source/SourceMetaDataVisitor.java
Cannot solve name expression TYPE_PARAMETERS
Cannot solve method call children.skip(TYPE_PARAMETERS) UnsolvedSymbolException{context='unknown', name='org.codehaus.groovy.antlr.parser.GroovyTokenTypes', typeSolver=null} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/source/SourceMetaDataVisitor.java
Cannot solve name expression MODIFIERS
Cannot solve method call children.skip(MODIFIERS) UnsolvedSymbolException{context='unknown', name='org.codehaus.groovy.antlr.parser.GroovyTokenTypes', typeSolver=null} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/source/SourceMetaDataVisitor.java
Method 'substring' cannot be resolved in context name.substring(startName, startName + 1) (line: 195) MethodCallExprContext{wrapped=name.substring(startName, startName + 1)}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}]
Method 'substring' cannot be resolved in context name.substring(startName, startName + 1) (line: 209) MethodCallExprContext{wrapped=name.substring(startName, startName + 1)}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}]
Cannot solve name expression PARAMETERS
Cannot solve method call t.childOfType(PARAMETERS) UnsolvedSymbolException{context='unknown', name='org.codehaus.groovy.antlr.parser.GroovyTokenTypes', typeSolver=null} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/source/SourceMetaDataVisitor.java
Cannot solve name expression PARAMETER_DEF
Cannot solve name expression VARIABLE_PARAMETER_DEF
Method 'getFirstChild' cannot be resolved in context child.getFirstChild() (line: 221) MethodCallExprContext{wrapped=child.getFirstChild()}. Parameter types: []
Cannot solve name expression VARIABLE_PARAMETER_DEF
Cannot solve name expression OPENING_VISIT
Cannot solve name expression OBJBLOCK
Cannot solve name expression Modifier
Cannot solve name expression Modifier
Cannot solve name expression Modifier
Cannot solve name expression Modifier
Cannot solve name expression Modifier
Cannot solve name expression Modifier
Cannot solve name expression MODIFIERS
Cannot solve method call children.skip(MODIFIERS) UnsolvedSymbolException{context='unknown', name='org.codehaus.groovy.antlr.parser.GroovyTokenTypes', typeSolver=null} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/source/SourceMetaDataVisitor.java
Cannot solve name expression StringUtils
Cannot solve name expression String
Cannot solve method call String.format("get%s", StringUtils.capitalize(propertyName)) UnsolvedSymbolException{context='Method 'capitalize' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=org.apache.commons.lang.StringUtils}'} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/source/SourceMetaDataVisitor.java
Cannot solve method call currentClass.addMethod(String.format("get%s", StringUtils.capitalize(propertyName)), propertyType, "") java.lang.RuntimeException: Error calculating the type of parameter StringUtils.capitalize(propertyName) of method call String.format("get%s", StringUtils.capitalize(propertyName)) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/source/SourceMetaDataVisitor.java
Cannot solve name expression Modifier
Cannot solve name expression StringUtils
Cannot solve name expression String
Cannot solve method call String.format("set%s", StringUtils.capitalize(propertyName)) UnsolvedSymbolException{context='Method 'capitalize' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=org.apache.commons.lang.StringUtils}'} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/source/SourceMetaDataVisitor.java
Cannot solve name expression TypeMetaData
Cannot solve method call currentClass.addMethod(String.format("set%s", StringUtils.capitalize(propertyName)), TypeMetaData.VOID, "") java.lang.RuntimeException: Error calculating the type of parameter StringUtils.capitalize(propertyName) of method call String.format("set%s", StringUtils.capitalize(propertyName)) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/source/SourceMetaDataVisitor.java
Cannot solve name expression ASSIGN
Cannot solve method call t.childOfType(ASSIGN) UnsolvedSymbolException{context='unknown', name='org.codehaus.groovy.antlr.parser.GroovyTokenTypes', typeSolver=null} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/source/SourceMetaDataVisitor.java
Cannot solve method call extractLiteral(assign.getFirstChild()) java.lang.RuntimeException: Method 'getFirstChild' cannot be resolved in context assign.getFirstChild() (line: 281) MethodCallExprContext{wrapped=assign.getFirstChild()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/source/SourceMetaDataVisitor.java
Cannot solve name expression EXPR
Cannot solve name expression ast
Method 'getType' cannot be resolved in context ast.getType() (line: 287) MethodCallExprContext{wrapped=ast.getType()}. Parameter types: []
Cannot solve method call extractLiteral(ast.getFirstChild()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context ast.getType() (line: 287) MethodCallExprContext{wrapped=ast.getType()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/source/SourceMetaDataVisitor.java
Cannot solve name expression NUM_INT
Cannot solve name expression NUM_LONG
Cannot solve name expression NUM_FLOAT
Cannot solve name expression NUM_DOUBLE
Cannot solve name expression NUM_BIG_INT
Cannot solve name expression NUM_BIG_DECIMAL
Cannot solve name expression STRING_LITERAL
Cannot solve name expression ast
Method 'getType' cannot be resolved in context ast.getType() (line: 287) MethodCallExprContext{wrapped=ast.getType()}. Parameter types: []
Cannot solve name expression MODIFIERS
Cannot solve method call ast.childOfType(MODIFIERS) UnsolvedSymbolException{context='unknown', name='org.codehaus.groovy.antlr.parser.GroovyTokenTypes', typeSolver=null} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/source/SourceMetaDataVisitor.java
Cannot solve name expression LITERAL_private
Cannot solve name expression modifierFlags
Cannot solve name expression Modifier
Cannot solve name expression LITERAL_protected
Cannot solve name expression modifierFlags
Cannot solve name expression Modifier
Cannot solve name expression LITERAL_public
Cannot solve name expression modifierFlags
Cannot solve name expression Modifier
Cannot solve name expression FINAL
Cannot solve name expression modifierFlags
Cannot solve name expression Modifier
Cannot solve name expression LITERAL_static
Cannot solve name expression modifierFlags
Cannot solve name expression Modifier
Cannot solve name expression TYPE
Cannot solve name expression ast
Method 'getType' cannot be resolved in context ast.getType() (line: 360) MethodCallExprContext{wrapped=ast.getType()}. Parameter types: []
Cannot solve name expression type
Cannot solve method call extractTypeName(typeName, type) java.lang.RuntimeException: Method 'getType' cannot be resolved in context ast.getType() (line: 360) MethodCallExprContext{wrapped=ast.getType()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/source/SourceMetaDataVisitor.java
Cannot solve name expression WILDCARD_TYPE
Cannot solve name expression groovy
Cannot solve name expression ast
Method 'getType' cannot be resolved in context ast.getType() (line: 360) MethodCallExprContext{wrapped=ast.getType()}. Parameter types: []
Cannot solve name expression ast
Method 'getType' cannot be resolved in context ast.getType() (line: 360) MethodCallExprContext{wrapped=ast.getType()}. Parameter types: []
Cannot solve name expression TYPE_UPPER_BOUNDS
Cannot solve name expression TYPE_LOWER_BOUNDS
Cannot solve name expression type
Method 'getType' cannot be resolved in context ast.getType() (line: 360) MethodCallExprContext{wrapped=ast.getType()}. Parameter types: []
Cannot solve name expression type
Method 'getType' cannot be resolved in context ast.getType() (line: 360) MethodCallExprContext{wrapped=ast.getType()}. Parameter types: []
Cannot solve name expression type
Method 'getType' cannot be resolved in context ast.getType() (line: 360) MethodCallExprContext{wrapped=ast.getType()}. Parameter types: []
Cannot solve name expression IDENT
Cannot solve name expression DOT
Cannot solve name expression ast
Cannot solve name expression type
Cannot solve method call extractTypeName(ast, type) java.lang.RuntimeException: Method 'getType' cannot be resolved in context ast.getType() (line: 360) MethodCallExprContext{wrapped=ast.getType()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/source/SourceMetaDataVisitor.java
Cannot solve name expression ast
Cannot solve name expression String
Cannot solve method call String.format("Unexpected token in type name: %s", ast) java.lang.RuntimeException: Method 'getType' cannot be resolved in context ast.getType() (line: 360) MethodCallExprContext{wrapped=ast.getType()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/source/SourceMetaDataVisitor.java
Cannot solve name expression LITERAL_boolean
Cannot solve name expression type
Method 'getType' cannot be resolved in context ast.getType() (line: 392) MethodCallExprContext{wrapped=ast.getType()}. Parameter types: []
Cannot solve name expression LITERAL_byte
Cannot solve name expression type
Method 'getType' cannot be resolved in context ast.getType() (line: 392) MethodCallExprContext{wrapped=ast.getType()}. Parameter types: []
Cannot solve name expression LITERAL_char
Cannot solve name expression type
Method 'getType' cannot be resolved in context ast.getType() (line: 392) MethodCallExprContext{wrapped=ast.getType()}. Parameter types: []
Cannot solve name expression LITERAL_double
Cannot solve name expression type
Method 'getType' cannot be resolved in context ast.getType() (line: 392) MethodCallExprContext{wrapped=ast.getType()}. Parameter types: []
Cannot solve name expression LITERAL_float
Cannot solve name expression type
Method 'getType' cannot be resolved in context ast.getType() (line: 392) MethodCallExprContext{wrapped=ast.getType()}. Parameter types: []
Cannot solve name expression LITERAL_int
Cannot solve name expression type
Method 'getType' cannot be resolved in context ast.getType() (line: 392) MethodCallExprContext{wrapped=ast.getType()}. Parameter types: []
Cannot solve name expression LITERAL_long
Cannot solve name expression type
Method 'getType' cannot be resolved in context ast.getType() (line: 392) MethodCallExprContext{wrapped=ast.getType()}. Parameter types: []
Cannot solve name expression LITERAL_void
Cannot solve name expression type
Method 'getType' cannot be resolved in context ast.getType() (line: 392) MethodCallExprContext{wrapped=ast.getType()}. Parameter types: []
Cannot solve name expression ARRAY_DECLARATOR
Cannot solve name expression ast
Method 'getType' cannot be resolved in context ast.getType() (line: 392) MethodCallExprContext{wrapped=ast.getType()}. Parameter types: []
Cannot solve name expression type
Cannot solve method call extractTypeName((GroovySourceAST) ast.getFirstChild(), type) java.lang.RuntimeException: Method 'getType' cannot be resolved in context ast.getType() (line: 392) MethodCallExprContext{wrapped=ast.getType()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/source/SourceMetaDataVisitor.java
Cannot solve name expression type
Method 'getType' cannot be resolved in context ast.getType() (line: 392) MethodCallExprContext{wrapped=ast.getType()}. Parameter types: []
Cannot solve name expression TYPE_ARGUMENTS
Cannot solve method call ast.childOfType(TYPE_ARGUMENTS) UnsolvedSymbolException{context='unknown', name='org.codehaus.groovy.antlr.parser.GroovyTokenTypes', typeSolver=null} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/source/SourceMetaDataVisitor.java
Cannot solve name expression TYPE_ARGUMENT
Cannot solve name expression MODIFIERS
Cannot solve method call t.childOfType(MODIFIERS) UnsolvedSymbolException{context='unknown', name='org.codehaus.groovy.antlr.parser.GroovyTokenTypes', typeSolver=null} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/source/SourceMetaDataVisitor.java
Cannot solve name expression ANNOTATION
Cannot solve method call modifiers.childrenOfType(ANNOTATION) UnsolvedSymbolException{context='unknown', name='org.codehaus.groovy.antlr.parser.GroovyTokenTypes', typeSolver=null} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/source/SourceMetaDataVisitor.java
Cannot solve name expression IDENT
Cannot solve method call t.childOfType(IDENT) UnsolvedSymbolException{context='unknown', name='org.codehaus.groovy.antlr.parser.GroovyTokenTypes', typeSolver=null} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/source/SourceMetaDataVisitor.java
Error calculating the type of parameter IDENT of method call t.childOfType(IDENT)
Cannot solve name expression DOT
Cannot solve name expression IDENT
Cannot solve name expression STAR
Cannot solve name expression DOT
Cannot solve method call t.childOfType(DOT) UnsolvedSymbolException{context='unknown', name='org.codehaus.groovy.antlr.parser.GroovyTokenTypes', typeSolver=null} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/source/SourceMetaDataVisitor.java
Cannot solve name expression IDENT
Cannot solve method call t.childOfType(IDENT) UnsolvedSymbolException{context='unknown', name='org.codehaus.groovy.antlr.parser.GroovyTokenTypes', typeSolver=null} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/source/SourceMetaDataVisitor.java
Cannot solve name expression String
Cannot solve field access MetaType.CLASS
Cannot solve field access MetaType.INTERFACE
Cannot solve field access MetaType.ENUM
Cannot solve method call GUtil.isTrue(property.getRawCommentText()) java.lang.RuntimeException: Method 'getRawCommentText' cannot be resolved in context property.getRawCommentText() (line: 156) MethodCallExprContext{wrapped=property.getRawCommentText()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/source/model/ClassMetaData.java
Cannot solve method call names.add(declaredMethod.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context declaredMethod.getName() (line: 182) MethodCallExprContext{wrapped=declaredMethod.getName()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/source/model/ClassMetaData.java
Method 'getOverrideSignature' cannot be resolved in context method.getOverrideSignature() (line: 189) MethodCallExprContext{wrapped=method.getOverrideSignature()}. Parameter types: []
Method 'getName' cannot be resolved in context method.getName() (line: 199) MethodCallExprContext{wrapped=method.getName()}. Parameter types: []
Method 'getName' cannot be resolved in context enumConstant.getName() (line: 262) MethodCallExprContext{wrapped=enumConstant.getName()}. Parameter types: []
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call name.equals(StringUtils.substringAfterLast(outerClassName, ".")) UnsolvedSymbolException{context='Method 'substringAfterLast' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=org.apache.commons.lang.StringUtils}'} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/source/TypeNameResolver.java
Cannot resolve field access null
Cannot solve field access LinkMetaData.Style.Javadoc
Cannot resolve field access null
Cannot solve field access LinkMetaData.Style.Groovydoc
Cannot solve method call method.substring(0, method.length() - 4) java.lang.RuntimeException: Method 'length' cannot be resolved in context method.length() (line: 69) MethodCallExprContext{wrapped=method.length()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/links/ClassLinkMetaData.java
Cannot solve method call String.format("Found multiple methods called '%s' in class '%s'. Candidates: %s", method, className, CollectionUtils.join(", ", candidates)) UnsolvedSymbolException{context='Method 'join' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{org.gradle.build.docs.dsl.links.ClassLinkMetaData.MethodLinkMetaData, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class CollectionUtils {

    /**
     * Returns null if the collection is empty otherwise expects a {@link #single(Iterable)} element to be found.
     */
    @Nullable
    public static <T> T findSingle(Collection<T> source) {
        return source.isEmpty() ? null : single(source);
    }

    /**
     * Returns the single element in the collection or throws.
     */
    public static <T> T single(Iterable<? extends T> source) {
        Iterator<? extends T> iterator = source.iterator();
        if (!iterator.hasNext()) {
            throw new NoSuchElementException("Expecting collection with single element, got none.");
        }
        T element = iterator.next();
        if (iterator.hasNext()) {
            throw new IllegalArgumentException("Expecting collection with single element, got multiple.");
        }
        return element;
    }

    public static <T> Collection<? extends T> checkedCast(Class<T> type, Collection<?> input) {
        for (Object o : input) {
            cast(type, o);
        }
        return Cast.uncheckedCast(input);
    }

    public static <T> T findFirst(Iterable<? extends T> source, Spec<? super T> filter) {
        for (T item : source) {
            if (filter.isSatisfiedBy(item)) {
                return item;
            }
        }
        return null;
    }

    public static <T> T findFirst(T[] source, Spec<? super T> filter) {
        for (T thing : source) {
            if (filter.isSatisfiedBy(thing)) {
                return thing;
            }
        }
        return null;
    }

    public static <T> T first(Iterable<? extends T> source) {
        return source.iterator().next();
    }

    public static <T> boolean any(Iterable<? extends T> source, Spec<? super T> filter) {
        return findFirst(source, filter) != null;
    }

    public static <T> boolean any(T[] source, Spec<? super T> filter) {
        return findFirst(source, filter) != null;
    }

    public static <T> Set<T> filter(Set<? extends T> set, Spec<? super T> filter) {
        return filter(set, new LinkedHashSet<T>(), filter);
    }

    public static <T> List<T> filter(List<? extends T> list, Spec<? super T> filter) {
        return filter(list, new LinkedList<T>(), filter);
    }

    public static <T> List<T> filter(T[] array, Spec<? super T> filter) {
        return filter(Arrays.asList(array), new LinkedList<T>(), filter);
    }

    /**
     * Returns a sorted copy of the provided collection of things. Uses the provided comparator to sort.
     */
    public static <T> List<T> sort(Iterable<? extends T> things, Comparator<? super T> comparator) {
        List<T> copy = toMutableList(things);
        Collections.sort(copy, comparator);
        return copy;
    }

    /**
     * Returns a sorted copy of the provided collection of things. Uses the natural ordering of the things.
     */
    public static <T extends Comparable> List<T> sort(Iterable<T> things) {
        List<T> copy = toMutableList(things);
        Collections.sort(copy);
        return copy;
    }

    public static <T, C extends Collection<T>> C filter(Iterable<? extends T> source, C destination, Spec<? super T> filter) {
        for (T item : source) {
            if (filter.isSatisfiedBy(item)) {
                destination.add(item);
            }
        }
        return destination;
    }

    public static <K, V> Map<K, V> filter(Map<K, V> map, Spec<Map.Entry<K, V>> filter) {
        return filter(map, new HashMap<K, V>(), filter);
    }

    public static <K, V> Map<K, V> filter(Map<K, V> map, Map<K, V> destination, Spec<Map.Entry<K, V>> filter) {
        for (Map.Entry<K, V> entry : map.entrySet()) {
            if (filter.isSatisfiedBy(entry)) {
                destination.put(entry.getKey(), entry.getValue());
            }
        }
        return destination;
    }

    public static <R, I> R[] collectArray(I[] list, Class<R> newType, Transformer<? extends R, ? super I> transformer) {
        @SuppressWarnings("unchecked") R[] destination = (R[]) Array.newInstance(newType, list.length);
        return collectArray(list, destination, transformer);
    }

    public static <R, I> R[] collectArray(I[] list, R[] destination, Transformer<? extends R, ? super I> transformer) {
        assert list.length <= destination.length;
        for (int i = 0; i < list.length; ++i) {
            destination[i] = transformer.transform(list[i]);
        }
        return destination;
    }

    public static <R, I> List<R> collect(List<? extends I> list, Transformer<? extends R, ? super I> transformer) {
        return collect(list, new ArrayList<R>(list.size()), transformer);
    }

    public static <R, I> List<R> collect(I[] list, Transformer<? extends R, ? super I> transformer) {
        return collect(Arrays.asList(list), transformer);
    }

    public static <R, I> Set<R> collect(Set<? extends I> set, Transformer<? extends R, ? super I> transformer) {
        return collect(set, new HashSet<R>(), transformer);
    }

    public static <R, I> List<R> collect(Iterable<? extends I> source, Transformer<? extends R, ? super I> transformer) {
        return collect(source, new LinkedList<R>(), transformer);
    }

    public static <R, I, C extends Collection<R>> C collect(Iterable<? extends I> source, C destination, Transformer<? extends R, ? super I> transformer) {
        for (I item : source) {
            destination.add(transformer.transform(item));
        }
        return destination;
    }

    public static List<String> toStringList(Iterable<?> iterable) {
        return collect(iterable, new LinkedList<String>(), Transformers.asString());
    }

    /**
     * Recursively unpacks all the given things into a flat list.
     *
     * Nulls are not removed, they are left intact.
     *
     * @param things The things to flatten
     * @return A flattened list of the given things
     */
    public static List<?> flattenCollections(Object... things) {
        return flattenCollections(Object.class, things);
    }

    /**
     * Recursively unpacks all the given things into a flat list, ensuring they are of a certain type.
     *
     * Nulls are not removed, they are left intact.
     *
     * If a non null object cannot be cast to the target type, a ClassCastException will be thrown.
     *
     * @param things The things to flatten
     * @param <T> The target type in the flattened list
     * @return A flattened list of the given things
     */
    public static <T> List<T> flattenCollections(Class<T> type, Object... things) {
        if (things == null) {
            return Collections.singletonList(null);
        } else if (things.length == 0) {
            return Collections.emptyList();
        } else if (things.length == 1) {
            Object thing = things[0];
            if (thing == null) {
                return Collections.singletonList(null);
            }
            if (thing.getClass().isArray()) {
                Object[] thingArray = (Object[]) thing;
                List<T> list = new ArrayList<T>(thingArray.length);
                for (Object thingThing : thingArray) {
                    list.addAll(flattenCollections(type, thingThing));
                }
                return list;
            }
            if (thing instanceof Collection) {
                Collection<?> collection = (Collection<?>) thing;
                List<T> list = new ArrayList<T>();
                for (Object element : collection) {
                    list.addAll(flattenCollections(type, element));
                }
                return list;
            }
            return Collections.singletonList(cast(type, thing));
        } else {
            List<T> list = new ArrayList<T>();
            for (Object thing : things) {
                list.addAll(flattenCollections(type, thing));
            }
            return list;
        }
    }

    public static <T> List<T> toList(Iterable<? extends T> things) {
        if (things instanceof List) {
            @SuppressWarnings("unchecked") List<T> castThings = (List<T>) things;
            return castThings;
        }
        return toMutableList(things);
    }

    public static <T> List<T> toList(Enumeration<? extends T> things) {
        AbstractList<T> list = new ArrayList<T>();
        while (things.hasMoreElements()) {
            list.add(things.nextElement());
        }
        return list;
    }

    private static <T> List<T> toMutableList(Iterable<? extends T> things) {
        if (things == null) {
            return new ArrayList<T>(0);
        }
        List<T> list = new ArrayList<T>();
        for (T thing : things) {
            list.add(thing);
        }
        return list;
    }

    public static <T> List<T> intersection(Collection<? extends Collection<T>> availableValuesByDescriptor) {
        List<T> result = new ArrayList<T>();
        Iterator<? extends Collection<T>> iterator = availableValuesByDescriptor.iterator();
        if (iterator.hasNext()) {
            Collection<T> firstSet = iterator.next();
            result.addAll(firstSet);
            while (iterator.hasNext()) {
                Collection<T> next = iterator.next();
                result.retainAll(next);
            }
        }
        return result;
    }

    public static <T> List<T> toList(T[] things) {
        if (things == null || things.length == 0) {
            return new ArrayList<T>(0);
        }
        List<T> list = new ArrayList<T>(things.length);
        Collections.addAll(list, things);
        return list;
    }

    public static <T> Set<T> toSet(Iterable<? extends T> things) {
        if (things == null) {
            return new HashSet<T>(0);
        }
        if (things instanceof Set) {
            @SuppressWarnings("unchecked") Set<T> castThings = (Set<T>) things;
            return castThings;
        }
        Set<T> set = new LinkedHashSet<T>();
        for (T thing : things) {
            set.add(thing);
        }
        return set;
    }

    public static <E> List<E> compact(List<E> list) {
        boolean foundAtLeastOneNull = false;
        List<E> compacted = null;
        int i = 0;
        for (E element : list) {
            if (element == null) {
                if (!foundAtLeastOneNull) {
                    compacted = new ArrayList<E>(list.size());
                    if (i > 0) {
                        compacted.addAll(list.subList(0, i));
                    }
                }
                foundAtLeastOneNull = true;
            } else if (foundAtLeastOneNull) {
                compacted.add(element);
            }
            ++i;
        }
        return foundAtLeastOneNull ? compacted : list;
    }

    public static <C extends Collection<String>> C stringize(Iterable<?> source, C destination) {
        return collect(source, destination, Transformers.asString());
    }

    public static List<String> stringize(Collection<?> source) {
        return stringize(source, new ArrayList<String>(source.size()));
    }

    public static <E> boolean replace(List<E> list, Spec<? super E> filter, Transformer<? extends E, ? super E> transformer) {
        boolean replaced = false;
        int i = 0;
        for (E it : list) {
            if (filter.isSatisfiedBy(it)) {
                list.set(i, transformer.transform(it));
                replaced = true;
            }
            ++i;
        }
        return replaced;
    }

    public static <K, V> void collectMap(Map<K, V> destination, Iterable<? extends V> items, Transformer<? extends K, ? super V> keyGenerator) {
        for (V item : items) {
            destination.put(keyGenerator.transform(item), item);
        }
    }

    /**
     * Given a set of values, derive a set of keys and return a map
     */
    public static <K, V> Map<K, V> collectMap(Iterable<? extends V> items, Transformer<? extends K, ? super V> keyGenerator) {
        Map<K, V> map = new LinkedHashMap<K, V>();
        collectMap(map, items, keyGenerator);
        return map;
    }

    public static <K, V> void collectMapValues(Map<K, V> destination, Iterable<? extends K> keys, Transformer<? extends V, ? super K> keyGenerator) {
        for (K item : keys) {
            destination.put(item, keyGenerator.transform(item));
        }
    }

    /**
     * Given a set of keys, derive a set of values and return a map
     */
    public static <K, V> Map<K, V> collectMapValues(Iterable<? extends K> keys, Transformer<? extends V, ? super K> keyGenerator) {
        Map<K, V> map = new LinkedHashMap<K, V>();
        collectMapValues(map, keys, keyGenerator);
        return map;
    }

    public static <T> boolean every(Iterable<? extends T> things, Spec<? super T> predicate) {
        for (T thing : things) {
            if (!predicate.isSatisfiedBy(thing)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Utility for adding an iterable to a collection.
     *
     * @param t1 The collection to add to
     * @param t2 The iterable to add each item of to the collection
     * @param <T> The element type of t1
     * @return t1
     */
    public static <T> Collection<T> addAll(Collection<T> t1, Iterable<? extends T> t2) {
        for (T t : t2) {
            t1.add(t);
        }
        return t1;
    }

    /**
     * Utility for adding an array to a collection.
     *
     * @param t1 The collection to add to
     * @param t2 The iterable to add each item of to the collection
     * @param <T> The element type of t1
     * @return t1
     */
    public static <T> Collection<T> addAll(Collection<T> t1, T... t2) {
        Collections.addAll(t1, t2);
        return t1;
    }

    /**
     * The result of diffing two sets.
     *
     * @param <T> The type of element the sets contain
     * @see CollectionUtils#diffSetsBy(java.util.Set, java.util.Set, org.gradle.api.Transformer)
     */
    public static class SetDiff<T> {

        public Set<T> leftOnly = new HashSet<T>();

        public Set<Pair<T, T>> common = new HashSet<Pair<T, T>>();

        public Set<T> rightOnly = new HashSet<T>();
    }

    /**
     * Provides a “diff report” of how the two sets are similar and how they are different, comparing the entries by some aspect.
     *
     * The transformer is used to generate the value to use to compare the entries by. That is, the entries are not compared by equals by an attribute or characteristic.
     *
     * The transformer is expected to produce a unique value for each entry in a single set. Behaviour is undefined if this condition is not met.
     *
     * @param left The set on the “left” side of the comparison.
     * @param right The set on the “right” side of the comparison.
     * @param compareBy Provides the value to compare entries from either side by
     * @param <T> The type of the entry objects
     * @return A representation of the difference
     */
    public static <T> SetDiff<T> diffSetsBy(Set<? extends T> left, Set<? extends T> right, Transformer<?, T> compareBy) {
        if (left == null) {
            throw new NullPointerException("'left' set is null");
        }
        if (right == null) {
            throw new NullPointerException("'right' set is null");
        }
        SetDiff<T> setDiff = new SetDiff<T>();
        Map<Object, T> indexedLeft = collectMap(left, compareBy);
        Map<Object, T> indexedRight = collectMap(right, compareBy);
        for (Map.Entry<Object, T> leftEntry : indexedLeft.entrySet()) {
            T rightValue = indexedRight.remove(leftEntry.getKey());
            if (rightValue == null) {
                setDiff.leftOnly.add(leftEntry.getValue());
            } else {
                Pair<T, T> pair = Pair.of(leftEntry.getValue(), rightValue);
                setDiff.common.add(pair);
            }
        }
        for (T rightValue : indexedRight.values()) {
            setDiff.rightOnly.add(rightValue);
        }
        return setDiff;
    }

    /**
     * Creates a string with {@code toString()} of each object with the given separator.
     *
     * <pre>
     * expect:
     * join(",", new Object[]{"a"}) == "a"
     * join(",", new Object[]{"a", "b", "c"}) == "a,b,c"
     * join(",", new Object[]{}) == ""
     * </pre>
     *
     * The {@code separator} must not be null and {@code objects} must not be null.
     *
     * @param separator The string by which to join each string representation
     * @param objects The objects to join the string representations of
     * @return The joined string
     */
    public static String join(String separator, Object[] objects) {
        return join(separator, objects == null ? null : Arrays.asList(objects));
    }

    /**
     * Creates a string with {@code toString()} of each object with the given separator.
     *
     * <pre>
     * expect:
     * join(",", ["a"]) == "a"
     * join(",", ["a", "b", "c"]) == "a,b,c"
     * join(",", []) == ""
     * </pre>
     *
     * The {@code separator} must not be null and {@code objects} must not be null.
     *
     * @param separator The string by which to join each string representation
     * @param objects The objects to join the string representations of
     * @return The joined string
     */
    public static String join(String separator, Iterable<?> objects) {
        if (separator == null) {
            throw new NullPointerException("The 'separator' cannot be null");
        }
        if (objects == null) {
            throw new NullPointerException("The 'objects' cannot be null");
        }
        StringBuilder string = new StringBuilder();
        Iterator<?> iterator = objects.iterator();
        if (iterator.hasNext()) {
            string.append(iterator.next().toString());
            while (iterator.hasNext()) {
                string.append(separator);
                string.append(iterator.next().toString());
            }
        }
        return string.toString();
    }

    /**
     * Partition given Collection into a Pair of Collections.
     *
     * <pre>Left</pre> Collection containing entries that satisfy the given predicate
     * <pre>Right</pre> Collection containing entries that do NOT satisfy the given predicate
     */
    public static <T> Pair<Collection<T>, Collection<T>> partition(Iterable<T> items, Spec<? super T> predicate) {
        Preconditions.checkNotNull(items, "Cannot partition null Collection");
        Preconditions.checkNotNull(predicate, "Cannot apply null Spec when partitioning");
        Collection<T> left = new LinkedList<T>();
        Collection<T> right = new LinkedList<T>();
        for (T item : items) {
            if (predicate.isSatisfiedBy(item)) {
                left.add(item);
            } else {
                right.add(item);
            }
        }
        return Pair.of(left, right);
    }

    public static class InjectionStep<T, I> {

        private final T target;

        private final I item;

        public InjectionStep(T target, I item) {
            this.target = target;
            this.item = item;
        }

        public T getTarget() {
            return target;
        }

        public I getItem() {
            return item;
        }
    }

    public static <T, I> T inject(T target, Iterable<? extends I> items, Action<InjectionStep<T, I>> action) {
        if (target == null) {
            throw new NullPointerException("The 'target' cannot be null");
        }
        if (items == null) {
            throw new NullPointerException("The 'items' cannot be null");
        }
        if (action == null) {
            throw new NullPointerException("The 'action' cannot be null");
        }
        for (I item : items) {
            action.execute(new InjectionStep<T, I>(target, item));
        }
        return target;
    }

    public static <K, V> ImmutableListMultimap<K, V> groupBy(Iterable<? extends V> iterable, Transformer<? extends K, V> grouper) {
        ImmutableListMultimap.Builder<K, V> builder = ImmutableListMultimap.builder();
        for (V element : iterable) {
            K key = grouper.transform(element);
            builder.put(key, element);
        }
        return builder.build();
    }

    public static <T> Iterable<? extends T> unpack(final Iterable<? extends Factory<? extends T>> factories) {
        return new Iterable<T>() {

            private final Iterator<? extends Factory<? extends T>> delegate = factories.iterator();

            public Iterator<T> iterator() {
                return new Iterator<T>() {

                    public boolean hasNext() {
                        return delegate.hasNext();
                    }

                    public T next() {
                        return delegate.next().create();
                    }

                    public void remove() {
                        throw new UnsupportedOperationException();
                    }
                };
            }
        };
    }

    @Nullable
    public static <T> List<T> nonEmptyOrNull(Iterable<T> iterable) {
        ImmutableList<T> list = ImmutableList.copyOf(iterable);
        return list.isEmpty() ? null : list;
    }

    public static <T> List<T> dedup(Iterable<T> source, final Equivalence<? super T> equivalence) {
        Iterable<Equivalence.Wrapper<T>> wrappers = Iterables.transform(source, new Function<T, Equivalence.Wrapper<T>>() {

            public Equivalence.Wrapper<T> apply(@Nullable T input) {
                return equivalence.wrap(input);
            }
        });
        Set<Equivalence.Wrapper<T>> deduped = ImmutableSet.copyOf(wrappers);
        return ImmutableList.copyOf(Iterables.transform(deduped, new Function<Equivalence.Wrapper<T>, T>() {

            public T apply(Equivalence.Wrapper<T> input) {
                return input.get();
            }
        }));
    }

    public static String asCommandLine(Iterable<String> arguments) {
        return Joiner.on(" ").join(collect(arguments, Transformers.asSafeCommandLineArgument()));
    }
}}'} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/links/ClassLinkMetaData.java
Cannot resolve field access null
Cannot solve field access LinkMetaData.Style.Dsldoc
Cannot resolve field access null
Cannot solve field access LinkMetaData.Style.Dsldoc
Cannot resolve field access null
Cannot solve field access LinkMetaData.Style.Dsldoc
Cannot solve method call javadocConverter.parse(classDoc.getClassMetaData(), listener) java.lang.RuntimeException: Method 'getClassMetaData' cannot be resolved in context classDoc.getClassMetaData() (line: 34) MethodCallExprContext{wrapped=classDoc.getClassMetaData()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocCommentBuilder.java
Error calculating the type of parameter classDoc.getClassMetaData() of method call javadocConverter.parse(classDoc.getClassMetaData(), listener)
Cannot solve method call classDoc.setComment(javadocConverter.parse(classDoc.getClassMetaData(), listener).getDocbook()) java.lang.RuntimeException: Error calculating the type of parameter classDoc.getClassMetaData() of method call javadocConverter.parse(classDoc.getClassMetaData(), listener) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocCommentBuilder.java
Cannot solve method call String.format("class %s", classDoc.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context classDoc.getName() (line: 38) MethodCallExprContext{wrapped=classDoc.getName()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocBuilder.java
Cannot solve method call listener.start(String.format("class %s", classDoc.getName())) java.lang.RuntimeException: Error calculating the type of parameter classDoc.getName() of method call String.format("class %s", classDoc.getName()) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocBuilder.java
Cannot solve method call String.format("class %s", classDoc.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context classDoc.getName() (line: 37) MethodCallExprContext{wrapped=classDoc.getName()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocRenderer.java
Cannot solve method call listener.start(String.format("class %s", classDoc.getName())) java.lang.RuntimeException: Error calculating the type of parameter classDoc.getName() of method call String.format("class %s", classDoc.getName()) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocRenderer.java
Method 'getOwnerDocument' cannot be resolved in context parent.getOwnerDocument() (line: 39) MethodCallExprContext{wrapped=parent.getOwnerDocument()}. Parameter types: []
Cannot solve method call chapter.setAttribute("id", classDoc.getId()) java.lang.RuntimeException: Method 'getId' cannot be resolved in context classDoc.getId() (line: 41) MethodCallExprContext{wrapped=classDoc.getId()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocRenderer.java
Method 'getTagName' cannot be resolved in context childElement.getTagName() (line: 34) MethodCallExprContext{wrapped=childElement.getTagName()}. Parameter types: []
Cannot solve method call String.format("No <%s> element found in <%s>", childName, element.getTagName()) java.lang.RuntimeException: Method 'getTagName' cannot be resolved in context element.getTagName() (line: 47) MethodCallExprContext{wrapped=element.getTagName()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ModelBuilderSupport.java
Method 'getTagName' cannot be resolved in context childElement.getTagName() (line: 56) MethodCallExprContext{wrapped=childElement.getTagName()}. Parameter types: []
Cannot solve method call LOGGER.warn(String.format("%s: %s", contextStack.getFirst(), message)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/DefaultGenerationListener.java
Cannot solve method call listener.warning(String.format("Could not convert Javadoc link '%s'", link)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocLinkConverter.java
Cannot solve method call element.appendChild(document.createTextNode(link)) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode(link) (line: 63) MethodCallExprContext{wrapped=document.createTextNode(link)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocLinkConverter.java
Cannot solve method call signature.append(typeNameResolver.resolve(typeMatcher.group(1), classMetaData)) java.lang.RuntimeException: Method 'resolve' cannot be resolved in context typeNameResolver.resolve(typeMatcher.group(1), classMetaData) (line: 110) MethodCallExprContext{wrapped=typeNameResolver.resolve(typeMatcher.group(1), classMetaData)}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.build.docs.dsl.source.model.ClassMetaData, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocLinkConverter.java
Cannot resolve field access null
Cannot solve method call listener.warning(String.format("Could not locate target class '%s' for field value link '%s'", targetClass, fieldName)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.build.docs.dsl.source.model.ClassMetaData, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocLinkConverter.java
Cannot solve method call element.appendChild(document.createTextNode(targetClassName + ":" + parts[1])) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode(targetClassName + ":" + parts[1]) (line: 163) MethodCallExprContext{wrapped=document.createTextNode(targetClassName + ":" + parts[1])}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocLinkConverter.java
Cannot solve method call listener.warning(String.format("Field '%s' does not have any value", fieldName)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocLinkConverter.java
Cannot solve method call element.appendChild(document.createTextNode(targetClass.getClassName() + ":" + parts[1])) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode(targetClass.getClassName() + ":" + parts[1]) (line: 174) MethodCallExprContext{wrapped=document.createTextNode(targetClass.getClassName() + ":" + parts[1])}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocLinkConverter.java
Cannot solve method call element.appendChild(document.createTextNode(value)) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode(value) (line: 183) MethodCallExprContext{wrapped=document.createTextNode(value)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocLinkConverter.java
Cannot solve method call td.appendChild(document.createTextNode("Block")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("Block") (line: 39) MethodCallExprContext{wrapped=document.createTextNode("Block")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlockTableRenderer.java
Cannot solve method call td.appendChild(document.createTextNode("Description")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("Description") (line: 42) MethodCallExprContext{wrapped=document.createTextNode("Description")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlockTableRenderer.java
Cannot solve method call link.setAttribute("linkend", blockDoc.getId()) java.lang.RuntimeException: Method 'getId' cannot be resolved in context blockDoc.getId() (line: 56) MethodCallExprContext{wrapped=blockDoc.getId()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlockTableRenderer.java
Cannot solve method call document.createTextNode(blockDoc.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context blockDoc.getName() (line: 59) MethodCallExprContext{wrapped=blockDoc.getName()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlockTableRenderer.java
Cannot solve method call literal.appendChild(document.createTextNode(blockDoc.getName())) java.lang.RuntimeException: Error calculating the type of parameter blockDoc.getName() of method call document.createTextNode(blockDoc.getName()) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlockTableRenderer.java
Cannot solve method call caution.appendChild(document.createTextNode("Deprecated")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("Deprecated") (line: 66) MethodCallExprContext{wrapped=document.createTextNode("Deprecated")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlockTableRenderer.java
Cannot solve method call caution.appendChild(document.createTextNode("Incubating")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("Incubating") (line: 71) MethodCallExprContext{wrapped=document.createTextNode("Incubating")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlockTableRenderer.java
Cannot solve method call document.importNode(blockDoc.getDescription(), true) java.lang.RuntimeException: Method 'getDescription' cannot be resolved in context blockDoc.getDescription() (line: 73) MethodCallExprContext{wrapped=blockDoc.getDescription()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlockTableRenderer.java
Cannot solve method call td.appendChild(document.importNode(blockDoc.getDescription(), true)) java.lang.RuntimeException: Error calculating the type of parameter blockDoc.getDescription() of method call document.importNode(blockDoc.getDescription(), true) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlockTableRenderer.java
Cannot solve method call ENTITIES.get(scanner.region().toLowerCase()) java.lang.RuntimeException: Method 'toLowerCase' cannot be resolved in context scanner.region().toLowerCase() (line: 115) MethodCallExprContext{wrapped=scanner.region().toLowerCase()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BasicJavadocLexer.java
Cannot solve method call getChild(classDoc.getPropertiesTable(), "thead") java.lang.RuntimeException: Method 'getPropertiesTable' cannot be resolved in context classDoc.getPropertiesTable() (line: 45) MethodCallExprContext{wrapped=classDoc.getPropertiesTable()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocPropertiesBuilder.java
Cannot solve method call inheritedValueTitleMapping.put(override.getTextContent(), element) java.lang.RuntimeException: Method 'getTextContent' cannot be resolved in context override.getTextContent() (line: 58) MethodCallExprContext{wrapped=override.getTextContent()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocPropertiesBuilder.java
Method 'getTextContent' cannot be resolved in context firstChild.getTextContent() (line: 62) MethodCallExprContext{wrapped=firstChild.getTextContent()}. Parameter types: []
Cannot solve method call firstChild.setTextContent(firstChild.getTextContent().replaceFirst("^\\s+", "")) java.lang.RuntimeException: Method 'getTextContent' cannot be resolved in context firstChild.getTextContent() (line: 62) MethodCallExprContext{wrapped=firstChild.getTextContent()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocPropertiesBuilder.java
Method 'getTextContent' cannot be resolved in context lastChild.getTextContent() (line: 66) MethodCallExprContext{wrapped=lastChild.getTextContent()}. Parameter types: []
Cannot solve method call lastChild.setTextContent(lastChild.getTextContent().replaceFirst("\\s+$", "")) java.lang.RuntimeException: Method 'getTextContent' cannot be resolved in context lastChild.getTextContent() (line: 66) MethodCallExprContext{wrapped=lastChild.getTextContent()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocPropertiesBuilder.java
Cannot solve method call LOG.info("Getting properties for {}", superType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context superType.getName() (line: 75) MethodCallExprContext{wrapped=superType.getName()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocPropertiesBuilder.java
Cannot solve method call additionalValues.put(newAttribute.getKey(), newAttribute) java.lang.RuntimeException: Method 'getKey' cannot be resolved in context newAttribute.getKey() (line: 82) MethodCallExprContext{wrapped=newAttribute.getKey()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocPropertiesBuilder.java
Cannot solve method call props.put(propertyDoc.getName(), propertyDoc.forClass(classDoc, additionalValues.values())) java.lang.RuntimeException: Method 'getName' cannot be resolved in context propertyDoc.getName() (line: 88) MethodCallExprContext{wrapped=propertyDoc.getName()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocPropertiesBuilder.java
Method 'getTextContent' cannot be resolved in context cells.get(0).getTextContent() (line: 97) MethodCallExprContext{wrapped=cells.get(0).getTextContent()}. Parameter types: []
Method 'getClassMetaData' cannot be resolved in context classDoc.getClassMetaData() (line: 98) MethodCallExprContext{wrapped=classDoc.getClassMetaData()}. Parameter types: []
Method 'getClassMetaData' cannot be resolved in context classDoc.getClassMetaData() (line: 100) MethodCallExprContext{wrapped=classDoc.getClassMetaData()}. Parameter types: []
Cannot solve method call String.format("No metadata for property '%s.%s'. Available properties: %s", classDoc.getName(), propName, classDoc.getClassMetaData().getPropertyNames()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context classDoc.getName() (line: 100) MethodCallExprContext{wrapped=classDoc.getName()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocPropertiesBuilder.java
Cannot solve method call additionalValues.put(attributeDoc.getKey(), attributeDoc) java.lang.RuntimeException: Method 'getKey' cannot be resolved in context attributeDoc.getKey() (line: 109) MethodCallExprContext{wrapped=attributeDoc.getKey()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocPropertiesBuilder.java
Cannot solve method call additionalValues.put(attributeDoc.getKey(), attributeDoc) java.lang.RuntimeException: Method 'getKey' cannot be resolved in context attributeDoc.getKey() (line: 119) MethodCallExprContext{wrapped=attributeDoc.getKey()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocPropertiesBuilder.java
Method 'parse' cannot be resolved in context javadocConverter.parse(property, listener) (line: 121) MethodCallExprContext{wrapped=javadocConverter.parse(property, listener)}. Parameter types: [ReferenceType{org.gradle.build.docs.dsl.source.model.PropertyMetaData, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{GenerationListener, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call String.format("Docbook content for '%s.%s' does not contain a description paragraph.", classDoc.getName(), propName) java.lang.RuntimeException: Method 'getName' cannot be resolved in context classDoc.getName() (line: 123) MethodCallExprContext{wrapped=classDoc.getName()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocPropertiesBuilder.java
Cannot solve method call children(classDoc.getPropertiesTable(), "tr") java.lang.RuntimeException: Method 'getPropertiesTable' cannot be resolved in context classDoc.getPropertiesTable() (line: 92) MethodCallExprContext{wrapped=classDoc.getPropertiesTable()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocPropertiesBuilder.java
Method 'getInterfaces' cannot be resolved in context classDoc.getInterfaces() (line: 50) MethodCallExprContext{wrapped=classDoc.getInterfaces()}. Parameter types: []
Cannot solve method call linkElement.appendChild(document.createTextNode(text)) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode(text) (line: 53) MethodCallExprContext{wrapped=document.createTextNode(text)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/LinkRenderer.java
Method 'getChildNodes' cannot be resolved in context linkElement.getChildNodes() (line: 62) MethodCallExprContext{wrapped=linkElement.getChildNodes()}. Parameter types: []
Cannot solve method call classNameElement.appendChild(document.createTextNode(className)) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode(className) (line: 77) MethodCallExprContext{wrapped=document.createTextNode(className)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/LinkRenderer.java
Cannot solve method call String.format("http://download.oracle.com/javase/1.5.0/docs/api/%s.html", className.replace(".", "/")) java.lang.RuntimeException: Method 'replace' cannot be resolved in context className.replace(".", "/") (line: 84) MethodCallExprContext{wrapped=className.replace(".", "/")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/LinkRenderer.java
Cannot solve method call linkElement.setAttribute("url", String.format("http://download.oracle.com/javase/1.5.0/docs/api/%s.html", className.replace(".", "/"))) java.lang.RuntimeException: Error calculating the type of parameter className.replace(".", "/") of method call String.format("http://download.oracle.com/javase/1.5.0/docs/api/%s.html", className.replace(".", "/")) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/LinkRenderer.java
Cannot solve method call document.createTextNode(StringUtils.substringAfterLast(className, ".")) UnsolvedSymbolException{context='Method 'substringAfterLast' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=org.apache.commons.lang.StringUtils}'} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/LinkRenderer.java
Cannot solve method call classNameElement.appendChild(document.createTextNode(StringUtils.substringAfterLast(className, "."))) java.lang.RuntimeException: Error calculating the type of parameter StringUtils.substringAfterLast(className, ".") of method call document.createTextNode(StringUtils.substringAfterLast(className, ".")) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/LinkRenderer.java
Cannot solve method call String.format("http://groovy.codehaus.org/gapi/%s.html", className.replace(".", "/")) java.lang.RuntimeException: Method 'replace' cannot be resolved in context className.replace(".", "/") (line: 93) MethodCallExprContext{wrapped=className.replace(".", "/")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/LinkRenderer.java
Cannot solve method call linkElement.setAttribute("url", String.format("http://groovy.codehaus.org/gapi/%s.html", className.replace(".", "/"))) java.lang.RuntimeException: Error calculating the type of parameter className.replace(".", "/") of method call String.format("http://groovy.codehaus.org/gapi/%s.html", className.replace(".", "/")) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/LinkRenderer.java
Cannot solve method call document.createTextNode(StringUtils.substringAfterLast(className, ".")) UnsolvedSymbolException{context='Method 'substringAfterLast' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=org.apache.commons.lang.StringUtils}'} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/LinkRenderer.java
Cannot solve method call classNameElement.appendChild(document.createTextNode(StringUtils.substringAfterLast(className, "."))) java.lang.RuntimeException: Error calculating the type of parameter StringUtils.substringAfterLast(className, ".") of method call document.createTextNode(StringUtils.substringAfterLast(className, ".")) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/LinkRenderer.java
Cannot solve method call listener.warning(String.format("Could not generate link for unknown class '%s'", className)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/LinkRenderer.java
Cannot solve method call element.appendChild(document.createTextNode(className)) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode(className) (line: 106) MethodCallExprContext{wrapped=document.createTextNode(className)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/LinkRenderer.java
Cannot solve method call listener.warning(String.format("Could not generate link for method %s", method)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.build.docs.dsl.source.model.MethodMetaData, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/LinkRenderer.java
Cannot solve method call document.createTextNode(String.format("%s.%s()", method.getOwnerClass().getClassName(), method.getName())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/LinkRenderer.java
Cannot solve method call element.appendChild(document.createTextNode(String.format("%s.%s()", method.getOwnerClass().getClassName(), method.getName()))) java.lang.RuntimeException: Error calculating the type of parameter String.format("%s.%s()", method.getOwnerClass().getClassName(), method.getName()) of method call document.createTextNode(String.format("%s.%s()", method.getOwnerClass().getClassName(), method.getName())) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/LinkRenderer.java
Cannot solve method call listener.warning(String.format("Could not generate link for enum constant %s", enumConstant)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.build.docs.dsl.source.model.EnumConstantMetaData, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/LinkRenderer.java
Cannot solve method call element.appendChild(document.createTextNode(enumConstant.toString())) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode(enumConstant.toString()) (line: 134) MethodCallExprContext{wrapped=document.createTextNode(enumConstant.toString())}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/LinkRenderer.java
Cannot solve method call document.createTextNode(classDoc.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context classDoc.getSimpleName() (line: 33) MethodCallExprContext{wrapped=classDoc.getSimpleName()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDescriptionRenderer.java
Cannot solve method call title.appendChild(document.createTextNode(classDoc.getSimpleName())) java.lang.RuntimeException: Error calculating the type of parameter classDoc.getSimpleName() of method call document.createTextNode(classDoc.getSimpleName()) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDescriptionRenderer.java
Cannot solve method call parent.appendChild(document.importNode(element, true)) java.lang.RuntimeException: Method 'importNode' cannot be resolved in context document.importNode(element, true) (line: 41) MethodCallExprContext{wrapped=document.importNode(element, true)}. Parameter types: [ReferenceType{Element, typeParametersMap=TypeParametersMap{nameToValue={}}}, PrimitiveTypeUsage{name='boolean'}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDescriptionRenderer.java
Method 'getClassSection' cannot be resolved in context classDoc.getClassSection() (line: 43) MethodCallExprContext{wrapped=classDoc.getClassSection()}. Parameter types: []
Method 'getTagName' cannot be resolved in context ((Element) child).getTagName() (line: 46) MethodCallExprContext{wrapped=((Element) child).getTagName()}. Parameter types: []
Cannot solve method call parent.appendChild(document.importNode(child, true)) java.lang.RuntimeException: Method 'importNode' cannot be resolved in context document.importNode(child, true) (line: 47) MethodCallExprContext{wrapped=document.importNode(child, true)}. Parameter types: [ReferenceType{Node, typeParametersMap=TypeParametersMap{nameToValue={}}}, PrimitiveTypeUsage{name='boolean'}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDescriptionRenderer.java
Cannot solve method call segtitle.appendChild(document.createTextNode("API Documentation")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("API Documentation") (line: 57) MethodCallExprContext{wrapped=document.createTextNode("API Documentation")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDescriptionRenderer.java
Cannot solve method call apilink.setAttribute("class", classDoc.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context classDoc.getName() (line: 64) MethodCallExprContext{wrapped=classDoc.getName()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDescriptionRenderer.java
Cannot solve method call apilink.setAttribute("style", classDoc.getStyle()) java.lang.RuntimeException: Method 'getStyle' cannot be resolved in context classDoc.getStyle() (line: 65) MethodCallExprContext{wrapped=classDoc.getStyle()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDescriptionRenderer.java
Method 'getSubClasses' cannot be resolved in context classDoc.getSubClasses() (line: 69) MethodCallExprContext{wrapped=classDoc.getSubClasses()}. Parameter types: []
Cannot solve method call segtitle.appendChild(document.createTextNode("Known Subtypes")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("Known Subtypes") (line: 74) MethodCallExprContext{wrapped=document.createTextNode("Known Subtypes")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDescriptionRenderer.java
Method 'getSubClasses' cannot be resolved in context classDoc.getSubClasses() (line: 82) MethodCallExprContext{wrapped=classDoc.getSubClasses()}. Parameter types: []
Cannot solve method call simplelist.setAttribute("columns", String.valueOf(columns)) UnsolvedSymbolException{context='Method 'valueOf' with parameterTypes [PrimitiveTypeUsage{name='int'}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDescriptionRenderer.java
Cannot solve method call apilink.setAttribute("class", subClass.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context subClass.getName() (line: 92) MethodCallExprContext{wrapped=subClass.getName()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDescriptionRenderer.java
Cannot solve method call td.appendChild(document.createTextNode("Method")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("Method") (line: 39) MethodCallExprContext{wrapped=document.createTextNode("Method")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/MethodTableRenderer.java
Cannot solve method call td.appendChild(document.createTextNode("Description")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("Description") (line: 42) MethodCallExprContext{wrapped=document.createTextNode("Description")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/MethodTableRenderer.java
Cannot solve method call link.setAttribute("linkend", methodDoc.getId()) java.lang.RuntimeException: Method 'getId' cannot be resolved in context methodDoc.getId() (line: 58) MethodCallExprContext{wrapped=methodDoc.getId()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/MethodTableRenderer.java
Cannot solve method call document.createTextNode(methodDoc.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context methodDoc.getName() (line: 59) MethodCallExprContext{wrapped=methodDoc.getName()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/MethodTableRenderer.java
Cannot solve method call link.appendChild(document.createTextNode(methodDoc.getName())) java.lang.RuntimeException: Error calculating the type of parameter methodDoc.getName() of method call document.createTextNode(methodDoc.getName()) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/MethodTableRenderer.java
Method 'getMetaData' cannot be resolved in context methodDoc.getMetaData() (line: 66) MethodCallExprContext{wrapped=methodDoc.getMetaData()}. Parameter types: []
Method 'getMetaData' cannot be resolved in context methodDoc.getMetaData() (line: 66) MethodCallExprContext{wrapped=methodDoc.getMetaData()}. Parameter types: []
Method 'getMetaData' cannot be resolved in context methodDoc.getMetaData() (line: 66) MethodCallExprContext{wrapped=methodDoc.getMetaData()}. Parameter types: []
Cannot solve method call signature.append(methodDoc.getMetaData().getParameters().get(i).getName()) java.lang.RuntimeException: Method 'getMetaData' cannot be resolved in context methodDoc.getMetaData() (line: 66) MethodCallExprContext{wrapped=methodDoc.getMetaData()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/MethodTableRenderer.java
Method 'getMetaData' cannot be resolved in context methodDoc.getMetaData() (line: 62) MethodCallExprContext{wrapped=methodDoc.getMetaData()}. Parameter types: []
Method 'getMetaData' cannot be resolved in context methodDoc.getMetaData() (line: 62) MethodCallExprContext{wrapped=methodDoc.getMetaData()}. Parameter types: []
Cannot solve method call literal.appendChild(document.createTextNode(signature.toString())) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode(signature.toString()) (line: 69) MethodCallExprContext{wrapped=document.createTextNode(signature.toString())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/MethodTableRenderer.java
Cannot solve method call caution.appendChild(document.createTextNode("Deprecated")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("Deprecated") (line: 76) MethodCallExprContext{wrapped=document.createTextNode("Deprecated")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/MethodTableRenderer.java
Cannot solve method call caution.appendChild(document.createTextNode("Incubating")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("Incubating") (line: 81) MethodCallExprContext{wrapped=document.createTextNode("Incubating")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/MethodTableRenderer.java
Cannot solve method call document.importNode(methodDoc.getDescription(), true) java.lang.RuntimeException: Method 'getDescription' cannot be resolved in context methodDoc.getDescription() (line: 83) MethodCallExprContext{wrapped=methodDoc.getDescription()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/MethodTableRenderer.java
Cannot solve method call td.appendChild(document.importNode(methodDoc.getDescription(), true)) java.lang.RuntimeException: Error calculating the type of parameter methodDoc.getDescription() of method call document.importNode(methodDoc.getDescription(), true) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/MethodTableRenderer.java
Cannot solve method call td.appendChild(document.createTextNode("Property")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("Property") (line: 39) MethodCallExprContext{wrapped=document.createTextNode("Property")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/PropertyTableRenderer.java
Cannot solve method call td.appendChild(document.createTextNode("Description")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("Description") (line: 42) MethodCallExprContext{wrapped=document.createTextNode("Description")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/PropertyTableRenderer.java
Cannot solve method call link.setAttribute("linkend", propDoc.getId()) java.lang.RuntimeException: Method 'getId' cannot be resolved in context propDoc.getId() (line: 56) MethodCallExprContext{wrapped=propDoc.getId()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/PropertyTableRenderer.java
Cannot solve method call document.createTextNode(propDoc.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context propDoc.getName() (line: 59) MethodCallExprContext{wrapped=propDoc.getName()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/PropertyTableRenderer.java
Cannot solve method call literal.appendChild(document.createTextNode(propDoc.getName())) java.lang.RuntimeException: Error calculating the type of parameter propDoc.getName() of method call document.createTextNode(propDoc.getName()) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/PropertyTableRenderer.java
Cannot solve method call caution.appendChild(document.createTextNode("Deprecated")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("Deprecated") (line: 66) MethodCallExprContext{wrapped=document.createTextNode("Deprecated")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/PropertyTableRenderer.java
Cannot solve method call caution.appendChild(document.createTextNode("Incubating")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("Incubating") (line: 71) MethodCallExprContext{wrapped=document.createTextNode("Incubating")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/PropertyTableRenderer.java
Cannot solve method call document.importNode(propDoc.getDescription(), true) java.lang.RuntimeException: Method 'getDescription' cannot be resolved in context propDoc.getDescription() (line: 73) MethodCallExprContext{wrapped=propDoc.getDescription()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/PropertyTableRenderer.java
Cannot solve method call td.appendChild(document.importNode(propDoc.getDescription(), true)) java.lang.RuntimeException: Error calculating the type of parameter propDoc.getDescription() of method call document.importNode(propDoc.getDescription(), true) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/PropertyTableRenderer.java
Method 'getTextContent' cannot be resolved in context cells.get(0).getTextContent() (line: 53) MethodCallExprContext{wrapped=cells.get(0).getTextContent()}. Parameter types: []
Method 'getClassMetaData' cannot be resolved in context classDoc.getClassMetaData() (line: 54) MethodCallExprContext{wrapped=classDoc.getClassMetaData()}. Parameter types: []
Method 'getClassMetaData' cannot be resolved in context classDoc.getClassMetaData() (line: 56) MethodCallExprContext{wrapped=classDoc.getClassMetaData()}. Parameter types: []
Cannot solve method call String.format("No metadata for method '%s.%s()'. Available methods: %s", classDoc.getName(), methodName, classDoc.getClassMetaData().getDeclaredMethodNames()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context classDoc.getName() (line: 56) MethodCallExprContext{wrapped=classDoc.getName()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocMethodsBuilder.java
Cannot solve method call String.format("Docbook content for '%s %s' does not contain a description paragraph.", classDoc.getName(), method.getSignature()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context classDoc.getName() (line: 62) MethodCallExprContext{wrapped=classDoc.getName()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocMethodsBuilder.java
Method 'getMetaData' cannot be resolved in context property.getMetaData() (line: 67) MethodCallExprContext{wrapped=property.getMetaData()}. Parameter types: []
Cannot solve method call children(classDoc.getMethodsTable(), "tr") java.lang.RuntimeException: Method 'getMethodsTable' cannot be resolved in context classDoc.getMethodsTable() (line: 48) MethodCallExprContext{wrapped=classDoc.getMethodsTable()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocMethodsBuilder.java
Method 'getMetaData' cannot be resolved in context method.getMetaData() (line: 85) MethodCallExprContext{wrapped=method.getMetaData()}. Parameter types: []
Cannot solve method call signatures.add(method.getMetaData().getOverrideSignature()) java.lang.RuntimeException: Method 'getMetaData' cannot be resolved in context method.getMetaData() (line: 85) MethodCallExprContext{wrapped=method.getMetaData()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocMethodsBuilder.java
Method 'getExtensionMethods' cannot be resolved in context extension.getExtensionMethods() (line: 31) MethodCallExprContext{wrapped=extension.getExtensionMethods()}. Parameter types: []
Cannot solve method call title.appendChild(document.createTextNode("Methods added by the ")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("Methods added by the ") (line: 42) MethodCallExprContext{wrapped=document.createTextNode("Methods added by the ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionMethodsSummaryRenderer.java
Cannot solve method call document.createTextNode(extension.getPluginId()) java.lang.RuntimeException: Method 'getPluginId' cannot be resolved in context extension.getPluginId() (line: 45) MethodCallExprContext{wrapped=extension.getPluginId()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionMethodsSummaryRenderer.java
Cannot solve method call literal.appendChild(document.createTextNode(extension.getPluginId())) java.lang.RuntimeException: Error calculating the type of parameter extension.getPluginId() of method call document.createTextNode(extension.getPluginId()) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionMethodsSummaryRenderer.java
Cannot solve method call title.appendChild(document.createTextNode(" plugin")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode(" plugin") (line: 46) MethodCallExprContext{wrapped=document.createTextNode(" plugin")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionMethodsSummaryRenderer.java
Cannot solve method call document.createTextNode(extension.getPluginId()) java.lang.RuntimeException: Method 'getPluginId' cannot be resolved in context extension.getPluginId() (line: 52) MethodCallExprContext{wrapped=extension.getPluginId()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionMethodsSummaryRenderer.java
Cannot solve method call literal.appendChild(document.createTextNode(extension.getPluginId())) java.lang.RuntimeException: Error calculating the type of parameter extension.getPluginId() of method call document.createTextNode(extension.getPluginId()) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionMethodsSummaryRenderer.java
Cannot solve method call titleabbrev.appendChild(document.createTextNode(" plugin")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode(" plugin") (line: 53) MethodCallExprContext{wrapped=document.createTextNode(" plugin")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionMethodsSummaryRenderer.java
Cannot solve method call title.appendChild(document.createTextNode("Methods - ")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("Methods - ") (line: 60) MethodCallExprContext{wrapped=document.createTextNode("Methods - ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionMethodsSummaryRenderer.java
Cannot solve method call document.createTextNode(extension.getPluginId()) java.lang.RuntimeException: Method 'getPluginId' cannot be resolved in context extension.getPluginId() (line: 63) MethodCallExprContext{wrapped=extension.getPluginId()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionMethodsSummaryRenderer.java
Cannot solve method call literal.appendChild(document.createTextNode(extension.getPluginId())) java.lang.RuntimeException: Error calculating the type of parameter extension.getPluginId() of method call document.createTextNode(extension.getPluginId()) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionMethodsSummaryRenderer.java
Cannot solve method call title.appendChild(document.createTextNode(" plugin")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode(" plugin") (line: 64) MethodCallExprContext{wrapped=document.createTextNode(" plugin")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionMethodsSummaryRenderer.java
Cannot solve method call methodTableRenderer.renderTo(extension.getExtensionMethods(), table) java.lang.RuntimeException: Method 'getExtensionMethods' cannot be resolved in context extension.getExtensionMethods() (line: 66) MethodCallExprContext{wrapped=extension.getExtensionMethods()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionMethodsSummaryRenderer.java
Method 'getExtensionProperties' cannot be resolved in context extension.getExtensionProperties() (line: 31) MethodCallExprContext{wrapped=extension.getExtensionProperties()}. Parameter types: []
Cannot solve method call title.appendChild(document.createTextNode("Properties added by the ")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("Properties added by the ") (line: 42) MethodCallExprContext{wrapped=document.createTextNode("Properties added by the ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionPropertiesSummaryRenderer.java
Cannot solve method call document.createTextNode(extension.getPluginId()) java.lang.RuntimeException: Method 'getPluginId' cannot be resolved in context extension.getPluginId() (line: 45) MethodCallExprContext{wrapped=extension.getPluginId()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionPropertiesSummaryRenderer.java
Cannot solve method call literal.appendChild(document.createTextNode(extension.getPluginId())) java.lang.RuntimeException: Error calculating the type of parameter extension.getPluginId() of method call document.createTextNode(extension.getPluginId()) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionPropertiesSummaryRenderer.java
Cannot solve method call title.appendChild(document.createTextNode(" plugin")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode(" plugin") (line: 46) MethodCallExprContext{wrapped=document.createTextNode(" plugin")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionPropertiesSummaryRenderer.java
Cannot solve method call document.createTextNode(extension.getPluginId()) java.lang.RuntimeException: Method 'getPluginId' cannot be resolved in context extension.getPluginId() (line: 52) MethodCallExprContext{wrapped=extension.getPluginId()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionPropertiesSummaryRenderer.java
Cannot solve method call literal.appendChild(document.createTextNode(extension.getPluginId())) java.lang.RuntimeException: Error calculating the type of parameter extension.getPluginId() of method call document.createTextNode(extension.getPluginId()) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionPropertiesSummaryRenderer.java
Cannot solve method call titleabbrev.appendChild(document.createTextNode(" plugin")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode(" plugin") (line: 53) MethodCallExprContext{wrapped=document.createTextNode(" plugin")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionPropertiesSummaryRenderer.java
Cannot solve method call title.appendChild(document.createTextNode("Properties - ")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("Properties - ") (line: 60) MethodCallExprContext{wrapped=document.createTextNode("Properties - ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionPropertiesSummaryRenderer.java
Cannot solve method call document.createTextNode(extension.getPluginId()) java.lang.RuntimeException: Method 'getPluginId' cannot be resolved in context extension.getPluginId() (line: 63) MethodCallExprContext{wrapped=extension.getPluginId()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionPropertiesSummaryRenderer.java
Cannot solve method call literal.appendChild(document.createTextNode(extension.getPluginId())) java.lang.RuntimeException: Error calculating the type of parameter extension.getPluginId() of method call document.createTextNode(extension.getPluginId()) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionPropertiesSummaryRenderer.java
Cannot solve method call title.appendChild(document.createTextNode(" plugin")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode(" plugin") (line: 64) MethodCallExprContext{wrapped=document.createTextNode(" plugin")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionPropertiesSummaryRenderer.java
Cannot solve method call propertyTableRenderer.renderTo(extension.getExtensionProperties(), table) java.lang.RuntimeException: Method 'getExtensionProperties' cannot be resolved in context extension.getExtensionProperties() (line: 66) MethodCallExprContext{wrapped=extension.getExtensionProperties()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionPropertiesSummaryRenderer.java
Cannot solve method call title.appendChild(document.createTextNode("Methods")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("Methods") (line: 45) MethodCallExprContext{wrapped=document.createTextNode("Methods")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/MethodsRenderer.java
Cannot solve method call document.createTextNode("Methods - " + classDoc.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context classDoc.getSimpleName() (line: 55) MethodCallExprContext{wrapped=classDoc.getSimpleName()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/MethodsRenderer.java
Cannot solve method call title.appendChild(document.createTextNode("Methods - " + classDoc.getSimpleName())) java.lang.RuntimeException: Error calculating the type of parameter "Methods - " + classDoc.getSimpleName() of method call document.createTextNode("Methods - " + classDoc.getSimpleName()) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/MethodsRenderer.java
Cannot solve method call para.appendChild(document.createTextNode("No methods")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("No methods") (line: 66) MethodCallExprContext{wrapped=document.createTextNode("No methods")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/MethodsRenderer.java
Cannot solve method call title.appendChild(document.createTextNode("Method details")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("Method details") (line: 78) MethodCallExprContext{wrapped=document.createTextNode("Method details")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/MethodsRenderer.java
Method 'getClassMethods' cannot be resolved in context classDoc.getClassMethods() (line: 93) MethodCallExprContext{wrapped=classDoc.getClassMethods()}. Parameter types: []
Method 'getExtensionMethods' cannot be resolved in context extensionDoc.getExtensionMethods() (line: 97) MethodCallExprContext{wrapped=extensionDoc.getExtensionMethods()}. Parameter types: []
Cannot solve method call model.getClassDoc(mixin.getMixinClass()) UnsolvedSymbolException{context='unknown', name='MixinMetaData', typeSolver=null} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocExtensionsBuilder.java
Method 'getMixinClasses' cannot be resolved in context classExtensionDoc.getMixinClasses() (line: 55) MethodCallExprContext{wrapped=classExtensionDoc.getMixinClasses()}. Parameter types: []
Method 'getExtensionMetaData' cannot be resolved in context classDoc.getExtensionMetaData() (line: 48) MethodCallExprContext{wrapped=classDoc.getExtensionMetaData()}. Parameter types: []
Cannot solve method call model.getClassDoc(extension.getExtensionClass()) UnsolvedSymbolException{context='unknown', name='ExtensionMetaData', typeSolver=null} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocExtensionsBuilder.java
Method 'getExtensionClasses' cannot be resolved in context classExtensionDoc.getExtensionClasses() (line: 64) MethodCallExprContext{wrapped=classExtensionDoc.getExtensionClasses()}. Parameter types: []
Method 'getExtensionMetaData' cannot be resolved in context classDoc.getExtensionMetaData() (line: 57) MethodCallExprContext{wrapped=classDoc.getExtensionMetaData()}. Parameter types: []
Method 'getTargetClass' cannot be resolved in context extensionDoc.getTargetClass() (line: 84) MethodCallExprContext{wrapped=extensionDoc.getTargetClass()}. Parameter types: []
Cannot solve method call para.appendChild(doc.createTextNode("The ")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context doc.createTextNode("The ") (line: 88) MethodCallExprContext{wrapped=doc.createTextNode("The ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocExtensionsBuilder.java
Cannot solve method call para.appendChild(linkRenderer.link(propertyMetaData.getType(), listener)) java.lang.RuntimeException: Method 'link' cannot be resolved in context linkRenderer.link(propertyMetaData.getType(), listener) (line: 89) MethodCallExprContext{wrapped=linkRenderer.link(propertyMetaData.getType(), listener)}. Parameter types: [ReferenceType{org.gradle.build.docs.dsl.source.model.TypeMetaData, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{GenerationListener, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocExtensionsBuilder.java
Cannot solve method call String.format(" added by the %s plugin.", extensionDoc.getPluginId()) java.lang.RuntimeException: Method 'getPluginId' cannot be resolved in context extensionDoc.getPluginId() (line: 90) MethodCallExprContext{wrapped=extensionDoc.getPluginId()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocExtensionsBuilder.java
Cannot solve method call doc.createTextNode(String.format(" added by the %s plugin.", extensionDoc.getPluginId())) java.lang.RuntimeException: Error calculating the type of parameter extensionDoc.getPluginId() of method call String.format(" added by the %s plugin.", extensionDoc.getPluginId()) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocExtensionsBuilder.java
Cannot solve method call para.appendChild(doc.createTextNode(String.format(" added by the %s plugin.", extensionDoc.getPluginId()))) java.lang.RuntimeException: Error calculating the type of parameter String.format(" added by the %s plugin.", extensionDoc.getPluginId()) of method call doc.createTextNode(String.format(" added by the %s plugin.", extensionDoc.getPluginId())) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocExtensionsBuilder.java
Method 'getExtraProperties' cannot be resolved in context extensionDoc.getExtraProperties() (line: 93) MethodCallExprContext{wrapped=extensionDoc.getExtraProperties()}. Parameter types: []
Cannot solve method call para.appendChild(doc.createTextNode("Configures the ")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context doc.createTextNode("Configures the ") (line: 96) MethodCallExprContext{wrapped=doc.createTextNode("Configures the ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocExtensionsBuilder.java
Cannot solve method call para.appendChild(linkRenderer.link(propertyMetaData.getType(), listener)) java.lang.RuntimeException: Method 'link' cannot be resolved in context linkRenderer.link(propertyMetaData.getType(), listener) (line: 97) MethodCallExprContext{wrapped=linkRenderer.link(propertyMetaData.getType(), listener)}. Parameter types: [ReferenceType{org.gradle.build.docs.dsl.source.model.TypeMetaData, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{GenerationListener, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocExtensionsBuilder.java
Cannot solve method call String.format(" added by the %s plugin.", extensionDoc.getPluginId()) java.lang.RuntimeException: Method 'getPluginId' cannot be resolved in context extensionDoc.getPluginId() (line: 98) MethodCallExprContext{wrapped=extensionDoc.getPluginId()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocExtensionsBuilder.java
Cannot solve method call doc.createTextNode(String.format(" added by the %s plugin.", extensionDoc.getPluginId())) java.lang.RuntimeException: Error calculating the type of parameter extensionDoc.getPluginId() of method call String.format(" added by the %s plugin.", extensionDoc.getPluginId()) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocExtensionsBuilder.java
Cannot solve method call para.appendChild(doc.createTextNode(String.format(" added by the %s plugin.", extensionDoc.getPluginId()))) java.lang.RuntimeException: Error calculating the type of parameter String.format(" added by the %s plugin.", extensionDoc.getPluginId()) of method call doc.createTextNode(String.format(" added by the %s plugin.", extensionDoc.getPluginId())) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ClassDocExtensionsBuilder.java
Method 'getTargetClass' cannot be resolved in context extensionDoc.getTargetClass() (line: 100) MethodCallExprContext{wrapped=extensionDoc.getTargetClass()}. Parameter types: []
Method 'getExtraBlocks' cannot be resolved in context extensionDoc.getExtraBlocks() (line: 103) MethodCallExprContext{wrapped=extensionDoc.getExtraBlocks()}. Parameter types: []
Method 'getExtensionClasses' cannot be resolved in context extensionDoc.getExtensionClasses() (line: 81) MethodCallExprContext{wrapped=extensionDoc.getExtensionClasses()}. Parameter types: []
Cannot solve method call section.setAttribute("id", propertyDoc.getId()) java.lang.RuntimeException: Method 'getId' cannot be resolved in context propertyDoc.getId() (line: 39) MethodCallExprContext{wrapped=propertyDoc.getId()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/PropertyDetailRenderer.java
Method 'getMetaData' cannot be resolved in context propertyDoc.getMetaData() (line: 44) MethodCallExprContext{wrapped=propertyDoc.getMetaData()}. Parameter types: []
Cannot solve method call linkRenderer.link(propertyDoc.getMetaData().getType(), listener) java.lang.RuntimeException: Method 'getMetaData' cannot be resolved in context propertyDoc.getMetaData() (line: 44) MethodCallExprContext{wrapped=propertyDoc.getMetaData()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/PropertyDetailRenderer.java
Cannot solve method call title.appendChild(linkRenderer.link(propertyDoc.getMetaData().getType(), listener)) java.lang.RuntimeException: Error calculating the type of parameter propertyDoc.getMetaData().getType() of method call linkRenderer.link(propertyDoc.getMetaData().getType(), listener) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/PropertyDetailRenderer.java
Cannot solve method call title.appendChild(document.createTextNode(" ")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode(" ") (line: 45) MethodCallExprContext{wrapped=document.createTextNode(" ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/PropertyDetailRenderer.java
Cannot solve method call document.createTextNode(propertyDoc.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context propertyDoc.getName() (line: 48) MethodCallExprContext{wrapped=propertyDoc.getName()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/PropertyDetailRenderer.java
Cannot solve method call literal.appendChild(document.createTextNode(propertyDoc.getName())) java.lang.RuntimeException: Error calculating the type of parameter propertyDoc.getName() of method call document.createTextNode(propertyDoc.getName()) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/PropertyDetailRenderer.java
Method 'getMetaData' cannot be resolved in context propertyDoc.getMetaData() (line: 49) MethodCallExprContext{wrapped=propertyDoc.getMetaData()}. Parameter types: []
Cannot solve method call title.appendChild(document.createTextNode(" (read-only)")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode(" (read-only)") (line: 50) MethodCallExprContext{wrapped=document.createTextNode(" (read-only)")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/PropertyDetailRenderer.java
Cannot solve method call section.appendChild(document.importNode(element, true)) java.lang.RuntimeException: Method 'importNode' cannot be resolved in context document.importNode(element, true) (line: 56) MethodCallExprContext{wrapped=document.importNode(element, true)}. Parameter types: [ReferenceType{Element, typeParametersMap=TypeParametersMap{nameToValue={}}}, PrimitiveTypeUsage{name='boolean'}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/PropertyDetailRenderer.java
Method 'getAdditionalValues' cannot be resolved in context propertyDoc.getAdditionalValues() (line: 59) MethodCallExprContext{wrapped=propertyDoc.getAdditionalValues()}. Parameter types: []
Cannot solve method call segtitle.appendChild(document.importNode(node, true)) java.lang.RuntimeException: Method 'importNode' cannot be resolved in context document.importNode(node, true) (line: 66) MethodCallExprContext{wrapped=document.importNode(node, true)}. Parameter types: [ReferenceType{Node, typeParametersMap=TypeParametersMap{nameToValue={}}}, PrimitiveTypeUsage{name='boolean'}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/PropertyDetailRenderer.java
Cannot solve method call seg.appendChild(document.importNode(node, true)) java.lang.RuntimeException: Method 'importNode' cannot be resolved in context document.importNode(node, true) (line: 75) MethodCallExprContext{wrapped=document.importNode(node, true)}. Parameter types: [ReferenceType{Node, typeParametersMap=TypeParametersMap{nameToValue={}}}, PrimitiveTypeUsage{name='boolean'}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/PropertyDetailRenderer.java
Method 'getExtensionBlocks' cannot be resolved in context extension.getExtensionBlocks() (line: 31) MethodCallExprContext{wrapped=extension.getExtensionBlocks()}. Parameter types: []
Cannot solve method call title.appendChild(document.createTextNode("Script blocks added by the ")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("Script blocks added by the ") (line: 42) MethodCallExprContext{wrapped=document.createTextNode("Script blocks added by the ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionBlocksSummaryRenderer.java
Cannot solve method call document.createTextNode(extension.getPluginId()) java.lang.RuntimeException: Method 'getPluginId' cannot be resolved in context extension.getPluginId() (line: 45) MethodCallExprContext{wrapped=extension.getPluginId()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionBlocksSummaryRenderer.java
Cannot solve method call literal.appendChild(document.createTextNode(extension.getPluginId())) java.lang.RuntimeException: Error calculating the type of parameter extension.getPluginId() of method call document.createTextNode(extension.getPluginId()) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionBlocksSummaryRenderer.java
Cannot solve method call title.appendChild(document.createTextNode(" plugin")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode(" plugin") (line: 46) MethodCallExprContext{wrapped=document.createTextNode(" plugin")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionBlocksSummaryRenderer.java
Cannot solve method call document.createTextNode(extension.getPluginId()) java.lang.RuntimeException: Method 'getPluginId' cannot be resolved in context extension.getPluginId() (line: 52) MethodCallExprContext{wrapped=extension.getPluginId()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionBlocksSummaryRenderer.java
Cannot solve method call literal.appendChild(document.createTextNode(extension.getPluginId())) java.lang.RuntimeException: Error calculating the type of parameter extension.getPluginId() of method call document.createTextNode(extension.getPluginId()) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionBlocksSummaryRenderer.java
Cannot solve method call titleabbrev.appendChild(document.createTextNode(" plugin")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode(" plugin") (line: 53) MethodCallExprContext{wrapped=document.createTextNode(" plugin")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionBlocksSummaryRenderer.java
Cannot solve method call title.appendChild(document.createTextNode("Script blocks - ")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("Script blocks - ") (line: 60) MethodCallExprContext{wrapped=document.createTextNode("Script blocks - ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionBlocksSummaryRenderer.java
Cannot solve method call document.createTextNode(extension.getPluginId()) java.lang.RuntimeException: Method 'getPluginId' cannot be resolved in context extension.getPluginId() (line: 63) MethodCallExprContext{wrapped=extension.getPluginId()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionBlocksSummaryRenderer.java
Cannot solve method call literal.appendChild(document.createTextNode(extension.getPluginId())) java.lang.RuntimeException: Error calculating the type of parameter extension.getPluginId() of method call document.createTextNode(extension.getPluginId()) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionBlocksSummaryRenderer.java
Cannot solve method call title.appendChild(document.createTextNode(" plugin")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode(" plugin") (line: 64) MethodCallExprContext{wrapped=document.createTextNode(" plugin")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionBlocksSummaryRenderer.java
Cannot solve method call blockTableRenderer.renderTo(extension.getExtensionBlocks(), table) java.lang.RuntimeException: Method 'getExtensionBlocks' cannot be resolved in context extension.getExtensionBlocks() (line: 66) MethodCallExprContext{wrapped=extension.getExtensionBlocks()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ExtensionBlocksSummaryRenderer.java
Cannot solve method call section.setAttribute("id", methodDoc.getId()) java.lang.RuntimeException: Method 'getId' cannot be resolved in context methodDoc.getId() (line: 41) MethodCallExprContext{wrapped=methodDoc.getId()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/MethodDetailRenderer.java
Method 'getMetaData' cannot be resolved in context methodDoc.getMetaData() (line: 46) MethodCallExprContext{wrapped=methodDoc.getMetaData()}. Parameter types: []
Cannot solve method call linkRenderer.link(methodDoc.getMetaData().getReturnType(), listener) java.lang.RuntimeException: Method 'getMetaData' cannot be resolved in context methodDoc.getMetaData() (line: 46) MethodCallExprContext{wrapped=methodDoc.getMetaData()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/MethodDetailRenderer.java
Cannot solve method call title.appendChild(linkRenderer.link(methodDoc.getMetaData().getReturnType(), listener)) java.lang.RuntimeException: Error calculating the type of parameter methodDoc.getMetaData().getReturnType() of method call linkRenderer.link(methodDoc.getMetaData().getReturnType(), listener) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/MethodDetailRenderer.java
Cannot solve method call title.appendChild(document.createTextNode(" ")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode(" ") (line: 47) MethodCallExprContext{wrapped=document.createTextNode(" ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/MethodDetailRenderer.java
Cannot solve method call document.createTextNode(methodDoc.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context methodDoc.getName() (line: 50) MethodCallExprContext{wrapped=methodDoc.getName()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/MethodDetailRenderer.java
Cannot solve method call literal.appendChild(document.createTextNode(methodDoc.getName())) java.lang.RuntimeException: Error calculating the type of parameter methodDoc.getName() of method call document.createTextNode(methodDoc.getName()) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/MethodDetailRenderer.java
Cannot solve method call title.appendChild(document.createTextNode("(")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("(") (line: 51) MethodCallExprContext{wrapped=document.createTextNode("(")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/MethodDetailRenderer.java
Method 'getMetaData' cannot be resolved in context methodDoc.getMetaData() (line: 52) MethodCallExprContext{wrapped=methodDoc.getMetaData()}. Parameter types: []
Cannot solve method call title.appendChild(document.createTextNode(", ")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode(", ") (line: 56) MethodCallExprContext{wrapped=document.createTextNode(", ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/MethodDetailRenderer.java
Cannot solve method call title.appendChild(document.createTextNode(" " + param.getName())) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode(" " + param.getName()) (line: 59) MethodCallExprContext{wrapped=document.createTextNode(" " + param.getName())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/MethodDetailRenderer.java
Cannot solve method call title.appendChild(document.createTextNode(")")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode(")") (line: 61) MethodCallExprContext{wrapped=document.createTextNode(")")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/MethodDetailRenderer.java
Cannot solve method call section.appendChild(document.importNode(element, true)) java.lang.RuntimeException: Method 'importNode' cannot be resolved in context document.importNode(element, true) (line: 66) MethodCallExprContext{wrapped=document.importNode(element, true)}. Parameter types: [ReferenceType{Element, typeParametersMap=TypeParametersMap{nameToValue={}}}, PrimitiveTypeUsage{name='boolean'}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/MethodDetailRenderer.java
Cannot solve method call stack.addFirst(document.createElement("root")) java.lang.RuntimeException: Method 'createElement' cannot be resolved in context document.createElement("root") (line: 34) MethodCallExprContext{wrapped=document.createElement("root")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/DocBookBuilder.java
Cannot solve method call appendChild(document.createTextNode(text)) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode(text) (line: 46) MethodCallExprContext{wrapped=document.createTextNode(text)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/DocBookBuilder.java
Method 'getTagName' cannot be resolved in context element.getTagName() (line: 53) MethodCallExprContext{wrapped=element.getTagName()}. Parameter types: []
Method 'getTagName' cannot be resolved in context stack.getFirst().getTagName() (line: 53) MethodCallExprContext{wrapped=stack.getFirst().getTagName()}. Parameter types: []
Method 'getParentNode' cannot be resolved in context element.getParentNode() (line: 73) MethodCallExprContext{wrapped=element.getParentNode()}. Parameter types: []
Method 'getTagName' cannot be resolved in context element.getTagName() (line: 79) MethodCallExprContext{wrapped=element.getTagName()}. Parameter types: []
Cannot solve method call document.createTextNode(String.format("Note: This %s is ", type)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ElementWarningsRenderer.java
Cannot solve method call para.appendChild(document.createTextNode(String.format("Note: This %s is ", type))) java.lang.RuntimeException: Error calculating the type of parameter String.format("Note: This %s is ", type) of method call document.createTextNode(String.format("Note: This %s is ", type)) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ElementWarningsRenderer.java
Cannot solve method call link.appendChild(document.createTextNode("deprecated")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("deprecated") (line: 35) MethodCallExprContext{wrapped=document.createTextNode("deprecated")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ElementWarningsRenderer.java
Cannot solve method call para.appendChild(document.createTextNode(" and will be removed in the next major version of Gradle.")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode(" and will be removed in the next major version of Gradle.") (line: 36) MethodCallExprContext{wrapped=document.createTextNode(" and will be removed in the next major version of Gradle.")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ElementWarningsRenderer.java
Cannot solve method call document.createTextNode(String.format("Note: This %s is ", type)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ElementWarningsRenderer.java
Cannot solve method call para.appendChild(document.createTextNode(String.format("Note: This %s is ", type))) java.lang.RuntimeException: Error calculating the type of parameter String.format("Note: This %s is ", type) of method call document.createTextNode(String.format("Note: This %s is ", type)) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ElementWarningsRenderer.java
Cannot solve method call link.appendChild(document.createTextNode("incubating")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("incubating") (line: 48) MethodCallExprContext{wrapped=document.createTextNode("incubating")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ElementWarningsRenderer.java
Cannot solve method call para.appendChild(document.createTextNode(" and may change in a future version of Gradle.")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode(" and may change in a future version of Gradle.") (line: 49) MethodCallExprContext{wrapped=document.createTextNode(" and may change in a future version of Gradle.")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ElementWarningsRenderer.java
Cannot solve method call listener.start(String.format("class %s", classMetaData)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.build.docs.dsl.source.model.ClassMetaData, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocConverter.java
Cannot solve method call listener.start(String.format("property %s", propertyMetaData)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.build.docs.dsl.source.model.PropertyMetaData, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocConverter.java
Cannot solve method call listener.start(String.format("method %s", methodMetaData)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.build.docs.dsl.source.model.MethodMetaData, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocConverter.java
Method 'getNodeName' cannot be resolved in context firstNode.getNodeName() (line: 102) MethodCallExprContext{wrapped=firstNode.getNodeName()}. Parameter types: []
Cannot solve method call getterPattern.matcher(comment.getData()) UnsolvedSymbolException{context='unknown', name='Text', typeSolver=null} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocConverter.java
Cannot solve method call listener.warning(String.format("Unsupported Javadoc tag '%s'", tag)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocConverter.java
Cannot solve method call document.createTextNode(String.format("{@%s %s}", tag, value)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocConverter.java
Cannot solve method call element.appendChild(document.createTextNode(String.format("{@%s %s}", tag, value))) java.lang.RuntimeException: Error calculating the type of parameter String.format("{@%s %s}", tag, value) of method call document.createTextNode(String.format("{@%s %s}", tag, value)) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocConverter.java
Cannot solve method call listener.warning(String.format("Unsupported HTML element <%s>", elementName)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocConverter.java
Cannot solve method call document.createTextNode(String.format("<%s>", elementName)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocConverter.java
Cannot solve method call element.appendChild(document.createTextNode(String.format("<%s>", elementName))) java.lang.RuntimeException: Error calculating the type of parameter String.format("<%s>", elementName) of method call document.createTextNode(String.format("<%s>", elementName)) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocConverter.java
Cannot solve method call nodes.appendChild(String.format("</%s>", elementName)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocConverter.java
Cannot solve method call element.appendChild(document.createTextNode(value)) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode(value) (line: 314) MethodCallExprContext{wrapped=document.createTextNode(value)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocConverter.java
Cannot solve method call nodes.push(document.createElement(newElementName)) java.lang.RuntimeException: Method 'createElement' cannot be resolved in context document.createElement(newElementName) (line: 345) MethodCallExprContext{wrapped=document.createElement(newElementName)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocConverter.java
Cannot solve method call nodes.push(document.createElement("title")) java.lang.RuntimeException: Method 'createElement' cannot be resolved in context document.createElement("title") (line: 417) MethodCallExprContext{wrapped=document.createElement("title")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocConverter.java
Cannot solve method call nodes.push(document.createElement("td")) java.lang.RuntimeException: Method 'createElement' cannot be resolved in context document.createElement("td") (line: 463) MethodCallExprContext{wrapped=document.createElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocConverter.java
Cannot solve method call nodes.push(document.createElement("td")) java.lang.RuntimeException: Method 'createElement' cannot be resolved in context document.createElement("td") (line: 467) MethodCallExprContext{wrapped=document.createElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocConverter.java
Cannot solve method call String.format("%s.%s", classMetaData.getClassName(), href.substring(1)) java.lang.RuntimeException: Method 'substring' cannot be resolved in context href.substring(1) (line: 538) MethodCallExprContext{wrapped=href.substring(1)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocConverter.java
Cannot solve method call nodes.push(document.createElement("term")) java.lang.RuntimeException: Method 'createElement' cannot be resolved in context document.createElement("term") (line: 611) MethodCallExprContext{wrapped=document.createElement("term")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocConverter.java
Cannot solve method call nodes.push(document.createElement("listitem")) java.lang.RuntimeException: Method 'createElement' cannot be resolved in context document.createElement("listitem") (line: 618) MethodCallExprContext{wrapped=document.createElement("listitem")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocConverter.java
Cannot solve method call nodes.appendChild(linkConverter.resolveValue(value, classMetaData, listener)) java.lang.RuntimeException: Method 'resolveValue' cannot be resolved in context linkConverter.resolveValue(value, classMetaData, listener) (line: 665) MethodCallExprContext{wrapped=linkConverter.resolveValue(value, classMetaData, listener)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.build.docs.dsl.source.model.ClassMetaData, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{GenerationListener, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocConverter.java
Cannot solve method call nodes.appendChild(linkConverter.resolve(value, classMetaData, listener)) java.lang.RuntimeException: Method 'resolve' cannot be resolved in context linkConverter.resolve(value, classMetaData, listener) (line: 704) MethodCallExprContext{wrapped=linkConverter.resolve(value, classMetaData, listener)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.build.docs.dsl.source.model.ClassMetaData, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{GenerationListener, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocConverter.java
Cannot solve method call Arrays.asList(document.createTextNode("!!NO INHERITED DOC COMMENT!!")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("!!NO INHERITED DOC COMMENT!!") (line: 752) MethodCallExprContext{wrapped=document.createTextNode("!!NO INHERITED DOC COMMENT!!")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocConverter.java
Cannot solve method call Arrays.asList(document.createTextNode("!!NO INHERITED DOC COMMENT!!")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("!!NO INHERITED DOC COMMENT!!") (line: 771) MethodCallExprContext{wrapped=document.createTextNode("!!NO INHERITED DOC COMMENT!!")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocConverter.java
Cannot solve method call title.appendChild(document.createTextNode("Script blocks")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("Script blocks") (line: 45) MethodCallExprContext{wrapped=document.createTextNode("Script blocks")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlocksRenderer.java
Cannot solve method call document.createTextNode("Script blocks - " + classDoc.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context classDoc.getSimpleName() (line: 54) MethodCallExprContext{wrapped=classDoc.getSimpleName()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlocksRenderer.java
Cannot solve method call title.appendChild(document.createTextNode("Script blocks - " + classDoc.getSimpleName())) java.lang.RuntimeException: Error calculating the type of parameter "Script blocks - " + classDoc.getSimpleName() of method call document.createTextNode("Script blocks - " + classDoc.getSimpleName()) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlocksRenderer.java
Cannot solve method call para.appendChild(document.createTextNode("No script blocks")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("No script blocks") (line: 66) MethodCallExprContext{wrapped=document.createTextNode("No script blocks")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlocksRenderer.java
Cannot solve method call title.appendChild(document.createTextNode("Script block details")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("Script block details") (line: 79) MethodCallExprContext{wrapped=document.createTextNode("Script block details")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlocksRenderer.java
Method 'getClassBlocks' cannot be resolved in context classDoc.getClassBlocks() (line: 94) MethodCallExprContext{wrapped=classDoc.getClassBlocks()}. Parameter types: []
Method 'getExtensionBlocks' cannot be resolved in context extensionDoc.getExtensionBlocks() (line: 98) MethodCallExprContext{wrapped=extensionDoc.getExtensionBlocks()}. Parameter types: []
Cannot solve method call title.appendChild(document.createTextNode("Properties")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("Properties") (line: 45) MethodCallExprContext{wrapped=document.createTextNode("Properties")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/PropertiesRenderer.java
Cannot solve method call document.createTextNode("Properties - " + classDoc.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context classDoc.getSimpleName() (line: 55) MethodCallExprContext{wrapped=classDoc.getSimpleName()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/PropertiesRenderer.java
Cannot solve method call title.appendChild(document.createTextNode("Properties - " + classDoc.getSimpleName())) java.lang.RuntimeException: Error calculating the type of parameter "Properties - " + classDoc.getSimpleName() of method call document.createTextNode("Properties - " + classDoc.getSimpleName()) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/PropertiesRenderer.java
Cannot solve method call para.appendChild(document.createTextNode("No properties")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("No properties") (line: 67) MethodCallExprContext{wrapped=document.createTextNode("No properties")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/PropertiesRenderer.java
Cannot solve method call title.appendChild(document.createTextNode("Property details")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("Property details") (line: 79) MethodCallExprContext{wrapped=document.createTextNode("Property details")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/PropertiesRenderer.java
Method 'getClassProperties' cannot be resolved in context classDoc.getClassProperties() (line: 94) MethodCallExprContext{wrapped=classDoc.getClassProperties()}. Parameter types: []
Method 'getExtensionProperties' cannot be resolved in context extensionDoc.getExtensionProperties() (line: 98) MethodCallExprContext{wrapped=extensionDoc.getExtensionProperties()}. Parameter types: []
Cannot solve method call m.region(pos, input.length()) java.lang.RuntimeException: Method 'length' cannot be resolved in context input.length() (line: 85) MethodCallExprContext{wrapped=input.length()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocScanner.java
Cannot solve method call m.region(pos, input.length()) java.lang.RuntimeException: Method 'length' cannot be resolved in context input.length() (line: 113) MethodCallExprContext{wrapped=input.length()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocScanner.java
Cannot solve method call m.region(pos, input.length()) java.lang.RuntimeException: Method 'length' cannot be resolved in context input.length() (line: 126) MethodCallExprContext{wrapped=input.length()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/JavadocScanner.java
Cannot solve method call section.setAttribute("id", blockDoc.getId()) java.lang.RuntimeException: Method 'getId' cannot be resolved in context blockDoc.getId() (line: 38) MethodCallExprContext{wrapped=blockDoc.getId()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlockDetailRenderer.java
Cannot solve method call document.createTextNode(blockDoc.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context blockDoc.getName() (line: 45) MethodCallExprContext{wrapped=blockDoc.getName()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlockDetailRenderer.java
Cannot solve method call literal.appendChild(document.createTextNode(blockDoc.getName())) java.lang.RuntimeException: Error calculating the type of parameter blockDoc.getName() of method call document.createTextNode(blockDoc.getName()) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlockDetailRenderer.java
Cannot solve method call title.appendChild(document.createTextNode(" { }")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode(" { }") (line: 46) MethodCallExprContext{wrapped=document.createTextNode(" { }")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlockDetailRenderer.java
Cannot solve method call section.appendChild(document.importNode(element, true)) java.lang.RuntimeException: Method 'importNode' cannot be resolved in context document.importNode(element, true) (line: 51) MethodCallExprContext{wrapped=document.importNode(element, true)}. Parameter types: [ReferenceType{Element, typeParametersMap=TypeParametersMap{nameToValue={}}}, PrimitiveTypeUsage{name='boolean'}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlockDetailRenderer.java
Cannot solve method call segtitle.appendChild(document.createTextNode("Delegates to")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("Delegates to") (line: 58) MethodCallExprContext{wrapped=document.createTextNode("Delegates to")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlockDetailRenderer.java
Cannot solve method call linkRenderer.link(blockDoc.getType(), listener) java.lang.RuntimeException: Method 'getType' cannot be resolved in context blockDoc.getType() (line: 75) MethodCallExprContext{wrapped=blockDoc.getType()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlockDetailRenderer.java
Cannot solve method call seg.appendChild(linkRenderer.link(blockDoc.getType(), listener)) java.lang.RuntimeException: Error calculating the type of parameter blockDoc.getType() of method call linkRenderer.link(blockDoc.getType(), listener) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlockDetailRenderer.java
Cannot solve method call seg.appendChild(document.createTextNode(" from ")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode(" from ") (line: 76) MethodCallExprContext{wrapped=document.createTextNode(" from ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlockDetailRenderer.java
Method 'getBlockProperty' cannot be resolved in context blockDoc.getBlockProperty() (line: 80) MethodCallExprContext{wrapped=blockDoc.getBlockProperty()}. Parameter types: []
Cannot solve method call link.setAttribute("linkend", blockDoc.getBlockProperty().getId()) java.lang.RuntimeException: Method 'getBlockProperty' cannot be resolved in context blockDoc.getBlockProperty() (line: 80) MethodCallExprContext{wrapped=blockDoc.getBlockProperty()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlockDetailRenderer.java
Method 'getBlockProperty' cannot be resolved in context blockDoc.getBlockProperty() (line: 83) MethodCallExprContext{wrapped=blockDoc.getBlockProperty()}. Parameter types: []
Cannot solve method call document.createTextNode(blockDoc.getBlockProperty().getName()) java.lang.RuntimeException: Method 'getBlockProperty' cannot be resolved in context blockDoc.getBlockProperty() (line: 83) MethodCallExprContext{wrapped=blockDoc.getBlockProperty()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlockDetailRenderer.java
Cannot solve method call literal.appendChild(document.createTextNode(blockDoc.getBlockProperty().getName())) java.lang.RuntimeException: Error calculating the type of parameter blockDoc.getBlockProperty().getName() of method call document.createTextNode(blockDoc.getBlockProperty().getName()) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlockDetailRenderer.java
Cannot solve method call seg.appendChild(document.createTextNode("Each ")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode("Each ") (line: 64) MethodCallExprContext{wrapped=document.createTextNode("Each ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlockDetailRenderer.java
Cannot solve method call linkRenderer.link(blockDoc.getType(), listener) java.lang.RuntimeException: Method 'getType' cannot be resolved in context blockDoc.getType() (line: 65) MethodCallExprContext{wrapped=blockDoc.getType()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlockDetailRenderer.java
Cannot solve method call seg.appendChild(linkRenderer.link(blockDoc.getType(), listener)) java.lang.RuntimeException: Error calculating the type of parameter blockDoc.getType() of method call linkRenderer.link(blockDoc.getType(), listener) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlockDetailRenderer.java
Cannot solve method call seg.appendChild(document.createTextNode(" in ")) java.lang.RuntimeException: Method 'createTextNode' cannot be resolved in context document.createTextNode(" in ") (line: 66) MethodCallExprContext{wrapped=document.createTextNode(" in ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlockDetailRenderer.java
Method 'getBlockProperty' cannot be resolved in context blockDoc.getBlockProperty() (line: 70) MethodCallExprContext{wrapped=blockDoc.getBlockProperty()}. Parameter types: []
Cannot solve method call link.setAttribute("linkend", blockDoc.getBlockProperty().getId()) java.lang.RuntimeException: Method 'getBlockProperty' cannot be resolved in context blockDoc.getBlockProperty() (line: 70) MethodCallExprContext{wrapped=blockDoc.getBlockProperty()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlockDetailRenderer.java
Method 'getBlockProperty' cannot be resolved in context blockDoc.getBlockProperty() (line: 73) MethodCallExprContext{wrapped=blockDoc.getBlockProperty()}. Parameter types: []
Cannot solve method call document.createTextNode(blockDoc.getBlockProperty().getName()) java.lang.RuntimeException: Method 'getBlockProperty' cannot be resolved in context blockDoc.getBlockProperty() (line: 73) MethodCallExprContext{wrapped=blockDoc.getBlockProperty()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlockDetailRenderer.java
Cannot solve method call literal.appendChild(document.createTextNode(blockDoc.getBlockProperty().getName())) java.lang.RuntimeException: Error calculating the type of parameter blockDoc.getBlockProperty().getName() of method call document.createTextNode(blockDoc.getBlockProperty().getName()) /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/BlockDetailRenderer.java
Method 'getMetaData' cannot be resolved in context propertyDoc.getMetaData() (line: 34) MethodCallExprContext{wrapped=propertyDoc.getMetaData()}. Parameter types: []
Method 'getMetaData' cannot be resolved in context propertyDoc.getMetaData() (line: 34) MethodCallExprContext{wrapped=propertyDoc.getMetaData()}. Parameter types: []
Cannot solve method call referencedType.equals(classDoc.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context classDoc.getName() (line: 35) MethodCallExprContext{wrapped=classDoc.getName()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/build/docs/dsl/docbook/ReferencedTypeBuilder.java
Cannot solve field access PathSensitivity.RELATIVE
Cannot solve method call classes.get(reader.getClassName()) java.lang.RuntimeException: Method 'getClassName' cannot be resolved in context reader.getClassName() (line: 179) MethodCallExprContext{wrapped=reader.getClassName()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/ShadedJar.java
Cannot resolve field access null
Cannot solve method call reader.accept(new ClassRemapper(classWriter, new Remapper() {

    public String map(String name) {
        if (ignored.matches(name)) {
            return name;
        }
        ClassDetails dependencyDetails = classes.get(name);
        if (dependencyDetails != details) {
            details.dependencies.add(dependencyDetails);
        }
        return dependencyDetails.outputClassName;
    }
}), ClassReader.EXPAND_FRAMES) UnsolvedSymbolException{context='unknown', name='EXPAND_FRAMES', typeSolver=null} /repo/buildSrc/src/main/groovy/org/gradle/ShadedJar.java
Method 'getParentFile' cannot be resolved in context outputFile.getParentFile() (line: 197) MethodCallExprContext{wrapped=outputFile.getParentFile()}. Parameter types: []
Cannot solve method call outputStream.write(classWriter.toByteArray()) java.lang.RuntimeException: Method 'toByteArray' cannot be resolved in context classWriter.toByteArray() (line: 200) MethodCallExprContext{wrapped=classWriter.toByteArray()}. Parameter types: [] /repo/buildSrc/src/main/groovy/org/gradle/ShadedJar.java
Method 'replace' cannot be resolved in context shadowPackage.replace('.', '/') (line: 290) MethodCallExprContext{wrapped=shadowPackage.replace('.', '/')}. Parameter types: [PrimitiveTypeUsage{name='char'}, PrimitiveTypeUsage{name='char'}]
Cannot solve method call Arrays.asList(formatProperty("action", "notification"), formatProperty("app", "Gradle Snarl Notifier"), formatProperty("class", "alert"), formatProperty("title", title), formatProperty("text", message), formatProperty("icon", icon == null ? null : icon.getAbsolutePath()), formatProperty("timeout", "10")) java.lang.RuntimeException: Method 'formatProperty' cannot be resolved in context formatProperty("action", "notification") (line: 84) MethodCallExprContext{wrapped=formatProperty("action", "notification")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/announce/src/main/java/org/gradle/api/plugins/announce/internal/Snarl.java
Error calculating the type of parameter (username + ":" + password).getBytes("UTF-8") of method call Base64.encodeBase64String((username + ":" + password).getBytes("UTF-8"))
Cannot solve method call logger.debug(IOUtils.toString(inputStream, "UTF-8")) UnsolvedSymbolException{context='Solving IOUtils', name='IOUtils', typeSolver=null} /repo/subprojects/announce/src/main/java/org/gradle/api/plugins/announce/internal/Twitter.java
Method 'replace' cannot be resolved in context value.replace("\\", "\\\\") (line: 70) MethodCallExprContext{wrapped=value.replace("\\", "\\\\")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call LOGGER.debug("Discarding message [" + title + "][" + message + "] as announcer is not available: " + e.getMessage()) java.lang.RuntimeException: Method 'getMessage' cannot be resolved in context e.getMessage() (line: 37) MethodCallExprContext{wrapped=e.getMessage()}. Parameter types: [] /repo/subprojects/announce/src/main/java/org/gradle/api/plugins/announce/internal/IgnoreUnavailableAnnouncer.java
Method 'getMessage' cannot be resolved in context e.getMessage() (line: 193) MethodCallExprContext{wrapped=e.getMessage()}. Parameter types: []
Method 'getGrammars' cannot be resolved in context antlrGrammarFile.getGrammars() (line: 33) MethodCallExprContext{wrapped=antlrGrammarFile.getGrammars()}. Parameter types: []
Cannot solve method call vocabName.substring(0, vocabName.length() - 1) java.lang.RuntimeException: Method 'length' cannot be resolved in context vocabName.length() (line: 125) MethodCallExprContext{wrapped=vocabName.length()}. Parameter types: [] /repo/subprojects/antlr/src/main/java/org/gradle/api/plugins/antlr/internal/antlr2/GrammarDelegate.java
Method 'trim' cannot be resolved in context string.trim() (line: 123) MethodCallExprContext{wrapped=string.trim()}. Parameter types: []
Method 'trim' cannot be resolved in context packageName.trim() (line: 90) MethodCallExprContext{wrapped=packageName.trim()}. Parameter types: []
Cannot solve method call line.substring(8, line.length() - 1) java.lang.RuntimeException: Method 'length' cannot be resolved in context line.length() (line: 84) MethodCallExprContext{wrapped=line.length()}. Parameter types: [] /repo/subprojects/antlr/src/main/java/org/gradle/api/plugins/antlr/internal/antlr2/MetadataExtracter.java
Cannot solve method call dependencies.add(project.getDependencies().create("antlr:antlr:2.7.7@jar")) java.lang.RuntimeException: Method 'create' cannot be resolved in context project.getDependencies().create("antlr:antlr:2.7.7@jar") (line: 62) MethodCallExprContext{wrapped=project.getDependencies().create("antlr:antlr:2.7.7@jar")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/antlr/src/main/java/org/gradle/api/plugins/antlr/AntlrPlugin.java
Cannot solve method call antlrTask.getConventionMapping().map("antlrClasspath", new Callable<Object>() {

    public Object call() throws Exception {
        return project.getConfigurations().getByName(ANTLR_CONFIGURATION_NAME);
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/antlr/src/main/java/org/gradle/api/plugins/antlr/AntlrPlugin.java
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 79) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 79) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call replaceAll(stat.getStatements()) java.lang.RuntimeException: Method 'getStatements' cannot be resolved in context stat.getStatements() (line: 71) MethodCallExprContext{wrapped=stat.getStatements()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/StatementReplacingVisitorSupport.java
Method 'getCollectionExpression' cannot be resolved in context stat.getCollectionExpression() (line: 76) MethodCallExprContext{wrapped=stat.getCollectionExpression()}. Parameter types: []
Cannot solve method call replace(stat.getLoopBlock()) java.lang.RuntimeException: Method 'getLoopBlock' cannot be resolved in context stat.getLoopBlock() (line: 77) MethodCallExprContext{wrapped=stat.getLoopBlock()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/StatementReplacingVisitorSupport.java
Cannot solve method call stat.setLoopBlock(replace(stat.getLoopBlock())) java.lang.RuntimeException: Error calculating the type of parameter stat.getLoopBlock() of method call replace(stat.getLoopBlock()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/StatementReplacingVisitorSupport.java
Method 'getBooleanExpression' cannot be resolved in context stat.getBooleanExpression() (line: 82) MethodCallExprContext{wrapped=stat.getBooleanExpression()}. Parameter types: []
Cannot solve method call replace(stat.getLoopBlock()) java.lang.RuntimeException: Method 'getLoopBlock' cannot be resolved in context stat.getLoopBlock() (line: 83) MethodCallExprContext{wrapped=stat.getLoopBlock()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/StatementReplacingVisitorSupport.java
Cannot solve method call stat.setLoopBlock(replace(stat.getLoopBlock())) java.lang.RuntimeException: Error calculating the type of parameter stat.getLoopBlock() of method call replace(stat.getLoopBlock()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/StatementReplacingVisitorSupport.java
Method 'getBooleanExpression' cannot be resolved in context stat.getBooleanExpression() (line: 88) MethodCallExprContext{wrapped=stat.getBooleanExpression()}. Parameter types: []
Cannot solve method call replace(stat.getLoopBlock()) java.lang.RuntimeException: Method 'getLoopBlock' cannot be resolved in context stat.getLoopBlock() (line: 89) MethodCallExprContext{wrapped=stat.getLoopBlock()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/StatementReplacingVisitorSupport.java
Cannot solve method call stat.setLoopBlock(replace(stat.getLoopBlock())) java.lang.RuntimeException: Error calculating the type of parameter stat.getLoopBlock() of method call replace(stat.getLoopBlock()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/StatementReplacingVisitorSupport.java
Method 'getBooleanExpression' cannot be resolved in context stat.getBooleanExpression() (line: 94) MethodCallExprContext{wrapped=stat.getBooleanExpression()}. Parameter types: []
Cannot solve method call replace(stat.getIfBlock()) java.lang.RuntimeException: Method 'getIfBlock' cannot be resolved in context stat.getIfBlock() (line: 95) MethodCallExprContext{wrapped=stat.getIfBlock()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/StatementReplacingVisitorSupport.java
Cannot solve method call stat.setIfBlock(replace(stat.getIfBlock())) java.lang.RuntimeException: Error calculating the type of parameter stat.getIfBlock() of method call replace(stat.getIfBlock()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/StatementReplacingVisitorSupport.java
Cannot solve method call replace(stat.getElseBlock()) java.lang.RuntimeException: Method 'getElseBlock' cannot be resolved in context stat.getElseBlock() (line: 96) MethodCallExprContext{wrapped=stat.getElseBlock()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/StatementReplacingVisitorSupport.java
Cannot solve method call stat.setElseBlock(replace(stat.getElseBlock())) java.lang.RuntimeException: Error calculating the type of parameter stat.getElseBlock() of method call replace(stat.getElseBlock()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/StatementReplacingVisitorSupport.java
Cannot solve method call replace(stat.getTryStatement()) java.lang.RuntimeException: Method 'getTryStatement' cannot be resolved in context stat.getTryStatement() (line: 102) MethodCallExprContext{wrapped=stat.getTryStatement()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/StatementReplacingVisitorSupport.java
Cannot solve method call stat.setTryStatement(replace(stat.getTryStatement())) java.lang.RuntimeException: Error calculating the type of parameter stat.getTryStatement() of method call replace(stat.getTryStatement()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/StatementReplacingVisitorSupport.java
Cannot solve method call replaceAll(stat.getCatchStatements()) java.lang.RuntimeException: Method 'getCatchStatements' cannot be resolved in context stat.getCatchStatements() (line: 103) MethodCallExprContext{wrapped=stat.getCatchStatements()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/StatementReplacingVisitorSupport.java
Cannot solve method call replace(stat.getFinallyStatement()) java.lang.RuntimeException: Method 'getFinallyStatement' cannot be resolved in context stat.getFinallyStatement() (line: 104) MethodCallExprContext{wrapped=stat.getFinallyStatement()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/StatementReplacingVisitorSupport.java
Cannot solve method call stat.setFinallyStatement(replace(stat.getFinallyStatement())) java.lang.RuntimeException: Error calculating the type of parameter stat.getFinallyStatement() of method call replace(stat.getFinallyStatement()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/StatementReplacingVisitorSupport.java
Method 'getExpression' cannot be resolved in context stat.getExpression() (line: 110) MethodCallExprContext{wrapped=stat.getExpression()}. Parameter types: []
Cannot solve method call replaceAll(stat.getCaseStatements()) java.lang.RuntimeException: Method 'getCaseStatements' cannot be resolved in context stat.getCaseStatements() (line: 111) MethodCallExprContext{wrapped=stat.getCaseStatements()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/StatementReplacingVisitorSupport.java
Cannot solve method call replace(stat.getDefaultStatement()) java.lang.RuntimeException: Method 'getDefaultStatement' cannot be resolved in context stat.getDefaultStatement() (line: 112) MethodCallExprContext{wrapped=stat.getDefaultStatement()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/StatementReplacingVisitorSupport.java
Cannot solve method call stat.setDefaultStatement(replace(stat.getDefaultStatement())) java.lang.RuntimeException: Error calculating the type of parameter stat.getDefaultStatement() of method call replace(stat.getDefaultStatement()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/StatementReplacingVisitorSupport.java
Method 'getExpression' cannot be resolved in context stat.getExpression() (line: 117) MethodCallExprContext{wrapped=stat.getExpression()}. Parameter types: []
Cannot solve method call replace(stat.getCode()) java.lang.RuntimeException: Method 'getCode' cannot be resolved in context stat.getCode() (line: 118) MethodCallExprContext{wrapped=stat.getCode()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/StatementReplacingVisitorSupport.java
Cannot solve method call stat.setCode(replace(stat.getCode())) java.lang.RuntimeException: Error calculating the type of parameter stat.getCode() of method call replace(stat.getCode()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/StatementReplacingVisitorSupport.java
Method 'getExpression' cannot be resolved in context stat.getExpression() (line: 123) MethodCallExprContext{wrapped=stat.getExpression()}. Parameter types: []
Cannot solve method call replace(stat.getCode()) java.lang.RuntimeException: Method 'getCode' cannot be resolved in context stat.getCode() (line: 124) MethodCallExprContext{wrapped=stat.getCode()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/StatementReplacingVisitorSupport.java
Cannot solve method call stat.setCode(replace(stat.getCode())) java.lang.RuntimeException: Error calculating the type of parameter stat.getCode() of method call replace(stat.getCode()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/StatementReplacingVisitorSupport.java
Cannot solve method call replace(stat.getCode()) java.lang.RuntimeException: Method 'getCode' cannot be resolved in context stat.getCode() (line: 129) MethodCallExprContext{wrapped=stat.getCode()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/StatementReplacingVisitorSupport.java
Cannot solve method call stat.setCode(replace(stat.getCode())) java.lang.RuntimeException: Error calculating the type of parameter stat.getCode() of method call replace(stat.getCode()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/StatementReplacingVisitorSupport.java
Method 'getMethod' cannot be resolved in context call.getMethod() (line: 47) MethodCallExprContext{wrapped=call.getMethod()}. Parameter types: []
Method 'getMethod' cannot be resolved in context call.getMethod() (line: 47) MethodCallExprContext{wrapped=call.getMethod()}. Parameter types: []
Method 'getText' cannot be resolved in context target.getText() (line: 53) MethodCallExprContext{wrapped=target.getText()}. Parameter types: []
Method 'getAST' cannot be resolved in context source.getAST() (line: 57) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Method 'getAST' cannot be resolved in context source.getAST() (line: 57) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Method 'getCode' cannot be resolved in context methodNode.getCode() (line: 60) MethodCallExprContext{wrapped=methodNode.getCode()}. Parameter types: []
Method 'getAST' cannot be resolved in context source.getAST() (line: 58) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Method 'getAST' cannot be resolved in context source.getAST() (line: 65) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Method 'getAST' cannot be resolved in context source.getAST() (line: 65) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Method 'getAST' cannot be resolved in context source.getAST() (line: 65) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Method 'getAST' cannot be resolved in context source.getAST() (line: 65) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Method 'getAST' cannot be resolved in context source.getAST() (line: 65) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Method 'getAST' cannot be resolved in context source.getAST() (line: 69) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Method 'getAST' cannot be resolved in context source.getAST() (line: 69) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Method 'getMethods' cannot be resolved in context declaringClass.getMethods() (line: 73) MethodCallExprContext{wrapped=declaringClass.getMethods()}. Parameter types: []
Cannot solve method call declaringClass.getDeclaredMethods(methodNode.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context methodNode.getName() (line: 74) MethodCallExprContext{wrapped=methodNode.getName()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/AstUtils.java
Error calculating the type of parameter methodNode.getName() of method call declaringClass.getDeclaredMethods(methodNode.getName())
Method 'getAST' cannot be resolved in context source.getAST() (line: 78) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Method 'getAST' cannot be resolved in context source.getAST() (line: 78) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Method 'getAST' cannot be resolved in context source.getAST() (line: 78) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Method 'getClassLoader' cannot be resolved in context source.getClassLoader() (line: 92) MethodCallExprContext{wrapped=source.getClassLoader()}. Parameter types: []
Method 'getMethod' cannot be resolved in context methodCall.getMethod() (line: 124) MethodCallExprContext{wrapped=methodCall.getMethod()}. Parameter types: []
Method 'getExpressions' cannot be resolved in context args.getExpressions() (line: 149) MethodCallExprContext{wrapped=args.getExpressions()}. Parameter types: []
Method 'getExpressions' cannot be resolved in context args.getExpressions() (line: 162) MethodCallExprContext{wrapped=args.getExpressions()}. Parameter types: []
Method 'getExpressions' cannot be resolved in context args.getExpressions() (line: 175) MethodCallExprContext{wrapped=args.getExpressions()}. Parameter types: []
Cannot solve method call names.contains(input.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context input.getName() (line: 196) MethodCallExprContext{wrapped=input.getName()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/AstUtils.java
Method 'getType' cannot be resolved in context constantExpression.getType() (line: 202) MethodCallExprContext{wrapped=constantExpression.getType()}. Parameter types: []
Method 'getType' cannot be resolved in context constantExpression.getType() (line: 202) MethodCallExprContext{wrapped=constantExpression.getType()}. Parameter types: []
Method 'getExpressions' cannot be resolved in context argumentList.getExpressions() (line: 213) MethodCallExprContext{wrapped=argumentList.getExpressions()}. Parameter types: []
Method 'getExpressions' cannot be resolved in context argumentList.getExpressions() (line: 214) MethodCallExprContext{wrapped=argumentList.getExpressions()}. Parameter types: []
Cannot solve method call classNode.implementsInterface(ClassHelper.GENERATED_CLOSURE_Type) UnsolvedSymbolException{context='unknown', name='GENERATED_CLOSURE_Type', typeSolver=null} /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/AstUtils.java
Method 'getErrorCollector' cannot be resolved in context sourceUnit.getErrorCollector() (line: 42) MethodCallExprContext{wrapped=sourceUnit.getErrorCollector()}. Parameter types: []
Cannot solve method call replaceAll(stat.getStatements()) java.lang.RuntimeException: Method 'getStatements' cannot be resolved in context stat.getStatements() (line: 63) MethodCallExprContext{wrapped=stat.getStatements()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(stat.getCollectionExpression()) java.lang.RuntimeException: Method 'getCollectionExpression' cannot be resolved in context stat.getCollectionExpression() (line: 68) MethodCallExprContext{wrapped=stat.getCollectionExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call stat.setCollectionExpression(replaceExpr(stat.getCollectionExpression())) java.lang.RuntimeException: Error calculating the type of parameter stat.getCollectionExpression() of method call replaceExpr(stat.getCollectionExpression()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replace(stat.getLoopBlock()) java.lang.RuntimeException: Method 'getLoopBlock' cannot be resolved in context stat.getLoopBlock() (line: 69) MethodCallExprContext{wrapped=stat.getLoopBlock()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call stat.setLoopBlock(replace(stat.getLoopBlock())) java.lang.RuntimeException: Error calculating the type of parameter stat.getLoopBlock() of method call replace(stat.getLoopBlock()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(stat.getBooleanExpression()) java.lang.RuntimeException: Method 'getBooleanExpression' cannot be resolved in context stat.getBooleanExpression() (line: 74) MethodCallExprContext{wrapped=stat.getBooleanExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replace(stat.getLoopBlock()) java.lang.RuntimeException: Method 'getLoopBlock' cannot be resolved in context stat.getLoopBlock() (line: 75) MethodCallExprContext{wrapped=stat.getLoopBlock()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call stat.setLoopBlock(replace(stat.getLoopBlock())) java.lang.RuntimeException: Error calculating the type of parameter stat.getLoopBlock() of method call replace(stat.getLoopBlock()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(stat.getBooleanExpression()) java.lang.RuntimeException: Method 'getBooleanExpression' cannot be resolved in context stat.getBooleanExpression() (line: 80) MethodCallExprContext{wrapped=stat.getBooleanExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replace(stat.getLoopBlock()) java.lang.RuntimeException: Method 'getLoopBlock' cannot be resolved in context stat.getLoopBlock() (line: 81) MethodCallExprContext{wrapped=stat.getLoopBlock()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call stat.setLoopBlock(replace(stat.getLoopBlock())) java.lang.RuntimeException: Error calculating the type of parameter stat.getLoopBlock() of method call replace(stat.getLoopBlock()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(stat.getBooleanExpression()) java.lang.RuntimeException: Method 'getBooleanExpression' cannot be resolved in context stat.getBooleanExpression() (line: 86) MethodCallExprContext{wrapped=stat.getBooleanExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replace(stat.getIfBlock()) java.lang.RuntimeException: Method 'getIfBlock' cannot be resolved in context stat.getIfBlock() (line: 87) MethodCallExprContext{wrapped=stat.getIfBlock()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call stat.setIfBlock(replace(stat.getIfBlock())) java.lang.RuntimeException: Error calculating the type of parameter stat.getIfBlock() of method call replace(stat.getIfBlock()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replace(stat.getElseBlock()) java.lang.RuntimeException: Method 'getElseBlock' cannot be resolved in context stat.getElseBlock() (line: 88) MethodCallExprContext{wrapped=stat.getElseBlock()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call stat.setElseBlock(replace(stat.getElseBlock())) java.lang.RuntimeException: Error calculating the type of parameter stat.getElseBlock() of method call replace(stat.getElseBlock()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replace(stat.getTryStatement()) java.lang.RuntimeException: Method 'getTryStatement' cannot be resolved in context stat.getTryStatement() (line: 94) MethodCallExprContext{wrapped=stat.getTryStatement()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call stat.setTryStatement(replace(stat.getTryStatement())) java.lang.RuntimeException: Error calculating the type of parameter stat.getTryStatement() of method call replace(stat.getTryStatement()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceAll(stat.getCatchStatements()) java.lang.RuntimeException: Method 'getCatchStatements' cannot be resolved in context stat.getCatchStatements() (line: 95) MethodCallExprContext{wrapped=stat.getCatchStatements()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replace(stat.getFinallyStatement()) java.lang.RuntimeException: Method 'getFinallyStatement' cannot be resolved in context stat.getFinallyStatement() (line: 96) MethodCallExprContext{wrapped=stat.getFinallyStatement()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call stat.setFinallyStatement(replace(stat.getFinallyStatement())) java.lang.RuntimeException: Error calculating the type of parameter stat.getFinallyStatement() of method call replace(stat.getFinallyStatement()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(stat.getExpression()) java.lang.RuntimeException: Method 'getExpression' cannot be resolved in context stat.getExpression() (line: 102) MethodCallExprContext{wrapped=stat.getExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call stat.setExpression(replaceExpr(stat.getExpression())) java.lang.RuntimeException: Error calculating the type of parameter stat.getExpression() of method call replaceExpr(stat.getExpression()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceAll(stat.getCaseStatements()) java.lang.RuntimeException: Method 'getCaseStatements' cannot be resolved in context stat.getCaseStatements() (line: 103) MethodCallExprContext{wrapped=stat.getCaseStatements()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replace(stat.getDefaultStatement()) java.lang.RuntimeException: Method 'getDefaultStatement' cannot be resolved in context stat.getDefaultStatement() (line: 104) MethodCallExprContext{wrapped=stat.getDefaultStatement()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call stat.setDefaultStatement(replace(stat.getDefaultStatement())) java.lang.RuntimeException: Error calculating the type of parameter stat.getDefaultStatement() of method call replace(stat.getDefaultStatement()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(stat.getExpression()) java.lang.RuntimeException: Method 'getExpression' cannot be resolved in context stat.getExpression() (line: 109) MethodCallExprContext{wrapped=stat.getExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call stat.setExpression(replaceExpr(stat.getExpression())) java.lang.RuntimeException: Error calculating the type of parameter stat.getExpression() of method call replaceExpr(stat.getExpression()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replace(stat.getCode()) java.lang.RuntimeException: Method 'getCode' cannot be resolved in context stat.getCode() (line: 110) MethodCallExprContext{wrapped=stat.getCode()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call stat.setCode(replace(stat.getCode())) java.lang.RuntimeException: Error calculating the type of parameter stat.getCode() of method call replace(stat.getCode()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(stat.getExpression()) java.lang.RuntimeException: Method 'getExpression' cannot be resolved in context stat.getExpression() (line: 115) MethodCallExprContext{wrapped=stat.getExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call stat.setExpression(replaceExpr(stat.getExpression())) java.lang.RuntimeException: Error calculating the type of parameter stat.getExpression() of method call replaceExpr(stat.getExpression()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replace(stat.getCode()) java.lang.RuntimeException: Method 'getCode' cannot be resolved in context stat.getCode() (line: 116) MethodCallExprContext{wrapped=stat.getCode()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call stat.setCode(replace(stat.getCode())) java.lang.RuntimeException: Error calculating the type of parameter stat.getCode() of method call replace(stat.getCode()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replace(stat.getCode()) java.lang.RuntimeException: Method 'getCode' cannot be resolved in context stat.getCode() (line: 121) MethodCallExprContext{wrapped=stat.getCode()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call stat.setCode(replace(stat.getCode())) java.lang.RuntimeException: Error calculating the type of parameter stat.getCode() of method call replace(stat.getCode()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(expr.getObjectExpression()) java.lang.RuntimeException: Method 'getObjectExpression' cannot be resolved in context expr.getObjectExpression() (line: 126) MethodCallExprContext{wrapped=expr.getObjectExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call expr.setObjectExpression(replaceExpr(expr.getObjectExpression())) java.lang.RuntimeException: Error calculating the type of parameter expr.getObjectExpression() of method call replaceExpr(expr.getObjectExpression()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(expr.getMethod()) java.lang.RuntimeException: Method 'getMethod' cannot be resolved in context expr.getMethod() (line: 127) MethodCallExprContext{wrapped=expr.getMethod()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call expr.setMethod(replaceExpr(expr.getMethod())) java.lang.RuntimeException: Error calculating the type of parameter expr.getMethod() of method call replaceExpr(expr.getMethod()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(expr.getArguments()) java.lang.RuntimeException: Method 'getArguments' cannot be resolved in context expr.getArguments() (line: 128) MethodCallExprContext{wrapped=expr.getArguments()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call expr.setArguments(replaceExpr(expr.getArguments())) java.lang.RuntimeException: Error calculating the type of parameter expr.getArguments() of method call replaceExpr(expr.getArguments()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(expr.getArguments()) java.lang.RuntimeException: Method 'getArguments' cannot be resolved in context expr.getArguments() (line: 136) MethodCallExprContext{wrapped=expr.getArguments()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call result.setType(expr.getType()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context expr.getType() (line: 137) MethodCallExprContext{wrapped=expr.getType()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(expr.getArguments()) java.lang.RuntimeException: Method 'getArguments' cannot be resolved in context expr.getArguments() (line: 146) MethodCallExprContext{wrapped=expr.getArguments()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(expr.getLeftExpression()) java.lang.RuntimeException: Method 'getLeftExpression' cannot be resolved in context expr.getLeftExpression() (line: 153) MethodCallExprContext{wrapped=expr.getLeftExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call expr.setLeftExpression(replaceExpr(expr.getLeftExpression())) java.lang.RuntimeException: Error calculating the type of parameter expr.getLeftExpression() of method call replaceExpr(expr.getLeftExpression()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(expr.getRightExpression()) java.lang.RuntimeException: Method 'getRightExpression' cannot be resolved in context expr.getRightExpression() (line: 154) MethodCallExprContext{wrapped=expr.getRightExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call expr.setRightExpression(replaceExpr(expr.getRightExpression())) java.lang.RuntimeException: Error calculating the type of parameter expr.getRightExpression() of method call replaceExpr(expr.getRightExpression()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(expr.getBooleanExpression()) java.lang.RuntimeException: Method 'getBooleanExpression' cannot be resolved in context expr.getBooleanExpression() (line: 160) MethodCallExprContext{wrapped=expr.getBooleanExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(expr.getTrueExpression()) java.lang.RuntimeException: Method 'getTrueExpression' cannot be resolved in context expr.getTrueExpression() (line: 161) MethodCallExprContext{wrapped=expr.getTrueExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(expr.getFalseExpression()) java.lang.RuntimeException: Method 'getFalseExpression' cannot be resolved in context expr.getFalseExpression() (line: 162) MethodCallExprContext{wrapped=expr.getFalseExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call result.setType(expr.getType()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context expr.getType() (line: 163) MethodCallExprContext{wrapped=expr.getType()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(expr.getTrueExpression()) java.lang.RuntimeException: Method 'getTrueExpression' cannot be resolved in context expr.getTrueExpression() (line: 171) MethodCallExprContext{wrapped=expr.getTrueExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(expr.getFalseExpression()) java.lang.RuntimeException: Method 'getFalseExpression' cannot be resolved in context expr.getFalseExpression() (line: 172) MethodCallExprContext{wrapped=expr.getFalseExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call result.setType(expr.getType()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context expr.getType() (line: 173) MethodCallExprContext{wrapped=expr.getType()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(expr.getExpression()) java.lang.RuntimeException: Method 'getExpression' cannot be resolved in context expr.getExpression() (line: 180) MethodCallExprContext{wrapped=expr.getExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call expr.setExpression(replaceExpr(expr.getExpression())) java.lang.RuntimeException: Error calculating the type of parameter expr.getExpression() of method call replaceExpr(expr.getExpression()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(expr.getExpression()) java.lang.RuntimeException: Method 'getExpression' cannot be resolved in context expr.getExpression() (line: 185) MethodCallExprContext{wrapped=expr.getExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call expr.setExpression(replaceExpr(expr.getExpression())) java.lang.RuntimeException: Error calculating the type of parameter expr.getExpression() of method call replaceExpr(expr.getExpression()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(expr.getExpression()) java.lang.RuntimeException: Method 'getExpression' cannot be resolved in context expr.getExpression() (line: 191) MethodCallExprContext{wrapped=expr.getExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call result.setType(expr.getType()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context expr.getType() (line: 192) MethodCallExprContext{wrapped=expr.getType()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(expr.getExpression()) java.lang.RuntimeException: Method 'getExpression' cannot be resolved in context expr.getExpression() (line: 200) MethodCallExprContext{wrapped=expr.getExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call result.setType(expr.getType()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context expr.getType() (line: 201) MethodCallExprContext{wrapped=expr.getType()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(parameter.getInitialExpression()) java.lang.RuntimeException: Method 'getInitialExpression' cannot be resolved in context parameter.getInitialExpression() (line: 210) MethodCallExprContext{wrapped=parameter.getInitialExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call parameter.setInitialExpression(replaceExpr(parameter.getInitialExpression())) java.lang.RuntimeException: Error calculating the type of parameter parameter.getInitialExpression() of method call replaceExpr(parameter.getInitialExpression()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Method 'getCode' cannot be resolved in context expr.getCode() (line: 213) MethodCallExprContext{wrapped=expr.getCode()}. Parameter types: []
Cannot solve method call replaceAllExprs(expr.getExpressions()) java.lang.RuntimeException: Method 'getExpressions' cannot be resolved in context expr.getExpressions() (line: 220) MethodCallExprContext{wrapped=expr.getExpressions()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceAllExprs(expr.getExpressions()) java.lang.RuntimeException: Method 'getExpressions' cannot be resolved in context expr.getExpressions() (line: 226) MethodCallExprContext{wrapped=expr.getExpressions()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceAllExprs(expr.getExpressions()) java.lang.RuntimeException: Method 'getExpressions' cannot be resolved in context expr.getExpressions() (line: 232) MethodCallExprContext{wrapped=expr.getExpressions()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceAllExprs(expr.getSizeExpression()) java.lang.RuntimeException: Method 'getSizeExpression' cannot be resolved in context expr.getSizeExpression() (line: 233) MethodCallExprContext{wrapped=expr.getSizeExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceAllExprs(expr.getMapEntryExpressions()) java.lang.RuntimeException: Method 'getMapEntryExpressions' cannot be resolved in context expr.getMapEntryExpressions() (line: 239) MethodCallExprContext{wrapped=expr.getMapEntryExpressions()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(expr.getKeyExpression()) java.lang.RuntimeException: Method 'getKeyExpression' cannot be resolved in context expr.getKeyExpression() (line: 246) MethodCallExprContext{wrapped=expr.getKeyExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(expr.getValueExpression()) java.lang.RuntimeException: Method 'getValueExpression' cannot be resolved in context expr.getValueExpression() (line: 247) MethodCallExprContext{wrapped=expr.getValueExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call result.setType(expr.getType()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context expr.getType() (line: 249) MethodCallExprContext{wrapped=expr.getType()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(expr.getFrom()) java.lang.RuntimeException: Method 'getFrom' cannot be resolved in context expr.getFrom() (line: 257) MethodCallExprContext{wrapped=expr.getFrom()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(expr.getTo()) java.lang.RuntimeException: Method 'getTo' cannot be resolved in context expr.getTo() (line: 258) MethodCallExprContext{wrapped=expr.getTo()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call result.setType(expr.getType()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context expr.getType() (line: 261) MethodCallExprContext{wrapped=expr.getType()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(expr.getExpression()) java.lang.RuntimeException: Method 'getExpression' cannot be resolved in context expr.getExpression() (line: 269) MethodCallExprContext{wrapped=expr.getExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call result.setType(expr.getType()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context expr.getType() (line: 271) MethodCallExprContext{wrapped=expr.getType()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(expr.getExpression()) java.lang.RuntimeException: Method 'getExpression' cannot be resolved in context expr.getExpression() (line: 279) MethodCallExprContext{wrapped=expr.getExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call result.setType(expr.getType()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context expr.getType() (line: 281) MethodCallExprContext{wrapped=expr.getType()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(expr.getExpression()) java.lang.RuntimeException: Method 'getExpression' cannot be resolved in context expr.getExpression() (line: 289) MethodCallExprContext{wrapped=expr.getExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call result.setType(expr.getType()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context expr.getType() (line: 292) MethodCallExprContext{wrapped=expr.getType()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(expr.getExpression()) java.lang.RuntimeException: Method 'getExpression' cannot be resolved in context expr.getExpression() (line: 300) MethodCallExprContext{wrapped=expr.getExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call result.setType(expr.getType()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context expr.getType() (line: 302) MethodCallExprContext{wrapped=expr.getType()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(expr.getExpression()) java.lang.RuntimeException: Method 'getExpression' cannot be resolved in context expr.getExpression() (line: 310) MethodCallExprContext{wrapped=expr.getExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call result.setType(expr.getType()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context expr.getType() (line: 312) MethodCallExprContext{wrapped=expr.getType()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(expr.getExpression()) java.lang.RuntimeException: Method 'getExpression' cannot be resolved in context expr.getExpression() (line: 320) MethodCallExprContext{wrapped=expr.getExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call result.setType(expr.getType()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context expr.getType() (line: 322) MethodCallExprContext{wrapped=expr.getType()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(expr.getExpression()) java.lang.RuntimeException: Method 'getExpression' cannot be resolved in context expr.getExpression() (line: 331) MethodCallExprContext{wrapped=expr.getExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call result.setCoerce(expr.isCoerce()) java.lang.RuntimeException: Method 'isCoerce' cannot be resolved in context expr.isCoerce() (line: 334) MethodCallExprContext{wrapped=expr.isCoerce()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call result.setType(expr.getType()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context expr.getType() (line: 335) MethodCallExprContext{wrapped=expr.getType()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(expr.getObjectExpression()) java.lang.RuntimeException: Method 'getObjectExpression' cannot be resolved in context expr.getObjectExpression() (line: 349) MethodCallExprContext{wrapped=expr.getObjectExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(expr.getProperty()) java.lang.RuntimeException: Method 'getProperty' cannot be resolved in context expr.getProperty() (line: 350) MethodCallExprContext{wrapped=expr.getProperty()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call result.setSpreadSafe(expr.isSpreadSafe()) java.lang.RuntimeException: Method 'isSpreadSafe' cannot be resolved in context expr.isSpreadSafe() (line: 353) MethodCallExprContext{wrapped=expr.isSpreadSafe()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call result.setStatic(expr.isStatic()) java.lang.RuntimeException: Method 'isStatic' cannot be resolved in context expr.isStatic() (line: 354) MethodCallExprContext{wrapped=expr.isStatic()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call result.setImplicitThis(expr.isImplicitThis()) java.lang.RuntimeException: Method 'isImplicitThis' cannot be resolved in context expr.isImplicitThis() (line: 355) MethodCallExprContext{wrapped=expr.isImplicitThis()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call result.setType(expr.getType()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context expr.getType() (line: 356) MethodCallExprContext{wrapped=expr.getType()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceAllExprs(expr.getStrings()) java.lang.RuntimeException: Method 'getStrings' cannot be resolved in context expr.getStrings() (line: 370) MethodCallExprContext{wrapped=expr.getStrings()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceAllExprs(expr.getValues()) java.lang.RuntimeException: Method 'getValues' cannot be resolved in context expr.getValues() (line: 371) MethodCallExprContext{wrapped=expr.getValues()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(stat.getBooleanExpression()) java.lang.RuntimeException: Method 'getBooleanExpression' cannot be resolved in context stat.getBooleanExpression() (line: 388) MethodCallExprContext{wrapped=stat.getBooleanExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(stat.getMessageExpression()) java.lang.RuntimeException: Method 'getMessageExpression' cannot be resolved in context stat.getMessageExpression() (line: 389) MethodCallExprContext{wrapped=stat.getMessageExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(stat.getExpression()) java.lang.RuntimeException: Method 'getExpression' cannot be resolved in context stat.getExpression() (line: 394) MethodCallExprContext{wrapped=stat.getExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call stat.setExpression(replaceExpr(stat.getExpression())) java.lang.RuntimeException: Error calculating the type of parameter stat.getExpression() of method call replaceExpr(stat.getExpression()) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(stat.getExpression()) java.lang.RuntimeException: Method 'getExpression' cannot be resolved in context stat.getExpression() (line: 399) MethodCallExprContext{wrapped=stat.getExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call replaceExpr(stat.getExpression()) java.lang.RuntimeException: Method 'getExpression' cannot be resolved in context stat.getExpression() (line: 404) MethodCallExprContext{wrapped=stat.getExpression()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/groovy/scripts/internal/ExpressionReplacingVisitorSupport.java
Cannot solve method call Iterables.transform(Iterables.concat(Arrays.asList(Object.class.getMethods()), Arrays.asList(GroovyObject.class.getMethods())), new Function<Method, Equivalence.Wrapper<Method>>() {

    public Equivalence.Wrapper<Method> apply(@Nullable Method input) {
        return SIGNATURE_EQUIVALENCE.wrap(input);
    }
}) UnsolvedSymbolException{context='Method 'concat' with parameterTypes [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.lang.reflect.Method, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.lang.reflect.Method, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/base-services-groovy/src/main/java/org/gradle/internal/reflect/GroovyMethods.java
Cannot solve method call ImmutableSet.copyOf(Iterables.transform(Iterables.concat(Arrays.asList(Object.class.getMethods()), Arrays.asList(GroovyObject.class.getMethods())), new Function<Method, Equivalence.Wrapper<Method>>() {

    public Equivalence.Wrapper<Method> apply(@Nullable Method input) {
        return SIGNATURE_EQUIVALENCE.wrap(input);
    }
})) java.lang.RuntimeException: Error calculating the type of parameter Iterables.concat(Arrays.asList(Object.class.getMethods()), Arrays.asList(GroovyObject.class.getMethods())) of method call Iterables.transform(Iterables.concat(Arrays.asList(Object.class.getMethods()), Arrays.asList(GroovyObject.class.getMethods())), new Function<Method, Equivalence.Wrapper<Method>>() {

    public Equivalence.Wrapper<Method> apply(@Nullable Method input) {
        return SIGNATURE_EQUIVALENCE.wrap(input);
    }
}) /repo/subprojects/base-services-groovy/src/main/java/org/gradle/internal/reflect/GroovyMethods.java
Cannot solve method call OBJECT_METHODS.contains(SIGNATURE_EQUIVALENCE.wrap(method)) java.lang.RuntimeException: Method 'wrap' cannot be resolved in context SIGNATURE_EQUIVALENCE.wrap(method) (line: 51) MethodCallExprContext{wrapped=SIGNATURE_EQUIVALENCE.wrap(method)}. Parameter types: [ReferenceType{java.lang.reflect.Method, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/internal/reflect/GroovyMethods.java
Cannot resolve field access null
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call Objects.equal(e.getType(), closure.getClass()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context e.getType() (line: 74) MethodCallExprContext{wrapped=e.getType()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/api/internal/ClosureBackedAction.java
Cannot solve method call Objects.equal(e.getMethod(), "doCall") java.lang.RuntimeException: Method 'getMethod' cannot be resolved in context e.getMethod() (line: 74) MethodCallExprContext{wrapped=e.getMethod()}. Parameter types: [] /repo/subprojects/base-services-groovy/src/main/java/org/gradle/api/internal/ClosureBackedAction.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call uncheckedCast(ObjectArrays.newArray(Spec.class, thisLength + specs.length)) UnsolvedSymbolException{context='Solving ObjectArrays', name='ObjectArrays', typeSolver=null} /repo/subprojects/base-services-groovy/src/main/java/org/gradle/api/specs/AndSpec.java
Cannot resolve field access null
Cannot solve method call toMessage(closure, argument) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/base-services-groovy/src/main/java/org/gradle/api/InvalidActionClosureException.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call CollectionUtils.collect(closure.getParameterTypes(), new Transformer<Object, Class>() {

    public Object transform(Class clazz) {
        return clazz.getName();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/base-services-groovy/src/main/java/org/gradle/api/InvalidActionClosureException.java
Cannot solve method call String.format("The closure '%s' is not valid as an action for argument '%s'. It should accept no parameters, or one compatible with type '%s'. It accepts (%s).", closure, argument, argument.getClass().getName(), CollectionUtils.join(", ", classNames)) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/base-services-groovy/src/main/java/org/gradle/api/InvalidActionClosureException.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call bh.consume(randomClasses[++i % ARR_LEN].getConstructors()) java.lang.RuntimeException: Method 'getConstructors' cannot be resolved in context randomClasses[++i % ARR_LEN].getConstructors() (line: 49) MethodCallExprContext{wrapped=randomClasses[++i % ARR_LEN].getConstructors()}. Parameter types: [] /repo/subprojects/base-services/src/jmh/java/org/gradle/internal/reflect/CachedConstructorsBenchmark.java
Cannot solve method call bh.consume(cache.get(randomClasses[++i % ARR_LEN])) java.lang.RuntimeException: Method 'get' cannot be resolved in context cache.get(randomClasses[++i % ARR_LEN]) (line: 54) MethodCallExprContext{wrapped=cache.get(randomClasses[++i % ARR_LEN])}. Parameter types: [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=null, boundedType=null}}}}] /repo/subprojects/base-services/src/jmh/java/org/gradle/internal/reflect/CachedConstructorsBenchmark.java
Cannot solve method call String.format("%s, for example %s.", candidate.description, Joiner.on(", ").join(candidate.examples)) UnsolvedSymbolException{context='Method 'on' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=Joiner}'} /repo/subprojects/base-services/src/main/java/org/gradle/internal/exceptions/FormattingDiagnosticsVisitor.java
Cannot solve method call formatted.add(String.format("%s, for example %s.", candidate.description, Joiner.on(", ").join(candidate.examples))) java.lang.RuntimeException: Error calculating the type of parameter Joiner.on(", ").join(candidate.examples) of method call String.format("%s, for example %s.", candidate.description, Joiner.on(", ").join(candidate.examples)) /repo/subprojects/base-services/src/main/java/org/gradle/internal/exceptions/FormattingDiagnosticsVisitor.java
Method 'toLowerCase' cannot be resolved in context vendor.toLowerCase() (line: 62) MethodCallExprContext{wrapped=vendor.toLowerCase()}. Parameter types: []
Method 'toLowerCase' cannot be resolved in context vendor.toLowerCase() (line: 65) MethodCallExprContext{wrapped=vendor.toLowerCase()}. Parameter types: []
Cannot solve method call LOGGER.info(String.format("Unable to find the '%s' executable using home: %s. We found it on the PATH: %s.", command, getJavaHome(), pathExecutable)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/base-services/src/main/java/org/gradle/internal/jvm/Jvm.java
Cannot solve method call LOGGER.error(String.format("Could not stop %s.", element), throwable) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.internal.concurrent.Stoppable, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/base-services/src/main/java/org/gradle/internal/concurrent/CompositeStoppable.java
Cannot resolve field access null
Cannot solve method call stop(Integer.MAX_VALUE, TimeUnit.SECONDS) UnsolvedSymbolException{context='unknown', name='MAX_VALUE', typeSolver=null} /repo/subprojects/base-services/src/main/java/org/gradle/internal/concurrent/StoppableExecutorImpl.java
Cannot solve field access State.RUNNING
Empty name expression STOPPING
Empty name expression STOPPED
Cannot solve method call usages.get(Thread.currentThread()) UnsolvedSymbolException{context='Method 'currentThread' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Thread}'} /repo/subprojects/base-services/src/main/java/org/gradle/internal/concurrent/ServiceLifecycle.java
Cannot solve method call usages.put(Thread.currentThread(), depth + 1) UnsolvedSymbolException{context='Method 'currentThread' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Thread}'} /repo/subprojects/base-services/src/main/java/org/gradle/internal/concurrent/ServiceLifecycle.java
Cannot solve method call usages.put(Thread.currentThread(), 1) UnsolvedSymbolException{context='Method 'currentThread' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Thread}'} /repo/subprojects/base-services/src/main/java/org/gradle/internal/concurrent/ServiceLifecycle.java
Cannot solve method call usages.remove(Thread.currentThread()) UnsolvedSymbolException{context='Method 'currentThread' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Thread}'} /repo/subprojects/base-services/src/main/java/org/gradle/internal/concurrent/ServiceLifecycle.java
Cannot solve method call usages.put(Thread.currentThread(), depth - 1) UnsolvedSymbolException{context='Method 'currentThread' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Thread}'} /repo/subprojects/base-services/src/main/java/org/gradle/internal/concurrent/ServiceLifecycle.java
Cannot solve field access State.STOPPING
Cannot solve field access State.STOPPED
Cannot solve field access State.RUNNING
Cannot solve field access State.STOPPING
Cannot solve field access State.STOPPED
Cannot solve method call usages.containsKey(Thread.currentThread()) UnsolvedSymbolException{context='Method 'currentThread' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Thread}'} /repo/subprojects/base-services/src/main/java/org/gradle/internal/concurrent/ServiceLifecycle.java
Cannot solve field access State.RUNNING
Cannot solve field access State.STOPPING
Cannot solve field access State.STOPPED
Cannot solve field access State.STOPPED
Cannot solve method call LOGGER.error(String.format("Failed to execute %s.", command), throwable) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{Runnable, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/base-services/src/main/java/org/gradle/internal/concurrent/ExecutorPolicy.java
Cannot solve method call rc.append(Integer.toHexString(c)) UnsolvedSymbolException{context='Method 'toHexString' with parameterTypes [PrimitiveTypeUsage{name='char'}]', name='ReflectionClassDeclaration{clazz=Integer}'} /repo/subprojects/base-services/src/main/java/org/gradle/internal/FileUtils.java
Cannot solve method call Collections.synchronizedList(Lists.<QueuedOperation>newArrayList()) UnsolvedSymbolException{context='Method 'newArrayList' with parameterTypes []', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Lists}'} /repo/subprojects/base-services/src/main/java/org/gradle/internal/operations/DefaultBuildOperationQueue.java
Cannot solve method call "Worker ".concat(worker.getDisplayName()) java.lang.RuntimeException: Method 'getDisplayName' cannot be resolved in context worker.getDisplayName() (line: 163) MethodCallExprContext{wrapped=worker.getDisplayName()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/operations/DefaultBuildOperationQueue.java
Error calculating the type of parameter worker.getDisplayName() of method call "Worker ".concat(worker.getDisplayName())
Error calculating the type of parameter worker.getDisplayName() of method call "Worker ".concat(worker.getDisplayName())
Cannot solve method call threads.get(Thread.currentThread()) UnsolvedSymbolException{context='Method 'currentThread' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Thread}'} /repo/subprojects/base-services/src/main/java/org/gradle/internal/operations/DefaultBuildOperationWorkerRegistry.java
Cannot solve method call String.format("%n    %s", cause.getMessage()) java.lang.RuntimeException: Method 'getMessage' cannot be resolved in context cause.getMessage() (line: 34) MethodCallExprContext{wrapped=cause.getMessage()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/operations/MultipleBuildOperationFailures.java
Cannot solve method call sb.append(String.format("%n    %s", cause.getMessage())) java.lang.RuntimeException: Error calculating the type of parameter cause.getMessage() of method call String.format("%n    %s", cause.getMessage()) /repo/subprojects/base-services/src/main/java/org/gradle/internal/operations/MultipleBuildOperationFailures.java
Cannot solve method call sb.append(String.format("%n    ...and %d more failures.", suppressedFailureCount)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, PrimitiveTypeUsage{name='int'}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/base-services/src/main/java/org/gradle/internal/operations/MultipleBuildOperationFailures.java
Cannot solve method call sb.append(String.format("%n    ...and %d more failure.", suppressedFailureCount)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, PrimitiveTypeUsage{name='int'}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/base-services/src/main/java/org/gradle/internal/operations/MultipleBuildOperationFailures.java
Cannot solve method call sb.append(String.format("%nSee the complete log at: ")) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/base-services/src/main/java/org/gradle/internal/operations/MultipleBuildOperationFailures.java
Error calculating the type of parameter String.format("%nSee the complete log at: ") of method call sb.append(String.format("%nSee the complete log at: "))
Cannot resolve field access null
Method 'weakValues' cannot be resolved in context new MapMaker().weakValues() (line: 27) MethodCallExprContext{wrapped=new MapMaker().weakValues()}. Parameter types: []
Cannot solve method call visitor.visitParent(getParent()) java.lang.RuntimeException: Method 'getParent' cannot be resolved in context getParent() (line: 56) MethodCallExprContext{wrapped=getParent()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/classloader/CachingClassLoader.java
Cannot solve method call hasher.putString(item, Charsets.UTF_8) UnsolvedSymbolException{context='unknown', name='UTF_8', typeSolver=null} /repo/subprojects/base-services/src/main/java/org/gradle/internal/classloader/DefaultHashingClassLoaderFactory.java
Cannot solve method call "unknown".getBytes(Charsets.UTF_8) UnsolvedSymbolException{context='unknown', name='UTF_8', typeSolver=null} /repo/subprojects/base-services/src/main/java/org/gradle/internal/classloader/ConfigurableClassLoaderHierarchyHasher.java
Cannot solve method call entry.getValue().getBytes(Charsets.UTF_8) UnsolvedSymbolException{context='unknown', name='UTF_8', typeSolver=null} /repo/subprojects/base-services/src/main/java/org/gradle/internal/classloader/ConfigurableClassLoaderHierarchyHasher.java
Cannot solve method call hashes.put(entry.getKey(), entry.getValue().getBytes(Charsets.UTF_8)) java.lang.RuntimeException: Error calculating the type of parameter Charsets.UTF_8 of method call entry.getValue().getBytes(Charsets.UTF_8) /repo/subprojects/base-services/src/main/java/org/gradle/internal/classloader/ConfigurableClassLoaderHierarchyHasher.java
Cannot solve method call hasher.putBytes(hash.asBytes()) java.lang.RuntimeException: Method 'asBytes' cannot be resolved in context hash.asBytes() (line: 94) MethodCallExprContext{wrapped=hash.asBytes()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/classloader/ConfigurableClassLoaderHierarchyHasher.java
Cannot solve method call visitParent(classLoader.getParent()) java.lang.RuntimeException: Method 'getParent' cannot be resolved in context classLoader.getParent() (line: 45) MethodCallExprContext{wrapped=classLoader.getParent()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/classloader/ClassLoaderVisitor.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call SYSTEM_PACKAGES.add(p.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context p.getName() (line: 51) MethodCallExprContext{wrapped=p.getName()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/classloader/FilteringClassLoader.java
Cannot solve method call visitor.visitParent(getParent()) java.lang.RuntimeException: Method 'getParent' cannot be resolved in context getParent() (line: 68) MethodCallExprContext{wrapped=getParent()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/classloader/FilteringClassLoader.java
Method 'getName' cannot be resolved in context pkg.getName() (line: 141) MethodCallExprContext{wrapped=pkg.getName()}. Parameter types: []
Cannot solve method call SYSTEM_PACKAGES.contains(pkg.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context pkg.getName() (line: 146) MethodCallExprContext{wrapped=pkg.getName()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/classloader/FilteringClassLoader.java
Cannot solve method call packageNames.contains(pkg.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context pkg.getName() (line: 149) MethodCallExprContext{wrapped=pkg.getName()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/classloader/FilteringClassLoader.java
Method 'getName' cannot be resolved in context pkg.getName() (line: 153) MethodCallExprContext{wrapped=pkg.getName()}. Parameter types: []
Cannot solve method call resourcePrefixes.add(packageName.replace('.', '/') + '/') java.lang.RuntimeException: Method 'replace' cannot be resolved in context packageName.replace('.', '/') (line: 224) MethodCallExprContext{wrapped=packageName.replace('.', '/')}. Parameter types: [PrimitiveTypeUsage{name='char'}, PrimitiveTypeUsage{name='char'}] /repo/subprojects/base-services/src/main/java/org/gradle/internal/classloader/FilteringClassLoader.java
Cannot solve method call classNames.add(clazz.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context clazz.getName() (line: 233) MethodCallExprContext{wrapped=clazz.getName()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/classloader/FilteringClassLoader.java
Cannot solve method call Collections.singleton(ClasspathUtil.getClasspathForResource(getSystemClassLoader(), "META-INF/services/javax.xml.parsers.SAXParserFactory")) UnsolvedSymbolException{context='Method 'getClasspathForResource' with parameterTypes [ReferenceType{java.lang.ClassLoader, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=public class ClasspathUtil {

    public static void addUrl(URLClassLoader classLoader, Iterable<URL> classpathElements) {
        try {
            Set<URI> original = new HashSet<URI>();
            for (URL url : classLoader.getURLs()) {
                original.add(url.toURI());
            }
            JavaMethod<URLClassLoader, Object> method = JavaReflectionUtil.method(URLClassLoader.class, Object.class, "addURL", URL.class);
            for (URL classpathElement : classpathElements) {
                if (original.add(classpathElement.toURI())) {
                    method.invoke(classLoader, classpathElement);
                }
            }
        } catch (Throwable t) {
            throw new RuntimeException(String.format("Could not add URLs %s to class path for ClassLoader %s", classpathElements, classLoader), t);
        }
    }

    public static List<URL> getClasspath(ClassLoader classLoader) {
        final List<URL> implementationClassPath = new ArrayList<URL>();
        new ClassLoaderVisitor() {

            @Override
            public void visitClassPath(URL[] classPath) {
                implementationClassPath.addAll(Arrays.asList(classPath));
            }
        }.visit(classLoader);
        return implementationClassPath;
    }

    public static File getClasspathForClass(Class<?> targetClass) {
        URI location;
        try {
            CodeSource codeSource = targetClass.getProtectionDomain().getCodeSource();
            if (codeSource != null && codeSource.getLocation() != null) {
                location = codeSource.getLocation().toURI();
                if (location.getScheme().equals("file")) {
                    return new File(location);
                }
            }
            String resourceName = targetClass.getName().replace('.', '/') + ".class";
            URL resource = targetClass.getClassLoader().getResource(resourceName);
            if (resource != null) {
                return getClasspathForResource(resource, resourceName);
            }
            throw new GradleException(String.format("Cannot determine classpath for class %s.", targetClass.getName()));
        } catch (URISyntaxException e) {
            throw UncheckedException.throwAsUncheckedException(e);
        }
    }

    public static File getClasspathForResource(ClassLoader classLoader, String name) {
        if (classLoader == null) {
            return getClasspathForResource(ClassLoader.getSystemResource(name), name);
        } else {
            return getClasspathForResource(classLoader.getResource(name), name);
        }
    }

    public static File getClasspathForResource(URL resource, String name) {
        URI location;
        try {
            location = resource.toURI();
            String path = location.getPath();
            if (location.getScheme().equals("file")) {
                assert path.endsWith("/" + name);
                return new File(path.substring(0, path.length() - (name.length() + 1)));
            } else if (location.getScheme().equals("jar")) {
                String schemeSpecificPart = location.getRawSchemeSpecificPart();
                int pos = schemeSpecificPart.indexOf("!");
                if (pos > 0) {
                    assert schemeSpecificPart.substring(pos + 1).equals("/" + name);
                    URI jarFile = new URI(schemeSpecificPart.substring(0, pos));
                    if (jarFile.getScheme().equals("file")) {
                        return new File(jarFile.getPath());
                    }
                }
            }
        } catch (URISyntaxException e) {
            throw UncheckedException.throwAsUncheckedException(e);
        }
        throw new GradleException(String.format("Cannot determine classpath for resource '%s' from location '%s'.", name, location));
    }
}}'} /repo/subprojects/base-services/src/main/java/org/gradle/internal/classloader/DefaultClassLoaderFactory.java
Cannot solve method call classPath.plus(Collections.singleton(ClasspathUtil.getClasspathForResource(getSystemClassLoader(), "META-INF/services/javax.xml.parsers.SAXParserFactory"))) java.lang.RuntimeException: Error calculating the type of parameter ClasspathUtil.getClasspathForResource(getSystemClassLoader(), "META-INF/services/javax.xml.parsers.SAXParserFactory") of method call Collections.singleton(ClasspathUtil.getClasspathForResource(getSystemClassLoader(), "META-INF/services/javax.xml.parsers.SAXParserFactory")) /repo/subprojects/base-services/src/main/java/org/gradle/internal/classloader/DefaultClassLoaderFactory.java
Cannot solve method call classLoaderSpec.allowResource("META-INF/services/" + serviceType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context serviceType.getName() (line: 85) MethodCallExprContext{wrapped=serviceType.getName()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/classloader/DefaultClassLoaderFactory.java
Method 'getProtectionDomain' cannot be resolved in context targetClass.getProtectionDomain() (line: 64) MethodCallExprContext{wrapped=targetClass.getProtectionDomain()}. Parameter types: []
Method 'getName' cannot be resolved in context targetClass.getName() (line: 71) MethodCallExprContext{wrapped=targetClass.getName()}. Parameter types: []
Method 'getClassLoader' cannot be resolved in context targetClass.getClassLoader() (line: 72) MethodCallExprContext{wrapped=targetClass.getClassLoader()}. Parameter types: []
Cannot solve method call String.format("Cannot determine classpath for class %s.", targetClass.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context targetClass.getName() (line: 76) MethodCallExprContext{wrapped=targetClass.getName()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/classloader/ClasspathUtil.java
Cannot solve method call getClasspathForResource(classLoader.getResource(name), name) java.lang.RuntimeException: Method 'getResource' cannot be resolved in context classLoader.getResource(name) (line: 86) MethodCallExprContext{wrapped=classLoader.getResource(name)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/base-services/src/main/java/org/gradle/internal/classloader/ClasspathUtil.java
Cannot solve method call getClasspathForResource(ClassLoader.getSystemResource(name), name) UnsolvedSymbolException{context='Method 'getSystemResource' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=ClassLoader}'} /repo/subprojects/base-services/src/main/java/org/gradle/internal/classloader/ClasspathUtil.java
Method 'substring' cannot be resolved in context schemeSpecificPart.substring(pos + 1) (line: 102) MethodCallExprContext{wrapped=schemeSpecificPart.substring(pos + 1)}. Parameter types: [PrimitiveTypeUsage{name='int'}]
Cannot solve method call path.substring(0, path.length() - (name.length() + 1)) java.lang.RuntimeException: Method 'length' cannot be resolved in context path.length() (line: 97) MethodCallExprContext{wrapped=path.length()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/classloader/ClasspathUtil.java
Cannot solve method call String.format("Could not find meta-data resource 'META-INF/services/%s' for service '%s'.", serviceType.getName(), serviceType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context serviceType.getName() (line: 73) MethodCallExprContext{wrapped=serviceType.getName()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/service/CachingServiceLocator.java
Cannot solve method call String.format("Could not find meta-data resource 'META-INF/services/%s' for service '%s'.", serviceType.getName(), serviceType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context serviceType.getName() (line: 63) MethodCallExprContext{wrapped=serviceType.getName()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/service/DefaultServiceLocator.java
Cannot solve method call String.format("Could not determine implementation classes for service '%s'.", serviceType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context serviceType.getName() (line: 86) MethodCallExprContext{wrapped=serviceType.getName()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/service/DefaultServiceLocator.java
Cannot solve method call String.format("Could not determine implementation class for service '%s' specified in resource '%s'.", serviceType.getName(), resource) java.lang.RuntimeException: Method 'getName' cannot be resolved in context serviceType.getName() (line: 117) MethodCallExprContext{wrapped=serviceType.getName()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/service/DefaultServiceLocator.java
Cannot solve method call String.format("No implementation class for service '%s' specified.", serviceType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context serviceType.getName() (line: 114) MethodCallExprContext{wrapped=serviceType.getName()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/service/DefaultServiceLocator.java
Cannot solve method call String.format("Could not load implementation class '%s' for service '%s' specified in resource '%s'.", implementationClassName, serviceType.getName(), resource) java.lang.RuntimeException: Method 'getName' cannot be resolved in context serviceType.getName() (line: 129) MethodCallExprContext{wrapped=serviceType.getName()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/service/DefaultServiceLocator.java
Cannot solve method call String.format("Implementation class '%s' is not assignable to service class '%s'.", implementationClassName, serviceType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context serviceType.getName() (line: 125) MethodCallExprContext{wrapped=serviceType.getName()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/service/DefaultServiceLocator.java
Cannot solve method call implementations.add(implClass.asSubclass(serviceType)) java.lang.RuntimeException: Method 'asSubclass' cannot be resolved in context implClass.asSubclass(serviceType) (line: 127) MethodCallExprContext{wrapped=implClass.asSubclass(serviceType)}. Parameter types: [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=TypeVariable {org.gradle.internal.service.DefaultServiceLocator.findServiceImplementations(Class<T>).T}}}}] /repo/subprojects/base-services/src/main/java/org/gradle/internal/service/DefaultServiceLocator.java
Method 'replaceAll' cannot be resolved in context line.replaceAll("#.*", "") (line: 145) MethodCallExprContext{wrapped=line.replaceAll("#.*", "")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call String.format("Could not create an implementation of service '%s'.", serviceType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context serviceType.getName() (line: 177) MethodCallExprContext{wrapped=serviceType.getName()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/service/DefaultServiceLocator.java
Cannot solve method call Arrays.asList(clazz.getDeclaredMethods()) java.lang.RuntimeException: Method 'getDeclaredMethods' cannot be resolved in context clazz.getDeclaredMethods() (line: 184) MethodCallExprContext{wrapped=clazz.getDeclaredMethods()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/service/DefaultServiceRegistry.java
Cannot solve method call remainingMethods.addAll(Arrays.asList(clazz.getDeclaredMethods())) java.lang.RuntimeException: Error calculating the type of parameter clazz.getDeclaredMethods() of method call Arrays.asList(clazz.getDeclaredMethods()) /repo/subprojects/base-services/src/main/java/org/gradle/internal/service/DefaultServiceRegistry.java
Cannot solve method call String.format("Cannot use decorator method %s.%s() when no parent registry is provided.", type.getSimpleName(), method.getName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context type.getSimpleName() (line: 206) MethodCallExprContext{wrapped=type.getSimpleName()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/service/DefaultServiceRegistry.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call method.getReturnType().equals(Void.TYPE) UnsolvedSymbolException{context='unknown', name='TYPE', typeSolver=null} /repo/subprojects/base-services/src/main/java/org/gradle/internal/service/DefaultServiceRegistry.java
Cannot solve method call String.format("Method %s.%s() must return void.", type.getSimpleName(), method.getName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context type.getSimpleName() (line: 272) MethodCallExprContext{wrapped=type.getSimpleName()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/service/DefaultServiceRegistry.java
Cannot resolve field access null
Cannot solve method call method.getReturnType().equals(Void.TYPE) UnsolvedSymbolException{context='unknown', name='TYPE', typeSolver=null} /repo/subprojects/base-services/src/main/java/org/gradle/internal/service/DefaultServiceRegistry.java
Cannot solve method call String.format("Method %s.%s() must not return void.", type.getSimpleName(), method.getName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context type.getSimpleName() (line: 286) MethodCallExprContext{wrapped=type.getSimpleName()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/service/DefaultServiceRegistry.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call method.getReturnType().equals(Void.TYPE) UnsolvedSymbolException{context='unknown', name='TYPE', typeSolver=null} /repo/subprojects/base-services/src/main/java/org/gradle/internal/service/DefaultServiceRegistry.java
Cannot solve method call String.format("Method %s.%s() must not return void.", type.getSimpleName(), method.getName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context type.getSimpleName() (line: 301) MethodCallExprContext{wrapped=type.getSimpleName()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/service/DefaultServiceRegistry.java
Cannot resolve field access null
Cannot solve method call String.format("Cannot locate service of type %s, as %s has been closed.", format(serviceType), getDisplayName()) java.lang.RuntimeException: Method 'format' cannot be resolved in context format(serviceType) (line: 400) MethodCallExprContext{wrapped=format(serviceType)}. Parameter types: [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=TypeVariable {org.gradle.internal.service.DefaultServiceRegistry.getAll(Class<T>).T}}}}] /repo/subprojects/base-services/src/main/java/org/gradle/internal/service/DefaultServiceRegistry.java
Cannot solve method call serviceType.cast(doGet(serviceType)) java.lang.RuntimeException: Method 'doGet' cannot be resolved in context doGet(serviceType) (line: 410) MethodCallExprContext{wrapped=doGet(serviceType)}. Parameter types: [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=TypeVariable {org.gradle.internal.service.DefaultServiceRegistry.get(Class<T>).T}}}}] /repo/subprojects/base-services/src/main/java/org/gradle/internal/service/DefaultServiceRegistry.java
Cannot solve method call String.format("Cannot locate factory for objects of type %s, as %s has been closed.", format(type), getDisplayName()) java.lang.RuntimeException: Method 'format' cannot be resolved in context format(type) (line: 444) MethodCallExprContext{wrapped=format(type)}. Parameter types: [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=TypeVariable {org.gradle.internal.service.DefaultServiceRegistry.getFactory(Class<T>).T}}}}] /repo/subprojects/base-services/src/main/java/org/gradle/internal/service/DefaultServiceRegistry.java
Cannot solve method call String.format("No factory for objects of type %s available in %s.", format(type), getDisplayName()) java.lang.RuntimeException: Method 'format' cannot be resolved in context format(type) (line: 453) MethodCallExprContext{wrapped=format(type)}. Parameter types: [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=TypeVariable {org.gradle.internal.service.DefaultServiceRegistry.getFactory(Class<T>).T}}}}] /repo/subprojects/base-services/src/main/java/org/gradle/internal/service/DefaultServiceRegistry.java
Cannot solve method call formatter.format("Multiple factories for objects of type %s available in %s:", format(type), getDisplayName()) java.lang.RuntimeException: Method 'format' cannot be resolved in context format(type) (line: 516) MethodCallExprContext{wrapped=format(type)}. Parameter types: [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=null, boundedType=null}}}}] /repo/subprojects/base-services/src/main/java/org/gradle/internal/service/DefaultServiceRegistry.java
Cannot solve method call result.add(serviceType.cast(prepare(context).get())) java.lang.RuntimeException: Method 'cast' cannot be resolved in context serviceType.cast(prepare(context).get()) (line: 657) MethodCallExprContext{wrapped=serviceType.cast(prepare(context).get())}. Parameter types: [ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/base-services/src/main/java/org/gradle/internal/service/DefaultServiceRegistry.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call String.format("Expected a single constructor for %s.", format(serviceType)) java.lang.RuntimeException: Method 'format' cannot be resolved in context format(serviceType) (line: 857) MethodCallExprContext{wrapped=format(serviceType)}. Parameter types: [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=null, boundedType=null}}}}] /repo/subprojects/base-services/src/main/java/org/gradle/internal/service/DefaultServiceRegistry.java
Cannot solve method call seen.putIfAbsent(key, service == null ? Optional.<ServiceProvider>absent() : Optional.of(service)) UnsolvedSymbolException{context='Method 'absent' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Optional}'} /repo/subprojects/base-services/src/main/java/org/gradle/internal/service/DefaultServiceRegistry.java
Cannot solve method call String.format("parent returned null for factory type '%s'", type.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context type.getName() (line: 1057) MethodCallExprContext{wrapped=type.getName()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/service/DefaultServiceRegistry.java
Cannot solve method call String.format("parent returned null for services of type %s", format(serviceType)) java.lang.RuntimeException: Method 'format' cannot be resolved in context format(serviceType) (line: 1098) MethodCallExprContext{wrapped=format(serviceType)}. Parameter types: [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=TypeVariable {org.gradle.internal.service.DefaultServiceRegistry.ParentServices.getAll(org.gradle.internal.service.DefaultServiceRegistry.LookupContext, Class<T>, java.util.List<T>).T}}}}] /repo/subprojects/base-services/src/main/java/org/gradle/internal/service/DefaultServiceRegistry.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call Character.isUpperCase(methodName.charAt(position - 1)) java.lang.RuntimeException: Method 'charAt' cannot be resolved in context methodName.charAt(position - 1) (line: 136) MethodCallExprContext{wrapped=methodName.charAt(position - 1)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/base-services/src/main/java/org/gradle/internal/reflect/PropertyAccessorType.java
Cannot solve method call Character.isUpperCase(methodName.charAt(position)) java.lang.RuntimeException: Method 'charAt' cannot be resolved in context methodName.charAt(position) (line: 139) MethodCallExprContext{wrapped=methodName.charAt(position)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/base-services/src/main/java/org/gradle/internal/reflect/PropertyAccessorType.java
Cannot solve method call Character.toLowerCase(propertyName.charAt(0)) java.lang.RuntimeException: Method 'charAt' cannot be resolved in context propertyName.charAt(0) (line: 55) MethodCallExprContext{wrapped=propertyName.charAt(0)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/base-services/src/main/java/org/gradle/internal/reflect/JavaReflectionUtil.java
Cannot solve method call Character.toLowerCase(propertyName.charAt(0)) java.lang.RuntimeException: Method 'charAt' cannot be resolved in context propertyName.charAt(0) (line: 51) MethodCallExprContext{wrapped=propertyName.charAt(0)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/base-services/src/main/java/org/gradle/internal/reflect/JavaReflectionUtil.java
Cannot solve method call String.format("Could not find getter method for property '%s' on class %s.", property, target.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context target.getSimpleName() (line: 70) MethodCallExprContext{wrapped=target.getSimpleName()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/reflect/JavaReflectionUtil.java
Cannot solve method call String.format("Could not find field '%s' on class %s.", fieldName, target.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context target.getSimpleName() (line: 94) MethodCallExprContext{wrapped=target.getSimpleName()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/reflect/JavaReflectionUtil.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call method.getReturnType().equals(Void.TYPE) UnsolvedSymbolException{context='unknown', name='TYPE', typeSolver=null} /repo/subprojects/base-services/src/main/java/org/gradle/internal/reflect/JavaReflectionUtil.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call returnType.equals(Boolean.TYPE) UnsolvedSymbolException{context='unknown', name='TYPE', typeSolver=null} /repo/subprojects/base-services/src/main/java/org/gradle/internal/reflect/JavaReflectionUtil.java
Cannot solve method call String.format("Could not find setter method for property '%s' on class %s.", property, target.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context target.getSimpleName() (line: 146) MethodCallExprContext{wrapped=target.getSimpleName()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/reflect/JavaReflectionUtil.java
Cannot resolve field access null
Cannot solve method call String.format("Could not find writeable field '%s' on class %s.", fieldName, target.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context target.getSimpleName() (line: 181) MethodCallExprContext{wrapped=target.getSimpleName()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/reflect/JavaReflectionUtil.java
Cannot solve method call Character.toUpperCase(propertyName.charAt(0)) java.lang.RuntimeException: Method 'charAt' cannot be resolved in context propertyName.charAt(0) (line: 195) MethodCallExprContext{wrapped=propertyName.charAt(0)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/base-services/src/main/java/org/gradle/internal/reflect/JavaReflectionUtil.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call getAnnotation(type.getSuperclass(), annotationType, false) java.lang.RuntimeException: Method 'getSuperclass' cannot be resolved in context type.getSuperclass() (line: 351) MethodCallExprContext{wrapped=type.getSuperclass()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/reflect/JavaReflectionUtil.java
Method 'getMethod' cannot be resolved in context object.getClass().getMethod("toString") (line: 361) MethodCallExprContext{wrapped=object.getClass().getMethod("toString")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call returnType.cast(method.invoke(target)) java.lang.RuntimeException: Method 'invoke' cannot be resolved in context method.invoke(target) (line: 393) MethodCallExprContext{wrapped=method.invoke(target)}. Parameter types: [TypeVariable {org.gradle.internal.reflect.JavaReflectionUtil.GetterMethodBackedPropertyAccessor.T}] /repo/subprojects/base-services/src/main/java/org/gradle/internal/reflect/JavaReflectionUtil.java
Cannot solve method call fieldType.cast(field.get(target)) java.lang.RuntimeException: T java.lang.Object /repo/subprojects/base-services/src/main/java/org/gradle/internal/reflect/JavaReflectionUtil.java
Cannot solve method call String.format("Could not create an instance of type %s.", targetType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context targetType.getName() (line: 24) MethodCallExprContext{wrapped=targetType.getName()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/reflect/ObjectInstantiationException.java
Method 'append' cannot be resolved in context sb.append(returnType) (line: 44) MethodCallExprContext{wrapped=sb.append(returnType)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context sb.append(owner) (line: 47) MethodCallExprContext{wrapped=sb.append(owner)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'name' cannot be resolved in context name(method.getName()) (line: 65) MethodCallExprContext{wrapped=name(method.getName())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'name' cannot be resolved in context name(method.getName()) (line: 65) MethodCallExprContext{wrapped=name(method.getName())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'name' cannot be resolved in context name(method.getName()) (line: 65) MethodCallExprContext{wrapped=name(method.getName())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'name' cannot be resolved in context name("<init>") (line: 72) MethodCallExprContext{wrapped=name("<init>")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'name' cannot be resolved in context name("<init>") (line: 72) MethodCallExprContext{wrapped=name("<init>")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call Collections.addAll(queue, current.getInterfaces()) java.lang.RuntimeException: Method 'getInterfaces' cannot be resolved in context current.getInterfaces() (line: 52) MethodCallExprContext{wrapped=current.getInterfaces()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/reflect/ClassInspector.java
Cannot resolve field access null
Cannot solve method call method.getReturnType().equals(Void.TYPE) UnsolvedSymbolException{context='unknown', name='TYPE', typeSolver=null} /repo/subprojects/base-services/src/main/java/org/gradle/internal/reflect/ClassInspector.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call method.getReturnType().equals(Boolean.TYPE) UnsolvedSymbolException{context='unknown', name='TYPE', typeSolver=null} /repo/subprojects/base-services/src/main/java/org/gradle/internal/reflect/ClassInspector.java
Cannot resolve field access null
Cannot resolve field access null
Method 'property' cannot be resolved in context classDetails.property(propertyName) (line: 92) MethodCallExprContext{wrapped=classDetails.property(propertyName)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'property' cannot be resolved in context classDetails.property(propertyName) (line: 87) MethodCallExprContext{wrapped=classDetails.property(propertyName)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'property' cannot be resolved in context classDetails.property(propertyName) (line: 81) MethodCallExprContext{wrapped=classDetails.property(propertyName)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call Character.isUpperCase(propertyName.charAt(0)) java.lang.RuntimeException: Method 'charAt' cannot be resolved in context propertyName.charAt(0) (line: 101) MethodCallExprContext{wrapped=propertyName.charAt(0)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/base-services/src/main/java/org/gradle/internal/reflect/ClassInspector.java
Cannot solve method call Character.isUpperCase(propertyName.charAt(1)) java.lang.RuntimeException: Method 'charAt' cannot be resolved in context propertyName.charAt(1) (line: 101) MethodCallExprContext{wrapped=propertyName.charAt(1)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/base-services/src/main/java/org/gradle/internal/reflect/ClassInspector.java
Cannot solve method call Character.toLowerCase(propertyName.charAt(0)) java.lang.RuntimeException: Method 'charAt' cannot be resolved in context propertyName.charAt(0) (line: 105) MethodCallExprContext{wrapped=propertyName.charAt(0)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/base-services/src/main/java/org/gradle/internal/reflect/ClassInspector.java
Cannot solve method call String.format("Could not find method %s(%s) on %s.", name, Joiner.on(", ").join(paramTypes), origTarget.getSimpleName()) UnsolvedSymbolException{context='Method 'on' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=Joiner}'} /repo/subprojects/base-services/src/main/java/org/gradle/internal/reflect/JavaMethod.java
Method 'append' cannot be resolved in context new EqualsBuilder().append(a.getName(), b.getName()) (line: 33) MethodCallExprContext{wrapped=new EqualsBuilder().append(a.getName(), b.getName())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context new EqualsBuilder().append(a.getName(), b.getName()) (line: 33) MethodCallExprContext{wrapped=new EqualsBuilder().append(a.getName(), b.getName())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context new HashCodeBuilder().append(method.getName()) (line: 47) MethodCallExprContext{wrapped=new HashCodeBuilder().append(method.getName())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context new HashCodeBuilder().append(method.getName()) (line: 47) MethodCallExprContext{wrapped=new HashCodeBuilder().append(method.getName())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context new EqualsBuilder().append(a.getName(), b.getName()) (line: 60) MethodCallExprContext{wrapped=new EqualsBuilder().append(a.getName(), b.getName())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context new EqualsBuilder().append(a.getName(), b.getName()) (line: 60) MethodCallExprContext{wrapped=new EqualsBuilder().append(a.getName(), b.getName())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context new EqualsBuilder().append(a.getName(), b.getName()) (line: 60) MethodCallExprContext{wrapped=new EqualsBuilder().append(a.getName(), b.getName())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context new HashCodeBuilder().append(method.getName()) (line: 69) MethodCallExprContext{wrapped=new HashCodeBuilder().append(method.getName())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context new HashCodeBuilder().append(method.getName()) (line: 69) MethodCallExprContext{wrapped=new HashCodeBuilder().append(method.getName())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context new HashCodeBuilder().append(method.getName()) (line: 69) MethodCallExprContext{wrapped=new HashCodeBuilder().append(method.getName())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call queue.add(Cast.<Class<? super T>>uncheckedCast(iface)) UnsolvedSymbolException{context='Method 'uncheckedCast' with parameterTypes [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=null, boundedType=null}}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class Cast {

    /**
     * Casts the given object to the given type, providing a better error message than the default.
     *
     * The standard {@link Class#cast(Object)} method produces unsatisfactory error messages on some platforms
     * when it fails. All this method does is provide a better, consistent, error message.
     *
     * This should be used whenever there is a chance the cast could fail. If in doubt, use this.
     *
     * @param outputType The type to cast the input to
     * @param object The object to be cast
     * @param <O> The type to be cast to
     * @param <I> The type of the object to be vast
     * @return The input object, cast to the output type
     */
    public static <O, I> O cast(Class<O> outputType, I object) {
        try {
            return outputType.cast(object);
        } catch (ClassCastException e) {
            throw new ClassCastException(String.format("Failed to cast object %s of type %s to target type %s", object, object.getClass().getName(), outputType.getName()));
        }
    }

    @SuppressWarnings("unchecked")
    public static <T> T uncheckedCast(Object object) {
        return (T) object;
    }
}}'} /repo/subprojects/base-services/src/main/java/org/gradle/internal/reflect/Types.java
Cannot solve method call type.cast(match.newInstance(params)) java.lang.RuntimeException: Object[] java.lang.Object /repo/subprojects/base-services/src/main/java/org/gradle/internal/reflect/DirectInstantiator.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call messageDigest.update(scriptText.getBytes()) java.lang.RuntimeException: Method 'getBytes' cannot be resolved in context scriptText.getBytes() (line: 34) MethodCallExprContext{wrapped=scriptText.getBytes()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/hash/HashUtil.java
Method 'createHash' cannot be resolved in context createHash(scriptText, "MD5") (line: 80) MethodCallExprContext{wrapped=createHash(scriptText, "MD5")}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call createCompactMD5FromHash(hashCode.asBytes()) java.lang.RuntimeException: Method 'asBytes' cannot be resolved in context hashCode.asBytes() (line: 84) MethodCallExprContext{wrapped=hashCode.asBytes()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/hash/HashUtil.java
Cannot solve method call compareHashCodes(a.asBytes(), b.asBytes()) java.lang.RuntimeException: Method 'asBytes' cannot be resolved in context a.asBytes() (line: 116) MethodCallExprContext{wrapped=a.asBytes()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/hash/HashUtil.java
Cannot resolve field access null
Cannot resolve field access null
Method 'trim' cannot be resolved in context inputString.trim() (line: 44) MethodCallExprContext{wrapped=inputString.trim()}. Parameter types: []
Method 'substring' cannot be resolved in context cleaned.substring(spaceIndex + 1) (line: 51) MethodCallExprContext{wrapped=cleaned.substring(spaceIndex + 1)}. Parameter types: [PrimitiveTypeUsage{name='int'}]
Cannot solve method call cleaned.substring(cleaned.lastIndexOf(' ') + 1) java.lang.RuntimeException: Method 'lastIndexOf' cannot be resolved in context cleaned.lastIndexOf(' ') (line: 49) MethodCallExprContext{wrapped=cleaned.lastIndexOf(' ')}. Parameter types: [PrimitiveTypeUsage{name='char'}] /repo/subprojects/base-services/src/main/java/org/gradle/internal/hash/HashValue.java
Method 'getClass' cannot be resolved in context object.getClass() (line: 41) MethodCallExprContext{wrapped=object.getClass()}. Parameter types: []
Cannot solve method call String.format("Failed to cast object %s of type %s to target type %s", object, object.getClass().getName(), outputType.getName()) java.lang.RuntimeException: Method 'getClass' cannot be resolved in context object.getClass() (line: 41) MethodCallExprContext{wrapped=object.getClass()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/Cast.java
Cannot solve method call concat(files, other.getAsFiles()) java.lang.RuntimeException: Method 'getAsFiles' cannot be resolved in context other.getAsFiles() (line: 109) MethodCallExprContext{wrapped=other.getAsFiles()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/internal/classpath/DefaultClassPath.java
Cannot solve method call of(function.apply(left), right) java.lang.RuntimeException: Method 'apply' cannot be resolved in context function.apply(left) (line: 68) MethodCallExprContext{wrapped=function.apply(left)}. Parameter types: [TypeVariable {org.gradle.internal.Pair.L}] /repo/subprojects/base-services/src/main/java/org/gradle/internal/Pair.java
Cannot solve method call of(left, function.apply(right)) java.lang.RuntimeException: Method 'apply' cannot be resolved in context function.apply(right) (line: 72) MethodCallExprContext{wrapped=function.apply(right)}. Parameter types: [TypeVariable {org.gradle.internal.Pair.R}] /repo/subprojects/base-services/src/main/java/org/gradle/internal/Pair.java
Cannot resolve field access null
Method 'matcher' cannot be resolved in context SINGLE_QUOTED.matcher(input) (line: 126) MethodCallExprContext{wrapped=SINGLE_QUOTED.matcher(input)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'matcher' cannot be resolved in context DOUBLE_QUOTED.matcher(input) (line: 126) MethodCallExprContext{wrapped=DOUBLE_QUOTED.matcher(input)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'matcher' cannot be resolved in context A_SINGLE_QUOTE.matcher(input) (line: 138) MethodCallExprContext{wrapped=A_SINGLE_QUOTE.matcher(input)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'toLowerCase' cannot be resolved in context executablePath.toLowerCase() (line: 219) MethodCallExprContext{wrapped=executablePath.toLowerCase()}. Parameter types: []
Cannot solve method call Math.max(executablePath.lastIndexOf('/'), executablePath.lastIndexOf('\\')) java.lang.RuntimeException: Method 'lastIndexOf' cannot be resolved in context executablePath.lastIndexOf('/') (line: 226) MethodCallExprContext{wrapped=executablePath.lastIndexOf('/')}. Parameter types: [PrimitiveTypeUsage{name='char'}] /repo/subprojects/base-services/src/main/java/org/gradle/internal/os/OperatingSystem.java
Method 'replace' cannot be resolved in context str.replace("\\", "\\\\") (line: 107) MethodCallExprContext{wrapped=str.replace("\\", "\\\\")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'matcher' cannot be resolved in context WHITESPACE.matcher(str) (line: 109) MethodCallExprContext{wrapped=WHITESPACE.matcher(str)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot resolve field access null
Method 'values' cannot be resolved in context values() (line: 58) MethodCallExprContext{wrapped=values()}. Parameter types: []
Method 'values' cannot be resolved in context values() (line: 58) MethodCallExprContext{wrapped=values()}. Parameter types: []
Method 'values' cannot be resolved in context values() (line: 66) MethodCallExprContext{wrapped=values()}. Parameter types: []
Method 'values' cannot be resolved in context values() (line: 92) MethodCallExprContext{wrapped=values()}. Parameter types: []
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call uncheckedCast(ObjectArrays.newArray(Spec.class, thisLength + specs.length)) UnsolvedSymbolException{context='Solving ObjectArrays', name='ObjectArrays', typeSolver=null} /repo/subprojects/base-services/src/main/java/org/gradle/api/specs/OrSpec.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call uncheckedCast(Iterators.toArray(iterator, Spec.class)) UnsolvedSymbolException{context='Method 'toArray' with parameterTypes [ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=WildcardUsage{type=EXTENDS, boundedType=ReferenceType{org.gradle.api.specs.Spec, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.api.specs.Spec.T=WildcardUsage{type=SUPER, boundedType=TypeVariable {org.gradle.api.specs.CompositeSpec.T}}}}}}}}}, ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.specs.Spec, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterators}'} /repo/subprojects/base-services/src/main/java/org/gradle/api/specs/CompositeSpec.java
Cannot solve method call uncheckedCast(specCollection.toArray(EMPTY)) java.lang.RuntimeException: org.gradle.api.specs.Spec<?>[] T[] /repo/subprojects/base-services/src/main/java/org/gradle/api/specs/CompositeSpec.java
Cannot resolve field access null
Cannot solve method call flatten(((Map) element).values(), addTo, flattenMaps, flattenArrays) java.lang.RuntimeException: Method 'values' cannot be resolved in context ((Map) element).values() (line: 72) MethodCallExprContext{wrapped=((Map) element).values()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/util/GUtil.java
Method 'getKey' cannot be resolved in context entry.getKey() (line: 177) MethodCallExprContext{wrapped=entry.getKey()}. Parameter types: []
Method 'getValue' cannot be resolved in context entry.getValue() (line: 177) MethodCallExprContext{wrapped=entry.getValue()}. Parameter types: []
Cannot solve method call dest.put(entry.getKey().toString(), entry.getValue().toString()) java.lang.RuntimeException: Method 'getKey' cannot be resolved in context entry.getKey() (line: 177) MethodCallExprContext{wrapped=entry.getKey()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/util/GUtil.java
Cannot resolve field access null
Cannot resolve field access null
Method 'subSequence' cannot be resolved in context string.subSequence(pos, matcher.start()) (line: 286) MethodCallExprContext{wrapped=string.subSequence(pos, matcher.start())}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}]
Cannot solve method call StringUtils.capitalize(string.subSequence(pos, matcher.start()).toString()) java.lang.RuntimeException: Method 'subSequence' cannot be resolved in context string.subSequence(pos, matcher.start()) (line: 286) MethodCallExprContext{wrapped=string.subSequence(pos, matcher.start())}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}] /repo/subprojects/base-services/src/main/java/org/gradle/util/GUtil.java
Cannot solve method call builder.append(StringUtils.capitalize(string.subSequence(pos, matcher.start()).toString())) java.lang.RuntimeException: Error calculating the type of parameter string.subSequence(pos, matcher.start()).toString() of method call StringUtils.capitalize(string.subSequence(pos, matcher.start()).toString()) /repo/subprojects/base-services/src/main/java/org/gradle/util/GUtil.java
Cannot solve method call string.subSequence(pos, string.length()) java.lang.RuntimeException: Method 'length' cannot be resolved in context string.length() (line: 289) MethodCallExprContext{wrapped=string.length()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/util/GUtil.java
Error calculating the type of parameter string.length() of method call string.subSequence(pos, string.length())
Cannot solve method call StringUtils.capitalize(string.subSequence(pos, string.length()).toString()) java.lang.RuntimeException: Error calculating the type of parameter string.length() of method call string.subSequence(pos, string.length()) /repo/subprojects/base-services/src/main/java/org/gradle/util/GUtil.java
Cannot solve method call builder.append(StringUtils.capitalize(string.subSequence(pos, string.length()).toString())) java.lang.RuntimeException: Error calculating the type of parameter string.subSequence(pos, string.length()).toString() of method call StringUtils.capitalize(string.subSequence(pos, string.length()).toString()) /repo/subprojects/base-services/src/main/java/org/gradle/util/GUtil.java
Cannot solve method call camelCase.subSequence(1, camelCase.length()) java.lang.RuntimeException: Method 'length' cannot be resolved in context camelCase.length() (line: 301) MethodCallExprContext{wrapped=camelCase.length()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/util/GUtil.java
Cannot solve method call group1.substring(0, group1.length() - 1) java.lang.RuntimeException: Method 'length' cannot be resolved in context group1.length() (line: 344) MethodCallExprContext{wrapped=group1.length()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/util/GUtil.java
Cannot solve method call builder.append(group1.substring(0, group1.length() - 1)) java.lang.RuntimeException: Error calculating the type of parameter group1.length() - 1 of method call group1.substring(0, group1.length() - 1) /repo/subprojects/base-services/src/main/java/org/gradle/util/GUtil.java
Cannot solve method call group1.substring(group1.length() - 1) java.lang.RuntimeException: Method 'length' cannot be resolved in context group1.length() (line: 346) MethodCallExprContext{wrapped=group1.length()}. Parameter types: [] /repo/subprojects/base-services/src/main/java/org/gradle/util/GUtil.java
Cannot solve method call builder.append(group1.substring(group1.length() - 1)) java.lang.RuntimeException: Error calculating the type of parameter group1.length() - 1 of method call group1.substring(group1.length() - 1) /repo/subprojects/base-services/src/main/java/org/gradle/util/GUtil.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Method 'iterator' cannot be resolved in context source.iterator() (line: 93) MethodCallExprContext{wrapped=source.iterator()}. Parameter types: []
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call string.append(iterator.next().toString()) java.lang.UnsupportedOperationException: unbounded wildcard /repo/subprojects/base-services/src/main/java/org/gradle/util/CollectionUtils.java
Cannot solve method call string.append(iterator.next().toString()) java.lang.UnsupportedOperationException: unbounded wildcard /repo/subprojects/base-services/src/main/java/org/gradle/util/CollectionUtils.java
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
Cannot solve method call ImmutableList.copyOf(Iterables.transform(deduped, new Function<Equivalence.Wrapper<T>, T>() {

    public T apply(Equivalence.Wrapper<T> input) {
        return input.get();
    }
})) UnsolvedSymbolException{context='Method 'transform' with parameterTypes [ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{Wrapper, typeParametersMap=TypeParametersMap{nameToValue={empty.Method=TypeVariable {org.gradle.util.CollectionUtils.dedup(Iterable<T>, Equivalence<? super T>).T}}}}}}}, ReferenceType{Function, typeParametersMap=TypeParametersMap{nameToValue={empty.Equivalence.Wrapper<Method>=TypeVariable {org.gradle.util.CollectionUtils.dedup(Iterable<T>, Equivalence<? super T>).T}, empty.Method=ReferenceType{Wrapper, typeParametersMap=TypeParametersMap{nameToValue={empty.Method=TypeVariable {org.gradle.util.CollectionUtils.dedup(Iterable<T>, Equivalence<? super T>).T}}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/base-services/src/main/java/org/gradle/util/CollectionUtils.java
Cannot solve method call Character.isWhitespace(str.charAt(i)) java.lang.RuntimeException: Method 'charAt' cannot be resolved in context str.charAt(i) (line: 90) MethodCallExprContext{wrapped=str.charAt(i)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/base-services/src/main/java/org/gradle/util/TextUtil.java
Method 'matcher' cannot be resolved in context WHITESPACE.matcher(line) (line: 107) MethodCallExprContext{wrapped=WHITESPACE.matcher(line)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot resolve field access null
Cannot resolve field access null
Cannot solve field access FileOutcomeIdentifier.JAR_ARTIFACT
Cannot solve field access FileOutcomeIdentifier.EAR_ARTIFACT
Cannot solve field access FileOutcomeIdentifier.WAR_ARTIFACT
Cannot solve field access FileOutcomeIdentifier.ZIP_ARTIFACT
String[] String
String[] String
Cannot resolve field access null
Cannot solve method call ((IConventionAware) task).getConventionMapping().map("reportDir", new Callable<File>() {

    @Override
    public File call() throws Exception {
        return reportingExtension.file(task.getName());
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/build-comparison/src/main/groovy/org/gradle/api/plugins/buildcomparison/gradle/CompareGradleBuildsPlugin.java
Cannot solve method call getFileResolver().resolve(String.format(TMP_FILESTORAGE_PREFIX + "-%s-%s", getName(), System.currentTimeMillis())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, PrimitiveTypeUsage{name='long'}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/build-comparison/src/main/groovy/org/gradle/api/plugins/buildcomparison/gradle/CompareGradleBuilds.java
Cannot solve method call ClosureBackedAction.execute(markupBuilder, renderAction) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/build-comparison/src/main/groovy/org/gradle/api/plugins/buildcomparison/render/internal/html/HtmlRenderContext.java
Cannot solve method call characteristicTransformer.transform(type.cast(source)) java.lang.RuntimeException: Method 'cast' cannot be resolved in context type.cast(source) (line: 33) MethodCallExprContext{wrapped=type.cast(source)}. Parameter types: [ReferenceType{org.gradle.api.plugins.buildcomparison.outcome.internal.BuildOutcome, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/build-comparison/src/main/groovy/org/gradle/api/plugins/buildcomparison/outcome/internal/ByTypeAndCharacteristicBuildOutcomeAssociator.java
Cannot solve method call characteristicTransformer.transform(type.cast(target)) java.lang.RuntimeException: Method 'cast' cannot be resolved in context type.cast(target) (line: 34) MethodCallExprContext{wrapped=type.cast(target)}. Parameter types: [ReferenceType{org.gradle.api.plugins.buildcomparison.outcome.internal.BuildOutcome, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/build-comparison/src/main/groovy/org/gradle/api/plugins/buildcomparison/outcome/internal/ByTypeAndCharacteristicBuildOutcomeAssociator.java
Cannot solve field access ComparisonResultType.TARGET_ONLY
Cannot solve field access ComparisonResultType.SOURCE_ONLY
Cannot solve field access ComparisonResultType.NON_EXISTENT
Cannot solve field access ComparisonResultType.EQUAL
Cannot solve field access ComparisonResultType.UNEQUAL
Cannot solve field access ComparisonResultType.EQUAL
Cannot solve field access ComparisonResultType.EQUAL
Cannot solve field access ComparisonResultType.NON_EXISTENT
Cannot solve method call walk(fileInputStream, allEntries, ImmutableList.<String>of()) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/build-comparison/src/main/groovy/org/gradle/api/plugins/buildcomparison/outcome/internal/archive/entry/FileToArchiveEntrySetTransformer.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot resolve field access null
Cannot solve method call bis.mark(Integer.MAX_VALUE) UnsolvedSymbolException{context='unknown', name='MAX_VALUE', typeSolver=null} /repo/subprojects/build-comparison/src/main/groovy/org/gradle/api/plugins/buildcomparison/outcome/internal/archive/entry/FileToArchiveEntrySetTransformer.java
Cannot solve method call walk(bis, allEntries, nextParentPaths) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/build-comparison/src/main/groovy/org/gradle/api/plugins/buildcomparison/outcome/internal/archive/entry/FileToArchiveEntrySetTransformer.java
Cannot solve method call builder.setSubEntries(subEntries) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/build-comparison/src/main/groovy/org/gradle/api/plugins/buildcomparison/outcome/internal/archive/entry/FileToArchiveEntrySetTransformer.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve field access ComparisonResultType.UNEQUAL
Cannot solve field access ComparisonResultType.EQUAL
Cannot solve field access ComparisonResultType.TARGET_ONLY
Cannot solve field access ComparisonResultType.SOURCE_ONLY
Method 'get' cannot be resolved in context components.get(i) (line: 49) MethodCallExprContext{wrapped=components.get(i)}. Parameter types: [PrimitiveTypeUsage{name='int'}]
Cannot solve method call Math.max(components.size(), o.components.size()) java.lang.RuntimeException: Method 'size' cannot be resolved in context components.size() (line: 40) MethodCallExprContext{wrapped=components.size()}. Parameter types: [] /repo/subprojects/build-comparison/src/main/groovy/org/gradle/api/plugins/buildcomparison/outcome/internal/archive/entry/ArchiveEntry.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call builder.associate(associationType.cast(fromBuildOutcome), associationType.cast(toBuildOutcome), (Class<BuildOutcome>) associationType) java.lang.RuntimeException: Method 'cast' cannot be resolved in context associationType.cast(fromBuildOutcome) (line: 54) MethodCallExprContext{wrapped=associationType.cast(fromBuildOutcome)}. Parameter types: [ReferenceType{org.gradle.api.plugins.buildcomparison.outcome.internal.BuildOutcome, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/build-comparison/src/main/groovy/org/gradle/api/plugins/buildcomparison/compare/internal/BuildComparisonSpecFactory.java
Method 'file' cannot be resolved in context project.file("build.gradle") (line: 43) MethodCallExprContext{wrapped=project.file("build.gradle")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'file' cannot be resolved in context project.file("settings.gradle") (line: 52) MethodCallExprContext{wrapped=project.file("settings.gradle")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call configureInit(project.getTasks().create(INIT_BUILD_TASK_NAME, InitBuild.class)) java.lang.RuntimeException: Method 'create' cannot be resolved in context project.getTasks().create(INIT_BUILD_TASK_NAME, InitBuild.class) (line: 94) MethodCallExprContext{wrapped=project.getTasks().create(INIT_BUILD_TASK_NAME, InitBuild.class)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.buildinit.tasks.InitBuild, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/build-init/src/main/groovy/org/gradle/buildinit/tasks/internal/TaskConfiguration.java
Cannot solve method call configureWrapper(project.getTasks().create("wrapper", Wrapper.class)) java.lang.RuntimeException: Method 'create' cannot be resolved in context project.getTasks().create("wrapper", Wrapper.class) (line: 98) MethodCallExprContext{wrapped=project.getTasks().create("wrapper", Wrapper.class)}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.tasks.wrapper.Wrapper, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/build-init/src/main/groovy/org/gradle/buildinit/tasks/internal/TaskConfiguration.java
Method 'file' cannot be resolved in context getProject().file("pom.xml") (line: 57) MethodCallExprContext{wrapped=getProject().file("pom.xml")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve field access BuildInitTestFramework.NONE
Method 'resolve' cannot be resolved in context fileResolver.resolve(".") (line: 38) MethodCallExprContext{wrapped=fileResolver.resolve(".")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call GUtil.map("rootProjectName", fileResolver.resolve(".").getName()) java.lang.RuntimeException: Method 'resolve' cannot be resolved in context fileResolver.resolve(".") (line: 38) MethodCallExprContext{wrapped=fileResolver.resolve(".")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/build-init/src/main/groovy/org/gradle/buildinit/plugins/internal/SimpleGlobalFilesBuildSettingsDescriptor.java
Method 'withTemplate' cannot be resolved in context templateOperationBuilder.newTemplateOperation().withTemplate("settings.gradle.template") (line: 34) MethodCallExprContext{wrapped=templateOperationBuilder.newTemplateOperation().withTemplate("settings.gradle.template")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'withTemplate' cannot be resolved in context templateOperationBuilder.newTemplateOperation().withTemplate("settings.gradle.template") (line: 34) MethodCallExprContext{wrapped=templateOperationBuilder.newTemplateOperation().withTemplate("settings.gradle.template")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Error calculating the type of parameter GUtil.map("ref_userguide_multiproject", "multi_project_builds") of method call templateOperationBuilder.newTemplateOperation().withTemplate("settings.gradle.template").withTarget("settings.gradle").withDocumentationBindings(GUtil.map("ref_userguide_multiproject", "multi_project_builds"))
Error calculating the type of parameter GUtil.map("rootProjectName", fileResolver.resolve(".").getName()) of method call templateOperationBuilder.newTemplateOperation().withTemplate("settings.gradle.template").withTarget("settings.gradle").withDocumentationBindings(GUtil.map("ref_userguide_multiproject", "multi_project_builds")).withBindings(GUtil.map("rootProjectName", fileResolver.resolve(".").getName()))
Error calculating the type of parameter GUtil.map("rootProjectName", fileResolver.resolve(".").getName()) of method call templateOperationBuilder.newTemplateOperation().withTemplate("settings.gradle.template").withTarget("settings.gradle").withDocumentationBindings(GUtil.map("ref_userguide_multiproject", "multi_project_builds")).withBindings(GUtil.map("rootProjectName", fileResolver.resolve(".").getName()))
Method 'append' cannot be resolved in context result.append('\\') (line: 36) MethodCallExprContext{wrapped=result.append('\\')}. Parameter types: [PrimitiveTypeUsage{name='char'}]
Method 'append' cannot be resolved in context result.append('\\') (line: 39) MethodCallExprContext{wrapped=result.append('\\')}. Parameter types: [PrimitiveTypeUsage{name='char'}]
Method 'append' cannot be resolved in context result.append('\\') (line: 42) MethodCallExprContext{wrapped=result.append('\\')}. Parameter types: [PrimitiveTypeUsage{name='char'}]
Method 'append' cannot be resolved in context result.append('\\') (line: 45) MethodCallExprContext{wrapped=result.append('\\')}. Parameter types: [PrimitiveTypeUsage{name='char'}]
Method 'append' cannot be resolved in context result.append('\\') (line: 48) MethodCallExprContext{wrapped=result.append('\\')}. Parameter types: [PrimitiveTypeUsage{name='char'}]
Method 'append' cannot be resolved in context result.append('\\') (line: 51) MethodCallExprContext{wrapped=result.append('\\')}. Parameter types: [PrimitiveTypeUsage{name='char'}]
Method 'append' cannot be resolved in context result.append('\\') (line: 54) MethodCallExprContext{wrapped=result.append('\\')}. Parameter types: [PrimitiveTypeUsage{name='char'}]
Cannot solve method call GUtil.map("junitVersion", libraryVersionProvider.getVersion("junit")) java.lang.RuntimeException: Method 'getVersion' cannot be resolved in context libraryVersionProvider.getVersion("junit") (line: 43) MethodCallExprContext{wrapped=libraryVersionProvider.getVersion("junit")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/build-init/src/main/groovy/org/gradle/buildinit/plugins/internal/BasicTemplateBasedProjectInitDescriptor.java
Cannot solve method call GUtil.map("slf4jVersion", libraryVersionProvider.getVersion("slf4j")) java.lang.RuntimeException: Method 'getVersion' cannot be resolved in context libraryVersionProvider.getVersion("slf4j") (line: 42) MethodCallExprContext{wrapped=libraryVersionProvider.getVersion("slf4j")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/build-init/src/main/groovy/org/gradle/buildinit/plugins/internal/BasicTemplateBasedProjectInitDescriptor.java
Method 'withTemplate' cannot be resolved in context templateOperationFactory.newTemplateOperation().withTemplate("build.gradle.template") (line: 38) MethodCallExprContext{wrapped=templateOperationFactory.newTemplateOperation().withTemplate("build.gradle.template")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'withTemplate' cannot be resolved in context templateOperationFactory.newTemplateOperation().withTemplate("build.gradle.template") (line: 38) MethodCallExprContext{wrapped=templateOperationFactory.newTemplateOperation().withTemplate("build.gradle.template")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Error calculating the type of parameter GUtil.map("ref_userguide_java_tutorial", "tutorial_java_projects") of method call templateOperationFactory.newTemplateOperation().withTemplate("build.gradle.template").withTarget("build.gradle").withDocumentationBindings(GUtil.map("ref_userguide_java_tutorial", "tutorial_java_projects"))
Error calculating the type of parameter GUtil.map("slf4jVersion", libraryVersionProvider.getVersion("slf4j")) of method call templateOperationFactory.newTemplateOperation().withTemplate("build.gradle.template").withTarget("build.gradle").withDocumentationBindings(GUtil.map("ref_userguide_java_tutorial", "tutorial_java_projects")).withBindings(GUtil.map("slf4jVersion", libraryVersionProvider.getVersion("slf4j")))
Error calculating the type of parameter GUtil.map("junitVersion", libraryVersionProvider.getVersion("junit")) of method call templateOperationFactory.newTemplateOperation().withTemplate("build.gradle.template").withTarget("build.gradle").withDocumentationBindings(GUtil.map("ref_userguide_java_tutorial", "tutorial_java_projects")).withBindings(GUtil.map("slf4jVersion", libraryVersionProvider.getVersion("slf4j"))).withBindings(GUtil.map("junitVersion", libraryVersionProvider.getVersion("junit")))
Error calculating the type of parameter GUtil.map("junitVersion", libraryVersionProvider.getVersion("junit")) of method call templateOperationFactory.newTemplateOperation().withTemplate("build.gradle.template").withTarget("build.gradle").withDocumentationBindings(GUtil.map("ref_userguide_java_tutorial", "tutorial_java_projects")).withBindings(GUtil.map("slf4jVersion", libraryVersionProvider.getVersion("slf4j"))).withBindings(GUtil.map("junitVersion", libraryVersionProvider.getVersion("junit")))
Cannot solve method call GUtil.map("spockVersion", libraryVersionProvider.getVersion("spock")) java.lang.RuntimeException: Method 'getVersion' cannot be resolved in context libraryVersionProvider.getVersion("spock") (line: 39) MethodCallExprContext{wrapped=libraryVersionProvider.getVersion("spock")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/build-init/src/main/groovy/org/gradle/buildinit/plugins/internal/GroovyLibraryProjectInitDescriptor.java
Cannot solve method call GUtil.map("junitVersion", libraryVersionProvider.getVersion("junit")) java.lang.RuntimeException: Method 'getVersion' cannot be resolved in context libraryVersionProvider.getVersion("junit") (line: 38) MethodCallExprContext{wrapped=libraryVersionProvider.getVersion("junit")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/build-init/src/main/groovy/org/gradle/buildinit/plugins/internal/GroovyLibraryProjectInitDescriptor.java
Cannot solve method call GUtil.map("groovyVersion", libraryVersionProvider.getVersion("groovy")) java.lang.RuntimeException: Method 'getVersion' cannot be resolved in context libraryVersionProvider.getVersion("groovy") (line: 37) MethodCallExprContext{wrapped=libraryVersionProvider.getVersion("groovy")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/build-init/src/main/groovy/org/gradle/buildinit/plugins/internal/GroovyLibraryProjectInitDescriptor.java
Method 'withTemplate' cannot be resolved in context templateOperationFactory.newTemplateOperation().withTemplate("groovylibrary/build.gradle.template") (line: 33) MethodCallExprContext{wrapped=templateOperationFactory.newTemplateOperation().withTemplate("groovylibrary/build.gradle.template")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'withTemplate' cannot be resolved in context templateOperationFactory.newTemplateOperation().withTemplate("groovylibrary/build.gradle.template") (line: 33) MethodCallExprContext{wrapped=templateOperationFactory.newTemplateOperation().withTemplate("groovylibrary/build.gradle.template")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Error calculating the type of parameter GUtil.map("ref_userguide_groovy_tutorial", "tutorial_groovy_projects") of method call templateOperationFactory.newTemplateOperation().withTemplate("groovylibrary/build.gradle.template").withTarget("build.gradle").withDocumentationBindings(GUtil.map("ref_userguide_groovy_tutorial", "tutorial_groovy_projects"))
Error calculating the type of parameter GUtil.map("groovyVersion", libraryVersionProvider.getVersion("groovy")) of method call templateOperationFactory.newTemplateOperation().withTemplate("groovylibrary/build.gradle.template").withTarget("build.gradle").withDocumentationBindings(GUtil.map("ref_userguide_groovy_tutorial", "tutorial_groovy_projects")).withBindings(GUtil.map("groovyVersion", libraryVersionProvider.getVersion("groovy")))
Error calculating the type of parameter GUtil.map("junitVersion", libraryVersionProvider.getVersion("junit")) of method call templateOperationFactory.newTemplateOperation().withTemplate("groovylibrary/build.gradle.template").withTarget("build.gradle").withDocumentationBindings(GUtil.map("ref_userguide_groovy_tutorial", "tutorial_groovy_projects")).withBindings(GUtil.map("groovyVersion", libraryVersionProvider.getVersion("groovy"))).withBindings(GUtil.map("junitVersion", libraryVersionProvider.getVersion("junit")))
Error calculating the type of parameter GUtil.map("spockVersion", libraryVersionProvider.getVersion("spock")) of method call templateOperationFactory.newTemplateOperation().withTemplate("groovylibrary/build.gradle.template").withTarget("build.gradle").withDocumentationBindings(GUtil.map("ref_userguide_groovy_tutorial", "tutorial_groovy_projects")).withBindings(GUtil.map("groovyVersion", libraryVersionProvider.getVersion("groovy"))).withBindings(GUtil.map("junitVersion", libraryVersionProvider.getVersion("junit"))).withBindings(GUtil.map("spockVersion", libraryVersionProvider.getVersion("spock")))
Error calculating the type of parameter GUtil.map("spockVersion", libraryVersionProvider.getVersion("spock")) of method call templateOperationFactory.newTemplateOperation().withTemplate("groovylibrary/build.gradle.template").withTarget("build.gradle").withDocumentationBindings(GUtil.map("ref_userguide_groovy_tutorial", "tutorial_groovy_projects")).withBindings(GUtil.map("groovyVersion", libraryVersionProvider.getVersion("groovy"))).withBindings(GUtil.map("junitVersion", libraryVersionProvider.getVersion("junit"))).withBindings(GUtil.map("spockVersion", libraryVersionProvider.getVersion("spock")))
Cannot solve method call GUtil.map("testngVersion", libraryVersionProvider.getVersion("testng")) java.lang.RuntimeException: Method 'getVersion' cannot be resolved in context libraryVersionProvider.getVersion("testng") (line: 48) MethodCallExprContext{wrapped=libraryVersionProvider.getVersion("testng")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/build-init/src/main/groovy/org/gradle/buildinit/plugins/internal/JavaLibraryProjectInitDescriptor.java
Cannot solve method call GUtil.map("spockVersion", libraryVersionProvider.getVersion("spock")) java.lang.RuntimeException: Method 'getVersion' cannot be resolved in context libraryVersionProvider.getVersion("spock") (line: 47) MethodCallExprContext{wrapped=libraryVersionProvider.getVersion("spock")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/build-init/src/main/groovy/org/gradle/buildinit/plugins/internal/JavaLibraryProjectInitDescriptor.java
Cannot solve method call GUtil.map("groovyVersion", libraryVersionProvider.getVersion("groovy")) java.lang.RuntimeException: Method 'getVersion' cannot be resolved in context libraryVersionProvider.getVersion("groovy") (line: 46) MethodCallExprContext{wrapped=libraryVersionProvider.getVersion("groovy")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/build-init/src/main/groovy/org/gradle/buildinit/plugins/internal/JavaLibraryProjectInitDescriptor.java
Cannot solve method call GUtil.map("slf4jVersion", libraryVersionProvider.getVersion("slf4j")) java.lang.RuntimeException: Method 'getVersion' cannot be resolved in context libraryVersionProvider.getVersion("slf4j") (line: 45) MethodCallExprContext{wrapped=libraryVersionProvider.getVersion("slf4j")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/build-init/src/main/groovy/org/gradle/buildinit/plugins/internal/JavaLibraryProjectInitDescriptor.java
Cannot solve method call GUtil.map("junitVersion", libraryVersionProvider.getVersion("junit")) java.lang.RuntimeException: Method 'getVersion' cannot be resolved in context libraryVersionProvider.getVersion("junit") (line: 44) MethodCallExprContext{wrapped=libraryVersionProvider.getVersion("junit")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/build-init/src/main/groovy/org/gradle/buildinit/plugins/internal/JavaLibraryProjectInitDescriptor.java
Method 'withTarget' cannot be resolved in context templateOperationFactory.newTemplateOperation().withTemplate(gradleBuildTemplate(testFramework)).withTarget("build.gradle") (line: 40) MethodCallExprContext{wrapped=templateOperationFactory.newTemplateOperation().withTemplate(gradleBuildTemplate(testFramework)).withTarget("build.gradle")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Error calculating the type of parameter GUtil.map("ref_userguide_java_tutorial", "tutorial_java_projects") of method call templateOperationFactory.newTemplateOperation().withTemplate(gradleBuildTemplate(testFramework)).withTarget("build.gradle").withDocumentationBindings(GUtil.map("ref_userguide_java_tutorial", "tutorial_java_projects"))
Error calculating the type of parameter GUtil.map("junitVersion", libraryVersionProvider.getVersion("junit")) of method call templateOperationFactory.newTemplateOperation().withTemplate(gradleBuildTemplate(testFramework)).withTarget("build.gradle").withDocumentationBindings(GUtil.map("ref_userguide_java_tutorial", "tutorial_java_projects")).withBindings(GUtil.map("junitVersion", libraryVersionProvider.getVersion("junit")))
Error calculating the type of parameter GUtil.map("slf4jVersion", libraryVersionProvider.getVersion("slf4j")) of method call templateOperationFactory.newTemplateOperation().withTemplate(gradleBuildTemplate(testFramework)).withTarget("build.gradle").withDocumentationBindings(GUtil.map("ref_userguide_java_tutorial", "tutorial_java_projects")).withBindings(GUtil.map("junitVersion", libraryVersionProvider.getVersion("junit"))).withBindings(GUtil.map("slf4jVersion", libraryVersionProvider.getVersion("slf4j")))
Error calculating the type of parameter GUtil.map("groovyVersion", libraryVersionProvider.getVersion("groovy")) of method call templateOperationFactory.newTemplateOperation().withTemplate(gradleBuildTemplate(testFramework)).withTarget("build.gradle").withDocumentationBindings(GUtil.map("ref_userguide_java_tutorial", "tutorial_java_projects")).withBindings(GUtil.map("junitVersion", libraryVersionProvider.getVersion("junit"))).withBindings(GUtil.map("slf4jVersion", libraryVersionProvider.getVersion("slf4j"))).withBindings(GUtil.map("groovyVersion", libraryVersionProvider.getVersion("groovy")))
Error calculating the type of parameter GUtil.map("spockVersion", libraryVersionProvider.getVersion("spock")) of method call templateOperationFactory.newTemplateOperation().withTemplate(gradleBuildTemplate(testFramework)).withTarget("build.gradle").withDocumentationBindings(GUtil.map("ref_userguide_java_tutorial", "tutorial_java_projects")).withBindings(GUtil.map("junitVersion", libraryVersionProvider.getVersion("junit"))).withBindings(GUtil.map("slf4jVersion", libraryVersionProvider.getVersion("slf4j"))).withBindings(GUtil.map("groovyVersion", libraryVersionProvider.getVersion("groovy"))).withBindings(GUtil.map("spockVersion", libraryVersionProvider.getVersion("spock")))
Error calculating the type of parameter GUtil.map("testngVersion", libraryVersionProvider.getVersion("testng")) of method call templateOperationFactory.newTemplateOperation().withTemplate(gradleBuildTemplate(testFramework)).withTarget("build.gradle").withDocumentationBindings(GUtil.map("ref_userguide_java_tutorial", "tutorial_java_projects")).withBindings(GUtil.map("junitVersion", libraryVersionProvider.getVersion("junit"))).withBindings(GUtil.map("slf4jVersion", libraryVersionProvider.getVersion("slf4j"))).withBindings(GUtil.map("groovyVersion", libraryVersionProvider.getVersion("groovy"))).withBindings(GUtil.map("spockVersion", libraryVersionProvider.getVersion("spock"))).withBindings(GUtil.map("testngVersion", libraryVersionProvider.getVersion("testng")))
Error calculating the type of parameter GUtil.map("testngVersion", libraryVersionProvider.getVersion("testng")) of method call templateOperationFactory.newTemplateOperation().withTemplate(gradleBuildTemplate(testFramework)).withTarget("build.gradle").withDocumentationBindings(GUtil.map("ref_userguide_java_tutorial", "tutorial_java_projects")).withBindings(GUtil.map("junitVersion", libraryVersionProvider.getVersion("junit"))).withBindings(GUtil.map("slf4jVersion", libraryVersionProvider.getVersion("slf4j"))).withBindings(GUtil.map("groovyVersion", libraryVersionProvider.getVersion("groovy"))).withBindings(GUtil.map("spockVersion", libraryVersionProvider.getVersion("spock"))).withBindings(GUtil.map("testngVersion", libraryVersionProvider.getVersion("testng")))
Empty name expression SPOCK
Empty name expression TESTNG
Empty name expression SPOCK
Empty name expression TESTNG
Method 'resolveFilesAsTree' cannot be resolved in context fileResolver.resolveFilesAsTree("src/main/" + language) (line: 42) MethodCallExprContext{wrapped=fileResolver.resolveFilesAsTree("src/main/" + language)}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'resolveFilesAsTree' cannot be resolved in context fileResolver.resolveFilesAsTree("src/test/" + language) (line: 42) MethodCallExprContext{wrapped=fileResolver.resolveFilesAsTree("src/test/" + language)}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call clazzTemplate.substring(clazzTemplate.lastIndexOf("/") + 1) java.lang.RuntimeException: Method 'lastIndexOf' cannot be resolved in context clazzTemplate.lastIndexOf("/") (line: 52) MethodCallExprContext{wrapped=clazzTemplate.lastIndexOf("/")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/build-init/src/main/groovy/org/gradle/buildinit/plugins/internal/LanguageLibraryProjectInitDescriptor.java
Error calculating the type of parameter clazzTemplate.lastIndexOf("/") + 1 of method call clazzTemplate.substring(clazzTemplate.lastIndexOf("/") + 1)
Method 'withTarget' cannot be resolved in context templateOperationFactory.newTemplateOperation().withTemplate(clazzTemplate).withTarget("src/" + sourceSetName + "/" + language + "/" + targetFileName) (line: 57) MethodCallExprContext{wrapped=templateOperationFactory.newTemplateOperation().withTemplate(clazzTemplate).withTarget("src/" + sourceSetName + "/" + language + "/" + targetFileName)}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'setClassWorld' cannot be resolved in context new DefaultContainerConfiguration().setClassWorld(new ClassWorld("plexus.core", ClassWorld.class.getClassLoader())) (line: 56) MethodCallExprContext{wrapped=new DefaultContainerConfiguration().setClassWorld(new ClassWorld("plexus.core", ClassWorld.class.getClassLoader()))}. Parameter types: [ReferenceType{ClassWorld, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call container.lookup(MavenExecutionRequestPopulator.class) UnsolvedSymbolException{context='unknown', name='MavenExecutionRequestPopulator', typeSolver=null} /repo/subprojects/build-init/src/main/groovy/org/gradle/buildinit/plugins/internal/maven/MavenProjectsCreator.java
Cannot solve method call builder.build(pomFile, buildingRequest) UnsolvedSymbolException{context='unknown', name='ProjectBuildingRequest', typeSolver=null} /repo/subprojects/build-init/src/main/groovy/org/gradle/buildinit/plugins/internal/maven/MavenProjectsCreator.java
Error calculating the type of parameter buildingRequest of method call builder.build(pomFile, buildingRequest)
Cannot solve method call builder.build(ImmutableList.of(pomFile), true, buildingRequest) UnsolvedSymbolException{context='Method 'of' with parameterTypes [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=ImmutableList}'} /repo/subprojects/build-init/src/main/groovy/org/gradle/buildinit/plugins/internal/maven/MavenProjectsCreator.java
Method 'append' cannot be resolved in context out.append("</projects>") (line: 42) MethodCallExprContext{wrapped=out.append("</projects>")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call new MavenXpp3Writer().write(out.getOutputStream(), project.getModel()) java.lang.RuntimeException: Method 'getModel' cannot be resolved in context project.getModel() (line: 48) MethodCallExprContext{wrapped=project.getModel()}. Parameter types: [] /repo/subprojects/build-init/src/main/groovy/org/gradle/buildinit/plugins/internal/maven/MavenProjectXmlWriter.java
Error calculating the type of parameter CharsetToolkit.getDefaultSystemCharset() of method call Resources.asCharSource(templateURL, CharsetToolkit.getDefaultSystemCharset())
Error calculating the type of parameter Charsets.UTF_8 of method call Files.asCharSink(target, Charsets.UTF_8)
Cannot solve method call GUtil.map("junitVersion", libraryVersionProvider.getVersion("junit")) java.lang.RuntimeException: Method 'getVersion' cannot be resolved in context libraryVersionProvider.getVersion("junit") (line: 42) MethodCallExprContext{wrapped=libraryVersionProvider.getVersion("junit")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/build-init/src/main/groovy/org/gradle/buildinit/plugins/internal/ScalaLibraryProjectInitDescriptor.java
Cannot solve method call GUtil.map("scalaXmlVersion", libraryVersionProvider.getVersion("scala-xml")) java.lang.RuntimeException: Method 'getVersion' cannot be resolved in context libraryVersionProvider.getVersion("scala-xml") (line: 41) MethodCallExprContext{wrapped=libraryVersionProvider.getVersion("scala-xml")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/build-init/src/main/groovy/org/gradle/buildinit/plugins/internal/ScalaLibraryProjectInitDescriptor.java
Cannot solve method call GUtil.map("scalaXmlModule", "scala-xml_" + libraryVersionProvider.getVersion("scala")) java.lang.RuntimeException: Method 'getVersion' cannot be resolved in context libraryVersionProvider.getVersion("scala") (line: 40) MethodCallExprContext{wrapped=libraryVersionProvider.getVersion("scala")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/build-init/src/main/groovy/org/gradle/buildinit/plugins/internal/ScalaLibraryProjectInitDescriptor.java
Cannot solve method call GUtil.map("scalaTestVersion", libraryVersionProvider.getVersion("scalatest")) java.lang.RuntimeException: Method 'getVersion' cannot be resolved in context libraryVersionProvider.getVersion("scalatest") (line: 39) MethodCallExprContext{wrapped=libraryVersionProvider.getVersion("scalatest")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/build-init/src/main/groovy/org/gradle/buildinit/plugins/internal/ScalaLibraryProjectInitDescriptor.java
Cannot solve method call GUtil.map("scalaTestModule", "scalatest_" + libraryVersionProvider.getVersion("scala")) java.lang.RuntimeException: Method 'getVersion' cannot be resolved in context libraryVersionProvider.getVersion("scala") (line: 38) MethodCallExprContext{wrapped=libraryVersionProvider.getVersion("scala")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/build-init/src/main/groovy/org/gradle/buildinit/plugins/internal/ScalaLibraryProjectInitDescriptor.java
Cannot solve method call GUtil.map("scalaLibraryVersion", libraryVersionProvider.getVersion("scala-library")) java.lang.RuntimeException: Method 'getVersion' cannot be resolved in context libraryVersionProvider.getVersion("scala-library") (line: 37) MethodCallExprContext{wrapped=libraryVersionProvider.getVersion("scala-library")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/build-init/src/main/groovy/org/gradle/buildinit/plugins/internal/ScalaLibraryProjectInitDescriptor.java
Cannot solve method call GUtil.map("scalaVersion", libraryVersionProvider.getVersion("scala")) java.lang.RuntimeException: Method 'getVersion' cannot be resolved in context libraryVersionProvider.getVersion("scala") (line: 36) MethodCallExprContext{wrapped=libraryVersionProvider.getVersion("scala")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/build-init/src/main/groovy/org/gradle/buildinit/plugins/internal/ScalaLibraryProjectInitDescriptor.java
Method 'withTemplate' cannot be resolved in context templateOperationFactory.newTemplateOperation().withTemplate("scalalibrary/build.gradle.template") (line: 32) MethodCallExprContext{wrapped=templateOperationFactory.newTemplateOperation().withTemplate("scalalibrary/build.gradle.template")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'withTemplate' cannot be resolved in context templateOperationFactory.newTemplateOperation().withTemplate("scalalibrary/build.gradle.template") (line: 32) MethodCallExprContext{wrapped=templateOperationFactory.newTemplateOperation().withTemplate("scalalibrary/build.gradle.template")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Error calculating the type of parameter GUtil.map("ref_userguide_scala_plugin", "scala_plugin") of method call templateOperationFactory.newTemplateOperation().withTemplate("scalalibrary/build.gradle.template").withTarget("build.gradle").withDocumentationBindings(GUtil.map("ref_userguide_scala_plugin", "scala_plugin"))
Error calculating the type of parameter GUtil.map("scalaVersion", libraryVersionProvider.getVersion("scala")) of method call templateOperationFactory.newTemplateOperation().withTemplate("scalalibrary/build.gradle.template").withTarget("build.gradle").withDocumentationBindings(GUtil.map("ref_userguide_scala_plugin", "scala_plugin")).withBindings(GUtil.map("scalaVersion", libraryVersionProvider.getVersion("scala")))
Error calculating the type of parameter GUtil.map("scalaLibraryVersion", libraryVersionProvider.getVersion("scala-library")) of method call templateOperationFactory.newTemplateOperation().withTemplate("scalalibrary/build.gradle.template").withTarget("build.gradle").withDocumentationBindings(GUtil.map("ref_userguide_scala_plugin", "scala_plugin")).withBindings(GUtil.map("scalaVersion", libraryVersionProvider.getVersion("scala"))).withBindings(GUtil.map("scalaLibraryVersion", libraryVersionProvider.getVersion("scala-library")))
Error calculating the type of parameter GUtil.map("scalaTestModule", "scalatest_" + libraryVersionProvider.getVersion("scala")) of method call templateOperationFactory.newTemplateOperation().withTemplate("scalalibrary/build.gradle.template").withTarget("build.gradle").withDocumentationBindings(GUtil.map("ref_userguide_scala_plugin", "scala_plugin")).withBindings(GUtil.map("scalaVersion", libraryVersionProvider.getVersion("scala"))).withBindings(GUtil.map("scalaLibraryVersion", libraryVersionProvider.getVersion("scala-library"))).withBindings(GUtil.map("scalaTestModule", "scalatest_" + libraryVersionProvider.getVersion("scala")))
Error calculating the type of parameter GUtil.map("scalaTestVersion", libraryVersionProvider.getVersion("scalatest")) of method call templateOperationFactory.newTemplateOperation().withTemplate("scalalibrary/build.gradle.template").withTarget("build.gradle").withDocumentationBindings(GUtil.map("ref_userguide_scala_plugin", "scala_plugin")).withBindings(GUtil.map("scalaVersion", libraryVersionProvider.getVersion("scala"))).withBindings(GUtil.map("scalaLibraryVersion", libraryVersionProvider.getVersion("scala-library"))).withBindings(GUtil.map("scalaTestModule", "scalatest_" + libraryVersionProvider.getVersion("scala"))).withBindings(GUtil.map("scalaTestVersion", libraryVersionProvider.getVersion("scalatest")))
Error calculating the type of parameter GUtil.map("scalaXmlModule", "scala-xml_" + libraryVersionProvider.getVersion("scala")) of method call templateOperationFactory.newTemplateOperation().withTemplate("scalalibrary/build.gradle.template").withTarget("build.gradle").withDocumentationBindings(GUtil.map("ref_userguide_scala_plugin", "scala_plugin")).withBindings(GUtil.map("scalaVersion", libraryVersionProvider.getVersion("scala"))).withBindings(GUtil.map("scalaLibraryVersion", libraryVersionProvider.getVersion("scala-library"))).withBindings(GUtil.map("scalaTestModule", "scalatest_" + libraryVersionProvider.getVersion("scala"))).withBindings(GUtil.map("scalaTestVersion", libraryVersionProvider.getVersion("scalatest"))).withBindings(GUtil.map("scalaXmlModule", "scala-xml_" + libraryVersionProvider.getVersion("scala")))
Error calculating the type of parameter GUtil.map("scalaXmlVersion", libraryVersionProvider.getVersion("scala-xml")) of method call templateOperationFactory.newTemplateOperation().withTemplate("scalalibrary/build.gradle.template").withTarget("build.gradle").withDocumentationBindings(GUtil.map("ref_userguide_scala_plugin", "scala_plugin")).withBindings(GUtil.map("scalaVersion", libraryVersionProvider.getVersion("scala"))).withBindings(GUtil.map("scalaLibraryVersion", libraryVersionProvider.getVersion("scala-library"))).withBindings(GUtil.map("scalaTestModule", "scalatest_" + libraryVersionProvider.getVersion("scala"))).withBindings(GUtil.map("scalaTestVersion", libraryVersionProvider.getVersion("scalatest"))).withBindings(GUtil.map("scalaXmlModule", "scala-xml_" + libraryVersionProvider.getVersion("scala"))).withBindings(GUtil.map("scalaXmlVersion", libraryVersionProvider.getVersion("scala-xml")))
Error calculating the type of parameter GUtil.map("junitVersion", libraryVersionProvider.getVersion("junit")) of method call templateOperationFactory.newTemplateOperation().withTemplate("scalalibrary/build.gradle.template").withTarget("build.gradle").withDocumentationBindings(GUtil.map("ref_userguide_scala_plugin", "scala_plugin")).withBindings(GUtil.map("scalaVersion", libraryVersionProvider.getVersion("scala"))).withBindings(GUtil.map("scalaLibraryVersion", libraryVersionProvider.getVersion("scala-library"))).withBindings(GUtil.map("scalaTestModule", "scalatest_" + libraryVersionProvider.getVersion("scala"))).withBindings(GUtil.map("scalaTestVersion", libraryVersionProvider.getVersion("scalatest"))).withBindings(GUtil.map("scalaXmlModule", "scala-xml_" + libraryVersionProvider.getVersion("scala"))).withBindings(GUtil.map("scalaXmlVersion", libraryVersionProvider.getVersion("scala-xml"))).withBindings(GUtil.map("junitVersion", libraryVersionProvider.getVersion("junit")))
Error calculating the type of parameter GUtil.map("junitVersion", libraryVersionProvider.getVersion("junit")) of method call templateOperationFactory.newTemplateOperation().withTemplate("scalalibrary/build.gradle.template").withTarget("build.gradle").withDocumentationBindings(GUtil.map("ref_userguide_scala_plugin", "scala_plugin")).withBindings(GUtil.map("scalaVersion", libraryVersionProvider.getVersion("scala"))).withBindings(GUtil.map("scalaLibraryVersion", libraryVersionProvider.getVersion("scala-library"))).withBindings(GUtil.map("scalaTestModule", "scalatest_" + libraryVersionProvider.getVersion("scala"))).withBindings(GUtil.map("scalaTestVersion", libraryVersionProvider.getVersion("scalatest"))).withBindings(GUtil.map("scalaXmlModule", "scala-xml_" + libraryVersionProvider.getVersion("scala"))).withBindings(GUtil.map("scalaXmlVersion", libraryVersionProvider.getVersion("scala-xml"))).withBindings(GUtil.map("junitVersion", libraryVersionProvider.getVersion("junit")))
Cannot solve field access PathBase.GRADLE_USER_HOME
Cannot solve field access DistributionType.BIN
Cannot solve field access PathBase.GRADLE_USER_HOME
Method 'getDistributionFor' cannot be resolved in context locator.getDistributionFor(gradleVersion, distributionType.name().toLowerCase()) (line: 273) MethodCallExprContext{wrapped=locator.getDistributionFor(gradleVersion, distributionType.name().toLowerCase())}. Parameter types: [ReferenceType{org.gradle.util.GradleVersion, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call String.format("options: %s, extraArguments: %s, removedOptions: %s", quoteAndJoin(presentOptions), quoteAndJoin(extraArguments), quoteAndJoin(removedOptions)) java.lang.RuntimeException: Method 'quoteAndJoin' cannot be resolved in context quoteAndJoin(presentOptions) (line: 37) MethodCallExprContext{wrapped=quoteAndJoin(presentOptions)}. Parameter types: [ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/cli/src/main/java/org/gradle/cli/ParsedCommandLine.java
Cannot solve method call presentOptions.addAll(option.getOptions()) java.lang.RuntimeException: Method 'getOptions' cannot be resolved in context option.getOptions() (line: 117) MethodCallExprContext{wrapped=option.getOptions()}. Parameter types: [] /repo/subprojects/cli/src/main/java/org/gradle/cli/ParsedCommandLine.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call parsedOption.onArgument(arg.substring(2)) java.lang.RuntimeException: Method 'substring' cannot be resolved in context arg.substring(2) (line: 119) MethodCallExprContext{wrapped=arg.substring(2)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/cli/src/main/java/org/gradle/cli/CommandLineParser.java
Cannot solve method call parseState.onStartOption(arg, arg.substring(1, 2)) java.lang.RuntimeException: Method 'substring' cannot be resolved in context arg.substring(1, 2) (line: 105) MethodCallExprContext{wrapped=arg.substring(1, 2)}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}] /repo/subprojects/cli/src/main/java/org/gradle/cli/CommandLineParser.java
Cannot solve method call parsedOption.onArgument(arg.substring(3)) java.lang.RuntimeException: Method 'substring' cannot be resolved in context arg.substring(3) (line: 106) MethodCallExprContext{wrapped=arg.substring(3)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/cli/src/main/java/org/gradle/cli/CommandLineParser.java
Cannot solve method call parseState.onStartOption(arg, arg.substring(2, endArg)) java.lang.RuntimeException: Method 'substring' cannot be resolved in context arg.substring(2, endArg) (line: 102) MethodCallExprContext{wrapped=arg.substring(2, endArg)}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}] /repo/subprojects/cli/src/main/java/org/gradle/cli/CommandLineParser.java
Cannot solve method call parsedOption.onArgument(arg.substring(endArg + 1)) java.lang.RuntimeException: Method 'substring' cannot be resolved in context arg.substring(endArg + 1) (line: 103) MethodCallExprContext{wrapped=arg.substring(endArg + 1)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/cli/src/main/java/org/gradle/cli/CommandLineParser.java
Cannot solve method call parseState.onStartOption(arg, arg.substring(2)) java.lang.RuntimeException: Method 'substring' cannot be resolved in context arg.substring(2) (line: 98) MethodCallExprContext{wrapped=arg.substring(2)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/cli/src/main/java/org/gradle/cli/CommandLineParser.java
Cannot solve method call commandLineOptions.add(optionsByString.get(option)) java.lang.RuntimeException: Method 'get' cannot be resolved in context optionsByString.get(option) (line: 168) MethodCallExprContext{wrapped=optionsByString.get(option)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/cli/src/main/java/org/gradle/cli/CommandLineParser.java
Cannot solve method call orderedOptions.addAll(optionsByString.values()) java.lang.RuntimeException: Method 'values' cannot be resolved in context optionsByString.values() (line: 184) MethodCallExprContext{wrapped=optionsByString.values()}. Parameter types: [] /repo/subprojects/cli/src/main/java/org/gradle/cli/CommandLineParser.java
Cannot solve method call orderedOptionStrings.addAll(option.getOptions()) java.lang.RuntimeException: Method 'getOptions' cannot be resolved in context option.getOptions() (line: 188) MethodCallExprContext{wrapped=option.getOptions()}. Parameter types: [] /repo/subprojects/cli/src/main/java/org/gradle/cli/CommandLineParser.java
Cannot solve method call Math.max(max, optionStr.length()) java.lang.RuntimeException: Method 'length' cannot be resolved in context optionStr.length() (line: 208) MethodCallExprContext{wrapped=optionStr.length()}. Parameter types: [] /repo/subprojects/cli/src/main/java/org/gradle/cli/CommandLineParser.java
Method 'getValue' cannot be resolved in context entry.getValue() (line: 211) MethodCallExprContext{wrapped=entry.getValue()}. Parameter types: []
Cannot solve method call formatter.format("%-" + max + "s  %s%n", entry.getKey(), entry.getValue()) java.lang.RuntimeException: Method 'getKey' cannot be resolved in context entry.getKey() (line: 214) MethodCallExprContext{wrapped=entry.getKey()}. Parameter types: [] /repo/subprojects/cli/src/main/java/org/gradle/cli/CommandLineParser.java
Cannot solve method call formatter.format("%s%n", entry.getKey()) java.lang.RuntimeException: Method 'getKey' cannot be resolved in context entry.getKey() (line: 212) MethodCallExprContext{wrapped=entry.getKey()}. Parameter types: [] /repo/subprojects/cli/src/main/java/org/gradle/cli/CommandLineParser.java
Method 'matcher' cannot be resolved in context OPTION_NAME_PATTERN.matcher(option) (line: 252) MethodCallExprContext{wrapped=OPTION_NAME_PATTERN.matcher(option)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getValues' cannot be resolved in context parsedOption.getValues() (line: 459) MethodCallExprContext{wrapped=parsedOption.getValues()}. Parameter types: []
Cannot solve method call deprecationPrinter.println("The " + optionString + " option is deprecated - " + option.getDeprecationWarning()) java.lang.RuntimeException: Method 'getDeprecationWarning' cannot be resolved in context option.getDeprecationWarning() (line: 466) MethodCallExprContext{wrapped=option.getDeprecationWarning()}. Parameter types: [] /repo/subprojects/cli/src/main/java/org/gradle/cli/CommandLineParser.java
Cannot solve method call Collections.min(option1.getOptions(), new OptionStringComparator()) java.lang.RuntimeException: Method 'getOptions' cannot be resolved in context option1.getOptions() (line: 512) MethodCallExprContext{wrapped=option1.getOptions()}. Parameter types: [] /repo/subprojects/cli/src/main/java/org/gradle/cli/CommandLineParser.java
Cannot solve method call Collections.min(option2.getOptions(), new OptionStringComparator()) java.lang.RuntimeException: Method 'getOptions' cannot be resolved in context option2.getOptions() (line: 513) MethodCallExprContext{wrapped=option2.getOptions()}. Parameter types: [] /repo/subprojects/cli/src/main/java/org/gradle/cli/CommandLineParser.java
Cannot solve method call properties.put(keyValueExpression.substring(0, pos), keyValueExpression.substring(pos + 1)) java.lang.RuntimeException: Method 'substring' cannot be resolved in context keyValueExpression.substring(0, pos) (line: 38) MethodCallExprContext{wrapped=keyValueExpression.substring(0, pos)}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}] /repo/subprojects/cli/src/main/java/org/gradle/cli/AbstractPropertiesCommandLineConverter.java
Cannot solve method call setConfig(project.getResources().getText().fromFile(file)) java.lang.RuntimeException: Method 'fromFile' cannot be resolved in context project.getResources().getText().fromFile(file) (line: 73) MethodCallExprContext{wrapped=project.getResources().getText().fromFile(file)}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/CodeNarcExtension.java
Cannot solve method call dependencies.add(project.getDependencies().create("jdepend:jdepend:" + extension.getToolVersion())) java.lang.RuntimeException: Method 'create' cannot be resolved in context project.getDependencies().create("jdepend:jdepend:" + extension.getToolVersion()) (line: 74) MethodCallExprContext{wrapped=project.getDependencies().create("jdepend:jdepend:" + extension.getToolVersion())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/JDependPlugin.java
Cannot solve method call dependencies.add(project.getDependencies().create("org.apache.ant:ant-jdepend:1.9.6")) java.lang.RuntimeException: Method 'create' cannot be resolved in context project.getDependencies().create("org.apache.ant:ant-jdepend:1.9.6") (line: 75) MethodCallExprContext{wrapped=project.getDependencies().create("org.apache.ant:ant-jdepend:1.9.6")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/JDependPlugin.java
Method 'conventionMappingOf' cannot be resolved in context conventionMappingOf(task) (line: 81) MethodCallExprContext{wrapped=conventionMappingOf(task)}. Parameter types: [ReferenceType{org.gradle.api.plugins.quality.JDepend, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call reportMapping.map("enabled", new Callable<Boolean>() {

    @Override
    public Boolean call() {
        return report.getName().equals("xml");
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/JDependPlugin.java
Cannot solve method call reportMapping.map("destination", new Callable<File>() {

    @Override
    public File call() {
        final String fileSuffix = report.getName().equals("text") ? "txt" : report.getName();
        return new File(extension.getReportsDir(), baseName + "." + fileSuffix);
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/JDependPlugin.java
Method 'conventionMappingOf' cannot be resolved in context conventionMappingOf(task) (line: 110) MethodCallExprContext{wrapped=conventionMappingOf(task)}. Parameter types: [ReferenceType{org.gradle.api.plugins.quality.JDepend, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call configuration.exclude(excludeProperties("ant", "ant")) java.lang.RuntimeException: Method 'excludeProperties' cannot be resolved in context excludeProperties("ant", "ant") (line: 98) MethodCallExprContext{wrapped=excludeProperties("ant", "ant")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/internal/AbstractCodeQualityPlugin.java
Cannot solve method call configuration.exclude(excludeProperties("org.apache.ant", "ant")) java.lang.RuntimeException: Method 'excludeProperties' cannot be resolved in context excludeProperties("org.apache.ant", "ant") (line: 99) MethodCallExprContext{wrapped=excludeProperties("org.apache.ant", "ant")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/internal/AbstractCodeQualityPlugin.java
Cannot solve method call configuration.exclude(excludeProperties("org.apache.ant", "ant-launcher")) java.lang.RuntimeException: Method 'excludeProperties' cannot be resolved in context excludeProperties("org.apache.ant", "ant-launcher") (line: 100) MethodCallExprContext{wrapped=excludeProperties("org.apache.ant", "ant-launcher")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/internal/AbstractCodeQualityPlugin.java
Cannot solve method call configuration.exclude(excludeProperties("org.slf4j", "slf4j-api")) java.lang.RuntimeException: Method 'excludeProperties' cannot be resolved in context excludeProperties("org.slf4j", "slf4j-api") (line: 101) MethodCallExprContext{wrapped=excludeProperties("org.slf4j", "slf4j-api")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/internal/AbstractCodeQualityPlugin.java
Cannot solve method call configuration.exclude(excludeProperties("org.slf4j", "jcl-over-slf4j")) java.lang.RuntimeException: Method 'excludeProperties' cannot be resolved in context excludeProperties("org.slf4j", "jcl-over-slf4j") (line: 102) MethodCallExprContext{wrapped=excludeProperties("org.slf4j", "jcl-over-slf4j")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/internal/AbstractCodeQualityPlugin.java
Cannot solve method call configuration.exclude(excludeProperties("org.slf4j", "log4j-over-slf4j")) java.lang.RuntimeException: Method 'excludeProperties' cannot be resolved in context excludeProperties("org.slf4j", "log4j-over-slf4j") (line: 103) MethodCallExprContext{wrapped=excludeProperties("org.slf4j", "log4j-over-slf4j")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/internal/AbstractCodeQualityPlugin.java
Cannot solve method call configuration.exclude(excludeProperties("commons-logging", "commons-logging")) java.lang.RuntimeException: Method 'excludeProperties' cannot be resolved in context excludeProperties("commons-logging", "commons-logging") (line: 104) MethodCallExprContext{wrapped=excludeProperties("commons-logging", "commons-logging")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/internal/AbstractCodeQualityPlugin.java
Cannot solve method call configuration.exclude(excludeProperties("log4j", "log4j")) java.lang.RuntimeException: Method 'excludeProperties' cannot be resolved in context excludeProperties("log4j", "log4j") (line: 105) MethodCallExprContext{wrapped=excludeProperties("log4j", "log4j")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/internal/AbstractCodeQualityPlugin.java
Cannot solve method call extensionMapping.map("sourceSets", Callables.returning(new ArrayList())) UnsolvedSymbolException{context='Method 'returning' with parameterTypes [ReferenceType{java.util.ArrayList, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.util.concurrent.Callables}'} /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/internal/AbstractCodeQualityPlugin.java
Method 'getByType' cannot be resolved in context project.getExtensions().getByType(ReportingExtension.class) (line: 123) MethodCallExprContext{wrapped=project.getExtensions().getByType(ReportingExtension.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.reporting.ReportingExtension, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call extensionMapping.map("reportsDir", new Callable<File>() {

    @Override
    public File call() {
        return project.getExtensions().getByType(ReportingExtension.class).file(getReportName());
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/internal/AbstractCodeQualityPlugin.java
Cannot solve method call extensionMapping.map("sourceSets", new Callable<SourceSetContainer>() {

    @Override
    public SourceSetContainer call() {
        return getJavaPluginConvention().getSourceSets();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/internal/AbstractCodeQualityPlugin.java
Method 'charAt' cannot be resolved in context prunedName.charAt(0) (line: 147) MethodCallExprContext{wrapped=prunedName.charAt(0)}. Parameter types: [PrimitiveTypeUsage{name='int'}]
Method 'getByName' cannot be resolved in context project.getTasks().getByName("check") (line: 189) MethodCallExprContext{wrapped=project.getTasks().getByName("check")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot resolve field access null
Cannot solve method call args.add(String.format("-effort:%s", effort)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/internal/findbugs/FindBugsSpecBuilder.java
Cannot solve method call args.add(String.format("-%s", reportLevel)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/internal/findbugs/FindBugsSpecBuilder.java
Cannot solve method call args.add(CollectionUtils.join(",", visitors)) UnsolvedSymbolException{context='Method 'join' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class CollectionUtils {

    /**
     * Returns null if the collection is empty otherwise expects a {@link #single(Iterable)} element to be found.
     */
    @Nullable
    public static <T> T findSingle(Collection<T> source) {
        return source.isEmpty() ? null : single(source);
    }

    /**
     * Returns the single element in the collection or throws.
     */
    public static <T> T single(Iterable<? extends T> source) {
        Iterator<? extends T> iterator = source.iterator();
        if (!iterator.hasNext()) {
            throw new NoSuchElementException("Expecting collection with single element, got none.");
        }
        T element = iterator.next();
        if (iterator.hasNext()) {
            throw new IllegalArgumentException("Expecting collection with single element, got multiple.");
        }
        return element;
    }

    public static <T> Collection<? extends T> checkedCast(Class<T> type, Collection<?> input) {
        for (Object o : input) {
            cast(type, o);
        }
        return Cast.uncheckedCast(input);
    }

    public static <T> T findFirst(Iterable<? extends T> source, Spec<? super T> filter) {
        for (T item : source) {
            if (filter.isSatisfiedBy(item)) {
                return item;
            }
        }
        return null;
    }

    public static <T> T findFirst(T[] source, Spec<? super T> filter) {
        for (T thing : source) {
            if (filter.isSatisfiedBy(thing)) {
                return thing;
            }
        }
        return null;
    }

    public static <T> T first(Iterable<? extends T> source) {
        return source.iterator().next();
    }

    public static <T> boolean any(Iterable<? extends T> source, Spec<? super T> filter) {
        return findFirst(source, filter) != null;
    }

    public static <T> boolean any(T[] source, Spec<? super T> filter) {
        return findFirst(source, filter) != null;
    }

    public static <T> Set<T> filter(Set<? extends T> set, Spec<? super T> filter) {
        return filter(set, new LinkedHashSet<T>(), filter);
    }

    public static <T> List<T> filter(List<? extends T> list, Spec<? super T> filter) {
        return filter(list, new LinkedList<T>(), filter);
    }

    public static <T> List<T> filter(T[] array, Spec<? super T> filter) {
        return filter(Arrays.asList(array), new LinkedList<T>(), filter);
    }

    /**
     * Returns a sorted copy of the provided collection of things. Uses the provided comparator to sort.
     */
    public static <T> List<T> sort(Iterable<? extends T> things, Comparator<? super T> comparator) {
        List<T> copy = toMutableList(things);
        Collections.sort(copy, comparator);
        return copy;
    }

    /**
     * Returns a sorted copy of the provided collection of things. Uses the natural ordering of the things.
     */
    public static <T extends Comparable> List<T> sort(Iterable<T> things) {
        List<T> copy = toMutableList(things);
        Collections.sort(copy);
        return copy;
    }

    public static <T, C extends Collection<T>> C filter(Iterable<? extends T> source, C destination, Spec<? super T> filter) {
        for (T item : source) {
            if (filter.isSatisfiedBy(item)) {
                destination.add(item);
            }
        }
        return destination;
    }

    public static <K, V> Map<K, V> filter(Map<K, V> map, Spec<Map.Entry<K, V>> filter) {
        return filter(map, new HashMap<K, V>(), filter);
    }

    public static <K, V> Map<K, V> filter(Map<K, V> map, Map<K, V> destination, Spec<Map.Entry<K, V>> filter) {
        for (Map.Entry<K, V> entry : map.entrySet()) {
            if (filter.isSatisfiedBy(entry)) {
                destination.put(entry.getKey(), entry.getValue());
            }
        }
        return destination;
    }

    public static <R, I> R[] collectArray(I[] list, Class<R> newType, Transformer<? extends R, ? super I> transformer) {
        @SuppressWarnings("unchecked") R[] destination = (R[]) Array.newInstance(newType, list.length);
        return collectArray(list, destination, transformer);
    }

    public static <R, I> R[] collectArray(I[] list, R[] destination, Transformer<? extends R, ? super I> transformer) {
        assert list.length <= destination.length;
        for (int i = 0; i < list.length; ++i) {
            destination[i] = transformer.transform(list[i]);
        }
        return destination;
    }

    public static <R, I> List<R> collect(List<? extends I> list, Transformer<? extends R, ? super I> transformer) {
        return collect(list, new ArrayList<R>(list.size()), transformer);
    }

    public static <R, I> List<R> collect(I[] list, Transformer<? extends R, ? super I> transformer) {
        return collect(Arrays.asList(list), transformer);
    }

    public static <R, I> Set<R> collect(Set<? extends I> set, Transformer<? extends R, ? super I> transformer) {
        return collect(set, new HashSet<R>(), transformer);
    }

    public static <R, I> List<R> collect(Iterable<? extends I> source, Transformer<? extends R, ? super I> transformer) {
        return collect(source, new LinkedList<R>(), transformer);
    }

    public static <R, I, C extends Collection<R>> C collect(Iterable<? extends I> source, C destination, Transformer<? extends R, ? super I> transformer) {
        for (I item : source) {
            destination.add(transformer.transform(item));
        }
        return destination;
    }

    public static List<String> toStringList(Iterable<?> iterable) {
        return collect(iterable, new LinkedList<String>(), Transformers.asString());
    }

    /**
     * Recursively unpacks all the given things into a flat list.
     *
     * Nulls are not removed, they are left intact.
     *
     * @param things The things to flatten
     * @return A flattened list of the given things
     */
    public static List<?> flattenCollections(Object... things) {
        return flattenCollections(Object.class, things);
    }

    /**
     * Recursively unpacks all the given things into a flat list, ensuring they are of a certain type.
     *
     * Nulls are not removed, they are left intact.
     *
     * If a non null object cannot be cast to the target type, a ClassCastException will be thrown.
     *
     * @param things The things to flatten
     * @param <T> The target type in the flattened list
     * @return A flattened list of the given things
     */
    public static <T> List<T> flattenCollections(Class<T> type, Object... things) {
        if (things == null) {
            return Collections.singletonList(null);
        } else if (things.length == 0) {
            return Collections.emptyList();
        } else if (things.length == 1) {
            Object thing = things[0];
            if (thing == null) {
                return Collections.singletonList(null);
            }
            if (thing.getClass().isArray()) {
                Object[] thingArray = (Object[]) thing;
                List<T> list = new ArrayList<T>(thingArray.length);
                for (Object thingThing : thingArray) {
                    list.addAll(flattenCollections(type, thingThing));
                }
                return list;
            }
            if (thing instanceof Collection) {
                Collection<?> collection = (Collection<?>) thing;
                List<T> list = new ArrayList<T>();
                for (Object element : collection) {
                    list.addAll(flattenCollections(type, element));
                }
                return list;
            }
            return Collections.singletonList(cast(type, thing));
        } else {
            List<T> list = new ArrayList<T>();
            for (Object thing : things) {
                list.addAll(flattenCollections(type, thing));
            }
            return list;
        }
    }

    public static <T> List<T> toList(Iterable<? extends T> things) {
        if (things instanceof List) {
            @SuppressWarnings("unchecked") List<T> castThings = (List<T>) things;
            return castThings;
        }
        return toMutableList(things);
    }

    public static <T> List<T> toList(Enumeration<? extends T> things) {
        AbstractList<T> list = new ArrayList<T>();
        while (things.hasMoreElements()) {
            list.add(things.nextElement());
        }
        return list;
    }

    private static <T> List<T> toMutableList(Iterable<? extends T> things) {
        if (things == null) {
            return new ArrayList<T>(0);
        }
        List<T> list = new ArrayList<T>();
        for (T thing : things) {
            list.add(thing);
        }
        return list;
    }

    public static <T> List<T> intersection(Collection<? extends Collection<T>> availableValuesByDescriptor) {
        List<T> result = new ArrayList<T>();
        Iterator<? extends Collection<T>> iterator = availableValuesByDescriptor.iterator();
        if (iterator.hasNext()) {
            Collection<T> firstSet = iterator.next();
            result.addAll(firstSet);
            while (iterator.hasNext()) {
                Collection<T> next = iterator.next();
                result.retainAll(next);
            }
        }
        return result;
    }

    public static <T> List<T> toList(T[] things) {
        if (things == null || things.length == 0) {
            return new ArrayList<T>(0);
        }
        List<T> list = new ArrayList<T>(things.length);
        Collections.addAll(list, things);
        return list;
    }

    public static <T> Set<T> toSet(Iterable<? extends T> things) {
        if (things == null) {
            return new HashSet<T>(0);
        }
        if (things instanceof Set) {
            @SuppressWarnings("unchecked") Set<T> castThings = (Set<T>) things;
            return castThings;
        }
        Set<T> set = new LinkedHashSet<T>();
        for (T thing : things) {
            set.add(thing);
        }
        return set;
    }

    public static <E> List<E> compact(List<E> list) {
        boolean foundAtLeastOneNull = false;
        List<E> compacted = null;
        int i = 0;
        for (E element : list) {
            if (element == null) {
                if (!foundAtLeastOneNull) {
                    compacted = new ArrayList<E>(list.size());
                    if (i > 0) {
                        compacted.addAll(list.subList(0, i));
                    }
                }
                foundAtLeastOneNull = true;
            } else if (foundAtLeastOneNull) {
                compacted.add(element);
            }
            ++i;
        }
        return foundAtLeastOneNull ? compacted : list;
    }

    public static <C extends Collection<String>> C stringize(Iterable<?> source, C destination) {
        return collect(source, destination, Transformers.asString());
    }

    public static List<String> stringize(Collection<?> source) {
        return stringize(source, new ArrayList<String>(source.size()));
    }

    public static <E> boolean replace(List<E> list, Spec<? super E> filter, Transformer<? extends E, ? super E> transformer) {
        boolean replaced = false;
        int i = 0;
        for (E it : list) {
            if (filter.isSatisfiedBy(it)) {
                list.set(i, transformer.transform(it));
                replaced = true;
            }
            ++i;
        }
        return replaced;
    }

    public static <K, V> void collectMap(Map<K, V> destination, Iterable<? extends V> items, Transformer<? extends K, ? super V> keyGenerator) {
        for (V item : items) {
            destination.put(keyGenerator.transform(item), item);
        }
    }

    /**
     * Given a set of values, derive a set of keys and return a map
     */
    public static <K, V> Map<K, V> collectMap(Iterable<? extends V> items, Transformer<? extends K, ? super V> keyGenerator) {
        Map<K, V> map = new LinkedHashMap<K, V>();
        collectMap(map, items, keyGenerator);
        return map;
    }

    public static <K, V> void collectMapValues(Map<K, V> destination, Iterable<? extends K> keys, Transformer<? extends V, ? super K> keyGenerator) {
        for (K item : keys) {
            destination.put(item, keyGenerator.transform(item));
        }
    }

    /**
     * Given a set of keys, derive a set of values and return a map
     */
    public static <K, V> Map<K, V> collectMapValues(Iterable<? extends K> keys, Transformer<? extends V, ? super K> keyGenerator) {
        Map<K, V> map = new LinkedHashMap<K, V>();
        collectMapValues(map, keys, keyGenerator);
        return map;
    }

    public static <T> boolean every(Iterable<? extends T> things, Spec<? super T> predicate) {
        for (T thing : things) {
            if (!predicate.isSatisfiedBy(thing)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Utility for adding an iterable to a collection.
     *
     * @param t1 The collection to add to
     * @param t2 The iterable to add each item of to the collection
     * @param <T> The element type of t1
     * @return t1
     */
    public static <T> Collection<T> addAll(Collection<T> t1, Iterable<? extends T> t2) {
        for (T t : t2) {
            t1.add(t);
        }
        return t1;
    }

    /**
     * Utility for adding an array to a collection.
     *
     * @param t1 The collection to add to
     * @param t2 The iterable to add each item of to the collection
     * @param <T> The element type of t1
     * @return t1
     */
    public static <T> Collection<T> addAll(Collection<T> t1, T... t2) {
        Collections.addAll(t1, t2);
        return t1;
    }

    /**
     * The result of diffing two sets.
     *
     * @param <T> The type of element the sets contain
     * @see CollectionUtils#diffSetsBy(java.util.Set, java.util.Set, org.gradle.api.Transformer)
     */
    public static class SetDiff<T> {

        public Set<T> leftOnly = new HashSet<T>();

        public Set<Pair<T, T>> common = new HashSet<Pair<T, T>>();

        public Set<T> rightOnly = new HashSet<T>();
    }

    /**
     * Provides a “diff report” of how the two sets are similar and how they are different, comparing the entries by some aspect.
     *
     * The transformer is used to generate the value to use to compare the entries by. That is, the entries are not compared by equals by an attribute or characteristic.
     *
     * The transformer is expected to produce a unique value for each entry in a single set. Behaviour is undefined if this condition is not met.
     *
     * @param left The set on the “left” side of the comparison.
     * @param right The set on the “right” side of the comparison.
     * @param compareBy Provides the value to compare entries from either side by
     * @param <T> The type of the entry objects
     * @return A representation of the difference
     */
    public static <T> SetDiff<T> diffSetsBy(Set<? extends T> left, Set<? extends T> right, Transformer<?, T> compareBy) {
        if (left == null) {
            throw new NullPointerException("'left' set is null");
        }
        if (right == null) {
            throw new NullPointerException("'right' set is null");
        }
        SetDiff<T> setDiff = new SetDiff<T>();
        Map<Object, T> indexedLeft = collectMap(left, compareBy);
        Map<Object, T> indexedRight = collectMap(right, compareBy);
        for (Map.Entry<Object, T> leftEntry : indexedLeft.entrySet()) {
            T rightValue = indexedRight.remove(leftEntry.getKey());
            if (rightValue == null) {
                setDiff.leftOnly.add(leftEntry.getValue());
            } else {
                Pair<T, T> pair = Pair.of(leftEntry.getValue(), rightValue);
                setDiff.common.add(pair);
            }
        }
        for (T rightValue : indexedRight.values()) {
            setDiff.rightOnly.add(rightValue);
        }
        return setDiff;
    }

    /**
     * Creates a string with {@code toString()} of each object with the given separator.
     *
     * <pre>
     * expect:
     * join(",", new Object[]{"a"}) == "a"
     * join(",", new Object[]{"a", "b", "c"}) == "a,b,c"
     * join(",", new Object[]{}) == ""
     * </pre>
     *
     * The {@code separator} must not be null and {@code objects} must not be null.
     *
     * @param separator The string by which to join each string representation
     * @param objects The objects to join the string representations of
     * @return The joined string
     */
    public static String join(String separator, Object[] objects) {
        return join(separator, objects == null ? null : Arrays.asList(objects));
    }

    /**
     * Creates a string with {@code toString()} of each object with the given separator.
     *
     * <pre>
     * expect:
     * join(",", ["a"]) == "a"
     * join(",", ["a", "b", "c"]) == "a,b,c"
     * join(",", []) == ""
     * </pre>
     *
     * The {@code separator} must not be null and {@code objects} must not be null.
     *
     * @param separator The string by which to join each string representation
     * @param objects The objects to join the string representations of
     * @return The joined string
     */
    public static String join(String separator, Iterable<?> objects) {
        if (separator == null) {
            throw new NullPointerException("The 'separator' cannot be null");
        }
        if (objects == null) {
            throw new NullPointerException("The 'objects' cannot be null");
        }
        StringBuilder string = new StringBuilder();
        Iterator<?> iterator = objects.iterator();
        if (iterator.hasNext()) {
            string.append(iterator.next().toString());
            while (iterator.hasNext()) {
                string.append(separator);
                string.append(iterator.next().toString());
            }
        }
        return string.toString();
    }

    /**
     * Partition given Collection into a Pair of Collections.
     *
     * <pre>Left</pre> Collection containing entries that satisfy the given predicate
     * <pre>Right</pre> Collection containing entries that do NOT satisfy the given predicate
     */
    public static <T> Pair<Collection<T>, Collection<T>> partition(Iterable<T> items, Spec<? super T> predicate) {
        Preconditions.checkNotNull(items, "Cannot partition null Collection");
        Preconditions.checkNotNull(predicate, "Cannot apply null Spec when partitioning");
        Collection<T> left = new LinkedList<T>();
        Collection<T> right = new LinkedList<T>();
        for (T item : items) {
            if (predicate.isSatisfiedBy(item)) {
                left.add(item);
            } else {
                right.add(item);
            }
        }
        return Pair.of(left, right);
    }

    public static class InjectionStep<T, I> {

        private final T target;

        private final I item;

        public InjectionStep(T target, I item) {
            this.target = target;
            this.item = item;
        }

        public T getTarget() {
            return target;
        }

        public I getItem() {
            return item;
        }
    }

    public static <T, I> T inject(T target, Iterable<? extends I> items, Action<InjectionStep<T, I>> action) {
        if (target == null) {
            throw new NullPointerException("The 'target' cannot be null");
        }
        if (items == null) {
            throw new NullPointerException("The 'items' cannot be null");
        }
        if (action == null) {
            throw new NullPointerException("The 'action' cannot be null");
        }
        for (I item : items) {
            action.execute(new InjectionStep<T, I>(target, item));
        }
        return target;
    }

    public static <K, V> ImmutableListMultimap<K, V> groupBy(Iterable<? extends V> iterable, Transformer<? extends K, V> grouper) {
        ImmutableListMultimap.Builder<K, V> builder = ImmutableListMultimap.builder();
        for (V element : iterable) {
            K key = grouper.transform(element);
            builder.put(key, element);
        }
        return builder.build();
    }

    public static <T> Iterable<? extends T> unpack(final Iterable<? extends Factory<? extends T>> factories) {
        return new Iterable<T>() {

            private final Iterator<? extends Factory<? extends T>> delegate = factories.iterator();

            public Iterator<T> iterator() {
                return new Iterator<T>() {

                    public boolean hasNext() {
                        return delegate.hasNext();
                    }

                    public T next() {
                        return delegate.next().create();
                    }

                    public void remove() {
                        throw new UnsupportedOperationException();
                    }
                };
            }
        };
    }

    @Nullable
    public static <T> List<T> nonEmptyOrNull(Iterable<T> iterable) {
        ImmutableList<T> list = ImmutableList.copyOf(iterable);
        return list.isEmpty() ? null : list;
    }

    public static <T> List<T> dedup(Iterable<T> source, final Equivalence<? super T> equivalence) {
        Iterable<Equivalence.Wrapper<T>> wrappers = Iterables.transform(source, new Function<T, Equivalence.Wrapper<T>>() {

            public Equivalence.Wrapper<T> apply(@Nullable T input) {
                return equivalence.wrap(input);
            }
        });
        Set<Equivalence.Wrapper<T>> deduped = ImmutableSet.copyOf(wrappers);
        return ImmutableList.copyOf(Iterables.transform(deduped, new Function<Equivalence.Wrapper<T>, T>() {

            public T apply(Equivalence.Wrapper<T> input) {
                return input.get();
            }
        }));
    }

    public static String asCommandLine(Iterable<String> arguments) {
        return Joiner.on(" ").join(collect(arguments, Transformers.asSafeCommandLineArgument()));
    }
}}'} /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/internal/findbugs/FindBugsSpecBuilder.java
Cannot solve method call args.add(CollectionUtils.join(",", omitVisitors)) UnsolvedSymbolException{context='Method 'join' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class CollectionUtils {

    /**
     * Returns null if the collection is empty otherwise expects a {@link #single(Iterable)} element to be found.
     */
    @Nullable
    public static <T> T findSingle(Collection<T> source) {
        return source.isEmpty() ? null : single(source);
    }

    /**
     * Returns the single element in the collection or throws.
     */
    public static <T> T single(Iterable<? extends T> source) {
        Iterator<? extends T> iterator = source.iterator();
        if (!iterator.hasNext()) {
            throw new NoSuchElementException("Expecting collection with single element, got none.");
        }
        T element = iterator.next();
        if (iterator.hasNext()) {
            throw new IllegalArgumentException("Expecting collection with single element, got multiple.");
        }
        return element;
    }

    public static <T> Collection<? extends T> checkedCast(Class<T> type, Collection<?> input) {
        for (Object o : input) {
            cast(type, o);
        }
        return Cast.uncheckedCast(input);
    }

    public static <T> T findFirst(Iterable<? extends T> source, Spec<? super T> filter) {
        for (T item : source) {
            if (filter.isSatisfiedBy(item)) {
                return item;
            }
        }
        return null;
    }

    public static <T> T findFirst(T[] source, Spec<? super T> filter) {
        for (T thing : source) {
            if (filter.isSatisfiedBy(thing)) {
                return thing;
            }
        }
        return null;
    }

    public static <T> T first(Iterable<? extends T> source) {
        return source.iterator().next();
    }

    public static <T> boolean any(Iterable<? extends T> source, Spec<? super T> filter) {
        return findFirst(source, filter) != null;
    }

    public static <T> boolean any(T[] source, Spec<? super T> filter) {
        return findFirst(source, filter) != null;
    }

    public static <T> Set<T> filter(Set<? extends T> set, Spec<? super T> filter) {
        return filter(set, new LinkedHashSet<T>(), filter);
    }

    public static <T> List<T> filter(List<? extends T> list, Spec<? super T> filter) {
        return filter(list, new LinkedList<T>(), filter);
    }

    public static <T> List<T> filter(T[] array, Spec<? super T> filter) {
        return filter(Arrays.asList(array), new LinkedList<T>(), filter);
    }

    /**
     * Returns a sorted copy of the provided collection of things. Uses the provided comparator to sort.
     */
    public static <T> List<T> sort(Iterable<? extends T> things, Comparator<? super T> comparator) {
        List<T> copy = toMutableList(things);
        Collections.sort(copy, comparator);
        return copy;
    }

    /**
     * Returns a sorted copy of the provided collection of things. Uses the natural ordering of the things.
     */
    public static <T extends Comparable> List<T> sort(Iterable<T> things) {
        List<T> copy = toMutableList(things);
        Collections.sort(copy);
        return copy;
    }

    public static <T, C extends Collection<T>> C filter(Iterable<? extends T> source, C destination, Spec<? super T> filter) {
        for (T item : source) {
            if (filter.isSatisfiedBy(item)) {
                destination.add(item);
            }
        }
        return destination;
    }

    public static <K, V> Map<K, V> filter(Map<K, V> map, Spec<Map.Entry<K, V>> filter) {
        return filter(map, new HashMap<K, V>(), filter);
    }

    public static <K, V> Map<K, V> filter(Map<K, V> map, Map<K, V> destination, Spec<Map.Entry<K, V>> filter) {
        for (Map.Entry<K, V> entry : map.entrySet()) {
            if (filter.isSatisfiedBy(entry)) {
                destination.put(entry.getKey(), entry.getValue());
            }
        }
        return destination;
    }

    public static <R, I> R[] collectArray(I[] list, Class<R> newType, Transformer<? extends R, ? super I> transformer) {
        @SuppressWarnings("unchecked") R[] destination = (R[]) Array.newInstance(newType, list.length);
        return collectArray(list, destination, transformer);
    }

    public static <R, I> R[] collectArray(I[] list, R[] destination, Transformer<? extends R, ? super I> transformer) {
        assert list.length <= destination.length;
        for (int i = 0; i < list.length; ++i) {
            destination[i] = transformer.transform(list[i]);
        }
        return destination;
    }

    public static <R, I> List<R> collect(List<? extends I> list, Transformer<? extends R, ? super I> transformer) {
        return collect(list, new ArrayList<R>(list.size()), transformer);
    }

    public static <R, I> List<R> collect(I[] list, Transformer<? extends R, ? super I> transformer) {
        return collect(Arrays.asList(list), transformer);
    }

    public static <R, I> Set<R> collect(Set<? extends I> set, Transformer<? extends R, ? super I> transformer) {
        return collect(set, new HashSet<R>(), transformer);
    }

    public static <R, I> List<R> collect(Iterable<? extends I> source, Transformer<? extends R, ? super I> transformer) {
        return collect(source, new LinkedList<R>(), transformer);
    }

    public static <R, I, C extends Collection<R>> C collect(Iterable<? extends I> source, C destination, Transformer<? extends R, ? super I> transformer) {
        for (I item : source) {
            destination.add(transformer.transform(item));
        }
        return destination;
    }

    public static List<String> toStringList(Iterable<?> iterable) {
        return collect(iterable, new LinkedList<String>(), Transformers.asString());
    }

    /**
     * Recursively unpacks all the given things into a flat list.
     *
     * Nulls are not removed, they are left intact.
     *
     * @param things The things to flatten
     * @return A flattened list of the given things
     */
    public static List<?> flattenCollections(Object... things) {
        return flattenCollections(Object.class, things);
    }

    /**
     * Recursively unpacks all the given things into a flat list, ensuring they are of a certain type.
     *
     * Nulls are not removed, they are left intact.
     *
     * If a non null object cannot be cast to the target type, a ClassCastException will be thrown.
     *
     * @param things The things to flatten
     * @param <T> The target type in the flattened list
     * @return A flattened list of the given things
     */
    public static <T> List<T> flattenCollections(Class<T> type, Object... things) {
        if (things == null) {
            return Collections.singletonList(null);
        } else if (things.length == 0) {
            return Collections.emptyList();
        } else if (things.length == 1) {
            Object thing = things[0];
            if (thing == null) {
                return Collections.singletonList(null);
            }
            if (thing.getClass().isArray()) {
                Object[] thingArray = (Object[]) thing;
                List<T> list = new ArrayList<T>(thingArray.length);
                for (Object thingThing : thingArray) {
                    list.addAll(flattenCollections(type, thingThing));
                }
                return list;
            }
            if (thing instanceof Collection) {
                Collection<?> collection = (Collection<?>) thing;
                List<T> list = new ArrayList<T>();
                for (Object element : collection) {
                    list.addAll(flattenCollections(type, element));
                }
                return list;
            }
            return Collections.singletonList(cast(type, thing));
        } else {
            List<T> list = new ArrayList<T>();
            for (Object thing : things) {
                list.addAll(flattenCollections(type, thing));
            }
            return list;
        }
    }

    public static <T> List<T> toList(Iterable<? extends T> things) {
        if (things instanceof List) {
            @SuppressWarnings("unchecked") List<T> castThings = (List<T>) things;
            return castThings;
        }
        return toMutableList(things);
    }

    public static <T> List<T> toList(Enumeration<? extends T> things) {
        AbstractList<T> list = new ArrayList<T>();
        while (things.hasMoreElements()) {
            list.add(things.nextElement());
        }
        return list;
    }

    private static <T> List<T> toMutableList(Iterable<? extends T> things) {
        if (things == null) {
            return new ArrayList<T>(0);
        }
        List<T> list = new ArrayList<T>();
        for (T thing : things) {
            list.add(thing);
        }
        return list;
    }

    public static <T> List<T> intersection(Collection<? extends Collection<T>> availableValuesByDescriptor) {
        List<T> result = new ArrayList<T>();
        Iterator<? extends Collection<T>> iterator = availableValuesByDescriptor.iterator();
        if (iterator.hasNext()) {
            Collection<T> firstSet = iterator.next();
            result.addAll(firstSet);
            while (iterator.hasNext()) {
                Collection<T> next = iterator.next();
                result.retainAll(next);
            }
        }
        return result;
    }

    public static <T> List<T> toList(T[] things) {
        if (things == null || things.length == 0) {
            return new ArrayList<T>(0);
        }
        List<T> list = new ArrayList<T>(things.length);
        Collections.addAll(list, things);
        return list;
    }

    public static <T> Set<T> toSet(Iterable<? extends T> things) {
        if (things == null) {
            return new HashSet<T>(0);
        }
        if (things instanceof Set) {
            @SuppressWarnings("unchecked") Set<T> castThings = (Set<T>) things;
            return castThings;
        }
        Set<T> set = new LinkedHashSet<T>();
        for (T thing : things) {
            set.add(thing);
        }
        return set;
    }

    public static <E> List<E> compact(List<E> list) {
        boolean foundAtLeastOneNull = false;
        List<E> compacted = null;
        int i = 0;
        for (E element : list) {
            if (element == null) {
                if (!foundAtLeastOneNull) {
                    compacted = new ArrayList<E>(list.size());
                    if (i > 0) {
                        compacted.addAll(list.subList(0, i));
                    }
                }
                foundAtLeastOneNull = true;
            } else if (foundAtLeastOneNull) {
                compacted.add(element);
            }
            ++i;
        }
        return foundAtLeastOneNull ? compacted : list;
    }

    public static <C extends Collection<String>> C stringize(Iterable<?> source, C destination) {
        return collect(source, destination, Transformers.asString());
    }

    public static List<String> stringize(Collection<?> source) {
        return stringize(source, new ArrayList<String>(source.size()));
    }

    public static <E> boolean replace(List<E> list, Spec<? super E> filter, Transformer<? extends E, ? super E> transformer) {
        boolean replaced = false;
        int i = 0;
        for (E it : list) {
            if (filter.isSatisfiedBy(it)) {
                list.set(i, transformer.transform(it));
                replaced = true;
            }
            ++i;
        }
        return replaced;
    }

    public static <K, V> void collectMap(Map<K, V> destination, Iterable<? extends V> items, Transformer<? extends K, ? super V> keyGenerator) {
        for (V item : items) {
            destination.put(keyGenerator.transform(item), item);
        }
    }

    /**
     * Given a set of values, derive a set of keys and return a map
     */
    public static <K, V> Map<K, V> collectMap(Iterable<? extends V> items, Transformer<? extends K, ? super V> keyGenerator) {
        Map<K, V> map = new LinkedHashMap<K, V>();
        collectMap(map, items, keyGenerator);
        return map;
    }

    public static <K, V> void collectMapValues(Map<K, V> destination, Iterable<? extends K> keys, Transformer<? extends V, ? super K> keyGenerator) {
        for (K item : keys) {
            destination.put(item, keyGenerator.transform(item));
        }
    }

    /**
     * Given a set of keys, derive a set of values and return a map
     */
    public static <K, V> Map<K, V> collectMapValues(Iterable<? extends K> keys, Transformer<? extends V, ? super K> keyGenerator) {
        Map<K, V> map = new LinkedHashMap<K, V>();
        collectMapValues(map, keys, keyGenerator);
        return map;
    }

    public static <T> boolean every(Iterable<? extends T> things, Spec<? super T> predicate) {
        for (T thing : things) {
            if (!predicate.isSatisfiedBy(thing)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Utility for adding an iterable to a collection.
     *
     * @param t1 The collection to add to
     * @param t2 The iterable to add each item of to the collection
     * @param <T> The element type of t1
     * @return t1
     */
    public static <T> Collection<T> addAll(Collection<T> t1, Iterable<? extends T> t2) {
        for (T t : t2) {
            t1.add(t);
        }
        return t1;
    }

    /**
     * Utility for adding an array to a collection.
     *
     * @param t1 The collection to add to
     * @param t2 The iterable to add each item of to the collection
     * @param <T> The element type of t1
     * @return t1
     */
    public static <T> Collection<T> addAll(Collection<T> t1, T... t2) {
        Collections.addAll(t1, t2);
        return t1;
    }

    /**
     * The result of diffing two sets.
     *
     * @param <T> The type of element the sets contain
     * @see CollectionUtils#diffSetsBy(java.util.Set, java.util.Set, org.gradle.api.Transformer)
     */
    public static class SetDiff<T> {

        public Set<T> leftOnly = new HashSet<T>();

        public Set<Pair<T, T>> common = new HashSet<Pair<T, T>>();

        public Set<T> rightOnly = new HashSet<T>();
    }

    /**
     * Provides a “diff report” of how the two sets are similar and how they are different, comparing the entries by some aspect.
     *
     * The transformer is used to generate the value to use to compare the entries by. That is, the entries are not compared by equals by an attribute or characteristic.
     *
     * The transformer is expected to produce a unique value for each entry in a single set. Behaviour is undefined if this condition is not met.
     *
     * @param left The set on the “left” side of the comparison.
     * @param right The set on the “right” side of the comparison.
     * @param compareBy Provides the value to compare entries from either side by
     * @param <T> The type of the entry objects
     * @return A representation of the difference
     */
    public static <T> SetDiff<T> diffSetsBy(Set<? extends T> left, Set<? extends T> right, Transformer<?, T> compareBy) {
        if (left == null) {
            throw new NullPointerException("'left' set is null");
        }
        if (right == null) {
            throw new NullPointerException("'right' set is null");
        }
        SetDiff<T> setDiff = new SetDiff<T>();
        Map<Object, T> indexedLeft = collectMap(left, compareBy);
        Map<Object, T> indexedRight = collectMap(right, compareBy);
        for (Map.Entry<Object, T> leftEntry : indexedLeft.entrySet()) {
            T rightValue = indexedRight.remove(leftEntry.getKey());
            if (rightValue == null) {
                setDiff.leftOnly.add(leftEntry.getValue());
            } else {
                Pair<T, T> pair = Pair.of(leftEntry.getValue(), rightValue);
                setDiff.common.add(pair);
            }
        }
        for (T rightValue : indexedRight.values()) {
            setDiff.rightOnly.add(rightValue);
        }
        return setDiff;
    }

    /**
     * Creates a string with {@code toString()} of each object with the given separator.
     *
     * <pre>
     * expect:
     * join(",", new Object[]{"a"}) == "a"
     * join(",", new Object[]{"a", "b", "c"}) == "a,b,c"
     * join(",", new Object[]{}) == ""
     * </pre>
     *
     * The {@code separator} must not be null and {@code objects} must not be null.
     *
     * @param separator The string by which to join each string representation
     * @param objects The objects to join the string representations of
     * @return The joined string
     */
    public static String join(String separator, Object[] objects) {
        return join(separator, objects == null ? null : Arrays.asList(objects));
    }

    /**
     * Creates a string with {@code toString()} of each object with the given separator.
     *
     * <pre>
     * expect:
     * join(",", ["a"]) == "a"
     * join(",", ["a", "b", "c"]) == "a,b,c"
     * join(",", []) == ""
     * </pre>
     *
     * The {@code separator} must not be null and {@code objects} must not be null.
     *
     * @param separator The string by which to join each string representation
     * @param objects The objects to join the string representations of
     * @return The joined string
     */
    public static String join(String separator, Iterable<?> objects) {
        if (separator == null) {
            throw new NullPointerException("The 'separator' cannot be null");
        }
        if (objects == null) {
            throw new NullPointerException("The 'objects' cannot be null");
        }
        StringBuilder string = new StringBuilder();
        Iterator<?> iterator = objects.iterator();
        if (iterator.hasNext()) {
            string.append(iterator.next().toString());
            while (iterator.hasNext()) {
                string.append(separator);
                string.append(iterator.next().toString());
            }
        }
        return string.toString();
    }

    /**
     * Partition given Collection into a Pair of Collections.
     *
     * <pre>Left</pre> Collection containing entries that satisfy the given predicate
     * <pre>Right</pre> Collection containing entries that do NOT satisfy the given predicate
     */
    public static <T> Pair<Collection<T>, Collection<T>> partition(Iterable<T> items, Spec<? super T> predicate) {
        Preconditions.checkNotNull(items, "Cannot partition null Collection");
        Preconditions.checkNotNull(predicate, "Cannot apply null Spec when partitioning");
        Collection<T> left = new LinkedList<T>();
        Collection<T> right = new LinkedList<T>();
        for (T item : items) {
            if (predicate.isSatisfiedBy(item)) {
                left.add(item);
            } else {
                right.add(item);
            }
        }
        return Pair.of(left, right);
    }

    public static class InjectionStep<T, I> {

        private final T target;

        private final I item;

        public InjectionStep(T target, I item) {
            this.target = target;
            this.item = item;
        }

        public T getTarget() {
            return target;
        }

        public I getItem() {
            return item;
        }
    }

    public static <T, I> T inject(T target, Iterable<? extends I> items, Action<InjectionStep<T, I>> action) {
        if (target == null) {
            throw new NullPointerException("The 'target' cannot be null");
        }
        if (items == null) {
            throw new NullPointerException("The 'items' cannot be null");
        }
        if (action == null) {
            throw new NullPointerException("The 'action' cannot be null");
        }
        for (I item : items) {
            action.execute(new InjectionStep<T, I>(target, item));
        }
        return target;
    }

    public static <K, V> ImmutableListMultimap<K, V> groupBy(Iterable<? extends V> iterable, Transformer<? extends K, V> grouper) {
        ImmutableListMultimap.Builder<K, V> builder = ImmutableListMultimap.builder();
        for (V element : iterable) {
            K key = grouper.transform(element);
            builder.put(key, element);
        }
        return builder.build();
    }

    public static <T> Iterable<? extends T> unpack(final Iterable<? extends Factory<? extends T>> factories) {
        return new Iterable<T>() {

            private final Iterator<? extends Factory<? extends T>> delegate = factories.iterator();

            public Iterator<T> iterator() {
                return new Iterator<T>() {

                    public boolean hasNext() {
                        return delegate.hasNext();
                    }

                    public T next() {
                        return delegate.next().create();
                    }

                    public void remove() {
                        throw new UnsupportedOperationException();
                    }
                };
            }
        };
    }

    @Nullable
    public static <T> List<T> nonEmptyOrNull(Iterable<T> iterable) {
        ImmutableList<T> list = ImmutableList.copyOf(iterable);
        return list.isEmpty() ? null : list;
    }

    public static <T> List<T> dedup(Iterable<T> source, final Equivalence<? super T> equivalence) {
        Iterable<Equivalence.Wrapper<T>> wrappers = Iterables.transform(source, new Function<T, Equivalence.Wrapper<T>>() {

            public Equivalence.Wrapper<T> apply(@Nullable T input) {
                return equivalence.wrap(input);
            }
        });
        Set<Equivalence.Wrapper<T>> deduped = ImmutableSet.copyOf(wrappers);
        return ImmutableList.copyOf(Iterables.transform(deduped, new Function<Equivalence.Wrapper<T>, T>() {

            public T apply(Equivalence.Wrapper<T> input) {
                return input.get();
            }
        }));
    }

    public static String asCommandLine(Iterable<String> arguments) {
        return Joiner.on(" ").join(collect(arguments, Transformers.asSafeCommandLineArgument()));
    }
}}'} /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/internal/findbugs/FindBugsSpecBuilder.java
Cannot solve field access JavaVersion.VERSION_1_7
Cannot solve method call this.ruleSetFiles.add(project.files(ruleSetFiles)) java.lang.RuntimeException: Object[] Object /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/PmdExtension.java
Cannot solve method call setConfig(project.getResources().getText().fromFile(configFile)) java.lang.RuntimeException: Method 'fromFile' cannot be resolved in context project.getResources().getText().fromFile(configFile) (line: 64) MethodCallExprContext{wrapped=project.getResources().getText().fromFile(configFile)}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/CheckstyleExtension.java
Cannot solve field access PathSensitivity.RELATIVE
Cannot resolve field access null
Cannot solve field access PathSensitivity.RELATIVE
Cannot solve field access PathSensitivity.NONE
Cannot solve method call setIncludeFilterConfig(project.getResources().getText().fromFile(filter)) java.lang.RuntimeException: Method 'fromFile' cannot be resolved in context project.getResources().getText().fromFile(filter) (line: 153) MethodCallExprContext{wrapped=project.getResources().getText().fromFile(filter)}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/FindBugsExtension.java
Cannot solve method call setExcludeFilterConfig(project.getResources().getText().fromFile(filter)) java.lang.RuntimeException: Method 'fromFile' cannot be resolved in context project.getResources().getText().fromFile(filter) (line: 186) MethodCallExprContext{wrapped=project.getResources().getText().fromFile(filter)}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/FindBugsExtension.java
Cannot solve method call setExcludeBugsFilterConfig(project.getResources().getText().fromFile(filter)) java.lang.RuntimeException: Method 'fromFile' cannot be resolved in context project.getResources().getText().fromFile(filter) (line: 219) MethodCallExprContext{wrapped=project.getResources().getText().fromFile(filter)}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/FindBugsExtension.java
Cannot solve method call project.getResources().getText().fromFile(project.getRootProject().file("config/codenarc/codenarc.xml")) java.lang.RuntimeException: Method 'file' cannot be resolved in context project.getRootProject().file("config/codenarc/codenarc.xml") (line: 62) MethodCallExprContext{wrapped=project.getRootProject().file("config/codenarc/codenarc.xml")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/CodeNarcPlugin.java
Cannot solve method call extension.setConfig(project.getResources().getText().fromFile(project.getRootProject().file("config/codenarc/codenarc.xml"))) java.lang.RuntimeException: Error calculating the type of parameter project.getRootProject().file("config/codenarc/codenarc.xml") of method call project.getResources().getText().fromFile(project.getRootProject().file("config/codenarc/codenarc.xml")) /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/CodeNarcPlugin.java
Cannot solve method call dependencies.add(project.getDependencies().create("org.codenarc:CodeNarc:" + extension.getToolVersion())) java.lang.RuntimeException: Method 'create' cannot be resolved in context project.getDependencies().create("org.codenarc:CodeNarc:" + extension.getToolVersion()) (line: 82) MethodCallExprContext{wrapped=project.getDependencies().create("org.codenarc:CodeNarc:" + extension.getToolVersion())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/CodeNarcPlugin.java
Cannot solve method call taskMapping.map("codenarcClasspath", Callables.returning(configuration)) UnsolvedSymbolException{context='Method 'returning' with parameterTypes [ReferenceType{org.gradle.api.artifacts.Configuration, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.util.concurrent.Callables}'} /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/CodeNarcPlugin.java
Cannot solve method call taskMapping.map("config", new Callable<TextResource>() {

    @Override
    public TextResource call() {
        return extension.getConfig();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/CodeNarcPlugin.java
Cannot solve method call taskMapping.map("maxPriority1Violations", new Callable<Integer>() {

    @Override
    public Integer call() {
        return extension.getMaxPriority1Violations();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/CodeNarcPlugin.java
Cannot solve method call taskMapping.map("maxPriority2Violations", new Callable<Integer>() {

    @Override
    public Integer call() {
        return extension.getMaxPriority2Violations();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/CodeNarcPlugin.java
Cannot solve method call taskMapping.map("maxPriority3Violations", new Callable<Integer>() {

    @Override
    public Integer call() {
        return extension.getMaxPriority3Violations();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/CodeNarcPlugin.java
Cannot solve method call taskMapping.map("ignoreFailures", new Callable<Boolean>() {

    @Override
    public Boolean call() {
        return extension.isIgnoreFailures();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/CodeNarcPlugin.java
Cannot solve method call reportMapping.map("enabled", new Callable<Boolean>() {

    @Override
    public Boolean call() {
        return report.getName().equals(extension.getReportFormat());
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/CodeNarcPlugin.java
Cannot solve method call reportMapping.map("destination", new Callable<File>() {

    @Override
    public File call() {
        String fileSuffix = report.getName().equals("text") ? "txt" : report.getName();
        return new File(extension.getReportsDir(), baseName + "." + fileSuffix);
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/CodeNarcPlugin.java
Cannot solve method call task.setSource(dynamicObject.getProperty("allGroovy")) java.lang.RuntimeException: Method 'getProperty' cannot be resolved in context dynamicObject.getProperty("allGroovy") (line: 148) MethodCallExprContext{wrapped=dynamicObject.getProperty("allGroovy")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/CodeNarcPlugin.java
Cannot solve field access PathSensitivity.RELATIVE
Cannot solve method call setConfig(getProject().getResources().getText().fromFile(configFile)) java.lang.RuntimeException: Method 'fromFile' cannot be resolved in context getProject().getResources().getText().fromFile(configFile) (line: 89) MethodCallExprContext{wrapped=getProject().getResources().getText().fromFile(configFile)}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/CodeNarc.java
Cannot solve method call extension.setRuleSetFiles(project.files()) java.lang.IndexOutOfBoundsException: Index: 0, Size: 0 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/PmdPlugin.java
Method 'conventionMappingOf' cannot be resolved in context conventionMappingOf(extension) (line: 70) MethodCallExprContext{wrapped=conventionMappingOf(extension)}. Parameter types: [ReferenceType{org.gradle.api.plugins.quality.PmdExtension, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve field access TargetJdk.VERSION_1_4
Cannot solve method call dependencies.add(project.getDependencies().create(dependency)) com.github.javaparser.symbolsolver.logic.ConfilictingGenericTypesException: No matching between ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual) /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/PmdPlugin.java
Cannot solve method call taskMapping.map("pmdClasspath", Callables.returning(configuration)) UnsolvedSymbolException{context='Method 'returning' with parameterTypes [ReferenceType{org.gradle.api.artifacts.Configuration, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.util.concurrent.Callables}'} /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/PmdPlugin.java
Cannot solve method call taskMapping.map("ruleSets", new Callable<List<String>>() {

    @Override
    public List<String> call() {
        return extension.getRuleSets();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/PmdPlugin.java
Cannot solve method call taskMapping.map("ruleSetConfig", new Callable<TextResource>() {

    @Override
    public TextResource call() {
        return extension.getRuleSetConfig();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/PmdPlugin.java
Cannot solve method call taskMapping.map("ruleSetFiles", new Callable<FileCollection>() {

    @Override
    public FileCollection call() {
        return extension.getRuleSetFiles();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/PmdPlugin.java
Cannot solve method call taskMapping.map("ignoreFailures", new Callable<Boolean>() {

    @Override
    public Boolean call() {
        return extension.isIgnoreFailures();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/PmdPlugin.java
Cannot solve method call taskMapping.map("rulePriority", new Callable<Integer>() {

    @Override
    public Integer call() {
        return extension.getRulePriority();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/PmdPlugin.java
Cannot solve method call taskMapping.map("consoleOutput", new Callable<Boolean>() {

    @Override
    public Boolean call() {
        return extension.isConsoleOutput();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/PmdPlugin.java
Cannot solve method call taskMapping.map("targetJdk", new Callable<TargetJdk>() {

    @Override
    public TargetJdk call() {
        return extension.getTargetJdk();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/PmdPlugin.java
Cannot solve method call reportMapping.map("enabled", Callables.returning(true)) UnsolvedSymbolException{context='Method 'returning' with parameterTypes [PrimitiveTypeUsage{name='boolean'}]', name='ReflectionClassDeclaration{clazz=com.google.common.util.concurrent.Callables}'} /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/PmdPlugin.java
Cannot solve method call reportMapping.map("destination", new Callable<File>() {

    @Override
    public File call() {
        return new File(extension.getReportsDir(), baseName + "." + report.getName());
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/PmdPlugin.java
Cannot solve method call toolVersion.compareTo(VersionNumber.parse("5.2.0")) UnsolvedSymbolException{context='Method 'parse' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * Represents, parses, and compares version numbers. Supports a couple of different schemes: <ul> <li>MAJOR.MINOR.MICRO-QUALIFIER (the default).</li> <li>MAJOR.MINOR.MICRO.PATCH-QUALIFIER.</li> </ul>
 *
 * <p>The {@link #parse} method handles missing parts and allows "." to be used instead of "-", and "_" to be used instead of "." for the patch number.
 *
 * <p>This class considers missing parts to be 0, so that "1.0" == "1.0.0" == "1.0.0_0".</p>
 *
 * <p>Note that this class considers "1.2.3-something" less than "1.2.3". Qualifiers are compared lexicographically ("1.2.3-alpha" < "1.2.3-beta") and case-insensitive ("1.2.3-alpha" <
 * "1.2.3.RELEASE").
 *
 * <p>To check if a version number is at least "1.2.3", disregarding a potential qualifier like "beta", use {@code version.getBaseVersion().compareTo(VersionNumber.parse("1.2.3")) >= 0}.
 */
public class VersionNumber implements Comparable<VersionNumber> {

    private static final DefaultScheme DEFAULT_SCHEME = new DefaultScheme();

    private static final SchemeWithPatchVersion PATCH_SCHEME = new SchemeWithPatchVersion();

    public static final VersionNumber UNKNOWN = version(0);

    private final int major;

    private final int minor;

    private final int micro;

    private final int patch;

    private final String qualifier;

    private final AbstractScheme scheme;

    public VersionNumber(int major, int minor, int micro, @Nullable String qualifier) {
        this(major, minor, micro, 0, qualifier, DEFAULT_SCHEME);
    }

    public VersionNumber(int major, int minor, int micro, int patch, @Nullable String qualifier) {
        this(major, minor, micro, patch, qualifier, PATCH_SCHEME);
    }

    private VersionNumber(int major, int minor, int micro, int patch, @Nullable String qualifier, AbstractScheme scheme) {
        this.major = major;
        this.minor = minor;
        this.micro = micro;
        this.patch = patch;
        this.qualifier = qualifier;
        this.scheme = scheme;
    }

    public int getMajor() {
        return major;
    }

    public int getMinor() {
        return minor;
    }

    public int getMicro() {
        return micro;
    }

    public int getPatch() {
        return patch;
    }

    public String getQualifier() {
        return qualifier;
    }

    public VersionNumber getBaseVersion() {
        return new VersionNumber(major, minor, micro, patch, null, scheme);
    }

    public int compareTo(VersionNumber other) {
        if (major != other.major) {
            return major - other.major;
        }
        if (minor != other.minor) {
            return minor - other.minor;
        }
        if (micro != other.micro) {
            return micro - other.micro;
        }
        if (patch != other.patch) {
            return patch - other.patch;
        }
        return Ordering.natural().nullsLast().compare(toLowerCase(qualifier), toLowerCase(other.qualifier));
    }

    public boolean equals(Object other) {
        return other instanceof VersionNumber && compareTo((VersionNumber) other) == 0;
    }

    public int hashCode() {
        int result = major;
        result = 31 * result + minor;
        result = 31 * result + micro;
        result = 31 * result + patch;
        result = 31 * result + Objects.hashCode(qualifier);
        return result;
    }

    public String toString() {
        return scheme.format(this);
    }

    public static VersionNumber version(int major) {
        return new VersionNumber(major, 0, 0, 0, null, DEFAULT_SCHEME);
    }

    /**
     * Returns the default MAJOR.MINOR.MICRO-QUALIFIER scheme.
     */
    public static Scheme scheme() {
        return DEFAULT_SCHEME;
    }

    /**
     * Returns the MAJOR.MINOR.MICRO.PATCH-QUALIFIER scheme.
     */
    public static Scheme withPatchNumber() {
        return PATCH_SCHEME;
    }

    public static VersionNumber parse(String versionString) {
        return DEFAULT_SCHEME.parse(versionString);
    }

    private String toLowerCase(@Nullable String string) {
        return string == null ? null : string.toLowerCase();
    }

    public interface Scheme {

        public VersionNumber parse(String value);

        public String format(VersionNumber versionNumber);
    }

    private abstract static class AbstractScheme implements Scheme {

        final int depth;

        protected AbstractScheme(int depth) {
            this.depth = depth;
        }

        public VersionNumber parse(String versionString) {
            if (versionString == null || versionString.length() == 0) {
                return UNKNOWN;
            }
            Scanner scanner = new Scanner(versionString);
            int major = 0;
            int minor = 0;
            int micro = 0;
            int patch = 0;
            if (!scanner.hasDigit()) {
                return UNKNOWN;
            }
            major = scanner.scanDigit();
            if (scanner.isSeparatorAndDigit('.')) {
                scanner.skipSeparator();
                minor = scanner.scanDigit();
                if (scanner.isSeparatorAndDigit('.')) {
                    scanner.skipSeparator();
                    micro = scanner.scanDigit();
                    if (depth > 3 && scanner.isSeparatorAndDigit('.', '_')) {
                        scanner.skipSeparator();
                        patch = scanner.scanDigit();
                    }
                }
            }
            if (scanner.isEnd()) {
                return new VersionNumber(major, minor, micro, patch, null, this);
            }
            if (scanner.isQualifier()) {
                scanner.skipSeparator();
                return new VersionNumber(major, minor, micro, patch, scanner.remainder(), this);
            }
            return UNKNOWN;
        }

        private static class Scanner {

            int pos;

            final String str;

            private Scanner(String string) {
                this.str = string;
            }

            boolean hasDigit() {
                return pos < str.length() && Character.isDigit(str.charAt(pos));
            }

            boolean isSeparatorAndDigit(char... separators) {
                return pos < str.length() - 1 && oneOf(separators) && Character.isDigit(str.charAt(pos + 1));
            }

            private boolean oneOf(char... separators) {
                char current = str.charAt(pos);
                for (int i = 0; i < separators.length; i++) {
                    char separator = separators[i];
                    if (current == separator) {
                        return true;
                    }
                }
                return false;
            }

            boolean isQualifier() {
                return pos < str.length() - 1 && oneOf('.', '-');
            }

            int scanDigit() {
                int start = pos;
                while (hasDigit()) {
                    pos++;
                }
                return Integer.parseInt(str.substring(start, pos));
            }

            public boolean isEnd() {
                return pos == str.length();
            }

            private boolean skip(char ch) {
                if (pos < str.length() && str.charAt(pos) == ch) {
                    pos++;
                    return true;
                }
                return false;
            }

            public void skipSeparator() {
                pos++;
            }

            public String remainder() {
                return pos == str.length() ? null : str.substring(pos);
            }
        }
    }

    private static class DefaultScheme extends AbstractScheme {

        private static final String VERSION_TEMPLATE = "%d.%d.%d%s";

        public DefaultScheme() {
            super(3);
        }

        public String format(VersionNumber versionNumber) {
            return String.format(VERSION_TEMPLATE, versionNumber.major, versionNumber.minor, versionNumber.micro, versionNumber.qualifier == null ? "" : "-" + versionNumber.qualifier);
        }
    }

    private static class SchemeWithPatchVersion extends AbstractScheme {

        private static final String VERSION_TEMPLATE = "%d.%d.%d.%d%s";

        private SchemeWithPatchVersion() {
            super(4);
        }

        public String format(VersionNumber versionNumber) {
            return String.format(VERSION_TEMPLATE, versionNumber.major, versionNumber.minor, versionNumber.micro, versionNumber.patch, versionNumber.qualifier == null ? "" : "-" + versionNumber.qualifier);
        }
    }
}}'} /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/PmdPlugin.java
Cannot solve method call taskMapping.map("classpath", new Callable<FileCollection>() {

    @Override
    public FileCollection call() throws Exception {
        return sourceSet.getOutput().plus(sourceSet.getCompileClasspath());
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/PmdPlugin.java
Cannot solve method call setConfig(getProject().getResources().getText().fromFile(configFile)) java.lang.RuntimeException: Method 'fromFile' cannot be resolved in context getProject().getResources().getText().fromFile(configFile) (line: 76) MethodCallExprContext{wrapped=getProject().getResources().getText().fromFile(configFile)}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/Checkstyle.java
Cannot resolve field access null
Cannot solve field access PathSensitivity.RELATIVE
Cannot solve method call setIncludeFilterConfig(getProject().getResources().getText().fromFile(filter)) java.lang.RuntimeException: Method 'fromFile' cannot be resolved in context getProject().getResources().getText().fromFile(filter) (line: 184) MethodCallExprContext{wrapped=getProject().getResources().getText().fromFile(filter)}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/FindBugs.java
Cannot solve method call setExcludeFilterConfig(getProject().getResources().getText().fromFile(filter)) java.lang.RuntimeException: Method 'fromFile' cannot be resolved in context getProject().getResources().getText().fromFile(filter) (line: 200) MethodCallExprContext{wrapped=getProject().getResources().getText().fromFile(filter)}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/FindBugs.java
Cannot solve method call setExcludeBugsFilterConfig(getProject().getResources().getText().fromFile(filter)) java.lang.RuntimeException: Method 'fromFile' cannot be resolved in context getProject().getResources().getText().fromFile(filter) (line: 216) MethodCallExprContext{wrapped=getProject().getResources().getText().fromFile(filter)}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/FindBugs.java
Cannot solve method call new FindBugsClasspathValidator(JavaVersion.current()).validateClasspath(Iterables.transform(getFindbugsClasspath().getFiles(), new Function<File, String>() {

    @Override
    public String apply(File input) {
        return input.getName();
    }
})) UnsolvedSymbolException{context='Method 'transform' with parameterTypes [ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{Function, typeParametersMap=TypeParametersMap{nameToValue={empty.Equivalence.Wrapper<Method>=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, empty.Method=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/FindBugs.java
Cannot solve field access LogLevel.DEBUG
Cannot solve field access LogLevel.DEBUG
Cannot solve method call new FindBugsSpecBuilder(getClasses()).withPluginsList(getPluginClasspath()).withSources(getSource()).withClasspath(getClasspath()).withDebugging(getLogger().isDebugEnabled()) java.lang.RuntimeException: Method 'isDebugEnabled' cannot be resolved in context getLogger().isDebugEnabled() (line: 244) MethodCallExprContext{wrapped=getLogger().isDebugEnabled()}. Parameter types: [] /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/FindBugs.java
Error calculating the type of parameter getLogger().isDebugEnabled() of method call new FindBugsSpecBuilder(getClasses()).withPluginsList(getPluginClasspath()).withSources(getSource()).withClasspath(getClasspath()).withDebugging(getLogger().isDebugEnabled())
Error calculating the type of parameter getLogger().isDebugEnabled() of method call new FindBugsSpecBuilder(getClasses()).withPluginsList(getPluginClasspath()).withSources(getSource()).withClasspath(getClasspath()).withDebugging(getLogger().isDebugEnabled())
Error calculating the type of parameter getLogger().isDebugEnabled() of method call new FindBugsSpecBuilder(getClasses()).withPluginsList(getPluginClasspath()).withSources(getSource()).withClasspath(getClasspath()).withDebugging(getLogger().isDebugEnabled())
Error calculating the type of parameter getLogger().isDebugEnabled() of method call new FindBugsSpecBuilder(getClasses()).withPluginsList(getPluginClasspath()).withSources(getSource()).withClasspath(getClasspath()).withDebugging(getLogger().isDebugEnabled())
Error calculating the type of parameter getLogger().isDebugEnabled() of method call new FindBugsSpecBuilder(getClasses()).withPluginsList(getPluginClasspath()).withSources(getSource()).withClasspath(getClasspath()).withDebugging(getLogger().isDebugEnabled())
Error calculating the type of parameter getLogger().isDebugEnabled() of method call new FindBugsSpecBuilder(getClasses()).withPluginsList(getPluginClasspath()).withSources(getSource()).withClasspath(getClasspath()).withDebugging(getLogger().isDebugEnabled())
Error calculating the type of parameter getLogger().isDebugEnabled() of method call new FindBugsSpecBuilder(getClasses()).withPluginsList(getPluginClasspath()).withSources(getSource()).withClasspath(getClasspath()).withDebugging(getLogger().isDebugEnabled())
Error calculating the type of parameter getLogger().isDebugEnabled() of method call new FindBugsSpecBuilder(getClasses()).withPluginsList(getPluginClasspath()).withSources(getSource()).withClasspath(getClasspath()).withDebugging(getLogger().isDebugEnabled())
Error calculating the type of parameter getLogger().isDebugEnabled() of method call new FindBugsSpecBuilder(getClasses()).withPluginsList(getPluginClasspath()).withSources(getSource()).withClasspath(getClasspath()).withDebugging(getLogger().isDebugEnabled())
Error calculating the type of parameter getLogger().isDebugEnabled() of method call new FindBugsSpecBuilder(getClasses()).withPluginsList(getPluginClasspath()).withSources(getSource()).withClasspath(getClasspath()).withDebugging(getLogger().isDebugEnabled())
Cannot solve field access PathSensitivity.RELATIVE
Cannot solve field access PathSensitivity.RELATIVE
Cannot solve method call task.setPluginClasspath(project.getConfigurations().getAt("findbugsPlugins")) java.lang.RuntimeException: Method 'getAt' cannot be resolved in context project.getConfigurations().getAt("findbugsPlugins") (line: 83) MethodCallExprContext{wrapped=project.getConfigurations().getAt("findbugsPlugins")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/FindBugsPlugin.java
Cannot solve method call dependencies.add(project.getDependencies().create("com.google.code.findbugs:findbugs:" + extension.getToolVersion())) java.lang.RuntimeException: Method 'create' cannot be resolved in context project.getDependencies().create("com.google.code.findbugs:findbugs:" + extension.getToolVersion()) (line: 94) MethodCallExprContext{wrapped=project.getDependencies().create("com.google.code.findbugs:findbugs:" + extension.getToolVersion())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/FindBugsPlugin.java
Cannot solve method call taskMapping.map("findbugsClasspath", Callables.returning(configuration)) UnsolvedSymbolException{context='Method 'returning' with parameterTypes [ReferenceType{org.gradle.api.artifacts.Configuration, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.util.concurrent.Callables}'} /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/FindBugsPlugin.java
Cannot solve method call taskMapping.map("ignoreFailures", new Callable<Boolean>() {

    @Override
    public Boolean call() {
        return extension.isIgnoreFailures();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/FindBugsPlugin.java
Cannot solve method call taskMapping.map("effort", new Callable<String>() {

    @Override
    public String call() {
        return extension.getEffort();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/FindBugsPlugin.java
Cannot solve method call taskMapping.map("reportLevel", new Callable<String>() {

    @Override
    public String call() {
        return extension.getReportLevel();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/FindBugsPlugin.java
Cannot solve method call taskMapping.map("visitors", new Callable<Collection<String>>() {

    @Override
    public Collection<String> call() {
        return extension.getVisitors();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/FindBugsPlugin.java
Cannot solve method call taskMapping.map("omitVisitors", new Callable<Collection<String>>() {

    @Override
    public Collection<String> call() {
        return extension.getOmitVisitors();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/FindBugsPlugin.java
Cannot solve method call taskMapping.map("excludeFilterConfig", new Callable<TextResource>() {

    @Override
    public TextResource call() {
        return extension.getExcludeFilterConfig();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/FindBugsPlugin.java
Cannot solve method call taskMapping.map("includeFilterConfig", new Callable<TextResource>() {

    @Override
    public TextResource call() {
        return extension.getIncludeFilterConfig();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/FindBugsPlugin.java
Cannot solve method call taskMapping.map("excludeBugsFilterConfig", new Callable<TextResource>() {

    @Override
    public TextResource call() {
        return extension.getExcludeBugsFilterConfig();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/FindBugsPlugin.java
Cannot solve method call taskMapping.map("extraArgs", new Callable<Collection<String>>() {

    @Override
    public Collection<String> call() {
        return extension.getExtraArgs();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/FindBugsPlugin.java
Cannot solve method call reportMapping.map("enabled", new Callable<Boolean>() {

    @Override
    public Boolean call() {
        return report.getName().equals("xml");
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/FindBugsPlugin.java
Cannot solve method call reportMapping.map("destination", new Callable<File>() {

    @Override
    public File call() {
        return new File(extension.getReportsDir(), baseName + "." + report.getName());
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/FindBugsPlugin.java
Method 'fileTree' cannot be resolved in context project.fileTree(sourceSet.getOutput().getClassesDir()) (line: 191) MethodCallExprContext{wrapped=project.fileTree(sourceSet.getOutput().getClassesDir())}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call taskMapping.map("classes", new Callable<FileCollection>() {

    @Override
    public FileCollection call() {
        // being passed to FindBugs Ant task, resulting in an error
        return project.fileTree(sourceSet.getOutput().getClassesDir()).builtBy(sourceSet.getOutput());
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/FindBugsPlugin.java
Cannot solve method call taskMapping.map("classpath", new Callable<FileCollection>() {

    @Override
    public FileCollection call() {
        return sourceSet.getCompileClasspath();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/FindBugsPlugin.java
Cannot solve method call extension.setConfig(project.getResources().getText().fromFile("config/checkstyle/checkstyle.xml")) java.lang.RuntimeException: Method 'fromFile' cannot be resolved in context project.getResources().getText().fromFile("config/checkstyle/checkstyle.xml") (line: 54) MethodCallExprContext{wrapped=project.getResources().getText().fromFile("config/checkstyle/checkstyle.xml")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/CheckstylePlugin.java
Cannot solve method call dependencies.add(project.getDependencies().create("com.puppycrawl.tools:checkstyle:" + extension.getToolVersion())) java.lang.RuntimeException: Method 'create' cannot be resolved in context project.getDependencies().create("com.puppycrawl.tools:checkstyle:" + extension.getToolVersion()) (line: 70) MethodCallExprContext{wrapped=project.getDependencies().create("com.puppycrawl.tools:checkstyle:" + extension.getToolVersion())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/CheckstylePlugin.java
Cannot solve method call taskMapping.map("checkstyleClasspath", Callables.returning(configuration)) UnsolvedSymbolException{context='Method 'returning' with parameterTypes [ReferenceType{org.gradle.api.artifacts.Configuration, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.util.concurrent.Callables}'} /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/CheckstylePlugin.java
Cannot solve method call taskMapping.map("config", new Callable<TextResource>() {

    @Override
    public TextResource call() {
        return extension.getConfig();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/CheckstylePlugin.java
Cannot solve method call taskMapping.map("configProperties", new Callable<Map<String, Object>>() {

    @Override
    public Map<String, Object> call() {
        return extension.getConfigProperties();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/CheckstylePlugin.java
Cannot solve method call taskMapping.map("ignoreFailures", new Callable<Boolean>() {

    @Override
    public Boolean call() {
        return extension.isIgnoreFailures();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/CheckstylePlugin.java
Cannot solve method call taskMapping.map("showViolations", new Callable<Boolean>() {

    @Override
    public Boolean call() {
        return extension.isShowViolations();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/CheckstylePlugin.java
Cannot solve method call reportMapping.map("enabled", Callables.returning(true)) UnsolvedSymbolException{context='Method 'returning' with parameterTypes [PrimitiveTypeUsage{name='boolean'}]', name='ReflectionClassDeclaration{clazz=com.google.common.util.concurrent.Callables}'} /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/CheckstylePlugin.java
Cannot solve method call reportMapping.map("destination", new Callable<File>() {

    @Override
    public File call() {
        return new File(extension.getReportsDir(), baseName + "." + report.getName());
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/CheckstylePlugin.java
Cannot solve method call Preconditions.checkArgument(path.startsWith(":"), "Task path '%s' is not a qualified task path (e.g. ':task' or ':project:task').", path) java.lang.RuntimeException: Method 'startsWith' cannot be resolved in context path.startsWith(":") (line: 57) MethodCallExprContext{wrapped=path.startsWith(":")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/composite-builds/src/main/java/org/gradle/composite/internal/DefaultIncludedBuild.java
Cannot solve method call builder.execute(DefaultBuildIdentifier.of(":", true), buildId, tasks) UnsolvedSymbolException{context='Method 'of' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, PrimitiveTypeUsage{name='boolean'}]', name='JavaParserClassDeclaration{wrappedNode=public class DefaultBuildIdentifier implements BuildIdentifier {

    private static final Interner<DefaultBuildIdentifier> CURRENT_INSTANCES_INTERNER = Interners.newWeakInterner();

    private static final Interner<DefaultBuildIdentifier> OTHER_INSTANCES_INTERNER = Interners.newStrongInterner();

    private final String name;

    private final boolean current;

    private String displayName;

    private DefaultBuildIdentifier(String name, boolean current) {
        this.name = name;
        this.current = current;
    }

    public static DefaultBuildIdentifier of(String name, boolean current) {
        DefaultBuildIdentifier instance = new DefaultBuildIdentifier(name, current);
        // see DefaultProjectComponentIdentifier for similar workaround
        if (current) {
            return CURRENT_INSTANCES_INTERNER.intern(instance);
        } else {
            return OTHER_INSTANCES_INTERNER.intern(instance);
        }
    }

    public static DefaultBuildIdentifier of(String name) {
        return of(name, false);
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public boolean isCurrentBuild() {
        return current;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof DefaultBuildIdentifier)) {
            return false;
        }
        DefaultBuildIdentifier that = (DefaultBuildIdentifier) o;
        return Objects.equal(name, that.name);
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(name);
    }

    @Override
    public String toString() {
        if (displayName == null) {
            displayName = createDisplayName();
        }
        return displayName;
    }

    protected String createDisplayName() {
        return "build '" + name + "'";
    }
}}'} /repo/subprojects/composite-builds/src/main/java/org/gradle/composite/internal/CompositeBuildTaskDelegate.java
Cannot solve method call Sets.newTreeSet(CollectionUtils.collect(providingProjects, new Transformer<String, ProjectComponentIdentifier>() {

    @Override
    public String transform(ProjectComponentIdentifier projectComponentIdentifier) {
        return projectComponentIdentifier.getDisplayName();
    }
})) UnsolvedSymbolException{context='Method 'collect' with parameterTypes [ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=ReferenceType{org.gradle.api.artifacts.component.ProjectComponentIdentifier, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{org.gradle.api.Transformer, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.api.Transformer.IN=ReferenceType{org.gradle.api.artifacts.component.ProjectComponentIdentifier, typeParametersMap=TypeParametersMap{nameToValue={}}}, org.gradle.api.Transformer.OUT=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class CollectionUtils {

    /**
     * Returns null if the collection is empty otherwise expects a {@link #single(Iterable)} element to be found.
     */
    @Nullable
    public static <T> T findSingle(Collection<T> source) {
        return source.isEmpty() ? null : single(source);
    }

    /**
     * Returns the single element in the collection or throws.
     */
    public static <T> T single(Iterable<? extends T> source) {
        Iterator<? extends T> iterator = source.iterator();
        if (!iterator.hasNext()) {
            throw new NoSuchElementException("Expecting collection with single element, got none.");
        }
        T element = iterator.next();
        if (iterator.hasNext()) {
            throw new IllegalArgumentException("Expecting collection with single element, got multiple.");
        }
        return element;
    }

    public static <T> Collection<? extends T> checkedCast(Class<T> type, Collection<?> input) {
        for (Object o : input) {
            cast(type, o);
        }
        return Cast.uncheckedCast(input);
    }

    public static <T> T findFirst(Iterable<? extends T> source, Spec<? super T> filter) {
        for (T item : source) {
            if (filter.isSatisfiedBy(item)) {
                return item;
            }
        }
        return null;
    }

    public static <T> T findFirst(T[] source, Spec<? super T> filter) {
        for (T thing : source) {
            if (filter.isSatisfiedBy(thing)) {
                return thing;
            }
        }
        return null;
    }

    public static <T> T first(Iterable<? extends T> source) {
        return source.iterator().next();
    }

    public static <T> boolean any(Iterable<? extends T> source, Spec<? super T> filter) {
        return findFirst(source, filter) != null;
    }

    public static <T> boolean any(T[] source, Spec<? super T> filter) {
        return findFirst(source, filter) != null;
    }

    public static <T> Set<T> filter(Set<? extends T> set, Spec<? super T> filter) {
        return filter(set, new LinkedHashSet<T>(), filter);
    }

    public static <T> List<T> filter(List<? extends T> list, Spec<? super T> filter) {
        return filter(list, new LinkedList<T>(), filter);
    }

    public static <T> List<T> filter(T[] array, Spec<? super T> filter) {
        return filter(Arrays.asList(array), new LinkedList<T>(), filter);
    }

    /**
     * Returns a sorted copy of the provided collection of things. Uses the provided comparator to sort.
     */
    public static <T> List<T> sort(Iterable<? extends T> things, Comparator<? super T> comparator) {
        List<T> copy = toMutableList(things);
        Collections.sort(copy, comparator);
        return copy;
    }

    /**
     * Returns a sorted copy of the provided collection of things. Uses the natural ordering of the things.
     */
    public static <T extends Comparable> List<T> sort(Iterable<T> things) {
        List<T> copy = toMutableList(things);
        Collections.sort(copy);
        return copy;
    }

    public static <T, C extends Collection<T>> C filter(Iterable<? extends T> source, C destination, Spec<? super T> filter) {
        for (T item : source) {
            if (filter.isSatisfiedBy(item)) {
                destination.add(item);
            }
        }
        return destination;
    }

    public static <K, V> Map<K, V> filter(Map<K, V> map, Spec<Map.Entry<K, V>> filter) {
        return filter(map, new HashMap<K, V>(), filter);
    }

    public static <K, V> Map<K, V> filter(Map<K, V> map, Map<K, V> destination, Spec<Map.Entry<K, V>> filter) {
        for (Map.Entry<K, V> entry : map.entrySet()) {
            if (filter.isSatisfiedBy(entry)) {
                destination.put(entry.getKey(), entry.getValue());
            }
        }
        return destination;
    }

    public static <R, I> R[] collectArray(I[] list, Class<R> newType, Transformer<? extends R, ? super I> transformer) {
        @SuppressWarnings("unchecked") R[] destination = (R[]) Array.newInstance(newType, list.length);
        return collectArray(list, destination, transformer);
    }

    public static <R, I> R[] collectArray(I[] list, R[] destination, Transformer<? extends R, ? super I> transformer) {
        assert list.length <= destination.length;
        for (int i = 0; i < list.length; ++i) {
            destination[i] = transformer.transform(list[i]);
        }
        return destination;
    }

    public static <R, I> List<R> collect(List<? extends I> list, Transformer<? extends R, ? super I> transformer) {
        return collect(list, new ArrayList<R>(list.size()), transformer);
    }

    public static <R, I> List<R> collect(I[] list, Transformer<? extends R, ? super I> transformer) {
        return collect(Arrays.asList(list), transformer);
    }

    public static <R, I> Set<R> collect(Set<? extends I> set, Transformer<? extends R, ? super I> transformer) {
        return collect(set, new HashSet<R>(), transformer);
    }

    public static <R, I> List<R> collect(Iterable<? extends I> source, Transformer<? extends R, ? super I> transformer) {
        return collect(source, new LinkedList<R>(), transformer);
    }

    public static <R, I, C extends Collection<R>> C collect(Iterable<? extends I> source, C destination, Transformer<? extends R, ? super I> transformer) {
        for (I item : source) {
            destination.add(transformer.transform(item));
        }
        return destination;
    }

    public static List<String> toStringList(Iterable<?> iterable) {
        return collect(iterable, new LinkedList<String>(), Transformers.asString());
    }

    /**
     * Recursively unpacks all the given things into a flat list.
     *
     * Nulls are not removed, they are left intact.
     *
     * @param things The things to flatten
     * @return A flattened list of the given things
     */
    public static List<?> flattenCollections(Object... things) {
        return flattenCollections(Object.class, things);
    }

    /**
     * Recursively unpacks all the given things into a flat list, ensuring they are of a certain type.
     *
     * Nulls are not removed, they are left intact.
     *
     * If a non null object cannot be cast to the target type, a ClassCastException will be thrown.
     *
     * @param things The things to flatten
     * @param <T> The target type in the flattened list
     * @return A flattened list of the given things
     */
    public static <T> List<T> flattenCollections(Class<T> type, Object... things) {
        if (things == null) {
            return Collections.singletonList(null);
        } else if (things.length == 0) {
            return Collections.emptyList();
        } else if (things.length == 1) {
            Object thing = things[0];
            if (thing == null) {
                return Collections.singletonList(null);
            }
            if (thing.getClass().isArray()) {
                Object[] thingArray = (Object[]) thing;
                List<T> list = new ArrayList<T>(thingArray.length);
                for (Object thingThing : thingArray) {
                    list.addAll(flattenCollections(type, thingThing));
                }
                return list;
            }
            if (thing instanceof Collection) {
                Collection<?> collection = (Collection<?>) thing;
                List<T> list = new ArrayList<T>();
                for (Object element : collection) {
                    list.addAll(flattenCollections(type, element));
                }
                return list;
            }
            return Collections.singletonList(cast(type, thing));
        } else {
            List<T> list = new ArrayList<T>();
            for (Object thing : things) {
                list.addAll(flattenCollections(type, thing));
            }
            return list;
        }
    }

    public static <T> List<T> toList(Iterable<? extends T> things) {
        if (things instanceof List) {
            @SuppressWarnings("unchecked") List<T> castThings = (List<T>) things;
            return castThings;
        }
        return toMutableList(things);
    }

    public static <T> List<T> toList(Enumeration<? extends T> things) {
        AbstractList<T> list = new ArrayList<T>();
        while (things.hasMoreElements()) {
            list.add(things.nextElement());
        }
        return list;
    }

    private static <T> List<T> toMutableList(Iterable<? extends T> things) {
        if (things == null) {
            return new ArrayList<T>(0);
        }
        List<T> list = new ArrayList<T>();
        for (T thing : things) {
            list.add(thing);
        }
        return list;
    }

    public static <T> List<T> intersection(Collection<? extends Collection<T>> availableValuesByDescriptor) {
        List<T> result = new ArrayList<T>();
        Iterator<? extends Collection<T>> iterator = availableValuesByDescriptor.iterator();
        if (iterator.hasNext()) {
            Collection<T> firstSet = iterator.next();
            result.addAll(firstSet);
            while (iterator.hasNext()) {
                Collection<T> next = iterator.next();
                result.retainAll(next);
            }
        }
        return result;
    }

    public static <T> List<T> toList(T[] things) {
        if (things == null || things.length == 0) {
            return new ArrayList<T>(0);
        }
        List<T> list = new ArrayList<T>(things.length);
        Collections.addAll(list, things);
        return list;
    }

    public static <T> Set<T> toSet(Iterable<? extends T> things) {
        if (things == null) {
            return new HashSet<T>(0);
        }
        if (things instanceof Set) {
            @SuppressWarnings("unchecked") Set<T> castThings = (Set<T>) things;
            return castThings;
        }
        Set<T> set = new LinkedHashSet<T>();
        for (T thing : things) {
            set.add(thing);
        }
        return set;
    }

    public static <E> List<E> compact(List<E> list) {
        boolean foundAtLeastOneNull = false;
        List<E> compacted = null;
        int i = 0;
        for (E element : list) {
            if (element == null) {
                if (!foundAtLeastOneNull) {
                    compacted = new ArrayList<E>(list.size());
                    if (i > 0) {
                        compacted.addAll(list.subList(0, i));
                    }
                }
                foundAtLeastOneNull = true;
            } else if (foundAtLeastOneNull) {
                compacted.add(element);
            }
            ++i;
        }
        return foundAtLeastOneNull ? compacted : list;
    }

    public static <C extends Collection<String>> C stringize(Iterable<?> source, C destination) {
        return collect(source, destination, Transformers.asString());
    }

    public static List<String> stringize(Collection<?> source) {
        return stringize(source, new ArrayList<String>(source.size()));
    }

    public static <E> boolean replace(List<E> list, Spec<? super E> filter, Transformer<? extends E, ? super E> transformer) {
        boolean replaced = false;
        int i = 0;
        for (E it : list) {
            if (filter.isSatisfiedBy(it)) {
                list.set(i, transformer.transform(it));
                replaced = true;
            }
            ++i;
        }
        return replaced;
    }

    public static <K, V> void collectMap(Map<K, V> destination, Iterable<? extends V> items, Transformer<? extends K, ? super V> keyGenerator) {
        for (V item : items) {
            destination.put(keyGenerator.transform(item), item);
        }
    }

    /**
     * Given a set of values, derive a set of keys and return a map
     */
    public static <K, V> Map<K, V> collectMap(Iterable<? extends V> items, Transformer<? extends K, ? super V> keyGenerator) {
        Map<K, V> map = new LinkedHashMap<K, V>();
        collectMap(map, items, keyGenerator);
        return map;
    }

    public static <K, V> void collectMapValues(Map<K, V> destination, Iterable<? extends K> keys, Transformer<? extends V, ? super K> keyGenerator) {
        for (K item : keys) {
            destination.put(item, keyGenerator.transform(item));
        }
    }

    /**
     * Given a set of keys, derive a set of values and return a map
     */
    public static <K, V> Map<K, V> collectMapValues(Iterable<? extends K> keys, Transformer<? extends V, ? super K> keyGenerator) {
        Map<K, V> map = new LinkedHashMap<K, V>();
        collectMapValues(map, keys, keyGenerator);
        return map;
    }

    public static <T> boolean every(Iterable<? extends T> things, Spec<? super T> predicate) {
        for (T thing : things) {
            if (!predicate.isSatisfiedBy(thing)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Utility for adding an iterable to a collection.
     *
     * @param t1 The collection to add to
     * @param t2 The iterable to add each item of to the collection
     * @param <T> The element type of t1
     * @return t1
     */
    public static <T> Collection<T> addAll(Collection<T> t1, Iterable<? extends T> t2) {
        for (T t : t2) {
            t1.add(t);
        }
        return t1;
    }

    /**
     * Utility for adding an array to a collection.
     *
     * @param t1 The collection to add to
     * @param t2 The iterable to add each item of to the collection
     * @param <T> The element type of t1
     * @return t1
     */
    public static <T> Collection<T> addAll(Collection<T> t1, T... t2) {
        Collections.addAll(t1, t2);
        return t1;
    }

    /**
     * The result of diffing two sets.
     *
     * @param <T> The type of element the sets contain
     * @see CollectionUtils#diffSetsBy(java.util.Set, java.util.Set, org.gradle.api.Transformer)
     */
    public static class SetDiff<T> {

        public Set<T> leftOnly = new HashSet<T>();

        public Set<Pair<T, T>> common = new HashSet<Pair<T, T>>();

        public Set<T> rightOnly = new HashSet<T>();
    }

    /**
     * Provides a “diff report” of how the two sets are similar and how they are different, comparing the entries by some aspect.
     *
     * The transformer is used to generate the value to use to compare the entries by. That is, the entries are not compared by equals by an attribute or characteristic.
     *
     * The transformer is expected to produce a unique value for each entry in a single set. Behaviour is undefined if this condition is not met.
     *
     * @param left The set on the “left” side of the comparison.
     * @param right The set on the “right” side of the comparison.
     * @param compareBy Provides the value to compare entries from either side by
     * @param <T> The type of the entry objects
     * @return A representation of the difference
     */
    public static <T> SetDiff<T> diffSetsBy(Set<? extends T> left, Set<? extends T> right, Transformer<?, T> compareBy) {
        if (left == null) {
            throw new NullPointerException("'left' set is null");
        }
        if (right == null) {
            throw new NullPointerException("'right' set is null");
        }
        SetDiff<T> setDiff = new SetDiff<T>();
        Map<Object, T> indexedLeft = collectMap(left, compareBy);
        Map<Object, T> indexedRight = collectMap(right, compareBy);
        for (Map.Entry<Object, T> leftEntry : indexedLeft.entrySet()) {
            T rightValue = indexedRight.remove(leftEntry.getKey());
            if (rightValue == null) {
                setDiff.leftOnly.add(leftEntry.getValue());
            } else {
                Pair<T, T> pair = Pair.of(leftEntry.getValue(), rightValue);
                setDiff.common.add(pair);
            }
        }
        for (T rightValue : indexedRight.values()) {
            setDiff.rightOnly.add(rightValue);
        }
        return setDiff;
    }

    /**
     * Creates a string with {@code toString()} of each object with the given separator.
     *
     * <pre>
     * expect:
     * join(",", new Object[]{"a"}) == "a"
     * join(",", new Object[]{"a", "b", "c"}) == "a,b,c"
     * join(",", new Object[]{}) == ""
     * </pre>
     *
     * The {@code separator} must not be null and {@code objects} must not be null.
     *
     * @param separator The string by which to join each string representation
     * @param objects The objects to join the string representations of
     * @return The joined string
     */
    public static String join(String separator, Object[] objects) {
        return join(separator, objects == null ? null : Arrays.asList(objects));
    }

    /**
     * Creates a string with {@code toString()} of each object with the given separator.
     *
     * <pre>
     * expect:
     * join(",", ["a"]) == "a"
     * join(",", ["a", "b", "c"]) == "a,b,c"
     * join(",", []) == ""
     * </pre>
     *
     * The {@code separator} must not be null and {@code objects} must not be null.
     *
     * @param separator The string by which to join each string representation
     * @param objects The objects to join the string representations of
     * @return The joined string
     */
    public static String join(String separator, Iterable<?> objects) {
        if (separator == null) {
            throw new NullPointerException("The 'separator' cannot be null");
        }
        if (objects == null) {
            throw new NullPointerException("The 'objects' cannot be null");
        }
        StringBuilder string = new StringBuilder();
        Iterator<?> iterator = objects.iterator();
        if (iterator.hasNext()) {
            string.append(iterator.next().toString());
            while (iterator.hasNext()) {
                string.append(separator);
                string.append(iterator.next().toString());
            }
        }
        return string.toString();
    }

    /**
     * Partition given Collection into a Pair of Collections.
     *
     * <pre>Left</pre> Collection containing entries that satisfy the given predicate
     * <pre>Right</pre> Collection containing entries that do NOT satisfy the given predicate
     */
    public static <T> Pair<Collection<T>, Collection<T>> partition(Iterable<T> items, Spec<? super T> predicate) {
        Preconditions.checkNotNull(items, "Cannot partition null Collection");
        Preconditions.checkNotNull(predicate, "Cannot apply null Spec when partitioning");
        Collection<T> left = new LinkedList<T>();
        Collection<T> right = new LinkedList<T>();
        for (T item : items) {
            if (predicate.isSatisfiedBy(item)) {
                left.add(item);
            } else {
                right.add(item);
            }
        }
        return Pair.of(left, right);
    }

    public static class InjectionStep<T, I> {

        private final T target;

        private final I item;

        public InjectionStep(T target, I item) {
            this.target = target;
            this.item = item;
        }

        public T getTarget() {
            return target;
        }

        public I getItem() {
            return item;
        }
    }

    public static <T, I> T inject(T target, Iterable<? extends I> items, Action<InjectionStep<T, I>> action) {
        if (target == null) {
            throw new NullPointerException("The 'target' cannot be null");
        }
        if (items == null) {
            throw new NullPointerException("The 'items' cannot be null");
        }
        if (action == null) {
            throw new NullPointerException("The 'action' cannot be null");
        }
        for (I item : items) {
            action.execute(new InjectionStep<T, I>(target, item));
        }
        return target;
    }

    public static <K, V> ImmutableListMultimap<K, V> groupBy(Iterable<? extends V> iterable, Transformer<? extends K, V> grouper) {
        ImmutableListMultimap.Builder<K, V> builder = ImmutableListMultimap.builder();
        for (V element : iterable) {
            K key = grouper.transform(element);
            builder.put(key, element);
        }
        return builder.build();
    }

    public static <T> Iterable<? extends T> unpack(final Iterable<? extends Factory<? extends T>> factories) {
        return new Iterable<T>() {

            private final Iterator<? extends Factory<? extends T>> delegate = factories.iterator();

            public Iterator<T> iterator() {
                return new Iterator<T>() {

                    public boolean hasNext() {
                        return delegate.hasNext();
                    }

                    public T next() {
                        return delegate.next().create();
                    }

                    public void remove() {
                        throw new UnsupportedOperationException();
                    }
                };
            }
        };
    }

    @Nullable
    public static <T> List<T> nonEmptyOrNull(Iterable<T> iterable) {
        ImmutableList<T> list = ImmutableList.copyOf(iterable);
        return list.isEmpty() ? null : list;
    }

    public static <T> List<T> dedup(Iterable<T> source, final Equivalence<? super T> equivalence) {
        Iterable<Equivalence.Wrapper<T>> wrappers = Iterables.transform(source, new Function<T, Equivalence.Wrapper<T>>() {

            public Equivalence.Wrapper<T> apply(@Nullable T input) {
                return equivalence.wrap(input);
            }
        });
        Set<Equivalence.Wrapper<T>> deduped = ImmutableSet.copyOf(wrappers);
        return ImmutableList.copyOf(Iterables.transform(deduped, new Function<Equivalence.Wrapper<T>, T>() {

            public T apply(Equivalence.Wrapper<T> input) {
                return input.get();
            }
        }));
    }

    public static String asCommandLine(Iterable<String> arguments) {
        return Joiner.on(" ").join(collect(arguments, Transformers.asSafeCommandLineArgument()));
    }
}}'} /repo/subprojects/composite-builds/src/main/java/org/gradle/composite/internal/CompositeBuildDependencySubstitutions.java
Method 'getScriptSource' cannot be resolved in context getScriptSource() (line: 76) MethodCallExprContext{wrapped=getScriptSource()}. Parameter types: []
Method 'getScriptSource' cannot be resolved in context getScriptSource() (line: 76) MethodCallExprContext{wrapped=getScriptSource()}. Parameter types: []
Method 'getScriptSource' cannot be resolved in context getScriptSource() (line: 76) MethodCallExprContext{wrapped=getScriptSource()}. Parameter types: []
Method 'getLocation' cannot be resolved in context getResource().getLocation() (line: 38) MethodCallExprContext{wrapped=getResource().getLocation()}. Parameter types: []
Cannot solve method call substringBeforeLast(substringAfterLast(path, "/"), ".") java.lang.RuntimeException: Method 'substringAfterLast' cannot be resolved in context substringAfterLast(path, "/") (line: 46) MethodCallExprContext{wrapped=substringAfterLast(path, "/")}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/AbstractUriScriptSource.java
Cannot solve method call isJavaIdentifierStart(className.charAt(0)) java.lang.RuntimeException: Method 'charAt' cannot be resolved in context className.charAt(0) (line: 54) MethodCallExprContext{wrapped=className.charAt(0)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/AbstractUriScriptSource.java
Cannot solve method call Math.min(className.length(), 30) java.lang.RuntimeException: Method 'length' cannot be resolved in context className.length() (line: 57) MethodCallExprContext{wrapped=className.length()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/AbstractUriScriptSource.java
Cannot solve method call className.setLength(Math.min(className.length(), 30)) java.lang.RuntimeException: Error calculating the type of parameter className.length() of method call Math.min(className.length(), 30) /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/AbstractUriScriptSource.java
Method 'getBinding' cannot be resolved in context getBinding() (line: 53) MethodCallExprContext{wrapped=getBinding()}. Parameter types: []
Method 'getMetaClass' cannot be resolved in context getMetaClass() (line: 56) MethodCallExprContext{wrapped=getMetaClass()}. Parameter types: []
Cannot solve method call compilationUnit.addPhaseOperation(packageDetector, Phases.CANONICALIZATION) UnsolvedSymbolException{context='unknown', name='CANONICALIZATION', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/DefaultScriptCompilationHandler.java
Cannot solve method call compilationUnit.addPhaseOperation(emptyScriptDetector, Phases.CANONICALIZATION) UnsolvedSymbolException{context='unknown', name='CANONICALIZATION', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/DefaultScriptCompilationHandler.java
Cannot solve method call String.format("%s should not contain a package statement.", StringUtils.capitalize(source.getDisplayName())) UnsolvedSymbolException{context='Method 'capitalize' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=org.apache.commons.lang.StringUtils}'} /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/DefaultScriptCompilationHandler.java
Cannot solve method call sourceField.get(syntaxErrorMessage) UnsolvedSymbolException{context='unknown', name='SyntaxErrorMessage', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/DefaultScriptCompilationHandler.java
Method 'getErrorCollector' cannot be resolved in context e.getErrorCollector() (line: 170) MethodCallExprContext{wrapped=e.getErrorCollector()}. Parameter types: []
Method 'getErrorCollector' cannot be resolved in context e.getErrorCollector() (line: 186) MethodCallExprContext{wrapped=e.getErrorCollector()}. Parameter types: []
Cannot solve method call configuration.setScriptBaseClass(scriptBaseClass.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context scriptBaseClass.getName() (line: 193) MethodCallExprContext{wrapped=scriptBaseClass.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/DefaultScriptCompilationHandler.java
Method 'getAST' cannot be resolved in context source.getAST() (line: 231) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Method 'getAST' cannot be resolved in context source.getAST() (line: 241) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Method 'getAST' cannot be resolved in context source.getAST() (line: 241) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Method 'getAST' cannot be resolved in context source.getAST() (line: 248) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Method 'getAST' cannot be resolved in context source.getAST() (line: 248) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Cannot resolve field access null
Cannot resolve field access null
Method 'loadClass' cannot be resolved in context loader.loadClass(source.getClassName()) (line: 338) MethodCallExprContext{wrapped=loader.loadClass(source.getClassName())}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call addClassLoader(knownClassLoaders, systemClassLoader.getParent(), "system-ext" + javaVmVersion) java.lang.RuntimeException: Method 'getParent' cannot be resolved in context systemClassLoader.getParent() (line: 39) MethodCallExprContext{wrapped=systemClassLoader.getParent()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/RegistryAwareClassLoaderHierarchyHasher.java
Method 'getLocation' cannot be resolved in context scriptSource.getResource().getLocation() (line: 53) MethodCallExprContext{wrapped=scriptSource.getResource().getLocation()}. Parameter types: []
Cannot solve method call String.format(pluginBlockMetadataExtractor.formatErrorMessage("all %s {} blocks must appear before any %s {} blocks in the script"), scriptTarget.getClasspathBlockName(), PLUGINS) java.lang.RuntimeException: Method 'formatErrorMessage' cannot be resolved in context pluginBlockMetadataExtractor.formatErrorMessage("all %s {} blocks must appear before any %s {} blocks in the script") (line: 103) MethodCallExprContext{wrapped=pluginBlockMetadataExtractor.formatErrorMessage("all %s {} blocks must appear before any %s {} blocks in the script")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/InitialPassStatementTransformer.java
Method 'getErrorCollector' cannot be resolved in context sourceUnit.getErrorCollector() (line: 106) MethodCallExprContext{wrapped=sourceUnit.getErrorCollector()}. Parameter types: []
Method 'getErrorCollector' cannot be resolved in context sourceUnit.getErrorCollector() (line: 95) MethodCallExprContext{wrapped=sourceUnit.getErrorCollector()}. Parameter types: []
Cannot solve method call String.format(pluginBlockMetadataExtractor.formatErrorMessage("only %s {} and other %s {} script blocks are allowed before %s {} blocks, no other statements are allowed"), scriptTarget.getClasspathBlockName(), PLUGINS, PLUGINS) java.lang.RuntimeException: Method 'formatErrorMessage' cannot be resolved in context pluginBlockMetadataExtractor.formatErrorMessage("only %s {} and other %s {} script blocks are allowed before %s {} blocks, no other statements are allowed") (line: 69) MethodCallExprContext{wrapped=pluginBlockMetadataExtractor.formatErrorMessage("only %s {} and other %s {} script blocks are allowed before %s {} blocks, no other statements are allowed")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/InitialPassStatementTransformer.java
Method 'getErrorCollector' cannot be resolved in context sourceUnit.getErrorCollector() (line: 78) MethodCallExprContext{wrapped=sourceUnit.getErrorCollector()}. Parameter types: []
Cannot solve method call String.format("%s%n%nSee %s for information on the pluginRepositories {} block%n%n", failureMessage, documentationRegistry.getDocumentationFor("plugins", "sec:plugin_repositories")) java.lang.RuntimeException: Method 'getDocumentationFor' cannot be resolved in context documentationRegistry.getDocumentationFor("plugins", "sec:plugin_repositories") (line: 121) MethodCallExprContext{wrapped=documentationRegistry.getDocumentationFor("plugins", "sec:plugin_repositories")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/InitialPassStatementTransformer.java
Method 'getAST' cannot be resolved in context source.getAST() (line: 55) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Method 'getAST' cannot be resolved in context source.getAST() (line: 55) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Cannot solve method call AstUtils.isVisible(source, importedClass.getClassName()) java.lang.RuntimeException: Method 'getClassName' cannot be resolved in context importedClass.getClassName() (line: 58) MethodCallExprContext{wrapped=importedClass.getClassName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/SubsetScriptTransformer.java
Cannot solve method call field.get(source.getAST()) java.lang.RuntimeException: Method 'getAST' cannot be resolved in context source.getAST() (line: 62) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/SubsetScriptTransformer.java
Cannot solve method call value.remove(importedClass.getAlias()) java.lang.RuntimeException: Method 'getAlias' cannot be resolved in context importedClass.getAlias() (line: 63) MethodCallExprContext{wrapped=importedClass.getAlias()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/SubsetScriptTransformer.java
Method 'getAST' cannot be resolved in context source.getAST() (line: 70) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Method 'getAST' cannot be resolved in context source.getAST() (line: 70) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Method 'getAST' cannot be resolved in context source.getAST() (line: 70) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Cannot solve method call AstUtils.isVisible(source, importedClass.getClassName()) java.lang.RuntimeException: Method 'getClassName' cannot be resolved in context importedClass.getClassName() (line: 73) MethodCallExprContext{wrapped=importedClass.getClassName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/SubsetScriptTransformer.java
Method 'getAST' cannot be resolved in context source.getAST() (line: 78) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Method 'getAST' cannot be resolved in context source.getAST() (line: 78) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Method 'getAST' cannot be resolved in context source.getAST() (line: 78) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Cannot solve method call AstUtils.isVisible(source, importedClass.getClassName()) java.lang.RuntimeException: Method 'getClassName' cannot be resolved in context importedClass.getClassName() (line: 81) MethodCallExprContext{wrapped=importedClass.getClassName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/SubsetScriptTransformer.java
Method 'getAST' cannot be resolved in context source.getAST() (line: 89) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Method 'getAST' cannot be resolved in context source.getAST() (line: 89) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Method 'getName' cannot be resolved in context methodNode.getName() (line: 100) MethodCallExprContext{wrapped=methodNode.getName()}. Parameter types: []
Method 'getAST' cannot be resolved in context source.getAST() (line: 106) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Method 'getAST' cannot be resolved in context source.getAST() (line: 106) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Method 'getExpressions' cannot be resolved in context args.getExpressions() (line: 51) MethodCallExprContext{wrapped=args.getExpressions()}. Parameter types: []
Method 'getExpressions' cannot be resolved in context args.getExpressions() (line: 51) MethodCallExprContext{wrapped=args.getExpressions()}. Parameter types: []
Method 'getExpressions' cannot be resolved in context args.getExpressions() (line: 57) MethodCallExprContext{wrapped=args.getExpressions()}. Parameter types: []
Method 'getExpressions' cannot be resolved in context args.getExpressions() (line: 95) MethodCallExprContext{wrapped=args.getExpressions()}. Parameter types: []
Method 'getLeftExpression' cannot be resolved in context expression.getLeftExpression() (line: 109) MethodCallExprContext{wrapped=expression.getLeftExpression()}. Parameter types: []
Cannot solve method call isTaskIdentifier(nestedMethod.getMethod()) java.lang.RuntimeException: Method 'getMethod' cannot be resolved in context nestedMethod.getMethod() (line: 128) MethodCallExprContext{wrapped=nestedMethod.getMethod()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/TaskDefinitionScriptTransformer.java
Method 'getExpressions' cannot be resolved in context nestedArgs.getExpressions() (line: 141) MethodCallExprContext{wrapped=nestedArgs.getExpressions()}. Parameter types: []
Method 'getExpressions' cannot be resolved in context nestedArgs.getExpressions() (line: 145) MethodCallExprContext{wrapped=nestedArgs.getExpressions()}. Parameter types: []
Method 'getExpressions' cannot be resolved in context nestedArgs.getExpressions() (line: 148) MethodCallExprContext{wrapped=nestedArgs.getExpressions()}. Parameter types: []
Method 'getExpressions' cannot be resolved in context nestedArgs.getExpressions() (line: 151) MethodCallExprContext{wrapped=nestedArgs.getExpressions()}. Parameter types: []
Method 'getExpressions' cannot be resolved in context nestedArgs.getExpressions() (line: 144) MethodCallExprContext{wrapped=nestedArgs.getExpressions()}. Parameter types: []
Method 'getExpressions' cannot be resolved in context nestedArgs.getExpressions() (line: 144) MethodCallExprContext{wrapped=nestedArgs.getExpressions()}. Parameter types: []
Method 'getExpressions' cannot be resolved in context args.getExpressions() (line: 158) MethodCallExprContext{wrapped=args.getExpressions()}. Parameter types: []
Cannot solve method call String.format("Statement labels may not be used in build scripts.%nIn case you tried to configure a property named '%s', replace ':' with '=' or ' ', otherwise it will not have the desired effect.", statement.getStatementLabel()) java.lang.RuntimeException: Method 'getStatementLabel' cannot be resolved in context statement.getStatementLabel() (line: 44) MethodCallExprContext{wrapped=statement.getStatementLabel()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/StatementLabelsScriptTransformer.java
Method 'getAST' cannot be resolved in context source.getAST() (line: 42) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Method 'getAST' cannot be resolved in context source.getAST() (line: 42) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Method 'getAST' cannot be resolved in context source.getAST() (line: 42) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call resolveGenericsHeader(node.getGenericsTypes()) java.lang.RuntimeException: Method 'getGenericsTypes' cannot be resolved in context node.getGenericsTypes() (line: 193) MethodCallExprContext{wrapped=node.getGenericsTypes()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call transform(p.getInitialExpression()) java.lang.RuntimeException: Method 'getInitialExpression' cannot be resolved in context p.getInitialExpression() (line: 197) MethodCallExprContext{wrapped=p.getInitialExpression()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call p.setInitialExpression(transform(p.getInitialExpression())) java.lang.RuntimeException: Error calculating the type of parameter p.getInitialExpression() of method call transform(p.getInitialExpression()) /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call resolveOrFail(p.getType(), p.getType()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context p.getType() (line: 198) MethodCallExprContext{wrapped=p.getType()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call resolveOrFail(node.getReturnType(), node) java.lang.RuntimeException: Method 'getReturnType' cannot be resolved in context node.getReturnType() (line: 205) MethodCallExprContext{wrapped=node.getReturnType()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call fieldTypesChecked.add(node.getField()) java.lang.RuntimeException: Method 'getField' cannot be resolved in context node.getField() (line: 228) MethodCallExprContext{wrapped=node.getField()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call addError("unable to resolve class " + type.getName() + " " + msg, node) java.lang.RuntimeException: Method 'getName' cannot be resolved in context type.getName() (line: 286) MethodCallExprContext{wrapped=type.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call resolveGenericsTypes(type.getGenericsTypes()) java.lang.RuntimeException: Method 'getGenericsTypes' cannot be resolved in context type.getGenericsTypes() (line: 290) MethodCallExprContext{wrapped=type.getGenericsTypes()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call resolveGenericsTypes(type.getGenericsTypes()) java.lang.RuntimeException: Method 'getGenericsTypes' cannot be resolved in context type.getGenericsTypes() (line: 306) MethodCallExprContext{wrapped=type.getGenericsTypes()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call type.setRedirect(gt.getType()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context gt.getType() (line: 328) MethodCallExprContext{wrapped=gt.getType()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Method 'getNameWithoutPackage' cannot be resolved in context currentClass.getNameWithoutPackage() (line: 334) MethodCallExprContext{wrapped=currentClass.getNameWithoutPackage()}. Parameter types: []
Cannot solve method call type.setRedirect(result.getClassNode()) UnsolvedSymbolException{context='unknown', name='ClassNodeResolver.LookupResult', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call hierClasses.containsKey(classToCheck.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context classToCheck.getName() (line: 375) MethodCallExprContext{wrapped=classToCheck.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call hierClasses.put(classToCheck.getName(), classToCheck) java.lang.RuntimeException: Method 'getName' cannot be resolved in context classToCheck.getName() (line: 378) MethodCallExprContext{wrapped=classToCheck.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Method 'getName' cannot be resolved in context type.getName() (line: 389) MethodCallExprContext{wrapped=type.getName()}. Parameter types: []
Method 'getName' cannot be resolved in context type.getName() (line: 434) MethodCallExprContext{wrapped=type.getName()}. Parameter types: []
Cannot solve method call type.setRedirect(tmp.redirect()) java.lang.RuntimeException: Method 'redirect' cannot be resolved in context tmp.redirect() (line: 481) MethodCallExprContext{wrapped=tmp.redirect()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call simpleNameToFQN.get(type.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context type.getName() (line: 507) MethodCallExprContext{wrapped=type.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call resolveFromResolver(type, fqn.get(0)) java.lang.RuntimeException: Method 'get' cannot be resolved in context fqn.get(0) (line: 509) MethodCallExprContext{wrapped=fqn.get(0)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call type.setRedirect(tmp.redirect()) java.lang.RuntimeException: Method 'redirect' cannot be resolved in context tmp.redirect() (line: 522) MethodCallExprContext{wrapped=tmp.redirect()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call type.setRedirect(ClassHelper.BigDecimal_TYPE) UnsolvedSymbolException{context='unknown', name='BigDecimal_TYPE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call type.setRedirect(ClassHelper.BigInteger_TYPE) UnsolvedSymbolException{context='unknown', name='BigInteger_TYPE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Method 'getName' cannot be resolved in context type.getName() (line: 559) MethodCallExprContext{wrapped=type.getName()}. Parameter types: []
Cannot solve method call addError("reference to " + name + " is ambiguous, both class " + type.getName() + " and " + iType.getName() + " match", type) java.lang.RuntimeException: Method 'getName' cannot be resolved in context type.getName() (line: 560) MethodCallExprContext{wrapped=type.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot resolve field access null
Cannot solve method call type.setRedirect(tmp.redirect()) java.lang.RuntimeException: Method 'redirect' cannot be resolved in context tmp.redirect() (line: 604) MethodCallExprContext{wrapped=tmp.redirect()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call name.substring(pname.length() + 1) java.lang.RuntimeException: Method 'length' cannot be resolved in context pname.length() (line: 629) MethodCallExprContext{wrapped=pname.length()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Error calculating the type of parameter pname.length() + 1 of method call name.substring(pname.length() + 1)
Cannot solve method call type.setRedirect(tmp.redirect()) java.lang.RuntimeException: Method 'redirect' cannot be resolved in context tmp.redirect() (line: 632) MethodCallExprContext{wrapped=tmp.redirect()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call type.setName(module.getPackageName() + name) UnsolvedSymbolException{context='unknown', name='ModuleNode', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Method 'getName' cannot be resolved in context mClass.getName() (line: 680) MethodCallExprContext{wrapped=mClass.getName()}. Parameter types: []
Cannot solve method call type.setRedirect(tmp.redirect()) java.lang.RuntimeException: Method 'redirect' cannot be resolved in context tmp.redirect() (line: 703) MethodCallExprContext{wrapped=tmp.redirect()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Method 'getFieldName' cannot be resolved in context importNode.getFieldName() (line: 711) MethodCallExprContext{wrapped=importNode.getFieldName()}. Parameter types: []
Cannot resolve field access null
Cannot solve method call type.setRedirect(tmp.redirect()) java.lang.RuntimeException: Method 'redirect' cannot be resolved in context tmp.redirect() (line: 715) MethodCallExprContext{wrapped=tmp.redirect()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call type.setRedirect(tmp.redirect()) java.lang.RuntimeException: Method 'redirect' cannot be resolved in context tmp.redirect() (line: 732) MethodCallExprContext{wrapped=tmp.redirect()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot resolve field access null
Cannot solve method call type.setRedirect(tmp.redirect()) java.lang.RuntimeException: Method 'redirect' cannot be resolved in context tmp.redirect() (line: 743) MethodCallExprContext{wrapped=tmp.redirect()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Method 'getModule' cannot be resolved in context currentClass.getModule() (line: 787) MethodCallExprContext{wrapped=currentClass.getModule()}. Parameter types: []
Cannot solve method call type.setRedirect(lr.getClassNode()) UnsolvedSymbolException{context='unknown', name='ClassNodeResolver.LookupResult', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Method 'getCompileUnit' cannot be resolved in context currentClass.getCompileUnit() (line: 795) MethodCallExprContext{wrapped=currentClass.getCompileUnit()}. Parameter types: []
Cannot solve method call resolveOrFail(exp.getType(), exp) java.lang.RuntimeException: Method 'getType' cannot be resolved in context exp.getType() (line: 827) MethodCallExprContext{wrapped=exp.getType()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call transform(pe.getProperty()) java.lang.RuntimeException: Method 'getProperty' cannot be resolved in context pe.getProperty() (line: 956) MethodCallExprContext{wrapped=pe.getProperty()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Method 'getSuperClass' cannot be resolved in context currentClass.getSuperClass() (line: 996) MethodCallExprContext{wrapped=currentClass.getSuperClass()}. Parameter types: []
Method 'getSuperClass' cannot be resolved in context currentClass.getSuperClass() (line: 1003) MethodCallExprContext{wrapped=currentClass.getSuperClass()}. Parameter types: []
Method 'getObjectExpression' cannot be resolved in context expression.getObjectExpression() (line: 1018) MethodCallExprContext{wrapped=expression.getObjectExpression()}. Parameter types: []
Cannot solve method call addError("The class '" + type.getName() + "' needs to be an outer class of '" + currentClass.getName() + "' when using '.this' or '.super'.", expression) java.lang.RuntimeException: Method 'getName' cannot be resolved in context type.getName() (line: 1035) MethodCallExprContext{wrapped=type.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot resolve field access null
Cannot solve method call addError("The usage of 'Class.this' and 'Class.super' within static nested class '" + currentClass.getName() + "' is not allowed in a static context.", expression) java.lang.RuntimeException: Method 'getName' cannot be resolved in context currentClass.getName() (line: 1045) MethodCallExprContext{wrapped=currentClass.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call Character.isLowerCase(name.charAt(0)) java.lang.RuntimeException: Method 'charAt' cannot be resolved in context name.charAt(0) (line: 1072) MethodCallExprContext{wrapped=name.charAt(0)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call scope.removeReferencedClassVariable(ve.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context ve.getName() (line: 1089) MethodCallExprContext{wrapped=ve.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call resolveOrFail(ve.getType(), ve) java.lang.RuntimeException: Method 'getType' cannot be resolved in context ve.getType() (line: 1098) MethodCallExprContext{wrapped=ve.getType()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call Character.isLowerCase(name.charAt(0)) java.lang.RuntimeException: Method 'charAt' cannot be resolved in context name.charAt(0) (line: 1110) MethodCallExprContext{wrapped=name.charAt(0)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call transform(be.getLeftExpression()) java.lang.RuntimeException: Method 'getLeftExpression' cannot be resolved in context be.getLeftExpression() (line: 1121) MethodCallExprContext{wrapped=be.getLeftExpression()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Method 'getOperation' cannot be resolved in context be.getOperation() (line: 1122) MethodCallExprContext{wrapped=be.getOperation()}. Parameter types: []
Method 'getType' cannot be resolved in context ce.getType() (line: 1126) MethodCallExprContext{wrapped=ce.getType()}. Parameter types: []
Method 'getType' cannot be resolved in context ce.getType() (line: 1127) MethodCallExprContext{wrapped=ce.getType()}. Parameter types: []
Cannot solve method call addError(error, be.getLeftExpression()) java.lang.RuntimeException: Method 'getLeftExpression' cannot be resolved in context be.getLeftExpression() (line: 1130) MethodCallExprContext{wrapped=be.getLeftExpression()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call transform(mapExpression.getExpression()) java.lang.RuntimeException: Method 'getExpression' cannot be resolved in context mapExpression.getExpression() (line: 1165) MethodCallExprContext{wrapped=mapExpression.getExpression()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Method 'getExpressions' cannot be resolved in context list.getExpressions() (line: 1136) MethodCallExprContext{wrapped=list.getExpressions()}. Parameter types: []
Method 'getType' cannot be resolved in context left.getType() (line: 1138) MethodCallExprContext{wrapped=left.getType()}. Parameter types: []
Cannot solve method call transform(be.getRightExpression()) java.lang.RuntimeException: Method 'getRightExpression' cannot be resolved in context be.getRightExpression() (line: 1174) MethodCallExprContext{wrapped=be.getRightExpression()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call me.setSourcePosition(be.getRightExpression()) java.lang.RuntimeException: Method 'getRightExpression' cannot be resolved in context be.getRightExpression() (line: 1175) MethodCallExprContext{wrapped=be.getRightExpression()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call transform(be.getRightExpression()) java.lang.RuntimeException: Method 'getRightExpression' cannot be resolved in context be.getRightExpression() (line: 1181) MethodCallExprContext{wrapped=be.getRightExpression()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call Modifier.isAbstract(type.getModifiers()) java.lang.RuntimeException: Method 'getModifiers' cannot be resolved in context type.getModifiers() (line: 1216) MethodCallExprContext{wrapped=type.getModifiers()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call transform(mce.getArguments()) java.lang.RuntimeException: Method 'getArguments' cannot be resolved in context mce.getArguments() (line: 1229) MethodCallExprContext{wrapped=mce.getArguments()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call transform(mce.getMethod()) java.lang.RuntimeException: Method 'getMethod' cannot be resolved in context mce.getMethod() (line: 1230) MethodCallExprContext{wrapped=mce.getMethod()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call transform(mce.getObjectExpression()) java.lang.RuntimeException: Method 'getObjectExpression' cannot be resolved in context mce.getObjectExpression() (line: 1231) MethodCallExprContext{wrapped=mce.getObjectExpression()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call resolveGenericsTypes(mce.getGenericsTypes()) java.lang.RuntimeException: Method 'getGenericsTypes' cannot be resolved in context mce.getGenericsTypes() (line: 1233) MethodCallExprContext{wrapped=mce.getGenericsTypes()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call result.setSafe(mce.isSafe()) java.lang.RuntimeException: Method 'isSafe' cannot be resolved in context mce.isSafe() (line: 1236) MethodCallExprContext{wrapped=mce.isSafe()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call result.setImplicitThis(mce.isImplicitThis()) java.lang.RuntimeException: Method 'isImplicitThis' cannot be resolved in context mce.isImplicitThis() (line: 1237) MethodCallExprContext{wrapped=mce.isImplicitThis()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call result.setSpreadSafe(mce.isSpreadSafe()) java.lang.RuntimeException: Method 'isSpreadSafe' cannot be resolved in context mce.isSpreadSafe() (line: 1238) MethodCallExprContext{wrapped=mce.isSpreadSafe()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call result.setGenericsTypes(mce.getGenericsTypes()) java.lang.RuntimeException: Method 'getGenericsTypes' cannot be resolved in context mce.getGenericsTypes() (line: 1240) MethodCallExprContext{wrapped=mce.getGenericsTypes()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call result.setMethodTarget(mce.getMethodTarget()) java.lang.RuntimeException: Method 'getMethodTarget' cannot be resolved in context mce.getMethodTarget() (line: 1241) MethodCallExprContext{wrapped=mce.getMethodTarget()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Method 'getType' cannot be resolved in context ce.getType() (line: 1253) MethodCallExprContext{wrapped=ce.getType()}. Parameter types: []
Cannot solve method call addError("you tried to assign a value to the class " + ce.getType().getName(), oldLeft) java.lang.RuntimeException: Method 'getType' cannot be resolved in context ce.getType() (line: 1253) MethodCallExprContext{wrapped=ce.getType()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call transform(de.getRightExpression()) java.lang.RuntimeException: Method 'getRightExpression' cannot be resolved in context de.getRightExpression() (line: 1256) MethodCallExprContext{wrapped=de.getRightExpression()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call newDeclExpr.setDeclaringClass(de.getDeclaringClass()) java.lang.RuntimeException: Method 'getDeclaringClass' cannot be resolved in context de.getDeclaringClass() (line: 1262) MethodCallExprContext{wrapped=de.getDeclaringClass()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call newDeclExpr.addAnnotations(de.getAnnotations()) java.lang.RuntimeException: Method 'getAnnotations' cannot be resolved in context de.getAnnotations() (line: 1265) MethodCallExprContext{wrapped=de.getAnnotations()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call newDeclExpr.setDeclaringClass(currentMethod.getDeclaringClass()) java.lang.RuntimeException: Method 'getDeclaringClass' cannot be resolved in context currentMethod.getDeclaringClass() (line: 1272) MethodCallExprContext{wrapped=currentMethod.getDeclaringClass()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call transform(member.getValue()) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context member.getValue() (line: 1281) MethodCallExprContext{wrapped=member.getValue()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call member.setValue(transform(member.getValue())) java.lang.RuntimeException: Error calculating the type of parameter member.getValue() of method call transform(member.getValue()) /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Method 'getMembers' cannot be resolved in context an.getMembers() (line: 1280) MethodCallExprContext{wrapped=an.getMembers()}. Parameter types: []
Cannot solve method call transform(member.getValue()) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context member.getValue() (line: 1301) MethodCallExprContext{wrapped=member.getValue()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Method 'getMembers' cannot be resolved in context an.getMembers() (line: 1300) MethodCallExprContext{wrapped=an.getMembers()}. Parameter types: []
Cannot solve method call tmpAnnotations.put(annTypeClass.getName(), an) java.lang.RuntimeException: Method 'getName' cannot be resolved in context annTypeClass.getName() (line: 1310) MethodCallExprContext{wrapped=annTypeClass.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call addError("Cannot specify duplicate annotation on the same member : " + annType.getName(), an) java.lang.RuntimeException: Method 'getName' cannot be resolved in context annType.getName() (line: 1312) MethodCallExprContext{wrapped=annType.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call transformInlineConstants(member.getValue()) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context member.getValue() (line: 1351) MethodCallExprContext{wrapped=member.getValue()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call member.setValue(transformInlineConstants(member.getValue())) java.lang.RuntimeException: Error calculating the type of parameter member.getValue() of method call transformInlineConstants(member.getValue()) /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Method 'getMembers' cannot be resolved in context an.getMembers() (line: 1350) MethodCallExprContext{wrapped=an.getMembers()}. Parameter types: []
Cannot solve method call type.getField(pe.getPropertyAsString()) java.lang.RuntimeException: Method 'getPropertyAsString' cannot be resolved in context pe.getPropertyAsString() (line: 1330) MethodCallExprContext{wrapped=pe.getPropertyAsString()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call addError("unable to find class '" + pe.getText() + "' for annotation attribute constant", pe.getObjectExpression()) java.lang.RuntimeException: Method 'getText' cannot be resolved in context pe.getText() (line: 1363) MethodCallExprContext{wrapped=pe.getText()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call Modifier.isStatic(node.getModifiers()) java.lang.RuntimeException: Method 'getModifiers' cannot be resolved in context node.getModifiers() (line: 1377) MethodCallExprContext{wrapped=node.getModifiers()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call resolveGenericsHeader(node.getGenericsTypes()) java.lang.RuntimeException: Method 'getGenericsTypes' cannot be resolved in context node.getGenericsTypes() (line: 1384) MethodCallExprContext{wrapped=node.getGenericsTypes()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call addError("unable to resolve class " + type.getName(), type) java.lang.RuntimeException: Method 'getName' cannot be resolved in context type.getName() (line: 1396) MethodCallExprContext{wrapped=type.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call type.setName(node.getPackageName() + "." + oldTypeName) java.lang.RuntimeException: Method 'getPackageName' cannot be resolved in context node.getPackageName() (line: 1408) MethodCallExprContext{wrapped=node.getPackageName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call addError("unable to resolve class " + type.getName(), type) java.lang.RuntimeException: Method 'getName' cannot be resolved in context type.getName() (line: 1414) MethodCallExprContext{wrapped=type.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call addError("unable to resolve class " + type.getName(), type) java.lang.RuntimeException: Method 'getName' cannot be resolved in context type.getName() (line: 1421) MethodCallExprContext{wrapped=type.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call addError("unable to resolve class " + type.getName(), type) java.lang.RuntimeException: Method 'getName' cannot be resolved in context type.getName() (line: 1428) MethodCallExprContext{wrapped=type.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call checkCyclicInheritence(node, node.getUnresolvedSuperClass(), node.getInterfaces()) java.lang.RuntimeException: Method 'getUnresolvedSuperClass' cannot be resolved in context node.getUnresolvedSuperClass() (line: 1442) MethodCallExprContext{wrapped=node.getUnresolvedSuperClass()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot resolve field access null
Cannot solve method call addError("Cyclic inheritance involving " + intfToCompare.getName() + " in interface " + originalNode.getName(), originalNode) java.lang.RuntimeException: Method 'getName' cannot be resolved in context intfToCompare.getName() (line: 1475) MethodCallExprContext{wrapped=intfToCompare.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call checkCyclicInheritence(originalNode, null, intf.getInterfaces()) java.lang.RuntimeException: Method 'getInterfaces' cannot be resolved in context intf.getInterfaces() (line: 1481) MethodCallExprContext{wrapped=intf.getInterfaces()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call addError("Cyclic inheritance involving " + parentToCompare.getName() + " in class " + originalNode.getName(), originalNode) java.lang.RuntimeException: Method 'getName' cannot be resolved in context parentToCompare.getName() (line: 1455) MethodCallExprContext{wrapped=parentToCompare.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot resolve field access null
Cannot solve method call addError("Cycle detected: the type " + originalNode.getName() + " cannot implement itself", originalNode) java.lang.RuntimeException: Method 'getName' cannot be resolved in context originalNode.getName() (line: 1461) MethodCallExprContext{wrapped=originalNode.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call checkCyclicInheritence(originalNode, parentToCompare.getUnresolvedSuperClass(), null) java.lang.RuntimeException: Method 'getUnresolvedSuperClass' cannot be resolved in context parentToCompare.getUnresolvedSuperClass() (line: 1469) MethodCallExprContext{wrapped=parentToCompare.getUnresolvedSuperClass()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call resolveOrFail(cs.getExceptionType(), cs) java.lang.RuntimeException: Method 'getExceptionType' cannot be resolved in context cs.getExceptionType() (line: 1490) MethodCallExprContext{wrapped=cs.getExceptionType()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Method 'getVariable' cannot be resolved in context cs.getVariable() (line: 1492) MethodCallExprContext{wrapped=cs.getVariable()}. Parameter types: []
Cannot solve method call resolveOrFail(forLoop.getVariableType(), forLoop) java.lang.RuntimeException: Method 'getVariableType' cannot be resolved in context forLoop.getVariableType() (line: 1498) MethodCallExprContext{wrapped=forLoop.getVariableType()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call classNode.setRedirect(ClassHelper.OBJECT_TYPE) UnsolvedSymbolException{context='unknown', name='OBJECT_TYPE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call type.setRedirect(gt.getType()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context gt.getType() (line: 1577) MethodCallExprContext{wrapped=gt.getType()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call type.setRedirect(ClassHelper.OBJECT_TYPE) UnsolvedSymbolException{context='unknown', name='OBJECT_TYPE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call resolveGenericsTypes(upperBound.getGenericsTypes()) java.lang.RuntimeException: Method 'getGenericsTypes' cannot be resolved in context upperBound.getGenericsTypes() (line: 1568) MethodCallExprContext{wrapped=upperBound.getGenericsTypes()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call resolveOrFail(genericsType.getLowerBound(), genericsType) java.lang.RuntimeException: Method 'getLowerBound' cannot be resolved in context genericsType.getLowerBound() (line: 1582) MethodCallExprContext{wrapped=genericsType.getLowerBound()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Cannot solve method call resolveGenericsTypes(type.getGenericsTypes()) java.lang.RuntimeException: Method 'getGenericsTypes' cannot be resolved in context type.getGenericsTypes() (line: 1585) MethodCallExprContext{wrapped=type.getGenericsTypes()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Method 'getType' cannot be resolved in context genericsType.getType() (line: 1586) MethodCallExprContext{wrapped=genericsType.getType()}. Parameter types: []
Cannot solve method call genericsType.setResolved(genericsType.getType().isResolved()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context genericsType.getType() (line: 1586) MethodCallExprContext{wrapped=genericsType.getType()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/GradleResolveVisitor.java
Method 'getAST' cannot be resolved in context source.getAST() (line: 48) MethodCallExprContext{wrapped=source.getAST()}. Parameter types: []
Cannot resolve field access null
Cannot solve method call scriptBlock.getName().equals(ModelBlockTransformer.MODEL) UnsolvedSymbolException{context='unknown', name='MODEL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/ImperativeStatementDetectingTransformer.java
Method 'cache' cannot be resolved in context cacheRepository.cache("scripts-remapped/" + source.getClassName() + "/" + sourceHash + "/" + classpathHash) (line: 99) MethodCallExprContext{wrapped=cacheRepository.cache("scripts-remapped/" + source.getClassName() + "/" + sourceHash + "/" + classpathHash)}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'cache' cannot be resolved in context cacheRepository.cache("scripts-remapped/" + source.getClassName() + "/" + sourceHash + "/" + classpathHash) (line: 99) MethodCallExprContext{wrapped=cacheRepository.cache("scripts-remapped/" + source.getClassName() + "/" + sourceHash + "/" + classpathHash)}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'cache' cannot be resolved in context cacheRepository.cache("scripts-remapped/" + source.getClassName() + "/" + sourceHash + "/" + classpathHash) (line: 99) MethodCallExprContext{wrapped=cacheRepository.cache("scripts-remapped/" + source.getClassName() + "/" + sourceHash + "/" + classpathHash)}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'cache' cannot be resolved in context cacheRepository.cache("scripts-remapped/" + source.getClassName() + "/" + sourceHash + "/" + classpathHash) (line: 99) MethodCallExprContext{wrapped=cacheRepository.cache("scripts-remapped/" + source.getClassName() + "/" + sourceHash + "/" + classpathHash)}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'newOperation' cannot be resolved in context progressLoggerFactory.newOperation(FileCacheBackedScriptClassCompiler.class) (line: 170) MethodCallExprContext{wrapped=progressLoggerFactory.newOperation(FileCacheBackedScriptClassCompiler.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.groovy.scripts.internal.FileCacheBackedScriptClassCompiler, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call remap(((Type) o).getDescriptor()) java.lang.RuntimeException: Method 'getDescriptor' cannot be resolved in context ((Type) o).getDescriptor() (line: 244) MethodCallExprContext{wrapped=((Type) o).getDescriptor()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/FileCacheBackedScriptClassCompiler.java
Cannot solve method call Type.getType(remap(((Type) o).getDescriptor())) java.lang.RuntimeException: Error calculating the type of parameter ((Type) o).getDescriptor() of method call remap(((Type) o).getDescriptor()) /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/FileCacheBackedScriptClassCompiler.java
Method 'getLocation' cannot be resolved in context scriptSource.getResource().getLocation() (line: 247) MethodCallExprContext{wrapped=scriptSource.getResource().getLocation()}. Parameter types: []
Cannot solve method call super.visitInnerClass(remap(name), remap(outerName), remap(innerName), access) com.github.javaparser.symbolsolver.logic.ConfilictingGenericTypesException: No matching between ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual) /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/FileCacheBackedScriptClassCompiler.java
Cannot solve method call super.visitOuterClass(remap(owner), remap(name), remap(desc)) com.github.javaparser.symbolsolver.logic.ConfilictingGenericTypesException: No matching between ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual) /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/FileCacheBackedScriptClassCompiler.java
Cannot solve method call super.visitLdcInsn(remap(cst)) com.github.javaparser.symbolsolver.logic.ConfilictingGenericTypesException: No matching between ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual) /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/FileCacheBackedScriptClassCompiler.java
Cannot solve method call super.visitLocalVariable(name, remap(desc), remap(signature), start, end, index) com.github.javaparser.symbolsolver.logic.ConfilictingGenericTypesException: No matching between ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual) /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/FileCacheBackedScriptClassCompiler.java
Cannot solve method call super.visitAnnotation(remap(desc), visible) com.github.javaparser.symbolsolver.logic.ConfilictingGenericTypesException: No matching between ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual) /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/FileCacheBackedScriptClassCompiler.java
Method 'cache' cannot be resolved in context cacheRepository.cache("scripts/" + sourceHash + "/" + dslId + "/" + classpathHash) (line: 345) MethodCallExprContext{wrapped=cacheRepository.cache("scripts/" + sourceHash + "/" + dslId + "/" + classpathHash)}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'cache' cannot be resolved in context cacheRepository.cache("scripts/" + sourceHash + "/" + dslId + "/" + classpathHash) (line: 345) MethodCallExprContext{wrapped=cacheRepository.cache("scripts/" + sourceHash + "/" + dslId + "/" + classpathHash)}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'cache' cannot be resolved in context cacheRepository.cache("scripts/" + sourceHash + "/" + dslId + "/" + classpathHash) (line: 345) MethodCallExprContext{wrapped=cacheRepository.cache("scripts/" + sourceHash + "/" + dslId + "/" + classpathHash)}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'cache' cannot be resolved in context cacheRepository.cache("scripts/" + sourceHash + "/" + dslId + "/" + classpathHash) (line: 345) MethodCallExprContext{wrapped=cacheRepository.cache("scripts/" + sourceHash + "/" + dslId + "/" + classpathHash)}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call renamed.substring(RemappingScriptSource.MAPPED_SCRIPT.length()) java.lang.RuntimeException: Method 'length' cannot be resolved in context RemappingScriptSource.MAPPED_SCRIPT.length() (line: 372) MethodCallExprContext{wrapped=RemappingScriptSource.MAPPED_SCRIPT.length()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/internal/FileCacheBackedScriptClassCompiler.java
Method 'getName' cannot be resolved in context methodNode.getName() (line: 41) MethodCallExprContext{wrapped=methodNode.getName()}. Parameter types: []
Cannot solve method call HashUtil.createCompactMD5(resource.getText()) java.lang.RuntimeException: Method 'getText' cannot be resolved in context resource.getText() (line: 30) MethodCallExprContext{wrapped=resource.getText()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/groovy/scripts/StringScriptSource.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call lockInformationRegion(LockMode.Exclusive, System.currentTimeMillis() + shortTimeoutMs) UnsolvedSymbolException{context='unknown', name='Exclusive', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/cache/internal/DefaultFileLockManager.java
Cannot resolve field access null
Cannot solve method call lockInformationRegion(LockMode.Exclusive, System.currentTimeMillis() + shortTimeoutMs) UnsolvedSymbolException{context='unknown', name='Exclusive', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/cache/internal/DefaultFileLockManager.java
Cannot solve method call lockFileAccess.writeLockInfo(port, lockId, metaDataProvider.getProcessIdentifier(), operationDisplayName) java.lang.RuntimeException: Method 'getProcessIdentifier' cannot be resolved in context metaDataProvider.getProcessIdentifier() (line: 282) MethodCallExprContext{wrapped=metaDataProvider.getProcessIdentifier()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/cache/internal/DefaultFileLockManager.java
Cannot resolve field access null
Cannot solve method call lockInformationRegion(LockMode.Shared, waitUntil) UnsolvedSymbolException{context='unknown', name='Shared', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/cache/internal/DefaultFileLockManager.java
Cannot resolve field access null
Cannot resolve field access null
Empty name expression CacheDirectory
Empty name expression DefaultTarget
Empty name expression CachePropertiesFile
Cannot resolve field access null
Cannot solve field access FileLockManager.LockMode.Shared
Cannot resolve field access null
Cannot solve field access FileLockManager.LockMode.Exclusive
Cannot resolve field access null
Cannot solve field access FileLockManager.LockMode.Exclusive
Cannot solve field access LockMode.Shared
Cannot solve field access VersionStrategy.CachePerVersion
Cannot solve field access LockTarget.DefaultTarget
Cannot solve field access VersionStrategy.SharedCache
Cannot resolve field access null
Cannot solve field access FileLockManager.LockMode.None
Cannot solve method call takeOwnership(String.format("Access %s", cacheDisplayName)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/core/src/main/java/org/gradle/cache/internal/DefaultCacheAccess.java
Method 'add' cannot be resolved in context new CompositeStoppable().add(caches) (line: 154) MethodCallExprContext{wrapped=new CompositeStoppable().add(caches)}. Parameter types: [ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{org.gradle.cache.internal.MultiProcessSafePersistentIndexedCache, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot resolve field access null
Cannot solve field access FileLockManager.LockMode.Shared
Cannot solve method call dataOutput.writeByte(protocol.getVersion()) java.lang.RuntimeException: Method 'getVersion' cannot be resolved in context protocol.getVersion() (line: 46) MethodCallExprContext{wrapped=protocol.getVersion()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/cache/internal/filelock/LockStateAccess.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call String.format("Unexpected lock protocol found in lock file. Expected %s, found %s.", protocol.getVersion(), protocolVersion) java.lang.RuntimeException: Method 'getVersion' cannot be resolved in context protocol.getVersion() (line: 74) MethodCallExprContext{wrapped=protocol.getVersion()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/cache/internal/filelock/LockStateAccess.java
Cannot solve method call String.format("Unexpected lock protocol found in lock file. Expected %s, found %s.", lockInfoSerializer.getVersion(), protocolVersion) java.lang.RuntimeException: Method 'getVersion' cannot be resolved in context lockInfoSerializer.getVersion() (line: 44) MethodCallExprContext{wrapped=lockInfoSerializer.getVersion()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/cache/internal/filelock/LockInfoAccess.java
Cannot solve method call outstr.writeByte(lockInfoSerializer.getVersion()) java.lang.RuntimeException: Method 'getVersion' cannot be resolved in context lockInfoSerializer.getVersion() (line: 55) MethodCallExprContext{wrapped=lockInfoSerializer.getVersion()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/cache/internal/filelock/LockInfoAccess.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call verifyTree(header.getRoot(), "", blocks, Long.MAX_VALUE, true) UnsolvedSymbolException{context='unknown', name='MAX_VALUE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/cache/internal/btree/BTreePersistentIndexedCache.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call verify(block, Integer.MAX_VALUE) UnsolvedSymbolException{context='unknown', name='MAX_VALUE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/cache/internal/btree/FreeListBlockStore.java
Cannot solve method call verify(store.read(block.nextBlock, FreeListBlock.class), block.largestInNextBlock) java.lang.RuntimeException: Method 'read' cannot be resolved in context store.read(block.nextBlock, FreeListBlock.class) (line: 118) MethodCallExprContext{wrapped=store.read(block.nextBlock, FreeListBlock.class)}. Parameter types: [ReferenceType{org.gradle.cache.internal.btree.BlockPointer, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.cache.internal.btree.FreeListBlockStore.FreeListBlock, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/core/src/main/java/org/gradle/cache/internal/btree/FreeListBlockStore.java
Cannot resolve field access null
Cannot solve method call payloadType.cast(factory.create(payloadType)) java.lang.RuntimeException: T ? extends org.gradle.cache.internal.btree.BlockPayload /repo/subprojects/core/src/main/java/org/gradle/cache/internal/btree/FileBackedBlockStore.java
Cannot resolve field access null
Cannot solve method call cachedProperties.getProperty(entry.getKey().toString()) java.lang.UnsupportedOperationException: unbounded wildcard /repo/subprojects/core/src/main/java/org/gradle/cache/internal/DefaultPersistentDirectoryCache.java
Cannot solve method call getCacheDir(getBuildCacheDir(project.getRootProject()), versionStrategy, "projects/" + project.getPath().replace(':', '_') + "/" + key) java.lang.RuntimeException: Method 'replace' cannot be resolved in context project.getPath().replace(':', '_') (line: 51) MethodCallExprContext{wrapped=project.getPath().replace(':', '_')}. Parameter types: [PrimitiveTypeUsage{name='char'}, PrimitiveTypeUsage{name='char'}] /repo/subprojects/core/src/main/java/org/gradle/cache/internal/DefaultCacheScopeMapping.java
Cannot solve method call getCacheDir(getBuildCacheDir(task.getProject().getRootProject()), versionStrategy, "tasks/" + task.getPath().replace(':', '_') + "/" + key) java.lang.RuntimeException: Method 'replace' cannot be resolved in context task.getPath().replace(':', '_') (line: 55) MethodCallExprContext{wrapped=task.getPath().replace(':', '_')}. Parameter types: [PrimitiveTypeUsage{name='char'}, PrimitiveTypeUsage{name='char'}] /repo/subprojects/core/src/main/java/org/gradle/cache/internal/DefaultCacheScopeMapping.java
Empty name expression CachePerVersion
Empty name expression SharedCache
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call String.format("Could not get unknown property '%s' for object of type %s.", name, publicType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context publicType.getName() (line: 89) MethodCallExprContext{wrapped=publicType.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/metaobject/AbstractDynamicObject.java
Cannot solve method call String.format("Could not get unknown property '%s' for %s of type %s.", name, getDisplayName(), publicType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context publicType.getName() (line: 86) MethodCallExprContext{wrapped=publicType.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/metaobject/AbstractDynamicObject.java
Cannot solve method call String.format("Cannot get the value of write-only property '%s' for object of type %s.", name, publicType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context publicType.getName() (line: 105) MethodCallExprContext{wrapped=publicType.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/metaobject/AbstractDynamicObject.java
Cannot solve method call String.format("Cannot get the value of write-only property '%s' for %s of type %s.", name, getDisplayName(), publicType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context publicType.getName() (line: 102) MethodCallExprContext{wrapped=publicType.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/metaobject/AbstractDynamicObject.java
Cannot solve method call String.format("Could not set unknown property '%s' for object of type %s.", name, publicType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context publicType.getName() (line: 121) MethodCallExprContext{wrapped=publicType.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/metaobject/AbstractDynamicObject.java
Cannot solve method call String.format("Could not set unknown property '%s' for %s of type %s.", name, getDisplayName(), publicType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context publicType.getName() (line: 118) MethodCallExprContext{wrapped=publicType.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/metaobject/AbstractDynamicObject.java
Cannot solve method call String.format("Cannot set the value of read-only property '%s' for object of type %s.", name, publicType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context publicType.getName() (line: 137) MethodCallExprContext{wrapped=publicType.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/metaobject/AbstractDynamicObject.java
Cannot solve method call String.format("Cannot set the value of read-only property '%s' for %s of type %s.", name, getDisplayName(), publicType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context publicType.getName() (line: 134) MethodCallExprContext{wrapped=publicType.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/metaobject/AbstractDynamicObject.java
Cannot solve method call String.format("Could not find method %s() for arguments %s on object of type %s.", name, Arrays.toString(params), publicType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context publicType.getName() (line: 177) MethodCallExprContext{wrapped=publicType.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/metaobject/AbstractDynamicObject.java
Cannot solve method call String.format("Could not find method %s() for arguments %s on %s of type %s.", name, Arrays.toString(params), getDisplayName(), publicType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context publicType.getName() (line: 175) MethodCallExprContext{wrapped=publicType.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/metaobject/AbstractDynamicObject.java
Cannot solve method call result.result(property.getProperty(bean)) java.lang.RuntimeException: Method 'getProperty' cannot be resolved in context property.getProperty(bean) (line: 197) MethodCallExprContext{wrapped=property.getProperty(bean)}. Parameter types: [ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/internal/metaobject/BeanDynamicObject.java
Cannot solve method call name.equals(e.getProperty()) java.lang.RuntimeException: Method 'getProperty' cannot be resolved in context e.getProperty() (line: 217) MethodCallExprContext{wrapped=e.getProperty()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/metaobject/BeanDynamicObject.java
Cannot solve method call result.result(propertyMissing.invoke(bean, new Object[] { name })) java.lang.RuntimeException: Method 'invoke' cannot be resolved in context propertyMissing.invoke(bean, new Object[] { name }) (line: 215) MethodCallExprContext{wrapped=propertyMissing.invoke(bean, new Object[] { name })}. Parameter types: [ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}, ResolvedArrayType{ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}] /repo/subprojects/core/src/main/java/org/gradle/internal/metaobject/BeanDynamicObject.java
Cannot solve method call name.equals(e.getProperty()) java.lang.RuntimeException: Method 'getProperty' cannot be resolved in context e.getProperty() (line: 226) MethodCallExprContext{wrapped=e.getProperty()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/metaobject/BeanDynamicObject.java
Method 'getName' cannot be resolved in context method.getName() (line: 248) MethodCallExprContext{wrapped=method.getName()}. Parameter types: []
Method 'getParameterTypes' cannot be resolved in context method.getParameterTypes() (line: 248) MethodCallExprContext{wrapped=method.getParameterTypes()}. Parameter types: []
Cannot solve method call propertySetTransformer.transformValue(property.getType(), value) java.lang.RuntimeException: Method 'getType' cannot be resolved in context property.getType() (line: 305) MethodCallExprContext{wrapped=property.getType()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/metaobject/BeanDynamicObject.java
Cannot solve method call propertySetTransformer.transformValue(metaBeanProperty.getField().getType(), value) UnsolvedSymbolException{context='unknown', name='MetaBeanProperty', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/internal/metaobject/BeanDynamicObject.java
Cannot solve method call MetaProperty.getSetterName(property.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context property.getName() (line: 280) MethodCallExprContext{wrapped=property.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/metaobject/BeanDynamicObject.java
Cannot solve method call name.equals(e.getProperty()) java.lang.RuntimeException: Method 'getProperty' cannot be resolved in context e.getProperty() (line: 321) MethodCallExprContext{wrapped=e.getProperty()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/metaobject/BeanDynamicObject.java
Method 'getName' cannot be resolved in context metaProperty.getName() (line: 339) MethodCallExprContext{wrapped=metaProperty.getName()}. Parameter types: []
Cannot solve method call properties.put(metaProperty.getName(), metaProperty.getProperty(bean)) java.lang.RuntimeException: Method 'getName' cannot be resolved in context metaProperty.getName() (line: 349) MethodCallExprContext{wrapped=metaProperty.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/metaobject/BeanDynamicObject.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call result.result(metaMethod.doMethodInvoke(bean, arguments)) java.lang.RuntimeException: Method 'doMethodInvoke' cannot be resolved in context metaMethod.doMethodInvoke(bean, arguments) (line: 382) MethodCallExprContext{wrapped=metaMethod.doMethodInvoke(bean, arguments)}. Parameter types: [ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}, ResolvedArrayType{ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}] /repo/subprojects/core/src/main/java/org/gradle/internal/metaobject/BeanDynamicObject.java
Method 'getParameterTypes' cannot be resolved in context method.getParameterTypes() (line: 388) MethodCallExprContext{wrapped=method.getParameterTypes()}. Parameter types: []
Cannot resolve field access null
Cannot solve method call argsTransformer.transform(method.getParameterTypes(), arguments) java.lang.RuntimeException: Method 'getParameterTypes' cannot be resolved in context method.getParameterTypes() (line: 391) MethodCallExprContext{wrapped=method.getParameterTypes()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/metaobject/BeanDynamicObject.java
Cannot solve method call result.result(method.doMethodInvoke(bean, transformed)) java.lang.RuntimeException: Method 'doMethodInvoke' cannot be resolved in context method.doMethodInvoke(bean, transformed) (line: 395) MethodCallExprContext{wrapped=method.doMethodInvoke(bean, transformed)}. Parameter types: [ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}, ResolvedArrayType{ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}] /repo/subprojects/core/src/main/java/org/gradle/internal/metaobject/BeanDynamicObject.java
Method 'getMethod' cannot be resolved in context e.getMethod() (line: 413) MethodCallExprContext{wrapped=e.getMethod()}. Parameter types: []
Cannot solve method call Arrays.equals(e.getArguments(), arguments) java.lang.RuntimeException: Method 'getArguments' cannot be resolved in context e.getArguments() (line: 413) MethodCallExprContext{wrapped=e.getArguments()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/metaobject/BeanDynamicObject.java
Cannot solve method call result.result(groovyObject.getProperty(name)) java.lang.RuntimeException: Method 'getProperty' cannot be resolved in context groovyObject.getProperty(name) (line: 443) MethodCallExprContext{wrapped=groovyObject.getProperty(name)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/internal/metaobject/BeanDynamicObject.java
Cannot solve method call Modifier.isStatic(metaProperty.getModifiers()) java.lang.RuntimeException: Method 'getModifiers' cannot be resolved in context metaProperty.getModifiers() (line: 496) MethodCallExprContext{wrapped=metaProperty.getModifiers()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/metaobject/BeanDynamicObject.java
Cannot solve method call Modifier.isStatic(metaMethod.getModifiers()) java.lang.RuntimeException: Method 'getModifiers' cannot be resolved in context metaMethod.getModifiers() (line: 510) MethodCallExprContext{wrapped=metaMethod.getModifiers()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/metaobject/BeanDynamicObject.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call closure.setResolveStrategy(Closure.DELEGATE_FIRST) UnsolvedSymbolException{context='unknown', name='DELEGATE_FIRST', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/internal/metaobject/MixInClosurePropertiesAsMethodsDynamicObject.java
Cannot solve method call result.result(closure.call(arguments)) java.lang.RuntimeException: Method 'call' cannot be resolved in context closure.call(arguments) (line: 45) MethodCallExprContext{wrapped=closure.call(arguments)}. Parameter types: [ResolvedArrayType{ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}] /repo/subprojects/core/src/main/java/org/gradle/internal/metaobject/MixInClosurePropertiesAsMethodsDynamicObject.java
Cannot solve method call DynamicObjectUtil.asDynamicObject(configureClosure.getOwner()) java.lang.RuntimeException: Method 'getOwner' cannot be resolved in context configureClosure.getOwner() (line: 35) MethodCallExprContext{wrapped=configureClosure.getOwner()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/metaobject/ConfigureDelegate.java
Method 'getCause' cannot be resolved in context getCause() (line: 85) MethodCallExprContext{wrapped=getCause()}. Parameter types: []
Cannot solve method call visitCauses(getCause(), new TreeVisitor<Throwable>() {

    @Override
    public void node(Throwable node) {
        causes.add(node);
    }
}) java.lang.RuntimeException: Method 'getCause' cannot be resolved in context getCause() (line: 112) MethodCallExprContext{wrapped=getCause()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/exceptions/LocationAwareException.java
Cannot solve method call visitCauses(getCause(), visitor) java.lang.RuntimeException: Method 'getCause' cannot be resolved in context getCause() (line: 126) MethodCallExprContext{wrapped=getCause()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/exceptions/LocationAwareException.java
Cannot solve method call visitor.node(t.getCause()) java.lang.RuntimeException: Method 'getCause' cannot be resolved in context t.getCause() (line: 155) MethodCallExprContext{wrapped=t.getCause()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/exceptions/LocationAwareException.java
Cannot solve field access Context.Outside
Cannot resolve field access null
Cannot solve field access Context.CData
Cannot solve field access Context.CData
Cannot solve field access Context.Outside
Cannot solve field access Context.StartTag
Cannot solve field access Context.Text
Cannot solve field access Context.StartTag
Cannot solve field access Context.ElementContent
Cannot solve field access Context.CData
Cannot solve field access Context.StartTag
Cannot solve field access Context.Outside
Cannot solve field access Context.CData
Cannot solve field access Context.StartTag
Cannot solve field access Context.Text
Cannot solve field access Context.ElementContent
Cannot solve field access Context.Outside
Cannot solve method call writeCDATA(cdata.charAt(i)) java.lang.RuntimeException: Method 'charAt' cannot be resolved in context cdata.charAt(i) (line: 171) MethodCallExprContext{wrapped=cdata.charAt(i)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/core/src/main/java/org/gradle/internal/xml/SimpleMarkupWriter.java
Cannot solve method call writeRaw(Integer.toHexString(ch)) UnsolvedSymbolException{context='Method 'toHexString' with parameterTypes [PrimitiveTypeUsage{name='char'}]', name='ReflectionClassDeclaration{clazz=Integer}'} /repo/subprojects/core/src/main/java/org/gradle/internal/xml/SimpleMarkupWriter.java
Cannot solve field access Context.CData
Cannot solve field access Context.CData
Cannot solve field access Context.CData
Cannot solve field access Context.Text
Cannot solve field access Context.StartTag
Cannot solve method call writeXmlAttributeEncoded(message.charAt(i)) java.lang.RuntimeException: Method 'charAt' cannot be resolved in context message.charAt(i) (line: 267) MethodCallExprContext{wrapped=message.charAt(i)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/core/src/main/java/org/gradle/internal/xml/SimpleMarkupWriter.java
Cannot solve method call writeXmlEncoded(message.charAt(i)) java.lang.RuntimeException: Method 'charAt' cannot be resolved in context message.charAt(i) (line: 287) MethodCallExprContext{wrapped=message.charAt(i)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/core/src/main/java/org/gradle/internal/xml/SimpleMarkupWriter.java
Method 'doTransform' cannot be resolved in context doTransform(stringWriter.toString()) (line: 98) MethodCallExprContext{wrapped=doTransform(stringWriter.toString())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
No matching between ReferenceType{Node, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual)
Cannot solve method call TextUtil.toPlatformLineSeparators(stripXmlDeclaration(stringValue)) com.github.javaparser.symbolsolver.logic.ConfilictingGenericTypesException: No matching between ReferenceType{CharSequence, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual) /repo/subprojects/core/src/main/java/org/gradle/internal/xml/XmlTransformer.java
Cannot solve method call writer.append(TextUtil.toPlatformLineSeparators(stripXmlDeclaration(stringValue))) java.lang.RuntimeException: Error calculating the type of parameter stripXmlDeclaration(stringValue) of method call TextUtil.toPlatformLineSeparators(stripXmlDeclaration(stringValue)) /repo/subprojects/core/src/main/java/org/gradle/internal/xml/XmlTransformer.java
Cannot solve method call TextUtil.toPlatformLineSeparators(stripXmlDeclaration(builder)) com.github.javaparser.symbolsolver.logic.ConfilictingGenericTypesException: No matching between ReferenceType{CharSequence, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{StringBuilder, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual) /repo/subprojects/core/src/main/java/org/gradle/internal/xml/XmlTransformer.java
Cannot solve method call writer.append(TextUtil.toPlatformLineSeparators(stripXmlDeclaration(builder))) java.lang.RuntimeException: Error calculating the type of parameter stripXmlDeclaration(builder) of method call TextUtil.toPlatformLineSeparators(stripXmlDeclaration(builder)) /repo/subprojects/core/src/main/java/org/gradle/internal/xml/XmlTransformer.java
Cannot solve method call printWriter.format("<!DOCTYPE %s PUBLIC \"%s\" \"%s\">%n", node.name(), publicId, systemId) java.lang.RuntimeException: Method 'name' cannot be resolved in context node.name() (line: 274) MethodCallExprContext{wrapped=node.name()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/xml/XmlTransformer.java
Cannot solve method call transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", String.valueOf(indentAmount)) UnsolvedSymbolException{context='Method 'valueOf' with parameterTypes [PrimitiveTypeUsage{name='int'}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/core/src/main/java/org/gradle/internal/xml/XmlTransformer.java
Cannot resolve field access null
Method 'getNodeValue' cannot be resolved in context child.getNodeValue() (line: 333) MethodCallExprContext{wrapped=child.getNodeValue()}. Parameter types: []
Method 'getNodeValue' cannot be resolved in context child.getNodeValue() (line: 333) MethodCallExprContext{wrapped=child.getNodeValue()}. Parameter types: []
Cannot solve method call str.substring(str.indexOf("?>") + 2) java.lang.RuntimeException: Method 'indexOf' cannot be resolved in context str.indexOf("?>") (line: 362) MethodCallExprContext{wrapped=str.indexOf("?>")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/internal/xml/XmlTransformer.java
Cannot solve method call values.addAll(cachedNodeValues.get(startNode)) java.lang.RuntimeException: N java.lang.Object /repo/subprojects/core/src/main/java/org/gradle/internal/graph/CachingDirectedGraphWalker.java
Method 'add' cannot be resolved in context graphWalker.add(node) (line: 34) MethodCallExprContext{wrapped=graphWalker.add(node)}. Parameter types: [TypeVariable {org.gradle.internal.graph.GraphAggregator.N}]
Cannot solve method call prefix.setLength(prefix.length() - 5) java.lang.RuntimeException: Method 'length' cannot be resolved in context prefix.length() (line: 62) MethodCallExprContext{wrapped=prefix.length()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/graph/GraphRenderer.java
Cannot resolve field access null
Cannot solve field access LogLevel.INFO
Cannot solve method call logInBoth(LogLevel.INFO, String.format("See %s for all output for %s.", getLogLocation(), configuration.getTaskName())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/core/src/main/java/org/gradle/internal/operations/logging/DefaultBuildOperationLogger.java
Cannot solve field access LogLevel.DEBUG
Cannot solve method call logInBoth(LogLevel.DEBUG, description.concat(" successful.")) java.lang.RuntimeException: Method 'concat' cannot be resolved in context description.concat(" successful.") (line: 69) MethodCallExprContext{wrapped=description.concat(" successful.")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/internal/operations/logging/DefaultBuildOperationLogger.java
Cannot solve field access LogLevel.DEBUG
Cannot solve method call logInBoth(LogLevel.DEBUG, description.concat(" failed.")) java.lang.RuntimeException: Method 'concat' cannot be resolved in context description.concat(" failed.") (line: 76) MethodCallExprContext{wrapped=description.concat(" failed.")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/internal/operations/logging/DefaultBuildOperationLogger.java
Cannot solve field access LogLevel.ERROR
Cannot solve method call logger.log(LogLevel.ERROR, String.format("...output for %d more failed operation(s) continued in %s.", suppressedCount, getLogLocation())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, PrimitiveTypeUsage{name='int'}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/core/src/main/java/org/gradle/internal/operations/logging/DefaultBuildOperationLogger.java
Cannot solve field access LogLevel.INFO
Cannot solve method call logInBoth(LogLevel.INFO, String.format("Finished %s, see full log %s.", configuration.getTaskName(), getLogLocation())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/core/src/main/java/org/gradle/internal/operations/logging/DefaultBuildOperationLogger.java
Cannot solve field access LogLevel.INFO
Cannot solve field access LogLevel.ERROR
Method 'getProtectionDomain' cannot be resolved in context clazz.getProtectionDomain() (line: 43) MethodCallExprContext{wrapped=clazz.getProtectionDomain()}. Parameter types: []
No matching between ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual)
Cannot solve method call delegate.convert(type.cast(notation), result) java.lang.RuntimeException: Method 'cast' cannot be resolved in context type.cast(notation) (line: 32) MethodCallExprContext{wrapped=type.cast(notation)}. Parameter types: [TypeVariable {org.gradle.internal.typeconversion.TypeFilteringNotationConverter.N}] /repo/subprojects/core/src/main/java/org/gradle/internal/typeconversion/TypeFilteringNotationConverter.java
Cannot solve method call String.format("Instances of %s.", passThroughType.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context passThroughType.getSimpleName() (line: 30) MethodCallExprContext{wrapped=passThroughType.getSimpleName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/typeconversion/JustReturningConverter.java
Cannot solve method call visitor.candidate(String.format("Instances of %s.", passThroughType.getSimpleName())) java.lang.RuntimeException: Error calculating the type of parameter passThroughType.getSimpleName() of method call String.format("Instances of %s.", passThroughType.getSimpleName()) /repo/subprojects/core/src/main/java/org/gradle/internal/typeconversion/JustReturningConverter.java
Cannot solve method call result.converted(passThroughType.cast(notation)) java.lang.RuntimeException: Method 'cast' cannot be resolved in context passThroughType.cast(notation) (line: 36) MethodCallExprContext{wrapped=passThroughType.cast(notation)}. Parameter types: [TypeVariable {org.gradle.internal.typeconversion.JustReturningConverter.N}] /repo/subprojects/core/src/main/java/org/gradle/internal/typeconversion/JustReturningConverter.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call ((MapKey) annotation).value() java.lang.UnsupportedOperationException: com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnnotationDeclaration /repo/subprojects/core/src/main/java/org/gradle/internal/typeconversion/MapNotationConverter.java
Cannot solve method call Arrays.asList(type.getEnumConstants()) java.lang.RuntimeException: Method 'getEnumConstants' cannot be resolved in context type.getEnumConstants() (line: 41) MethodCallExprContext{wrapped=type.getEnumConstants()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/typeconversion/EnumFromCharSequenceNotationParser.java
Method 'name' cannot be resolved in context enumValue.name() (line: 44) MethodCallExprContext{wrapped=enumValue.name()}. Parameter types: []
Cannot solve method call Arrays.asList(type.getEnumConstants()) java.lang.RuntimeException: Method 'getEnumConstants' cannot be resolved in context type.getEnumConstants() (line: 50) MethodCallExprContext{wrapped=type.getEnumConstants()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/typeconversion/EnumFromCharSequenceNotationParser.java
Cannot solve method call CollectionUtils.collect(Arrays.asList(type.getEnumConstants()), new Transformer<String, T>() {

    @Override
    public String transform(T t) {
        return t.name();
    }
}) java.lang.RuntimeException: Error calculating the type of parameter type.getEnumConstants() of method call Arrays.asList(type.getEnumConstants()) /repo/subprojects/core/src/main/java/org/gradle/internal/typeconversion/EnumFromCharSequenceNotationParser.java
Cannot solve method call String.format("Cannot convert string value '%s' to an enum value of type '%s' (valid case insensitive values: %s)", enumString, type.getName(), Joiner.on(", ").join(CollectionUtils.collect(Arrays.asList(type.getEnumConstants()), new Transformer<String, T>() {

    @Override
    public String transform(T t) {
        return t.name();
    }
}))) java.lang.RuntimeException: Method 'getName' cannot be resolved in context type.getName() (line: 50) MethodCallExprContext{wrapped=type.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/typeconversion/EnumFromCharSequenceNotationParser.java
Cannot solve method call values.add(enumConstant.name()) java.lang.RuntimeException: Method 'name' cannot be resolved in context enumConstant.name() (line: 67) MethodCallExprContext{wrapped=enumConstant.name()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/typeconversion/EnumFromCharSequenceNotationParser.java
Cannot solve method call String.format("One of the following values: %s", GUtil.toString(values)) UnsolvedSymbolException{context='Method 'toString' with parameterTypes [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public class GUtil {

    private static final Pattern WORD_SEPARATOR = Pattern.compile("\\W+");

    private static final Pattern UPPER_LOWER = Pattern.compile("(?m)([A-Z]*)([a-z0-9]*)");

    public static <T extends Collection> T flatten(Object[] elements, T addTo, boolean flattenMaps) {
        return flatten(asList(elements), addTo, flattenMaps);
    }

    public static <T extends Collection> T flatten(Object[] elements, T addTo) {
        return flatten(asList(elements), addTo);
    }

    public static <T extends Collection> T flatten(Collection elements, T addTo) {
        return flatten(elements, addTo, true);
    }

    public static <T extends Collection> T flattenElements(Object... elements) {
        Collection<T> out = new LinkedList<T>();
        flatten(elements, out, true);
        return (T) out;
    }

    public static <T extends Collection> T flatten(Collection elements, T addTo, boolean flattenMapsAndArrays) {
        return flatten(elements, addTo, flattenMapsAndArrays, flattenMapsAndArrays);
    }

    public static <T extends Collection> T flatten(Collection elements, T addTo, boolean flattenMaps, boolean flattenArrays) {
        Iterator iter = elements.iterator();
        while (iter.hasNext()) {
            Object element = iter.next();
            if (element instanceof Collection) {
                flatten((Collection) element, addTo, flattenMaps, flattenArrays);
            } else if ((element instanceof Map) && flattenMaps) {
                flatten(((Map) element).values(), addTo, flattenMaps, flattenArrays);
            } else if ((element.getClass().isArray()) && flattenArrays) {
                flatten(asList((Object[]) element), addTo, flattenMaps, flattenArrays);
            } else {
                addTo.add(element);
            }
        }
        return addTo;
    }

    /**
     * Flattens input collections (including arrays *but* not maps). If input is not a collection wraps it in a collection and returns it.
     *
     * @param input any object
     * @return collection of flattened input or single input wrapped in a collection.
     */
    public static Collection collectionize(Object input) {
        if (input == null) {
            return emptyList();
        } else if (input instanceof Collection) {
            Collection out = new LinkedList();
            flatten((Collection) input, out, false, true);
            return out;
        } else if (input.getClass().isArray()) {
            Collection out = new LinkedList();
            flatten(asList((Object[]) input), out, false, true);
            return out;
        } else {
            return asList(input);
        }
    }

    public static List flatten(Collection elements, boolean flattenMapsAndArrays) {
        return flatten(elements, new ArrayList(), flattenMapsAndArrays);
    }

    public static List flatten(Collection elements) {
        return flatten(elements, new ArrayList());
    }

    public static String asPath(Iterable<?> collection) {
        return CollectionUtils.join(File.pathSeparator, collection);
    }

    public static List<String> prefix(String prefix, Collection<String> strings) {
        List<String> prefixed = new ArrayList<String>();
        for (String string : strings) {
            prefixed.add(prefix + string);
        }
        return prefixed;
    }

    public static boolean isTrue(Object object) {
        if (object == null) {
            return false;
        }
        if (object instanceof Collection) {
            return ((Collection) object).size() > 0;
        } else if (object instanceof String) {
            return ((String) object).length() > 0;
        }
        return true;
    }

    public static <T> T elvis(T object, T defaultValue) {
        return isTrue(object) ? object : defaultValue;
    }

    public static <V, T extends Collection<? super V>> T addToCollection(T dest, boolean failOnNull, Iterable<? extends V>... srcs) {
        for (Iterable<? extends V> src : srcs) {
            for (V v : src) {
                if (failOnNull && v == null) {
                    throw new IllegalArgumentException("Illegal null value provided in this collection: " + src);
                }
                dest.add(v);
            }
        }
        return dest;
    }

    public static <V, T extends Collection<? super V>> T addToCollection(T dest, Iterable<? extends V>... srcs) {
        return addToCollection(dest, false, srcs);
    }

    public static Comparator<String> caseInsensitive() {
        return new Comparator<String>() {

            public int compare(String o1, String o2) {
                int diff = o1.compareToIgnoreCase(o2);
                if (diff != 0) {
                    return diff;
                }
                return o1.compareTo(o2);
            }
        };
    }

    public static Map addMaps(Map map1, Map map2) {
        HashMap map = new HashMap();
        map.putAll(map1);
        map.putAll(map2);
        return map;
    }

    public static void addToMap(Map<String, String> dest, Map<?, ?> src) {
        for (Map.Entry<?, ?> entry : src.entrySet()) {
            dest.put(entry.getKey().toString(), entry.getValue().toString());
        }
    }

    public static Properties loadProperties(File propertyFile) {
        try {
            FileInputStream inputStream = new FileInputStream(propertyFile);
            try {
                return loadProperties(inputStream);
            } finally {
                inputStream.close();
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static Properties loadProperties(URL url) {
        try {
            URLConnection uc = url.openConnection();
            uc.setUseCaches(false);
            return loadProperties(uc.getInputStream());
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static Properties loadProperties(InputStream inputStream) {
        Properties properties = new Properties();
        try {
            properties.load(inputStream);
            inputStream.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
        return properties;
    }

    public static void saveProperties(Properties properties, File propertyFile) {
        try {
            FileOutputStream propertiesFileOutputStream = new FileOutputStream(propertyFile);
            try {
                properties.store(propertiesFileOutputStream, null);
            } finally {
                propertiesFileOutputStream.close();
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static void saveProperties(Properties properties, OutputStream outputStream) {
        try {
            try {
                properties.store(outputStream, null);
            } finally {
                outputStream.close();
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static void savePropertiesNoDateComment(Properties properties, OutputStream outputStream) {
        saveProperties(properties, new LineBufferingOutputStream(new SkipFirstTextStream(new WriterTextStream(new OutputStreamWriter(outputStream, Charsets.ISO_8859_1)))));
    }

    public static Map map(Object... objects) {
        Map map = new HashMap();
        assert objects.length % 2 == 0;
        for (int i = 0; i < objects.length; i += 2) {
            map.put(objects[i], objects[i + 1]);
        }
        return map;
    }

    public static String toString(Iterable<?> names) {
        Formatter formatter = new Formatter();
        boolean first = true;
        for (Object name : names) {
            if (first) {
                formatter.format("'%s'", name);
                first = false;
            } else {
                formatter.format(", '%s'", name);
            }
        }
        return formatter.toString();
    }

    /**
     * Converts an arbitrary string to a camel-case string which can be used in a Java identifier. Eg, with_underscores -> withUnderscores
     */
    public static String toCamelCase(CharSequence string) {
        if (string == null) {
            return null;
        }
        StringBuilder builder = new StringBuilder();
        Matcher matcher = WORD_SEPARATOR.matcher(string);
        int pos = 0;
        while (matcher.find()) {
            builder.append(StringUtils.capitalize(string.subSequence(pos, matcher.start()).toString()));
            pos = matcher.end();
        }
        builder.append(StringUtils.capitalize(string.subSequence(pos, string.length()).toString()));
        return builder.toString();
    }

    public static String toLowerCamelCase(CharSequence string) {
        String camelCase = toCamelCase(string);
        if (camelCase == null) {
            return null;
        }
        if (camelCase.length() == 0) {
            return "";
        }
        return ((Character) camelCase.charAt(0)).toString().toLowerCase() + camelCase.subSequence(1, camelCase.length());
    }

    /**
     * Converts an arbitrary string to upper case identifier with words separated by _. Eg, camelCase -> CAMEL_CASE
     */
    public static String toConstant(CharSequence string) {
        if (string == null) {
            return null;
        }
        return toWords(string, '_').toUpperCase();
    }

    /**
     * Converts an arbitrary string to space-separated words. Eg, camelCase -> camel case, with_underscores -> with underscores
     */
    public static String toWords(CharSequence string) {
        return toWords(string, ' ');
    }

    public static String toWords(CharSequence string, char separator) {
        if (string == null) {
            return null;
        }
        StringBuilder builder = new StringBuilder();
        int pos = 0;
        Matcher matcher = UPPER_LOWER.matcher(string);
        while (pos < string.length()) {
            matcher.find(pos);
            if (matcher.end() == pos) {
                // Not looking at a match
                pos++;
                continue;
            }
            if (builder.length() > 0) {
                builder.append(separator);
            }
            String group1 = matcher.group(1).toLowerCase();
            String group2 = matcher.group(2);
            if (group2.length() == 0) {
                builder.append(group1);
            } else {
                if (group1.length() > 1) {
                    builder.append(group1.substring(0, group1.length() - 1));
                    builder.append(separator);
                    builder.append(group1.substring(group1.length() - 1));
                } else {
                    builder.append(group1);
                }
                builder.append(group2);
            }
            pos = matcher.end();
        }
        return builder.toString();
    }

    public static byte[] serialize(Object object) {
        StreamByteBuffer buffer = new StreamByteBuffer();
        serialize(object, buffer.getOutputStream());
        return buffer.readAsByteArray();
    }

    public static void serialize(Object object, OutputStream outputStream) {
        try {
            ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);
            objectOutputStream.writeObject(object);
            objectOutputStream.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static <T> Comparator<T> last(final Comparator<? super T> comparator, final T lastValue) {
        return new Comparator<T>() {

            public int compare(T o1, T o2) {
                boolean o1Last = comparator.compare(o1, lastValue) == 0;
                boolean o2Last = comparator.compare(o2, lastValue) == 0;
                if (o1Last && o2Last) {
                    return 0;
                }
                if (o1Last && !o2Last) {
                    return 1;
                }
                if (!o1Last && o2Last) {
                    return -1;
                }
                return comparator.compare(o1, o2);
            }
        };
    }

    /**
     * Calls the given callable converting any thrown exception to an unchecked exception via {@link UncheckedException#throwAsUncheckedException(Throwable)}
     *
     * @param callable The callable to call
     * @param <T> Callable's return type
     * @return The value returned by {@link Callable#call()}
     */
    public static <T> T uncheckedCall(Callable<T> callable) {
        try {
            return callable.call();
        } catch (Exception e) {
            throw UncheckedException.throwAsUncheckedException(e);
        }
    }
}}'} /repo/subprojects/core/src/main/java/org/gradle/internal/typeconversion/EnumFromCharSequenceNotationParser.java
Cannot solve method call visitor.candidate(String.format("One of the following values: %s", GUtil.toString(values))) java.lang.RuntimeException: Error calculating the type of parameter GUtil.toString(values) of method call String.format("One of the following values: %s", GUtil.toString(values)) /repo/subprojects/core/src/main/java/org/gradle/internal/typeconversion/EnumFromCharSequenceNotationParser.java
Cannot solve method call String.format("Closure that returns boolean and takes a single %s as a parameter.", type.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context type.getSimpleName() (line: 38) MethodCallExprContext{wrapped=type.getSimpleName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/typeconversion/ClosureToSpecNotationConverter.java
Cannot solve method call visitor.candidate(String.format("Closure that returns boolean and takes a single %s as a parameter.", type.getSimpleName())) java.lang.RuntimeException: Error calculating the type of parameter type.getSimpleName() of method call String.format("Closure that returns boolean and takes a single %s as a parameter.", type.getSimpleName()) /repo/subprojects/core/src/main/java/org/gradle/internal/typeconversion/ClosureToSpecNotationConverter.java
Cannot solve method call String.format("Instances of %s.", typeToken.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context typeToken.getSimpleName() (line: 37) MethodCallExprContext{wrapped=typeToken.getSimpleName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/typeconversion/TypedNotationConverter.java
Cannot solve method call visitor.candidate(String.format("Instances of %s.", typeToken.getSimpleName())) java.lang.RuntimeException: Error calculating the type of parameter typeToken.getSimpleName() of method call String.format("Instances of %s.", typeToken.getSimpleName()) /repo/subprojects/core/src/main/java/org/gradle/internal/typeconversion/TypedNotationConverter.java
Cannot solve method call parseType(typeToken.cast(notation)) java.lang.RuntimeException: Method 'cast' cannot be resolved in context typeToken.cast(notation) (line: 43) MethodCallExprContext{wrapped=typeToken.cast(notation)}. Parameter types: [ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/internal/typeconversion/TypedNotationConverter.java
Cannot solve method call result.converted(parseType(typeToken.cast(notation))) java.lang.RuntimeException: Error calculating the type of parameter typeToken.cast(notation) of method call parseType(typeToken.cast(notation)) /repo/subprojects/core/src/main/java/org/gradle/internal/typeconversion/TypedNotationConverter.java
Cannot solve method call "an object of type ".concat(resultingType.getTargetType().getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context resultingType.getTargetType().getSimpleName() (line: 123) MethodCallExprContext{wrapped=resultingType.getTargetType().getSimpleName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/typeconversion/NotationParserBuilder.java
T ? extends T
Cannot solve method call visitor.candidate("A " + type.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context type.getSimpleName() (line: 94) MethodCallExprContext{wrapped=type.getSimpleName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/typeconversion/DefaultTypeConverter.java
Cannot solve method call String.format("Cannot convert value '%s' to type %s", notation, type.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context type.getSimpleName() (line: 144) MethodCallExprContext{wrapped=type.getSimpleName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/typeconversion/DefaultTypeConverter.java
Cannot solve method call String.format("Cannot convert value '%s' to type %s", notation, type.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context type.getSimpleName() (line: 134) MethodCallExprContext{wrapped=type.getSimpleName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/typeconversion/DefaultTypeConverter.java
Cannot solve method call String.format("Cannot convert value '%s' to type %s", notation, type.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context type.getSimpleName() (line: 137) MethodCallExprContext{wrapped=type.getSimpleName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/typeconversion/DefaultTypeConverter.java
Cannot solve method call result.converted(fileResolver.resolve(notation)) com.github.javaparser.symbolsolver.logic.ConfilictingGenericTypesException: No matching between ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual) /repo/subprojects/core/src/main/java/org/gradle/internal/typeconversion/DefaultTypeConverter.java
No matching between ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{CharSequence, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual)
No matching between ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{CharSequence, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual)
Cannot solve method call String.format("Cannot convert string value '%s' with length %d to type %s", notation, notation.length(), target.getSimpleName()) java.lang.RuntimeException: Method 'length' cannot be resolved in context notation.length() (line: 317) MethodCallExprContext{wrapped=notation.length()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/typeconversion/DefaultTypeConverter.java
Cannot solve method call result.converted(notation.charAt(0)) java.lang.RuntimeException: Method 'charAt' cannot be resolved in context notation.charAt(0) (line: 320) MethodCallExprContext{wrapped=notation.charAt(0)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/core/src/main/java/org/gradle/internal/typeconversion/DefaultTypeConverter.java
Cannot solve field access ShowStacktrace.ALWAYS_FULL
Cannot solve method call DefaultModelSchemaExtractor.withDefaultStrategies(serviceRegistry.getAll(ModelSchemaExtractionStrategy.class), aspectExtractor) java.lang.RuntimeException: Method 'getAll' cannot be resolved in context serviceRegistry.getAll(ModelSchemaExtractionStrategy.class) (line: 336) MethodCallExprContext{wrapped=serviceRegistry.getAll(ModelSchemaExtractionStrategy.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.model.internal.manage.schema.extract.ModelSchemaExtractionStrategy, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/core/src/main/java/org/gradle/internal/service/scopes/GlobalScopeServices.java
Cannot solve method call parentRegistry.createChild(get(GradleInternal.class).getClassLoaderScope()) java.lang.RuntimeException: Method 'getClassLoaderScope' cannot be resolved in context get(GradleInternal.class).getClassLoaderScope() (line: 149) MethodCallExprContext{wrapped=get(GradleInternal.class).getClassLoaderScope()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/service/scopes/GradleScopeServices.java
Method 'displayName' cannot be resolved in context ServiceRegistryBuilder.builder().parent(sharedServices).displayName("services for Gradle user home dir " + gradleUserHomeDir) (line: 82) MethodCallExprContext{wrapped=ServiceRegistryBuilder.builder().parent(sharedServices).displayName("services for Gradle user home dir " + gradleUserHomeDir)}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'displayName' cannot be resolved in context ServiceRegistryBuilder.builder().parent(sharedServices).displayName("services for Gradle user home dir " + gradleUserHomeDir) (line: 82) MethodCallExprContext{wrapped=ServiceRegistryBuilder.builder().parent(sharedServices).displayName("services for Gradle user home dir " + gradleUserHomeDir)}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'displayName' cannot be resolved in context ServiceRegistryBuilder.builder().parent(sharedServices).displayName("services for Gradle user home dir " + gradleUserHomeDir) (line: 82) MethodCallExprContext{wrapped=ServiceRegistryBuilder.builder().parent(sharedServices).displayName("services for Gradle user home dir " + gradleUserHomeDir)}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'createChild' cannot be resolved in context project.getClassLoaderScope().createChild("plugins") (line: 110) MethodCallExprContext{wrapped=project.getClassLoaderScope().createChild("plugins")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call parentRegistry.createChild(project.getClassLoaderScope().createChild("plugins").lock()) java.lang.RuntimeException: Method 'createChild' cannot be resolved in context project.getClassLoaderScope().createChild("plugins") (line: 110) MethodCallExprContext{wrapped=project.getClassLoaderScope().createChild("plugins")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/internal/service/scopes/ProjectScopeServices.java
Cannot solve method call delegate.search(toPath(key, "*")) java.lang.RuntimeException: Method 'toPath' cannot be resolved in context toPath(key, "*") (line: 50) MethodCallExprContext{wrapped=toPath(key, "*")}. Parameter types: [TypeVariable {org.gradle.internal.resource.local.GroupedAndNamedUniqueFileStore.K}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/internal/resource/local/GroupedAndNamedUniqueFileStore.java
Cannot solve method call String.format("'%s'(%s)", getName(), getType().getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context getType().getSimpleName() (line: 67) MethodCallExprContext{wrapped=getType().getSimpleName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/authentication/AbstractAuthentication.java
Cannot solve field access Type.CREATE
Cannot solve field access Type.MODIFY
Cannot solve field access Type.DELETE
Cannot solve field access Type.UNDEFINED
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call LOGGER.debug("Interrupting poller thread '{}'", pollerThread.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context pollerThread.getName() (line: 186) MethodCallExprContext{wrapped=pollerThread.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/filewatch/jdk7/WatchServiceFileWatcherBacking.java
Cannot resolve field access null
Cannot solve field access FileWatcherEvent.Type.UNDEFINED
Cannot resolve field access null
Cannot solve field access FileWatcherEvent.Type.CREATE
Cannot solve method call isAncestorOfAnyRoot(directory, allRequestedRoots, true) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/internal/filewatch/jdk7/WatchPointsRegistry.java
Cannot solve method call LOG.debug("not watching directory: {} allRequestedRoots: {} roots: {} unfiltered: {}", directory, allRequestedRoots, rootSubset.roots, rootSubset.combinedFileSystemSubset) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/internal/filewatch/jdk7/WatchPointsRegistry.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call Iterables.concat(currentWatchPoints, startingWatchPointCandidates) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/internal/filewatch/jdk7/WatchPointsRegistry.java
Cannot solve method call FileUtils.calculateRoots(Iterables.concat(currentWatchPoints, startingWatchPointCandidates)) java.lang.RuntimeException: Error calculating the type of parameter currentWatchPoints of method call Iterables.concat(currentWatchPoints, startingWatchPointCandidates) /repo/subprojects/core/src/main/java/org/gradle/internal/filewatch/jdk7/WatchPointsRegistry.java
Error calculating the type of parameter currentWatchPoints of method call ImmutableSet.<File>builder().addAll(currentWatchPoints)
Error calculating the type of parameter currentWatchPoints of method call ImmutableSet.<File>builder().addAll(currentWatchPoints)
Error calculating the type of parameter allRequestedRoots of method call ImmutableSet.<File>builder().addAll(allRequestedRoots)
Error calculating the type of parameter allRequestedRoots of method call ImmutableSet.<File>builder().addAll(allRequestedRoots)
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call isAncestorOfAnyRoot(file, allRequestedRoots) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/internal/filewatch/jdk7/WatchPointsRegistry.java
Cannot solve method call isAncestorOfAnyRoot(file, currentWatchPoints) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/internal/filewatch/jdk7/WatchPointsRegistry.java
Cannot solve method call LOG.debug("not watching file: {} currentWatchPoints: {} allRequestedRoots: {} roots: {} unfiltered: {}", file, currentWatchPoints, allRequestedRoots, roots, combinedRoots) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/internal/filewatch/jdk7/WatchPointsRegistry.java
Cannot resolve field access null
Cannot solve field access FileWatcherEvent.Type.MODIFY
Cannot solve method call aggregatedEvents.put(file, event.getType()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context event.getType() (line: 53) MethodCallExprContext{wrapped=event.getType()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/filewatch/ChangeReporter.java
Method 'getFile' cannot be resolved in context event.getFile() (line: 65) MethodCallExprContext{wrapped=event.getFile()}. Parameter types: []
Cannot solve field access LogLevel.LIFECYCLE
Cannot solve field access LogLevel.LIFECYCLE
Cannot solve field access TaskExecutionOutcome.FROM_CACHE
Cannot solve field access TaskExecutionOutcome.UP_TO_DATE
Cannot solve field access TaskExecutionOutcome.SKIPPED
Cannot solve field access TaskExecutionOutcome.EXECUTED
Cannot solve field access LogLevel.ERROR
Cannot solve field access LogLevel.ERROR
Cannot solve field access ShowStacktrace.INTERNAL_EXCEPTIONS
Cannot solve field access ExceptionStyle.FULL
Cannot solve method call getMessage(scriptException.getCause()) java.lang.RuntimeException: Method 'getCause' cannot be resolved in context scriptException.getCause() (line: 143) MethodCallExprContext{wrapped=scriptException.getCause()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/buildevents/BuildExceptionReporter.java
Cannot solve method call details.details.text(getMessage(scriptException.getCause())) java.lang.RuntimeException: Error calculating the type of parameter scriptException.getCause() of method call getMessage(scriptException.getCause()) /repo/subprojects/core/src/main/java/org/gradle/internal/buildevents/BuildExceptionReporter.java
Method 'text' cannot be resolved in context details.details.style(Info).text("> ") (line: 168) MethodCallExprContext{wrapped=details.details.style(Info).text("> ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve field access ExceptionStyle.NONE
Cannot solve field access LogLevel.DEBUG
Cannot solve field access LogLevel.INFO
Empty name expression NONE
Empty name expression FULL
Cannot solve field access ExceptionStyle.NONE
Cannot solve method call currentTask.setDescription("Execute ".concat(displayName)) java.lang.RuntimeException: Method 'concat' cannot be resolved in context "Execute ".concat(displayName) (line: 50) MethodCallExprContext{wrapped="Execute ".concat(displayName)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/internal/buildevents/TaskExecutionLogger.java
Cannot resolve field access null
Cannot solve field access FileLockManager.LockMode.None
Cannot resolve field access null
Cannot solve field access CacheBuilder.LockTarget.DefaultTarget
Method 'cache' cannot be resolved in context cacheRepository.cache("jars-2") (line: 47) MethodCallExprContext{wrapped=cacheRepository.cache("jars-2")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'cache' cannot be resolved in context cacheRepository.cache("jars-2") (line: 47) MethodCallExprContext{wrapped=cacheRepository.cache("jars-2")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'cache' cannot be resolved in context cacheRepository.cache("jars-2") (line: 47) MethodCallExprContext{wrapped=cacheRepository.cache("jars-2")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'cache' cannot be resolved in context cacheRepository.cache("jars-2") (line: 47) MethodCallExprContext{wrapped=cacheRepository.cache("jars-2")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call scripts.containsKey(directCaller.getFileName()) java.lang.RuntimeException: Method 'getFileName' cannot be resolved in context directCaller.getFileName() (line: 62) MethodCallExprContext{wrapped=directCaller.getFileName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/featurelifecycle/ScriptUsageLocationReporter.java
Method 'getClassName' cannot be resolved in context stack.get(caller).getClassName() (line: 68) MethodCallExprContext{wrapped=stack.get(caller).getClassName()}. Parameter types: []
Cannot solve method call scripts.containsKey(indirectCaller.getFileName()) java.lang.RuntimeException: Method 'getFileName' cannot be resolved in context indirectCaller.getFileName() (line: 75) MethodCallExprContext{wrapped=indirectCaller.getFileName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/featurelifecycle/ScriptUsageLocationReporter.java
Cannot solve method call scripts.get(stackTraceElement.getFileName()) java.lang.RuntimeException: Method 'getFileName' cannot be resolved in context stackTraceElement.getFileName() (line: 81) MethodCallExprContext{wrapped=stackTraceElement.getFileName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/featurelifecycle/ScriptUsageLocationReporter.java
Cannot solve method call target.append(StringUtils.capitalize(scriptSource.getDisplayName())) UnsolvedSymbolException{context='Method 'capitalize' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=org.apache.commons.lang.StringUtils}'} /repo/subprojects/core/src/main/java/org/gradle/internal/featurelifecycle/ScriptUsageLocationReporter.java
Cannot solve method call target.append(stackTraceElement.getLineNumber()) java.lang.RuntimeException: Method 'getLineNumber' cannot be resolved in context stackTraceElement.getLineNumber() (line: 85) MethodCallExprContext{wrapped=stackTraceElement.getLineNumber()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/internal/featurelifecycle/ScriptUsageLocationReporter.java
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 54) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 54) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 54) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 54) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 54) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 54) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 54) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 54) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 69) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 69) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 69) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 69) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 69) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 69) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 69) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 69) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 69) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 69) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 69) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 69) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 69) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 69) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 69) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 69) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 69) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 69) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 69) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 69) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 69) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 69) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 69) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 69) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 69) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 69) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 69) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 69) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 76) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 76) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("h2") (line: 77) MethodCallExprContext{wrapped=htmlWriter.startElement("h2")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("h2") (line: 77) MethodCallExprContext{wrapped=htmlWriter.startElement("h2")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("th") (line: 81) MethodCallExprContext{wrapped=htmlWriter.startElement("th")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("th") (line: 81) MethodCallExprContext{wrapped=htmlWriter.startElement("th")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("th") (line: 82) MethodCallExprContext{wrapped=htmlWriter.startElement("th")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("th") (line: 82) MethodCallExprContext{wrapped=htmlWriter.startElement("th")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("th") (line: 82) MethodCallExprContext{wrapped=htmlWriter.startElement("th")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 86) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 86) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 87) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 87) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 87) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 90) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 90) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 91) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 91) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 91) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 94) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 94) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 95) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 95) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 95) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 98) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 98) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 99) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 99) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 99) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 102) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 102) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 103) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 103) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 103) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 106) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 106) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 107) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 107) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 107) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 111) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 111) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("h2") (line: 112) MethodCallExprContext{wrapped=htmlWriter.startElement("h2")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("h2") (line: 112) MethodCallExprContext{wrapped=htmlWriter.startElement("h2")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("th") (line: 116) MethodCallExprContext{wrapped=htmlWriter.startElement("th")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("th") (line: 116) MethodCallExprContext{wrapped=htmlWriter.startElement("th")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("th") (line: 117) MethodCallExprContext{wrapped=htmlWriter.startElement("th")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("th") (line: 117) MethodCallExprContext{wrapped=htmlWriter.startElement("th")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("th") (line: 117) MethodCallExprContext{wrapped=htmlWriter.startElement("th")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 121) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 121) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 122) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 122) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 122) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 126) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 126) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 127) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 127) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 127) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 132) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 132) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("h2") (line: 133) MethodCallExprContext{wrapped=htmlWriter.startElement("h2")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("h2") (line: 133) MethodCallExprContext{wrapped=htmlWriter.startElement("h2")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("h2") (line: 133) MethodCallExprContext{wrapped=htmlWriter.startElement("h2")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("h2") (line: 133) MethodCallExprContext{wrapped=htmlWriter.startElement("h2")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("th") (line: 137) MethodCallExprContext{wrapped=htmlWriter.startElement("th")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("th") (line: 137) MethodCallExprContext{wrapped=htmlWriter.startElement("th")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("th") (line: 138) MethodCallExprContext{wrapped=htmlWriter.startElement("th")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("th") (line: 138) MethodCallExprContext{wrapped=htmlWriter.startElement("th")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("th") (line: 138) MethodCallExprContext{wrapped=htmlWriter.startElement("th")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 142) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 142) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 143) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 143) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 143) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 148) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 148) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 149) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 149) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("td") (line: 149) MethodCallExprContext{wrapped=htmlWriter.startElement("td")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 154) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 154) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("h2") (line: 155) MethodCallExprContext{wrapped=htmlWriter.startElement("h2")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("h2") (line: 155) MethodCallExprContext{wrapped=htmlWriter.startElement("h2")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("h2") (line: 155) MethodCallExprContext{wrapped=htmlWriter.startElement("h2")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("h2") (line: 155) MethodCallExprContext{wrapped=htmlWriter.startElement("h2")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("h2") (line: 155) MethodCallExprContext{wrapped=htmlWriter.startElement("h2")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("h2") (line: 155) MethodCallExprContext{wrapped=htmlWriter.startElement("h2")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("h2") (line: 155) MethodCallExprContext{wrapped=htmlWriter.startElement("h2")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("h2") (line: 155) MethodCallExprContext{wrapped=htmlWriter.startElement("h2")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("h2") (line: 155) MethodCallExprContext{wrapped=htmlWriter.startElement("h2")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("h2") (line: 155) MethodCallExprContext{wrapped=htmlWriter.startElement("h2")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("h2") (line: 155) MethodCallExprContext{wrapped=htmlWriter.startElement("h2")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("h2") (line: 155) MethodCallExprContext{wrapped=htmlWriter.startElement("h2")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("h2") (line: 155) MethodCallExprContext{wrapped=htmlWriter.startElement("h2")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("h2") (line: 155) MethodCallExprContext{wrapped=htmlWriter.startElement("h2")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("h2") (line: 155) MethodCallExprContext{wrapped=htmlWriter.startElement("h2")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("h2") (line: 155) MethodCallExprContext{wrapped=htmlWriter.startElement("h2")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("h2") (line: 155) MethodCallExprContext{wrapped=htmlWriter.startElement("h2")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("tr") (line: 165) MethodCallExprContext{wrapped=htmlWriter.startElement("tr")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("tr") (line: 165) MethodCallExprContext{wrapped=htmlWriter.startElement("tr")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("tr") (line: 165) MethodCallExprContext{wrapped=htmlWriter.startElement("tr")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("tr") (line: 165) MethodCallExprContext{wrapped=htmlWriter.startElement("tr")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("tr") (line: 165) MethodCallExprContext{wrapped=htmlWriter.startElement("tr")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("tr") (line: 165) MethodCallExprContext{wrapped=htmlWriter.startElement("tr")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("tr") (line: 165) MethodCallExprContext{wrapped=htmlWriter.startElement("tr")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("tr") (line: 165) MethodCallExprContext{wrapped=htmlWriter.startElement("tr")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("tr") (line: 165) MethodCallExprContext{wrapped=htmlWriter.startElement("tr")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("tr") (line: 165) MethodCallExprContext{wrapped=htmlWriter.startElement("tr")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("tr") (line: 165) MethodCallExprContext{wrapped=htmlWriter.startElement("tr")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("tr") (line: 171) MethodCallExprContext{wrapped=htmlWriter.startElement("tr")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("tr") (line: 171) MethodCallExprContext{wrapped=htmlWriter.startElement("tr")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("tr") (line: 171) MethodCallExprContext{wrapped=htmlWriter.startElement("tr")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("tr") (line: 171) MethodCallExprContext{wrapped=htmlWriter.startElement("tr")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("tr") (line: 171) MethodCallExprContext{wrapped=htmlWriter.startElement("tr")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("tr") (line: 171) MethodCallExprContext{wrapped=htmlWriter.startElement("tr")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("tr") (line: 171) MethodCallExprContext{wrapped=htmlWriter.startElement("tr")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("tr") (line: 171) MethodCallExprContext{wrapped=htmlWriter.startElement("tr")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("tr") (line: 171) MethodCallExprContext{wrapped=htmlWriter.startElement("tr")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("tr") (line: 171) MethodCallExprContext{wrapped=htmlWriter.startElement("tr")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("tr") (line: 171) MethodCallExprContext{wrapped=htmlWriter.startElement("tr")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("tr") (line: 171) MethodCallExprContext{wrapped=htmlWriter.startElement("tr")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call CLASS_GENERATOR.newInstance(DefaultProject.class, name, parentProject, (projectDir != null) ? projectDir.getAbsoluteFile() : new File(parentProject.getProjectDir(), name), new StringScriptSource("test build file", null), parentProject.getGradle(), parentProject.getGradle().getServiceRegistryFactory(), parentProject.getClassLoaderScope().createChild("project-" + name), parentProject.getBaseClassLoaderScope()) java.lang.RuntimeException: Method 'createChild' cannot be resolved in context parentProject.getClassLoaderScope().createChild("project-" + name) (line: 60) MethodCallExprContext{wrapped=parentProject.getClassLoaderScope().createChild("project-" + name)}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/testfixtures/internal/ProjectBuilderImpl.java
Method 'displayName' cannot be resolved in context ServiceRegistryBuilder.builder().displayName("global services") (line: 102) MethodCallExprContext{wrapped=ServiceRegistryBuilder.builder().displayName("global services")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'displayName' cannot be resolved in context ServiceRegistryBuilder.builder().displayName("global services") (line: 102) MethodCallExprContext{wrapped=ServiceRegistryBuilder.builder().displayName("global services")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'displayName' cannot be resolved in context ServiceRegistryBuilder.builder().displayName("global services") (line: 102) MethodCallExprContext{wrapped=ServiceRegistryBuilder.builder().displayName("global services")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'displayName' cannot be resolved in context ServiceRegistryBuilder.builder().displayName("global services") (line: 102) MethodCallExprContext{wrapped=ServiceRegistryBuilder.builder().displayName("global services")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriterWriter.startElement("div") (line: 37) MethodCallExprContext{wrapped=htmlWriterWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriterWriter.startElement("ul") (line: 38) MethodCallExprContext{wrapped=htmlWriterWriter.startElement("ul")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriterWriter.startElement("a") (line: 43) MethodCallExprContext{wrapped=htmlWriterWriter.startElement("a")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriterWriter.startElement("a") (line: 43) MethodCallExprContext{wrapped=htmlWriterWriter.startElement("a")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriterWriter.startElement("a") (line: 43) MethodCallExprContext{wrapped=htmlWriterWriter.startElement("a")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriterWriter.startElement("div") (line: 51) MethodCallExprContext{wrapped=htmlWriterWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriterWriter.startElement("div") (line: 51) MethodCallExprContext{wrapped=htmlWriterWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriterWriter.startElement("h2") (line: 52) MethodCallExprContext{wrapped=htmlWriterWriter.startElement("h2")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriterWriter.startElement("h2") (line: 52) MethodCallExprContext{wrapped=htmlWriterWriter.startElement("h2")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("span") (line: 26) MethodCallExprContext{wrapped=htmlWriter.startElement("span")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("span") (line: 26) MethodCallExprContext{wrapped=htmlWriter.startElement("span")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("span") (line: 26) MethodCallExprContext{wrapped=htmlWriter.startElement("span")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("span") (line: 26) MethodCallExprContext{wrapped=htmlWriter.startElement("span")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("span") (line: 26) MethodCallExprContext{wrapped=htmlWriter.startElement("span")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call result.append(BigDecimal.valueOf(duration).divide(BigDecimal.valueOf(MILLIS_PER_SECOND)).setScale(secondsScale, BigDecimal.ROUND_HALF_UP)) com.github.javaparser.resolution.MethodAmbiguityException: Ambiguous method call: cannot find a most applicable method: MethodUsage{declaration=ReflectionMethodDeclaration{method=public java.math.BigDecimal java.math.BigDecimal.setScale(int,int)}, paramTypes=[PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}]}, MethodUsage{declaration=ReflectionMethodDeclaration{method=public java.math.BigDecimal java.math.BigDecimal.setScale(int,java.math.RoundingMode)}, paramTypes=[PrimitiveTypeUsage{name='int'}, ReferenceType{java.math.RoundingMode, typeParametersMap=TypeParametersMap{nameToValue={}}}]}. First declared in java.math.BigDecimal /repo/subprojects/core/src/main/java/org/gradle/reporting/DurationFormatter.java
Method 'startElement' cannot be resolved in context htmlWriter.startElement("head") (line: 57) MethodCallExprContext{wrapped=htmlWriter.startElement("head")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("head") (line: 57) MethodCallExprContext{wrapped=htmlWriter.startElement("head")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("head") (line: 57) MethodCallExprContext{wrapped=htmlWriter.startElement("head")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("head") (line: 57) MethodCallExprContext{wrapped=htmlWriter.startElement("head")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("head") (line: 57) MethodCallExprContext{wrapped=htmlWriter.startElement("head")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("head") (line: 57) MethodCallExprContext{wrapped=htmlWriter.startElement("head")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("head") (line: 57) MethodCallExprContext{wrapped=htmlWriter.startElement("head")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("head") (line: 57) MethodCallExprContext{wrapped=htmlWriter.startElement("head")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("head") (line: 57) MethodCallExprContext{wrapped=htmlWriter.startElement("head")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("head") (line: 57) MethodCallExprContext{wrapped=htmlWriter.startElement("head")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("head") (line: 57) MethodCallExprContext{wrapped=htmlWriter.startElement("head")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("head") (line: 57) MethodCallExprContext{wrapped=htmlWriter.startElement("head")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("head") (line: 57) MethodCallExprContext{wrapped=htmlWriter.startElement("head")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("head") (line: 57) MethodCallExprContext{wrapped=htmlWriter.startElement("head")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("head") (line: 57) MethodCallExprContext{wrapped=htmlWriter.startElement("head")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("head") (line: 57) MethodCallExprContext{wrapped=htmlWriter.startElement("head")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("head") (line: 57) MethodCallExprContext{wrapped=htmlWriter.startElement("head")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("head") (line: 57) MethodCallExprContext{wrapped=htmlWriter.startElement("head")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("head") (line: 57) MethodCallExprContext{wrapped=htmlWriter.startElement("head")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("head") (line: 57) MethodCallExprContext{wrapped=htmlWriter.startElement("head")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("head") (line: 57) MethodCallExprContext{wrapped=htmlWriter.startElement("head")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("head") (line: 57) MethodCallExprContext{wrapped=htmlWriter.startElement("head")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("head") (line: 57) MethodCallExprContext{wrapped=htmlWriter.startElement("head")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("head") (line: 57) MethodCallExprContext{wrapped=htmlWriter.startElement("head")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("head") (line: 57) MethodCallExprContext{wrapped=htmlWriter.startElement("head")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("head") (line: 57) MethodCallExprContext{wrapped=htmlWriter.startElement("head")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("head") (line: 57) MethodCallExprContext{wrapped=htmlWriter.startElement("head")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("body") (line: 66) MethodCallExprContext{wrapped=htmlWriter.startElement("body")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("body") (line: 66) MethodCallExprContext{wrapped=htmlWriter.startElement("body")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("body") (line: 66) MethodCallExprContext{wrapped=htmlWriter.startElement("body")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("body") (line: 66) MethodCallExprContext{wrapped=htmlWriter.startElement("body")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("body") (line: 66) MethodCallExprContext{wrapped=htmlWriter.startElement("body")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 73) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 73) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 73) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 73) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 73) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 73) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 73) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 73) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 73) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 73) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 73) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 73) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 73) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 73) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 73) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 73) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 73) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 73) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 73) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 73) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context htmlWriter.startElement("div") (line: 73) MethodCallExprContext{wrapped=htmlWriter.startElement("div")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Error calculating the type of parameter String.format(" at %s", builder.formatDate(new Date())) of method call htmlWriter.startElement("div").attribute("id", "footer").startElement("p").startElement("div").startElement("label").attribute("class", "hidden").attribute("id", "label-for-line-wrapping-toggle").attribute("for", "line-wrapping-toggle").characters("Wrap lines").startElement("input").attribute("id", "line-wrapping-toggle").attribute("type", "checkbox").attribute("autocomplete", "off").endElement().endElement().endElement().characters("Generated by ").startElement("a").attribute("href", "http://www.gradle.org").characters("Gradle " + GradleVersion.current().getVersion()).endElement().characters(String.format(" at %s", builder.formatDate(new Date())))
Error calculating the type of parameter String.format(" at %s", builder.formatDate(new Date())) of method call htmlWriter.startElement("div").attribute("id", "footer").startElement("p").startElement("div").startElement("label").attribute("class", "hidden").attribute("id", "label-for-line-wrapping-toggle").attribute("for", "line-wrapping-toggle").characters("Wrap lines").startElement("input").attribute("id", "line-wrapping-toggle").attribute("type", "checkbox").attribute("autocomplete", "off").endElement().endElement().endElement().characters("Generated by ").startElement("a").attribute("href", "http://www.gradle.org").characters("Gradle " + GradleVersion.current().getVersion()).endElement().characters(String.format(" at %s", builder.formatDate(new Date())))
Error calculating the type of parameter String.format(" at %s", builder.formatDate(new Date())) of method call htmlWriter.startElement("div").attribute("id", "footer").startElement("p").startElement("div").startElement("label").attribute("class", "hidden").attribute("id", "label-for-line-wrapping-toggle").attribute("for", "line-wrapping-toggle").characters("Wrap lines").startElement("input").attribute("id", "line-wrapping-toggle").attribute("type", "checkbox").attribute("autocomplete", "off").endElement().endElement().endElement().characters("Generated by ").startElement("a").attribute("href", "http://www.gradle.org").characters("Gradle " + GradleVersion.current().getVersion()).endElement().characters(String.format(" at %s", builder.formatDate(new Date())))
Error calculating the type of parameter String.format(" at %s", builder.formatDate(new Date())) of method call htmlWriter.startElement("div").attribute("id", "footer").startElement("p").startElement("div").startElement("label").attribute("class", "hidden").attribute("id", "label-for-line-wrapping-toggle").attribute("for", "line-wrapping-toggle").characters("Wrap lines").startElement("input").attribute("id", "line-wrapping-toggle").attribute("type", "checkbox").attribute("autocomplete", "off").endElement().endElement().endElement().characters("Generated by ").startElement("a").attribute("href", "http://www.gradle.org").characters("Gradle " + GradleVersion.current().getVersion()).endElement().characters(String.format(" at %s", builder.formatDate(new Date())))
Cannot solve method call buildOperationExecutor.run(BuildOperationDetails.displayName("Build buildSrc").progressDisplayName("buildSrc").build(), new Factory<ClassPath>() {

    @Override
    public ClassPath create() {
        return buildBuildSrc(startParameter);
    }
}) UnsolvedSymbolException{context='Method 'displayName' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * Meta-data about a build operation.
 */
public class BuildOperationDetails {

    private final String displayName;

    private final String progressDisplayName;

    private BuildOperationDetails(String displayName, String progressDisplayName) {
        this.displayName = displayName;
        this.progressDisplayName = progressDisplayName;
    }

    /**
     * Returns the display name for the operation. This should be a standalone human consumable description of the
     * operation, and should describe the operation whether currently running or not, eg "run test A" rather than
     * "running test A".
     */
    public String getDisplayName() {
        return displayName;
    }

    /**
     * Returns the display name to use for progress logging for the operation. Should be short and describe the operation
     * as it is running, eg "running test A" rather than "run test A".
     *
     * <p>When null, no progress logging is generated for the operation. Defaults to null.
     */
    @Nullable
    public String getProgressDisplayName() {
        return progressDisplayName;
    }

    public static Builder displayName(String displayName) {
        return new Builder(displayName);
    }

    public static class Builder {

        private final String displayName;

        private String progressDisplayName;

        private Builder(String displayName) {
            this.displayName = displayName;
        }

        public Builder progressDisplayName(String progressDisplayName) {
            this.progressDisplayName = progressDisplayName;
            return this;
        }

        public BuildOperationDetails build() {
            return new BuildOperationDetails(displayName, progressDisplayName);
        }
    }
}}'} /repo/subprojects/core/src/main/java/org/gradle/initialization/buildsrc/BuildSourceBuilder.java
Cannot resolve field access null
Cannot solve field access FileLockManager.LockMode.None
Cannot resolve field access null
Cannot solve field access CacheBuilder.LockTarget.CachePropertiesFile
Method 'withDisplayName' cannot be resolved in context cacheRepository.cache(new File(startParameter.getCurrentDir(), ".gradle/noVersion/buildSrc")).withCrossVersionCache(CacheBuilder.LockTarget.CachePropertiesFile).withDisplayName("buildSrc state cache") (line: 101) MethodCallExprContext{wrapped=cacheRepository.cache(new File(startParameter.getCurrentDir(), ".gradle/noVersion/buildSrc")).withCrossVersionCache(CacheBuilder.LockTarget.CachePropertiesFile).withDisplayName("buildSrc state cache")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'withDisplayName' cannot be resolved in context cacheRepository.cache(new File(startParameter.getCurrentDir(), ".gradle/noVersion/buildSrc")).withCrossVersionCache(CacheBuilder.LockTarget.CachePropertiesFile).withDisplayName("buildSrc state cache") (line: 101) MethodCallExprContext{wrapped=cacheRepository.cache(new File(startParameter.getCurrentDir(), ".gradle/noVersion/buildSrc")).withCrossVersionCache(CacheBuilder.LockTarget.CachePropertiesFile).withDisplayName("buildSrc state cache")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'withDisplayName' cannot be resolved in context cacheRepository.cache(new File(startParameter.getCurrentDir(), ".gradle/noVersion/buildSrc")).withCrossVersionCache(CacheBuilder.LockTarget.CachePropertiesFile).withDisplayName("buildSrc state cache") (line: 101) MethodCallExprContext{wrapped=cacheRepository.cache(new File(startParameter.getCurrentDir(), ".gradle/noVersion/buildSrc")).withCrossVersionCache(CacheBuilder.LockTarget.CachePropertiesFile).withDisplayName("buildSrc state cache")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call WrapUtil.toMap("from", BuildSrcBuildListenerFactory.class.getResource(DEFAULT_BUILD_SOURCE_SCRIPT_RESOURCE)) java.lang.RuntimeException: Method 'getResource' cannot be resolved in context BuildSrcBuildListenerFactory.class.getResource(DEFAULT_BUILD_SOURCE_SCRIPT_RESOURCE) (line: 49) MethodCallExprContext{wrapped=BuildSrcBuildListenerFactory.class.getResource(DEFAULT_BUILD_SOURCE_SCRIPT_RESOURCE)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/initialization/buildsrc/BuildSrcBuildListenerFactory.java
Cannot solve method call gradle.getRootProject().apply(WrapUtil.toMap("from", BuildSrcBuildListenerFactory.class.getResource(DEFAULT_BUILD_SOURCE_SCRIPT_RESOURCE))) java.lang.RuntimeException: Error calculating the type of parameter BuildSrcBuildListenerFactory.class.getResource(DEFAULT_BUILD_SOURCE_SCRIPT_RESOURCE) of method call WrapUtil.toMap("from", BuildSrcBuildListenerFactory.class.getResource(DEFAULT_BUILD_SOURCE_SCRIPT_RESOURCE)) /repo/subprojects/core/src/main/java/org/gradle/initialization/buildsrc/BuildSrcBuildListenerFactory.java
Cannot solve method call projectFactory.createProject(rootProjectDescriptor, null, gradle, baseClassLoaderScope.createChild("root-project"), baseClassLoaderScope) java.lang.RuntimeException: Method 'createChild' cannot be resolved in context baseClassLoaderScope.createChild("root-project") (line: 45) MethodCallExprContext{wrapped=baseClassLoaderScope.createChild("root-project")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/initialization/InstantiatingBuildLoader.java
Cannot solve method call projectFactory.createProject(childProjectDescriptor, parent, gradle, parent.getClassLoaderScope().createChild("project-" + childProjectDescriptor.getName()), baseClassLoaderScope) java.lang.RuntimeException: Method 'createChild' cannot be resolved in context parent.getClassLoaderScope().createChild("project-" + childProjectDescriptor.getName()) (line: 52) MethodCallExprContext{wrapped=parent.getClassLoaderScope().createChild("project-" + childProjectDescriptor.getName())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/initialization/InstantiatingBuildLoader.java
Cannot solve method call Type.getType(MetaClassRegistry.class) UnsolvedSymbolException{context='unknown', name='MetaClassRegistry', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot solve method call Type.getType(GroovySystem.class) UnsolvedSymbolException{context='unknown', name='GroovySystem', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call Type.getMethodDescriptor(Type.VOID_TYPE, OBJECT_TYPE, STRING_TYPE, OBJECT_TYPE) UnsolvedSymbolException{context='unknown', name='VOID_TYPE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call Type.getMethodDescriptor(Type.VOID_TYPE, STRING_TYPE, OBJECT_TYPE) UnsolvedSymbolException{context='unknown', name='VOID_TYPE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call interfaceNames.add(GROOVY_OBJECT_TYPE.getInternalName()) java.lang.RuntimeException: Method 'getInternalName' cannot be resolved in context GROOVY_OBJECT_TYPE.getInternalName() (line: 125) MethodCallExprContext{wrapped=GROOVY_OBJECT_TYPE.getInternalName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call Type.getMethodDescriptor(Type.BOOLEAN_TYPE) UnsolvedSymbolException{context='unknown', name='BOOLEAN_TYPE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Error calculating the type of parameter Type.BOOLEAN_TYPE of method call Type.getMethodDescriptor(Type.BOOLEAN_TYPE)
Cannot solve field access PropertyAccessorType.IS_GETTER
Cannot solve field access PropertyAccessorType.GET_GETTER
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, className, "getMetaClass", RETURN_META_CLASS, false) UnsolvedSymbolException{context='unknown', name='INVOKEVIRTUAL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 1) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, META_CLASS_TYPE.getInternalName(), "getProperty", RETURN_OBJECT_FROM_OBJECT_STRING, true) UnsolvedSymbolException{context='unknown', name='INVOKEINTERFACE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitInsn(Opcodes.ARETURN) UnsolvedSymbolException{context='unknown', name='ARETURN', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, className, "getMetaClass", RETURN_META_CLASS, false) UnsolvedSymbolException{context='unknown', name='INVOKEVIRTUAL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 1) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 2) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, META_CLASS_TYPE.getInternalName(), "setProperty", RETURN_VOID_FROM_OBJECT_STRING_OBJECT, true) UnsolvedSymbolException{context='unknown', name='INVOKEINTERFACE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitInsn(Opcodes.RETURN) UnsolvedSymbolException{context='unknown', name='RETURN', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, className, "getMetaClass", RETURN_META_CLASS, false) UnsolvedSymbolException{context='unknown', name='INVOKEVIRTUAL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 1) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 2) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, META_CLASS_TYPE.getInternalName(), "invokeMethod", RETURN_OBJECT_FROM_OBJECT_STRING_OBJECT, true) UnsolvedSymbolException{context='unknown', name='INVOKEINTERFACE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitInsn(Opcodes.ARETURN) UnsolvedSymbolException{context='unknown', name='ARETURN', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitFieldInsn(Opcodes.GETFIELD, className, META_CLASS_FIELD, META_CLASS_TYPE.getDescriptor()) UnsolvedSymbolException{context='unknown', name='GETFIELD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitInsn(Opcodes.DUP) UnsolvedSymbolException{context='unknown', name='DUP', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitJumpInsn(Opcodes.IFNULL, lookup) UnsolvedSymbolException{context='unknown', name='IFNULL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitInsn(Opcodes.ARETURN) UnsolvedSymbolException{context='unknown', name='ARETURN', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitFrame(Opcodes.F_NEW, 1, new Object[] { className }, 1, new Object[] { META_CLASS_TYPE.getInternalName() }) UnsolvedSymbolException{context='unknown', name='F_NEW', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, GROOVY_SYSTEM_TYPE.getInternalName(), "getMetaClassRegistry", RETURN_META_CLASS_REGISTRY, false) UnsolvedSymbolException{context='unknown', name='INVOKESTATIC', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, OBJECT_TYPE.getInternalName(), "getClass", RETURN_CLASS, false) UnsolvedSymbolException{context='unknown', name='INVOKEVIRTUAL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, META_CLASS_REGISTRY_TYPE.getInternalName(), "getMetaClass", RETURN_META_CLASS_FROM_CLASS, true) UnsolvedSymbolException{context='unknown', name='INVOKEINTERFACE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitFieldInsn(Opcodes.PUTFIELD, className, META_CLASS_FIELD, META_CLASS_TYPE.getDescriptor()) UnsolvedSymbolException{context='unknown', name='PUTFIELD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitFieldInsn(Opcodes.GETFIELD, className, META_CLASS_FIELD, META_CLASS_TYPE.getDescriptor()) UnsolvedSymbolException{context='unknown', name='GETFIELD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitInsn(Opcodes.ARETURN) UnsolvedSymbolException{context='unknown', name='ARETURN', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call Type.getMethodDescriptor(Type.VOID_TYPE, META_CLASS_TYPE) UnsolvedSymbolException{context='unknown', name='VOID_TYPE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 1) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitFieldInsn(Opcodes.PUTFIELD, className, META_CLASS_FIELD, META_CLASS_TYPE.getDescriptor()) UnsolvedSymbolException{context='unknown', name='PUTFIELD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitInsn(Opcodes.RETURN) UnsolvedSymbolException{context='unknown', name='RETURN', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call Type.getMethodDescriptor(Type.getType(String.class)) UnsolvedSymbolException{context='Method 'getType' with parameterTypes [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=org.objectweb.asm.Type}'} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call mv.visitInsn(Opcodes.ARETURN) UnsolvedSymbolException{context='unknown', name='ARETURN', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call mv.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call mv.visitFieldInsn(Opcodes.GETFIELD, className, booleanField, "Z") UnsolvedSymbolException{context='unknown', name='GETFIELD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot resolve field access null
Cannot solve method call mv.visitInsn(Opcodes.IRETURN) UnsolvedSymbolException{context='unknown', name='IRETURN', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/MixInLegacyTypesClassLoader.java
Cannot solve field access Stage.Build
Cannot solve field access Stage.Configure
Cannot solve field access Stage.Load
Cannot solve field access Stage.Build
Cannot solve field access Stage.Load
Cannot solve field access Stage.Load
Cannot solve field access Stage.Load
Cannot solve field access Stage.Configure
Cannot solve field access Stage.Configure
Cannot solve field access Stage.Build
Method 'hasArgument' cannot be resolved in context parser.option(PROJECT_CACHE_DIR).hasArgument() (line: 78) MethodCallExprContext{wrapped=parser.option(PROJECT_CACHE_DIR).hasArgument()}. Parameter types: []
Method 'hasArguments' cannot be resolved in context parser.option(INIT_SCRIPT, "init-script").hasArguments() (line: 80) MethodCallExprContext{wrapped=parser.option(INIT_SCRIPT, "init-script").hasArguments()}. Parameter types: []
Method 'hasArgument' cannot be resolved in context parser.option(SETTINGS_FILE, "settings-file").hasArgument() (line: 81) MethodCallExprContext{wrapped=parser.option(SETTINGS_FILE, "settings-file").hasArgument()}. Parameter types: []
Method 'hasArgument' cannot be resolved in context parser.option(BUILD_FILE, "build-file").hasArgument() (line: 82) MethodCallExprContext{wrapped=parser.option(BUILD_FILE, "build-file").hasArgument()}. Parameter types: []
Method 'hasArguments' cannot be resolved in context parser.option(EXCLUDE_TASK, "exclude-task").hasArguments() (line: 86) MethodCallExprContext{wrapped=parser.option(EXCLUDE_TASK, "exclude-task").hasArguments()}. Parameter types: []
Method 'hasDescription' cannot be resolved in context parser.option(PARALLEL).hasDescription("Build projects in parallel. Gradle will attempt to determine the optimal number of executor threads to use.") (line: 91) MethodCallExprContext{wrapped=parser.option(PARALLEL).hasDescription("Build projects in parallel. Gradle will attempt to determine the optimal number of executor threads to use.")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'hasArgument' cannot be resolved in context parser.option(MAX_WORKERS).hasArgument() (line: 92) MethodCallExprContext{wrapped=parser.option(MAX_WORKERS).hasArgument()}. Parameter types: []
Method 'hasArgument' cannot be resolved in context parser.option(MAX_WORKERS).hasArgument() (line: 92) MethodCallExprContext{wrapped=parser.option(MAX_WORKERS).hasArgument()}. Parameter types: []
Method 'hasDescription' cannot be resolved in context parser.option(CONFIGURE_ON_DEMAND).hasDescription("Only relevant projects are configured in this build run. This means faster build for large multi-project builds.") (line: 93) MethodCallExprContext{wrapped=parser.option(CONFIGURE_ON_DEMAND).hasDescription("Only relevant projects are configured in this build run. This means faster build for large multi-project builds.")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'hasDescription' cannot be resolved in context parser.option(CONTINUOUS, CONTINUOUS_SHORT_FLAG).hasDescription("Enables continuous build. Gradle does not exit and will re-execute tasks when task file inputs change.") (line: 94) MethodCallExprContext{wrapped=parser.option(CONTINUOUS, CONTINUOUS_SHORT_FLAG).hasDescription("Enables continuous build. Gradle does not exit and will re-execute tasks when task file inputs change.")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'hasArguments' cannot be resolved in context parser.option(INCLUDE_BUILD).hasArguments() (line: 95) MethodCallExprContext{wrapped=parser.option(INCLUDE_BUILD).hasArguments()}. Parameter types: []
Method 'hasArguments' cannot be resolved in context parser.option(INCLUDE_BUILD).hasArguments() (line: 95) MethodCallExprContext{wrapped=parser.option(INCLUDE_BUILD).hasArguments()}. Parameter types: []
Cannot solve method call resolver.transform(options.option(BUILD_FILE).getValue()) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context options.option(BUILD_FILE).getValue() (line: 120) MethodCallExprContext{wrapped=options.option(BUILD_FILE).getValue()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/initialization/DefaultCommandLineConverter.java
Cannot solve method call startParameter.setBuildFile(resolver.transform(options.option(BUILD_FILE).getValue())) java.lang.RuntimeException: Error calculating the type of parameter options.option(BUILD_FILE).getValue() of method call resolver.transform(options.option(BUILD_FILE).getValue()) /repo/subprojects/core/src/main/java/org/gradle/initialization/DefaultCommandLineConverter.java
Cannot solve method call resolver.transform(options.option(SETTINGS_FILE).getValue()) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context options.option(SETTINGS_FILE).getValue() (line: 123) MethodCallExprContext{wrapped=options.option(SETTINGS_FILE).getValue()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/initialization/DefaultCommandLineConverter.java
Cannot solve method call startParameter.setSettingsFile(resolver.transform(options.option(SETTINGS_FILE).getValue())) java.lang.RuntimeException: Error calculating the type of parameter options.option(SETTINGS_FILE).getValue() of method call resolver.transform(options.option(SETTINGS_FILE).getValue()) /repo/subprojects/core/src/main/java/org/gradle/initialization/DefaultCommandLineConverter.java
Cannot solve method call resolver.transform(options.option(PROJECT_CACHE_DIR).getValue()) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context options.option(PROJECT_CACHE_DIR).getValue() (line: 131) MethodCallExprContext{wrapped=options.option(PROJECT_CACHE_DIR).getValue()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/initialization/DefaultCommandLineConverter.java
Cannot solve method call startParameter.setProjectCacheDir(resolver.transform(options.option(PROJECT_CACHE_DIR).getValue())) java.lang.RuntimeException: Error calculating the type of parameter options.option(PROJECT_CACHE_DIR).getValue() of method call resolver.transform(options.option(PROJECT_CACHE_DIR).getValue()) /repo/subprojects/core/src/main/java/org/gradle/initialization/DefaultCommandLineConverter.java
Cannot solve method call startParameter.setExcludedTaskNames(options.option(EXCLUDE_TASK).getValues()) java.lang.RuntimeException: Method 'getValues' cannot be resolved in context options.option(EXCLUDE_TASK).getValues() (line: 155) MethodCallExprContext{wrapped=options.option(EXCLUDE_TASK).getValues()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/initialization/DefaultCommandLineConverter.java
Cannot solve method call instantiator.newInstance(DefaultSettings.class, serviceRegistryFactory, gradle, rootClassLoaderScope.createChild("settings"), rootClassLoaderScope, settingsDir, settingsScript, startParameter) java.lang.RuntimeException: Method 'createChild' cannot be resolved in context rootClassLoaderScope.createChild("settings") (line: 44) MethodCallExprContext{wrapped=rootClassLoaderScope.createChild("settings")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/initialization/SettingsFactory.java
Cannot solve method call scripts.containsKey(element.getFileName()) java.lang.RuntimeException: Method 'getFileName' cannot be resolved in context element.getFileName() (line: 65) MethodCallExprContext{wrapped=element.getFileName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/initialization/DefaultExceptionAnalyser.java
Cannot solve method call scripts.get(element.getFileName()) java.lang.RuntimeException: Method 'getFileName' cannot be resolved in context element.getFileName() (line: 66) MethodCallExprContext{wrapped=element.getFileName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/initialization/DefaultExceptionAnalyser.java
Cannot solve method call classNames.add(line.trim()) java.lang.RuntimeException: Method 'trim' cannot be resolved in context line.trim() (line: 49) MethodCallExprContext{wrapped=line.trim()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/initialization/LegacyTypesUtil.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call visitor.visit(Opcodes.V1_7, Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC | Opcodes.ACC_INTERFACE | Opcodes.ACC_ABSTRACT, name.replace('.', '/'), null, OBJECT_TYPE.getInternalName(), null) UnsolvedSymbolException{context='unknown', name='V1_7', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/initialization/LegacyTypesUtil.java
Cannot resolve field access null
Cannot solve method call doNewInstance(startParameter, false, requestContext.getCancellationToken(), requestContext, requestContext.getEventConsumer(), buildScopeServices, ImmutableList.of()) UnsolvedSymbolException{context='Method 'of' with parameterTypes []', name='ReflectionClassDeclaration{clazz=ImmutableList}'} /repo/subprojects/core/src/main/java/org/gradle/initialization/DefaultGradleLauncherFactory.java
Cannot solve method call loggingManager.addStandardOutputListener(listenerManager.getBroadcaster(StandardOutputListener.class)) java.lang.RuntimeException: Method 'getBroadcaster' cannot be resolved in context listenerManager.getBroadcaster(StandardOutputListener.class) (line: 149) MethodCallExprContext{wrapped=listenerManager.getBroadcaster(StandardOutputListener.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.logging.StandardOutputListener, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/core/src/main/java/org/gradle/initialization/DefaultGradleLauncherFactory.java
Cannot solve method call loggingManager.addStandardErrorListener(listenerManager.getBroadcaster(StandardOutputListener.class)) java.lang.RuntimeException: Method 'getBroadcaster' cannot be resolved in context listenerManager.getBroadcaster(StandardOutputListener.class) (line: 150) MethodCallExprContext{wrapped=listenerManager.getBroadcaster(StandardOutputListener.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.logging.StandardOutputListener, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/core/src/main/java/org/gradle/initialization/DefaultGradleLauncherFactory.java
Empty name expression ALWAYS
Empty name expression ALWAYS_FULL
Cannot solve method call resolver.transform(options.option(PROJECT_DIR).getValue()) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context options.option(PROJECT_DIR).getValue() (line: 40) MethodCallExprContext{wrapped=options.option(PROJECT_DIR).getValue()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/initialization/LayoutCommandLineConverter.java
Cannot solve method call target.setProjectDir(resolver.transform(options.option(PROJECT_DIR).getValue())) java.lang.RuntimeException: Error calculating the type of parameter options.option(PROJECT_DIR).getValue() of method call resolver.transform(options.option(PROJECT_DIR).getValue()) /repo/subprojects/core/src/main/java/org/gradle/initialization/LayoutCommandLineConverter.java
Cannot solve method call resolver.transform(options.option(GRADLE_USER_HOME).getValue()) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context options.option(GRADLE_USER_HOME).getValue() (line: 43) MethodCallExprContext{wrapped=options.option(GRADLE_USER_HOME).getValue()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/initialization/LayoutCommandLineConverter.java
Cannot solve method call target.setGradleUserHomeDir(resolver.transform(options.option(GRADLE_USER_HOME).getValue())) java.lang.RuntimeException: Error calculating the type of parameter options.option(GRADLE_USER_HOME).getValue() of method call resolver.transform(options.option(GRADLE_USER_HOME).getValue()) /repo/subprojects/core/src/main/java/org/gradle/initialization/LayoutCommandLineConverter.java
Cannot solve method call parser.option(NO_SEARCH_UPWARDS, "no-search-upward").hasDescription(String.format("Don't search in parent folders for a %s file.", Settings.DEFAULT_SETTINGS_FILE)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/core/src/main/java/org/gradle/initialization/LayoutCommandLineConverter.java
Method 'hasArgument' cannot be resolved in context parser.option(PROJECT_DIR, "project-dir").hasArgument() (line: 50) MethodCallExprContext{wrapped=parser.option(PROJECT_DIR, "project-dir").hasArgument()}. Parameter types: []
Method 'hasArgument' cannot be resolved in context parser.option(GRADLE_USER_HOME, "gradle-user-home").hasArgument() (line: 51) MethodCallExprContext{wrapped=parser.option(GRADLE_USER_HOME, "gradle-user-home").hasArgument()}. Parameter types: []
Cannot solve method call matches.add(candidates.getProject(":")) java.lang.RuntimeException: Method 'getProject' cannot be resolved in context candidates.getProject(":") (line: 42) MethodCallExprContext{wrapped=candidates.getProject(":")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/initialization/DefaultProjectSpec.java
Cannot solve method call entry.getKey().substring(SYSTEM_PROJECT_PROPERTIES_PREFIX.length()) java.lang.RuntimeException: Method 'length' cannot be resolved in context SYSTEM_PROJECT_PROPERTIES_PREFIX.length() (line: 84) MethodCallExprContext{wrapped=SYSTEM_PROJECT_PROPERTIES_PREFIX.length()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/initialization/DefaultGradlePropertiesLoader.java
Cannot solve method call systemProjectProperties.put(entry.getKey().substring(SYSTEM_PROJECT_PROPERTIES_PREFIX.length()), entry.getValue()) java.lang.RuntimeException: Error calculating the type of parameter SYSTEM_PROJECT_PROPERTIES_PREFIX.length() of method call entry.getKey().substring(SYSTEM_PROJECT_PROPERTIES_PREFIX.length()) /repo/subprojects/core/src/main/java/org/gradle/initialization/DefaultGradlePropertiesLoader.java
Cannot solve method call entry.getKey().substring(ENV_PROJECT_PROPERTIES_PREFIX.length()) java.lang.RuntimeException: Method 'length' cannot be resolved in context ENV_PROJECT_PROPERTIES_PREFIX.length() (line: 95) MethodCallExprContext{wrapped=ENV_PROJECT_PROPERTIES_PREFIX.length()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/initialization/DefaultGradlePropertiesLoader.java
Cannot solve method call envProjectProperties.put(entry.getKey().substring(ENV_PROJECT_PROPERTIES_PREFIX.length()), entry.getValue()) java.lang.RuntimeException: Error calculating the type of parameter ENV_PROJECT_PROPERTIES_PREFIX.length() of method call entry.getKey().substring(ENV_PROJECT_PROPERTIES_PREFIX.length()) /repo/subprojects/core/src/main/java/org/gradle/initialization/DefaultGradlePropertiesLoader.java
Cannot solve method call key.substring((Project.SYSTEM_PROP_PREFIX + '.').length()) java.lang.RuntimeException: Method 'length' cannot be resolved in context (Project.SYSTEM_PROP_PREFIX + '.').length() (line: 111) MethodCallExprContext{wrapped=(Project.SYSTEM_PROP_PREFIX + '.').length()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/initialization/DefaultGradlePropertiesLoader.java
Cannot solve method call System.setProperty(key.substring((Project.SYSTEM_PROP_PREFIX + '.').length()), properties.get(key)) java.lang.RuntimeException: Error calculating the type of parameter (Project.SYSTEM_PROP_PREFIX + '.').length() of method call key.substring((Project.SYSTEM_PROP_PREFIX + '.').length()) /repo/subprojects/core/src/main/java/org/gradle/initialization/DefaultGradlePropertiesLoader.java
Cannot solve field access ModelActionRole.Create
Method 'inRange' cannot be resolved in context inRange('a', 'z') (line: 31) MethodCallExprContext{wrapped=inRange('a', 'z')}. Parameter types: [PrimitiveTypeUsage{name='char'}, PrimitiveTypeUsage{name='char'}]
Error calculating the type of parameter inRange('A', 'Z') of method call inRange('a', 'z').or(inRange('A', 'Z'))
Error calculating the type of parameter inRange('0', '9') of method call inRange('a', 'z').or(inRange('A', 'Z')).or(inRange('0', '9'))
Error calculating the type of parameter anyOf(".-_") of method call inRange('a', 'z').or(inRange('A', 'Z')).or(inRange('0', '9')).or(anyOf(".-_"))
Cannot solve method call value.substring(0, value.lastIndexOf(SEPARATOR)) java.lang.RuntimeException: Method 'lastIndexOf' cannot be resolved in context value.lastIndexOf(SEPARATOR) (line: 81) MethodCallExprContext{wrapped=value.lastIndexOf(SEPARATOR)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/plugin/internal/PluginId.java
Cannot solve method call value.substring(value.lastIndexOf(PluginId.SEPARATOR) + 1) java.lang.RuntimeException: Method 'lastIndexOf' cannot be resolved in context value.lastIndexOf(PluginId.SEPARATOR) (line: 89) MethodCallExprContext{wrapped=value.lastIndexOf(PluginId.SEPARATOR)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/plugin/internal/PluginId.java
Method 'getValue' cannot be resolved in context argumentExpression.getValue() (line: 87) MethodCallExprContext{wrapped=argumentExpression.getValue()}. Parameter types: []
Method 'getText' cannot be resolved in context methodName.getText() (line: 93) MethodCallExprContext{wrapped=methodName.getText()}. Parameter types: []
Cannot solve method call pluginRequestCollector.createSpec(call.getLineNumber()) java.lang.RuntimeException: Method 'getLineNumber' cannot be resolved in context call.getLineNumber() (line: 97) MethodCallExprContext{wrapped=call.getLineNumber()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/plugin/use/internal/PluginUseScriptBlockMetadataExtractor.java
Error calculating the type of parameter call.getLineNumber() of method call pluginRequestCollector.createSpec(call.getLineNumber())
Cannot solve method call call.setNodeMetaData(PluginDependencySpec.class, pluginRequestCollector.createSpec(call.getLineNumber()).id(argStringValue)) java.lang.RuntimeException: Error calculating the type of parameter call.getLineNumber() of method call pluginRequestCollector.createSpec(call.getLineNumber()) /repo/subprojects/core/src/main/java/org/gradle/plugin/use/internal/PluginUseScriptBlockMetadataExtractor.java
Method 'getText' cannot be resolved in context methodName.getText() (line: 106) MethodCallExprContext{wrapped=methodName.getText()}. Parameter types: []
Method 'getExpression' cannot be resolved in context statement.getExpression() (line: 152) MethodCallExprContext{wrapped=statement.getExpression()}. Parameter types: []
Method 'getCode' cannot be resolved in context closureArg.getCode() (line: 55) MethodCallExprContext{wrapped=closureArg.getCode()}. Parameter types: []
Cannot solve method call String.format("%s%n%nSee %s for information on the plugins {} block%n%n", message, documentationRegistry.getDocumentationFor("plugins", "sec:plugins_block")) java.lang.RuntimeException: Method 'getDocumentationFor' cannot be resolved in context documentationRegistry.getDocumentationFor("plugins", "sec:plugins_block") (line: 164) MethodCallExprContext{wrapped=documentationRegistry.getDocumentationFor("plugins", "sec:plugins_block")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/plugin/use/internal/PluginUseScriptBlockMetadataExtractor.java
Method 'append' cannot be resolved in context b.append("[id: '") (line: 73) MethodCallExprContext{wrapped=b.append("[id: '")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context b.append("[id: '") (line: 73) MethodCallExprContext{wrapped=b.append("[id: '")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context b.append(", version: '") (line: 75) MethodCallExprContext{wrapped=b.append(", version: '")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context b.append(", version: '") (line: 75) MethodCallExprContext{wrapped=b.append(", version: '")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call LOGGER.info("No tasks specified. Using project default tasks {}", GUtil.toString(defaultTasks)) UnsolvedSymbolException{context='Method 'toString' with parameterTypes [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public class GUtil {

    private static final Pattern WORD_SEPARATOR = Pattern.compile("\\W+");

    private static final Pattern UPPER_LOWER = Pattern.compile("(?m)([A-Z]*)([a-z0-9]*)");

    public static <T extends Collection> T flatten(Object[] elements, T addTo, boolean flattenMaps) {
        return flatten(asList(elements), addTo, flattenMaps);
    }

    public static <T extends Collection> T flatten(Object[] elements, T addTo) {
        return flatten(asList(elements), addTo);
    }

    public static <T extends Collection> T flatten(Collection elements, T addTo) {
        return flatten(elements, addTo, true);
    }

    public static <T extends Collection> T flattenElements(Object... elements) {
        Collection<T> out = new LinkedList<T>();
        flatten(elements, out, true);
        return (T) out;
    }

    public static <T extends Collection> T flatten(Collection elements, T addTo, boolean flattenMapsAndArrays) {
        return flatten(elements, addTo, flattenMapsAndArrays, flattenMapsAndArrays);
    }

    public static <T extends Collection> T flatten(Collection elements, T addTo, boolean flattenMaps, boolean flattenArrays) {
        Iterator iter = elements.iterator();
        while (iter.hasNext()) {
            Object element = iter.next();
            if (element instanceof Collection) {
                flatten((Collection) element, addTo, flattenMaps, flattenArrays);
            } else if ((element instanceof Map) && flattenMaps) {
                flatten(((Map) element).values(), addTo, flattenMaps, flattenArrays);
            } else if ((element.getClass().isArray()) && flattenArrays) {
                flatten(asList((Object[]) element), addTo, flattenMaps, flattenArrays);
            } else {
                addTo.add(element);
            }
        }
        return addTo;
    }

    /**
     * Flattens input collections (including arrays *but* not maps). If input is not a collection wraps it in a collection and returns it.
     *
     * @param input any object
     * @return collection of flattened input or single input wrapped in a collection.
     */
    public static Collection collectionize(Object input) {
        if (input == null) {
            return emptyList();
        } else if (input instanceof Collection) {
            Collection out = new LinkedList();
            flatten((Collection) input, out, false, true);
            return out;
        } else if (input.getClass().isArray()) {
            Collection out = new LinkedList();
            flatten(asList((Object[]) input), out, false, true);
            return out;
        } else {
            return asList(input);
        }
    }

    public static List flatten(Collection elements, boolean flattenMapsAndArrays) {
        return flatten(elements, new ArrayList(), flattenMapsAndArrays);
    }

    public static List flatten(Collection elements) {
        return flatten(elements, new ArrayList());
    }

    public static String asPath(Iterable<?> collection) {
        return CollectionUtils.join(File.pathSeparator, collection);
    }

    public static List<String> prefix(String prefix, Collection<String> strings) {
        List<String> prefixed = new ArrayList<String>();
        for (String string : strings) {
            prefixed.add(prefix + string);
        }
        return prefixed;
    }

    public static boolean isTrue(Object object) {
        if (object == null) {
            return false;
        }
        if (object instanceof Collection) {
            return ((Collection) object).size() > 0;
        } else if (object instanceof String) {
            return ((String) object).length() > 0;
        }
        return true;
    }

    public static <T> T elvis(T object, T defaultValue) {
        return isTrue(object) ? object : defaultValue;
    }

    public static <V, T extends Collection<? super V>> T addToCollection(T dest, boolean failOnNull, Iterable<? extends V>... srcs) {
        for (Iterable<? extends V> src : srcs) {
            for (V v : src) {
                if (failOnNull && v == null) {
                    throw new IllegalArgumentException("Illegal null value provided in this collection: " + src);
                }
                dest.add(v);
            }
        }
        return dest;
    }

    public static <V, T extends Collection<? super V>> T addToCollection(T dest, Iterable<? extends V>... srcs) {
        return addToCollection(dest, false, srcs);
    }

    public static Comparator<String> caseInsensitive() {
        return new Comparator<String>() {

            public int compare(String o1, String o2) {
                int diff = o1.compareToIgnoreCase(o2);
                if (diff != 0) {
                    return diff;
                }
                return o1.compareTo(o2);
            }
        };
    }

    public static Map addMaps(Map map1, Map map2) {
        HashMap map = new HashMap();
        map.putAll(map1);
        map.putAll(map2);
        return map;
    }

    public static void addToMap(Map<String, String> dest, Map<?, ?> src) {
        for (Map.Entry<?, ?> entry : src.entrySet()) {
            dest.put(entry.getKey().toString(), entry.getValue().toString());
        }
    }

    public static Properties loadProperties(File propertyFile) {
        try {
            FileInputStream inputStream = new FileInputStream(propertyFile);
            try {
                return loadProperties(inputStream);
            } finally {
                inputStream.close();
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static Properties loadProperties(URL url) {
        try {
            URLConnection uc = url.openConnection();
            uc.setUseCaches(false);
            return loadProperties(uc.getInputStream());
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static Properties loadProperties(InputStream inputStream) {
        Properties properties = new Properties();
        try {
            properties.load(inputStream);
            inputStream.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
        return properties;
    }

    public static void saveProperties(Properties properties, File propertyFile) {
        try {
            FileOutputStream propertiesFileOutputStream = new FileOutputStream(propertyFile);
            try {
                properties.store(propertiesFileOutputStream, null);
            } finally {
                propertiesFileOutputStream.close();
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static void saveProperties(Properties properties, OutputStream outputStream) {
        try {
            try {
                properties.store(outputStream, null);
            } finally {
                outputStream.close();
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static void savePropertiesNoDateComment(Properties properties, OutputStream outputStream) {
        saveProperties(properties, new LineBufferingOutputStream(new SkipFirstTextStream(new WriterTextStream(new OutputStreamWriter(outputStream, Charsets.ISO_8859_1)))));
    }

    public static Map map(Object... objects) {
        Map map = new HashMap();
        assert objects.length % 2 == 0;
        for (int i = 0; i < objects.length; i += 2) {
            map.put(objects[i], objects[i + 1]);
        }
        return map;
    }

    public static String toString(Iterable<?> names) {
        Formatter formatter = new Formatter();
        boolean first = true;
        for (Object name : names) {
            if (first) {
                formatter.format("'%s'", name);
                first = false;
            } else {
                formatter.format(", '%s'", name);
            }
        }
        return formatter.toString();
    }

    /**
     * Converts an arbitrary string to a camel-case string which can be used in a Java identifier. Eg, with_underscores -> withUnderscores
     */
    public static String toCamelCase(CharSequence string) {
        if (string == null) {
            return null;
        }
        StringBuilder builder = new StringBuilder();
        Matcher matcher = WORD_SEPARATOR.matcher(string);
        int pos = 0;
        while (matcher.find()) {
            builder.append(StringUtils.capitalize(string.subSequence(pos, matcher.start()).toString()));
            pos = matcher.end();
        }
        builder.append(StringUtils.capitalize(string.subSequence(pos, string.length()).toString()));
        return builder.toString();
    }

    public static String toLowerCamelCase(CharSequence string) {
        String camelCase = toCamelCase(string);
        if (camelCase == null) {
            return null;
        }
        if (camelCase.length() == 0) {
            return "";
        }
        return ((Character) camelCase.charAt(0)).toString().toLowerCase() + camelCase.subSequence(1, camelCase.length());
    }

    /**
     * Converts an arbitrary string to upper case identifier with words separated by _. Eg, camelCase -> CAMEL_CASE
     */
    public static String toConstant(CharSequence string) {
        if (string == null) {
            return null;
        }
        return toWords(string, '_').toUpperCase();
    }

    /**
     * Converts an arbitrary string to space-separated words. Eg, camelCase -> camel case, with_underscores -> with underscores
     */
    public static String toWords(CharSequence string) {
        return toWords(string, ' ');
    }

    public static String toWords(CharSequence string, char separator) {
        if (string == null) {
            return null;
        }
        StringBuilder builder = new StringBuilder();
        int pos = 0;
        Matcher matcher = UPPER_LOWER.matcher(string);
        while (pos < string.length()) {
            matcher.find(pos);
            if (matcher.end() == pos) {
                // Not looking at a match
                pos++;
                continue;
            }
            if (builder.length() > 0) {
                builder.append(separator);
            }
            String group1 = matcher.group(1).toLowerCase();
            String group2 = matcher.group(2);
            if (group2.length() == 0) {
                builder.append(group1);
            } else {
                if (group1.length() > 1) {
                    builder.append(group1.substring(0, group1.length() - 1));
                    builder.append(separator);
                    builder.append(group1.substring(group1.length() - 1));
                } else {
                    builder.append(group1);
                }
                builder.append(group2);
            }
            pos = matcher.end();
        }
        return builder.toString();
    }

    public static byte[] serialize(Object object) {
        StreamByteBuffer buffer = new StreamByteBuffer();
        serialize(object, buffer.getOutputStream());
        return buffer.readAsByteArray();
    }

    public static void serialize(Object object, OutputStream outputStream) {
        try {
            ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);
            objectOutputStream.writeObject(object);
            objectOutputStream.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static <T> Comparator<T> last(final Comparator<? super T> comparator, final T lastValue) {
        return new Comparator<T>() {

            public int compare(T o1, T o2) {
                boolean o1Last = comparator.compare(o1, lastValue) == 0;
                boolean o2Last = comparator.compare(o2, lastValue) == 0;
                if (o1Last && o2Last) {
                    return 0;
                }
                if (o1Last && !o2Last) {
                    return 1;
                }
                if (!o1Last && o2Last) {
                    return -1;
                }
                return comparator.compare(o1, o2);
            }
        };
    }

    /**
     * Calls the given callable converting any thrown exception to an unchecked exception via {@link UncheckedException#throwAsUncheckedException(Throwable)}
     *
     * @param callable The callable to call
     * @param <T> Callable's return type
     * @return The value returned by {@link Callable#call()}
     */
    public static <T> T uncheckedCall(Callable<T> callable) {
        try {
            return callable.call();
        } catch (Exception e) {
            throw UncheckedException.throwAsUncheckedException(e);
        }
    }
}}'} /repo/subprojects/core/src/main/java/org/gradle/execution/DefaultTasksBuildExecutionAction.java
Cannot solve method call LOGGER.info("No tasks specified. Using default task {}", GUtil.toString(defaultTasks)) UnsolvedSymbolException{context='Method 'toString' with parameterTypes [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public class GUtil {

    private static final Pattern WORD_SEPARATOR = Pattern.compile("\\W+");

    private static final Pattern UPPER_LOWER = Pattern.compile("(?m)([A-Z]*)([a-z0-9]*)");

    public static <T extends Collection> T flatten(Object[] elements, T addTo, boolean flattenMaps) {
        return flatten(asList(elements), addTo, flattenMaps);
    }

    public static <T extends Collection> T flatten(Object[] elements, T addTo) {
        return flatten(asList(elements), addTo);
    }

    public static <T extends Collection> T flatten(Collection elements, T addTo) {
        return flatten(elements, addTo, true);
    }

    public static <T extends Collection> T flattenElements(Object... elements) {
        Collection<T> out = new LinkedList<T>();
        flatten(elements, out, true);
        return (T) out;
    }

    public static <T extends Collection> T flatten(Collection elements, T addTo, boolean flattenMapsAndArrays) {
        return flatten(elements, addTo, flattenMapsAndArrays, flattenMapsAndArrays);
    }

    public static <T extends Collection> T flatten(Collection elements, T addTo, boolean flattenMaps, boolean flattenArrays) {
        Iterator iter = elements.iterator();
        while (iter.hasNext()) {
            Object element = iter.next();
            if (element instanceof Collection) {
                flatten((Collection) element, addTo, flattenMaps, flattenArrays);
            } else if ((element instanceof Map) && flattenMaps) {
                flatten(((Map) element).values(), addTo, flattenMaps, flattenArrays);
            } else if ((element.getClass().isArray()) && flattenArrays) {
                flatten(asList((Object[]) element), addTo, flattenMaps, flattenArrays);
            } else {
                addTo.add(element);
            }
        }
        return addTo;
    }

    /**
     * Flattens input collections (including arrays *but* not maps). If input is not a collection wraps it in a collection and returns it.
     *
     * @param input any object
     * @return collection of flattened input or single input wrapped in a collection.
     */
    public static Collection collectionize(Object input) {
        if (input == null) {
            return emptyList();
        } else if (input instanceof Collection) {
            Collection out = new LinkedList();
            flatten((Collection) input, out, false, true);
            return out;
        } else if (input.getClass().isArray()) {
            Collection out = new LinkedList();
            flatten(asList((Object[]) input), out, false, true);
            return out;
        } else {
            return asList(input);
        }
    }

    public static List flatten(Collection elements, boolean flattenMapsAndArrays) {
        return flatten(elements, new ArrayList(), flattenMapsAndArrays);
    }

    public static List flatten(Collection elements) {
        return flatten(elements, new ArrayList());
    }

    public static String asPath(Iterable<?> collection) {
        return CollectionUtils.join(File.pathSeparator, collection);
    }

    public static List<String> prefix(String prefix, Collection<String> strings) {
        List<String> prefixed = new ArrayList<String>();
        for (String string : strings) {
            prefixed.add(prefix + string);
        }
        return prefixed;
    }

    public static boolean isTrue(Object object) {
        if (object == null) {
            return false;
        }
        if (object instanceof Collection) {
            return ((Collection) object).size() > 0;
        } else if (object instanceof String) {
            return ((String) object).length() > 0;
        }
        return true;
    }

    public static <T> T elvis(T object, T defaultValue) {
        return isTrue(object) ? object : defaultValue;
    }

    public static <V, T extends Collection<? super V>> T addToCollection(T dest, boolean failOnNull, Iterable<? extends V>... srcs) {
        for (Iterable<? extends V> src : srcs) {
            for (V v : src) {
                if (failOnNull && v == null) {
                    throw new IllegalArgumentException("Illegal null value provided in this collection: " + src);
                }
                dest.add(v);
            }
        }
        return dest;
    }

    public static <V, T extends Collection<? super V>> T addToCollection(T dest, Iterable<? extends V>... srcs) {
        return addToCollection(dest, false, srcs);
    }

    public static Comparator<String> caseInsensitive() {
        return new Comparator<String>() {

            public int compare(String o1, String o2) {
                int diff = o1.compareToIgnoreCase(o2);
                if (diff != 0) {
                    return diff;
                }
                return o1.compareTo(o2);
            }
        };
    }

    public static Map addMaps(Map map1, Map map2) {
        HashMap map = new HashMap();
        map.putAll(map1);
        map.putAll(map2);
        return map;
    }

    public static void addToMap(Map<String, String> dest, Map<?, ?> src) {
        for (Map.Entry<?, ?> entry : src.entrySet()) {
            dest.put(entry.getKey().toString(), entry.getValue().toString());
        }
    }

    public static Properties loadProperties(File propertyFile) {
        try {
            FileInputStream inputStream = new FileInputStream(propertyFile);
            try {
                return loadProperties(inputStream);
            } finally {
                inputStream.close();
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static Properties loadProperties(URL url) {
        try {
            URLConnection uc = url.openConnection();
            uc.setUseCaches(false);
            return loadProperties(uc.getInputStream());
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static Properties loadProperties(InputStream inputStream) {
        Properties properties = new Properties();
        try {
            properties.load(inputStream);
            inputStream.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
        return properties;
    }

    public static void saveProperties(Properties properties, File propertyFile) {
        try {
            FileOutputStream propertiesFileOutputStream = new FileOutputStream(propertyFile);
            try {
                properties.store(propertiesFileOutputStream, null);
            } finally {
                propertiesFileOutputStream.close();
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static void saveProperties(Properties properties, OutputStream outputStream) {
        try {
            try {
                properties.store(outputStream, null);
            } finally {
                outputStream.close();
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static void savePropertiesNoDateComment(Properties properties, OutputStream outputStream) {
        saveProperties(properties, new LineBufferingOutputStream(new SkipFirstTextStream(new WriterTextStream(new OutputStreamWriter(outputStream, Charsets.ISO_8859_1)))));
    }

    public static Map map(Object... objects) {
        Map map = new HashMap();
        assert objects.length % 2 == 0;
        for (int i = 0; i < objects.length; i += 2) {
            map.put(objects[i], objects[i + 1]);
        }
        return map;
    }

    public static String toString(Iterable<?> names) {
        Formatter formatter = new Formatter();
        boolean first = true;
        for (Object name : names) {
            if (first) {
                formatter.format("'%s'", name);
                first = false;
            } else {
                formatter.format(", '%s'", name);
            }
        }
        return formatter.toString();
    }

    /**
     * Converts an arbitrary string to a camel-case string which can be used in a Java identifier. Eg, with_underscores -> withUnderscores
     */
    public static String toCamelCase(CharSequence string) {
        if (string == null) {
            return null;
        }
        StringBuilder builder = new StringBuilder();
        Matcher matcher = WORD_SEPARATOR.matcher(string);
        int pos = 0;
        while (matcher.find()) {
            builder.append(StringUtils.capitalize(string.subSequence(pos, matcher.start()).toString()));
            pos = matcher.end();
        }
        builder.append(StringUtils.capitalize(string.subSequence(pos, string.length()).toString()));
        return builder.toString();
    }

    public static String toLowerCamelCase(CharSequence string) {
        String camelCase = toCamelCase(string);
        if (camelCase == null) {
            return null;
        }
        if (camelCase.length() == 0) {
            return "";
        }
        return ((Character) camelCase.charAt(0)).toString().toLowerCase() + camelCase.subSequence(1, camelCase.length());
    }

    /**
     * Converts an arbitrary string to upper case identifier with words separated by _. Eg, camelCase -> CAMEL_CASE
     */
    public static String toConstant(CharSequence string) {
        if (string == null) {
            return null;
        }
        return toWords(string, '_').toUpperCase();
    }

    /**
     * Converts an arbitrary string to space-separated words. Eg, camelCase -> camel case, with_underscores -> with underscores
     */
    public static String toWords(CharSequence string) {
        return toWords(string, ' ');
    }

    public static String toWords(CharSequence string, char separator) {
        if (string == null) {
            return null;
        }
        StringBuilder builder = new StringBuilder();
        int pos = 0;
        Matcher matcher = UPPER_LOWER.matcher(string);
        while (pos < string.length()) {
            matcher.find(pos);
            if (matcher.end() == pos) {
                // Not looking at a match
                pos++;
                continue;
            }
            if (builder.length() > 0) {
                builder.append(separator);
            }
            String group1 = matcher.group(1).toLowerCase();
            String group2 = matcher.group(2);
            if (group2.length() == 0) {
                builder.append(group1);
            } else {
                if (group1.length() > 1) {
                    builder.append(group1.substring(0, group1.length() - 1));
                    builder.append(separator);
                    builder.append(group1.substring(group1.length() - 1));
                } else {
                    builder.append(group1);
                }
                builder.append(group2);
            }
            pos = matcher.end();
        }
        return builder.toString();
    }

    public static byte[] serialize(Object object) {
        StreamByteBuffer buffer = new StreamByteBuffer();
        serialize(object, buffer.getOutputStream());
        return buffer.readAsByteArray();
    }

    public static void serialize(Object object, OutputStream outputStream) {
        try {
            ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);
            objectOutputStream.writeObject(object);
            objectOutputStream.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static <T> Comparator<T> last(final Comparator<? super T> comparator, final T lastValue) {
        return new Comparator<T>() {

            public int compare(T o1, T o2) {
                boolean o1Last = comparator.compare(o1, lastValue) == 0;
                boolean o2Last = comparator.compare(o2, lastValue) == 0;
                if (o1Last && o2Last) {
                    return 0;
                }
                if (o1Last && !o2Last) {
                    return 1;
                }
                if (!o1Last && o2Last) {
                    return -1;
                }
                return comparator.compare(o1, o2);
            }
        };
    }

    /**
     * Calls the given callable converting any thrown exception to an unchecked exception via {@link UncheckedException#throwAsUncheckedException(Throwable)}
     *
     * @param callable The callable to call
     * @param <T> Callable's return type
     * @return The value returned by {@link Callable#call()}
     */
    public static <T> T uncheckedCall(Callable<T> callable) {
        try {
            return callable.call();
        } catch (Exception e) {
            throw UncheckedException.throwAsUncheckedException(e);
        }
    }
}}'} /repo/subprojects/core/src/main/java/org/gradle/execution/DefaultTasksBuildExecutionAction.java
Cannot solve method call gradle.getTaskGraph().useFilter(Specs.intersect(filters)) UnsolvedSymbolException{context='Method 'intersect' with parameterTypes [ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{org.gradle.api.specs.Spec, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.api.specs.Spec.T=ReferenceType{org.gradle.api.Task, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * Provides a number of {@link org.gradle.api.specs.Spec} implementations.
 */
public class Specs {

    public static final Spec<Object> SATISFIES_ALL = new Spec<Object>() {

        public boolean isSatisfiedBy(Object element) {
            return true;
        }
    };

    public static <T> Spec<T> satisfyAll() {
        return Cast.uncheckedCast(SATISFIES_ALL);
    }

    public static final Spec<Object> SATISFIES_NONE = new Spec<Object>() {

        public boolean isSatisfiedBy(Object element) {
            return false;
        }
    };

    public static <T> Spec<T> satisfyNone() {
        return Cast.uncheckedCast(SATISFIES_NONE);
    }

    public static <T> Spec<T> convertClosureToSpec(final Closure closure) {
        return new ClosureSpec<T>(closure);
    }

    /**
     * Returns a spec that selects the intersection of those items selected by the given specs. Returns a spec that selects everything when no specs provided.
     */
    public static <T> Spec<T> intersect(Spec<? super T>... specs) {
        if (specs.length == 0) {
            return satisfyAll();
        }
        if (specs.length == 1) {
            return Cast.uncheckedCast(specs[0]);
        }
        return doIntersect(Arrays.asList(specs));
    }

    /**
     * Returns a spec that selects the intersection of those items selected by the given specs. Returns a spec that selects everything when no specs provided.
     */
    public static <T> Spec<T> intersect(Collection<? extends Spec<? super T>> specs) {
        if (specs.size() == 0) {
            return satisfyAll();
        }
        return doIntersect(specs);
    }

    private static <T> Spec<T> doIntersect(Collection<? extends Spec<? super T>> specs) {
        List<Spec<? super T>> filtered = new ArrayList<Spec<? super T>>(specs.size());
        for (Spec<? super T> spec : specs) {
            if (spec == SATISFIES_NONE) {
                return satisfyNone();
            }
            if (spec != SATISFIES_ALL) {
                filtered.add(spec);
            }
        }
        if (filtered.size() == 0) {
            return satisfyAll();
        }
        if (filtered.size() == 1) {
            return Cast.uncheckedCast(filtered.get(0));
        }
        return new AndSpec<T>(filtered);
    }

    /**
     * Returns a spec that selects the union of those items selected by the provided spec. Selects everything when no specs provided.
     */
    public static <T> Spec<T> union(Spec<? super T>... specs) {
        if (specs.length == 0) {
            return satisfyAll();
        }
        if (specs.length == 1) {
            return Cast.uncheckedCast(specs[0]);
        }
        return doUnion(Arrays.asList(specs));
    }

    /**
     * Returns a spec that selects the union of those items selected by the provided spec. Selects everything when no specs provided.
     */
    public static <T> Spec<T> union(Collection<? extends Spec<? super T>> specs) {
        if (specs.size() == 0) {
            return satisfyAll();
        }
        return doUnion(specs);
    }

    private static <T> Spec<T> doUnion(Collection<? extends Spec<? super T>> specs) {
        List<Spec<? super T>> filtered = new ArrayList<Spec<? super T>>(specs.size());
        for (Spec<? super T> spec : specs) {
            if (spec == SATISFIES_ALL) {
                return satisfyAll();
            }
            if (spec != SATISFIES_NONE) {
                filtered.add(spec);
            }
        }
        if (filtered.size() == 0) {
            return satisfyNone();
        }
        if (filtered.size() == 1) {
            return Cast.uncheckedCast(filtered.get(0));
        }
        return new OrSpec<T>(filtered);
    }

    /**
     * Returns a spec that selects everything that is not selected by the given spec.
     */
    public static <T> Spec<T> negate(Spec<? super T> spec) {
        if (spec == SATISFIES_ALL) {
            return satisfyNone();
        }
        if (spec == SATISFIES_NONE) {
            return satisfyAll();
        }
        if (spec instanceof NotSpec) {
            NotSpec<? super T> notSpec = (NotSpec<? super T>) spec;
            return Cast.uncheckedCast(notSpec.getSourceSpec());
        }
        return new NotSpec<T>(spec);
    }
}}'} /repo/subprojects/core/src/main/java/org/gradle/execution/ExcludedTaskFilteringBuildConfigurationAction.java
Cannot solve field access TaskExecutionState.UNKNOWN
Cannot solve field access TaskExecutionState.SHOULD_RUN
Cannot solve field access TaskExecutionState.MUST_NOT_RUN
Cannot solve field access TaskExecutionState.NOT_REQUIRED
Cannot solve field access TaskExecutionState.UNKNOWN
Cannot solve field access TaskExecutionState.SHOULD_RUN
Cannot solve field access TaskExecutionState.MUST_RUN
Cannot solve field access TaskExecutionState.UNKNOWN
Cannot solve field access TaskExecutionState.EXECUTED
Cannot solve field access TaskExecutionState.SKIPPED
Cannot solve field access TaskExecutionState.UNKNOWN
Cannot solve field access TaskExecutionState.NOT_REQUIRED
Cannot solve field access TaskExecutionState.MUST_NOT_RUN
Cannot solve field access TaskExecutionState.EXECUTED
Cannot solve field access TaskExecutionState.NOT_REQUIRED
Cannot solve field access TaskExecutionState.MUST_NOT_RUN
Cannot solve field access TaskExecutionState.EXECUTING
Cannot solve field access TaskExecutionState.EXECUTING
Cannot solve field access TaskExecutionState.EXECUTED
Cannot solve field access TaskExecutionState.SHOULD_RUN
Cannot solve field access TaskExecutionState.SKIPPED
Cannot solve field access TaskExecutionState.SHOULD_RUN
Cannot solve field access TaskExecutionState.NOT_REQUIRED
Cannot solve field access TaskExecutionState.MUST_NOT_RUN
Cannot solve field access TaskExecutionState.SHOULD_RUN
Cannot solve field access TaskExecutionState.MUST_NOT_RUN
Cannot solve field access TaskExecutionState.MUST_RUN
Cannot solve field access TaskExecutionState.MUST_RUN
Cannot solve field access TaskExecutionState.EXECUTING
Cannot solve method call filter.isSatisfiedBy(successor.getTask()) java.lang.RuntimeException: Method 'getTask' cannot be resolved in context successor.getTask() (line: 164) MethodCallExprContext{wrapped=successor.getTask()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/execution/taskgraph/DefaultTaskExecutionPlan.java
Cannot solve method call filter.isSatisfiedBy(finalizerNode.getTask()) java.lang.RuntimeException: Method 'getTask' cannot be resolved in context finalizerNode.getTask() (line: 214) MethodCallExprContext{wrapped=finalizerNode.getTask()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/execution/taskgraph/DefaultTaskExecutionPlan.java
Cannot solve method call filter.isSatisfiedBy(taskInfo.getTask()) java.lang.RuntimeException: Method 'getTask' cannot be resolved in context taskInfo.getTask() (line: 230) MethodCallExprContext{wrapped=taskInfo.getTask()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/execution/taskgraph/DefaultTaskExecutionPlan.java
Cannot solve method call Lists.newArrayList(Iterables.transform(entryTasks, new Function<TaskInfo, TaskInfoInVisitingSegment>() {

    int index;

    public TaskInfoInVisitingSegment apply(TaskInfo taskInfo) {
        return new TaskInfoInVisitingSegment(taskInfo, index++);
    }
})) UnsolvedSymbolException{context='Method 'transform' with parameterTypes [ReferenceType{Set, typeParametersMap=TypeParametersMap{nameToValue={empty.String=ReferenceType{TaskInfo, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{Function, typeParametersMap=TypeParametersMap{nameToValue={empty.Equivalence.Wrapper<Method>=ReferenceType{org.gradle.execution.taskgraph.DefaultTaskExecutionPlan.TaskInfoInVisitingSegment, typeParametersMap=TypeParametersMap{nameToValue={}}}, empty.Method=ReferenceType{TaskInfo, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/core/src/main/java/org/gradle/execution/taskgraph/DefaultTaskExecutionPlan.java
Cannot solve method call executionPlan.containsKey(taskNode.getTask()) java.lang.RuntimeException: Method 'getTask' cannot be resolved in context taskNode.getTask() (line: 258) MethodCallExprContext{wrapped=taskNode.getTask()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/execution/taskgraph/DefaultTaskExecutionPlan.java
Cannot solve method call executionPlan.put(taskNode.getTask(), taskNode) java.lang.RuntimeException: Method 'getTask' cannot be resolved in context taskNode.getTask() (line: 298) MethodCallExprContext{wrapped=taskNode.getTask()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/execution/taskgraph/DefaultTaskExecutionPlan.java
Cannot solve method call addAllReversed(finalizerTasks, taskNode.getFinalizers()) java.lang.RuntimeException: Method 'getFinalizers' cannot be resolved in context taskNode.getFinalizers() (line: 301) MethodCallExprContext{wrapped=taskNode.getFinalizers()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/execution/taskgraph/DefaultTaskExecutionPlan.java
Cannot solve method call executionQueue.addAll(executionPlan.values()) java.lang.RuntimeException: Method 'values' cannot be resolved in context executionPlan.values() (line: 310) MethodCallExprContext{wrapped=executionPlan.values()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/execution/taskgraph/DefaultTaskExecutionPlan.java
Method 'peek' cannot be resolved in context walkedShouldRunAfterEdges.peek() (line: 314) MethodCallExprContext{wrapped=walkedShouldRunAfterEdges.peek()}. Parameter types: []
Method 'peek' cannot be resolved in context walkedShouldRunAfterEdges.peek() (line: 314) MethodCallExprContext{wrapped=walkedShouldRunAfterEdges.peek()}. Parameter types: []
Method 'entrySet' cannot be resolved in context executionPlan.entrySet() (line: 320) MethodCallExprContext{wrapped=executionPlan.entrySet()}. Parameter types: []
Cannot solve method call addAllReversed(dependsOnTasks, taskNode.getDependencySuccessors()) java.lang.RuntimeException: Method 'getDependencySuccessors' cannot be resolved in context taskNode.getDependencySuccessors() (line: 349) MethodCallExprContext{wrapped=taskNode.getDependencySuccessors()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/execution/taskgraph/DefaultTaskExecutionPlan.java
Cannot solve method call addAllReversed(dependsOnTasks, taskNode.getMustSuccessors()) java.lang.RuntimeException: Method 'getMustSuccessors' cannot be resolved in context taskNode.getMustSuccessors() (line: 350) MethodCallExprContext{wrapped=taskNode.getMustSuccessors()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/execution/taskgraph/DefaultTaskExecutionPlan.java
Cannot solve method call addAllReversed(dependsOnTasks, taskNode.getShouldSuccessors()) java.lang.RuntimeException: Method 'getShouldSuccessors' cannot be resolved in context taskNode.getShouldSuccessors() (line: 351) MethodCallExprContext{wrapped=taskNode.getShouldSuccessors()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/execution/taskgraph/DefaultTaskExecutionPlan.java
Cannot solve method call Iterables.removeIf(taskNode.getShouldSuccessors(), new Predicate<TaskInfo>() {

    public boolean apply(TaskInfo input) {
        return visitingNodes.containsEntry(input, taskNodeWithVisitingSegment.visitingSegment);
    }
}) java.lang.RuntimeException: Method 'getShouldSuccessors' cannot be resolved in context taskNode.getShouldSuccessors() (line: 356) MethodCallExprContext{wrapped=taskNode.getShouldSuccessors()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/execution/taskgraph/DefaultTaskExecutionPlan.java
Method 'getShouldSuccessors' cannot be resolved in context taskNode.getShouldSuccessors() (line: 364) MethodCallExprContext{wrapped=taskNode.getShouldSuccessors()}. Parameter types: []
Cannot solve method call planBeforeVisiting.put(taskNode, executionPlan.size()) java.lang.RuntimeException: Method 'size' cannot be resolved in context executionPlan.size() (line: 365) MethodCallExprContext{wrapped=executionPlan.size()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/execution/taskgraph/DefaultTaskExecutionPlan.java
Method 'peek' cannot be resolved in context path.peek() (line: 370) MethodCallExprContext{wrapped=path.peek()}. Parameter types: []
Method 'peek' cannot be resolved in context path.peek() (line: 370) MethodCallExprContext{wrapped=path.peek()}. Parameter types: []
Cannot solve method call dependsOnTasks.addAll(finalizer.getDependencySuccessors()) java.lang.RuntimeException: Method 'getDependencySuccessors' cannot be resolved in context finalizer.getDependencySuccessors() (line: 381) MethodCallExprContext{wrapped=finalizer.getDependencySuccessors()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/execution/taskgraph/DefaultTaskExecutionPlan.java
Cannot solve method call dependsOnTasks.addAll(finalizer.getMustSuccessors()) java.lang.RuntimeException: Method 'getMustSuccessors' cannot be resolved in context finalizer.getMustSuccessors() (line: 382) MethodCallExprContext{wrapped=finalizer.getMustSuccessors()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/execution/taskgraph/DefaultTaskExecutionPlan.java
Cannot solve method call dependsOnTasks.addAll(finalizer.getShouldSuccessors()) java.lang.RuntimeException: Method 'getShouldSuccessors' cannot be resolved in context finalizer.getShouldSuccessors() (line: 383) MethodCallExprContext{wrapped=finalizer.getShouldSuccessors()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/execution/taskgraph/DefaultTaskExecutionPlan.java
Cannot solve method call connectedNodes.addAll(node.getDependencySuccessors()) java.lang.RuntimeException: Method 'getDependencySuccessors' cannot be resolved in context node.getDependencySuccessors() (line: 399) MethodCallExprContext{wrapped=node.getDependencySuccessors()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/execution/taskgraph/DefaultTaskExecutionPlan.java
Cannot solve method call connectedNodes.addAll(node.getMustSuccessors()) java.lang.RuntimeException: Method 'getMustSuccessors' cannot be resolved in context node.getMustSuccessors() (line: 400) MethodCallExprContext{wrapped=node.getMustSuccessors()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/execution/taskgraph/DefaultTaskExecutionPlan.java
Method 'getTask' cannot be resolved in context node.getTask() (line: 409) MethodCallExprContext{wrapped=node.getTask()}. Parameter types: []
Cannot resolve field access null
Cannot solve field access StyledTextOutput.Style.Identifier
Cannot solve method call output.withStyle(StyledTextOutput.Style.Identifier).text(node.getTask().getPath()) java.lang.RuntimeException: Method 'getTask' cannot be resolved in context node.getTask() (line: 409) MethodCallExprContext{wrapped=node.getTask()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/execution/taskgraph/DefaultTaskExecutionPlan.java
Method 'getDependencySuccessors' cannot be resolved in context node.getDependencySuccessors() (line: 414) MethodCallExprContext{wrapped=node.getDependencySuccessors()}. Parameter types: []
Method 'getMustSuccessors' cannot be resolved in context node.getMustSuccessors() (line: 414) MethodCallExprContext{wrapped=node.getMustSuccessors()}. Parameter types: []
Cannot solve method call graphRenderer.renderTo(firstCycle.get(0), writer) java.lang.RuntimeException: Method 'get' cannot be resolved in context firstCycle.get(0) (line: 421) MethodCallExprContext{wrapped=firstCycle.get(0)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/core/src/main/java/org/gradle/execution/taskgraph/DefaultTaskExecutionPlan.java
Cannot solve method call Sets.newHashSet(Iterables.transform(task.getOutputs().getFiles(), new Function<File, String>() {

    @Override
    public String apply(File file) {
        String path;
        try {
            path = file.getCanonicalPath();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
        return path;
    }
})) UnsolvedSymbolException{context='Method 'transform' with parameterTypes [ReferenceType{org.gradle.api.file.FileCollection, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{Function, typeParametersMap=TypeParametersMap{nameToValue={empty.Equivalence.Wrapper<Method>=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, empty.Method=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/core/src/main/java/org/gradle/execution/taskgraph/DefaultTaskExecutionPlan.java
Cannot solve method call longer.startsWith(shorter + StandardSystemProperty.FILE_SEPARATOR.value()) UnsolvedSymbolException{context='unknown', name='FILE_SEPARATOR', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/execution/taskgraph/DefaultTaskExecutionPlan.java
Cannot solve method call task.getClass().isAnnotationPresent(ParallelizableTask.class) java.lang.UnsupportedOperationException /repo/subprojects/core/src/main/java/org/gradle/execution/taskgraph/DefaultTaskExecutionPlan.java
Cannot solve method call enforceWithDependencies(finalizerNode, Sets.<TaskInfo>newHashSet()) UnsolvedSymbolException{context='Method 'newHashSet' with parameterTypes []', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Sets}'} /repo/subprojects/core/src/main/java/org/gradle/execution/taskgraph/DefaultTaskExecutionPlan.java
Cannot solve method call failureHandler.onTaskFailure(taskInfo.getTask()) java.lang.RuntimeException: Method 'getTask' cannot be resolved in context taskInfo.getTask() (line: 681) MethodCallExprContext{wrapped=taskInfo.getTask()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/execution/taskgraph/DefaultTaskExecutionPlan.java
Cannot solve method call this.failures.add(taskInfo.getTaskFailure()) java.lang.RuntimeException: Method 'getTaskFailure' cannot be resolved in context taskInfo.getTaskFailure() (line: 682) MethodCallExprContext{wrapped=taskInfo.getTaskFailure()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/execution/taskgraph/DefaultTaskExecutionPlan.java
Cannot solve method call UncheckedException.throwAsUncheckedException(failures.get(0)) java.lang.RuntimeException: Method 'get' cannot be resolved in context failures.get(0) (line: 730) MethodCallExprContext{wrapped=failures.get(0)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/core/src/main/java/org/gradle/execution/taskgraph/DefaultTaskExecutionPlan.java
Method 'getState' cannot be resolved in context task.getState() (line: 764) MethodCallExprContext{wrapped=task.getState()}. Parameter types: []
Cannot solve field access TaskGraphState.EMPTY
Cannot solve field access TaskGraphState.DIRTY
Cannot solve field access TaskGraphState.DIRTY
Empty name expression EMPTY
Empty name expression DIRTY
Cannot solve field access TaskGraphState.POPULATED
Empty name expression POPULATED
Cannot solve method call LOGGER.info("{} ({}) started.", taskPath, Thread.currentThread()) UnsolvedSymbolException{context='Method 'currentThread' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Thread}'} /repo/subprojects/core/src/main/java/org/gradle/execution/taskgraph/AbstractTaskPlanExecutor.java
Cannot solve method call LOGGER.info("{} ({}) completed. Took {}.", taskPath, Thread.currentThread(), prettyTime(taskDuration)) UnsolvedSymbolException{context='Method 'currentThread' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Thread}'} /repo/subprojects/core/src/main/java/org/gradle/execution/taskgraph/AbstractTaskPlanExecutor.java
Cannot solve method call LOGGER.debug("Task worker [{}] finished, busy: {}, idle: {}", Thread.currentThread(), prettyTime(busy), prettyTime(total - busy)) UnsolvedSymbolException{context='Method 'currentThread' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Thread}'} /repo/subprojects/core/src/main/java/org/gradle/execution/taskgraph/AbstractTaskPlanExecutor.java
Cannot resolve field access null
TypeVariable {org.gradle.api.internal.collections.FilteredList.T} is not a Reference Type
TypeVariable {org.gradle.api.internal.collections.FilteredList.T} is not a Reference Type
Cannot resolve field access null
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call fileCollectionFactory.fixed("Task " + task.getPath() + " outputs", builder.build()) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/changes/DefaultTaskArtifactStateRepository.java
Cannot solve method call currentExecution.setDeclaredOutputFilePaths(getDeclaredOutputFilePaths(task)) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/state/CacheBackedTaskHistoryRepository.java
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
Cannot solve method call declaredOutputFilePaths.add(stringInterner.intern(file.getAbsolutePath())) java.lang.RuntimeException: Method 'intern' cannot be resolved in context stringInterner.intern(file.getAbsolutePath()) (line: 144) MethodCallExprContext{wrapped=stringInterner.intern(file.getAbsolutePath())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/state/CacheBackedTaskHistoryRepository.java
Cannot solve method call setDeclaredOutputFilePaths(taskExecutionSnapshot.getDeclaredOutputFilePaths()) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/state/CacheBackedTaskHistoryRepository.java
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
Cannot solve method call encoder.writeBinary(classLoaderHash.asBytes()) java.lang.RuntimeException: Method 'asBytes' cannot be resolved in context classLoaderHash.asBytes() (line: 382) MethodCallExprContext{wrapped=classLoaderHash.asBytes()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/state/CacheBackedTaskHistoryRepository.java
Cannot solve method call encoder.writeBinary(actionsClassLoaderHash.asBytes()) java.lang.RuntimeException: Method 'asBytes' cannot be resolved in context actionsClassLoaderHash.asBytes() (line: 389) MethodCallExprContext{wrapped=actionsClassLoaderHash.asBytes()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/state/CacheBackedTaskHistoryRepository.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call encoder.writeSmallInt(execution.getDeclaredOutputFilePaths().size()) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/state/CacheBackedTaskHistoryRepository.java
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
Cannot solve field access ChangeType.REMOVED
Cannot solve field access ChangeType.ADDED
Cannot solve field access ChangeType.REMOVED
Cannot solve field access ChangeType.REPLACED
Cannot solve field access ChangeType.MODIFIED
Cannot solve field access LogLevel.INFO
Cannot solve method call logger.log(LogLevel.INFO, "Cache entries evicted. In-memory cache of {}: Size{{}} MaxSize{{}}, {} {}", cacheId, cache.size(), maxSize, cache.stats(), EVICTION_MITIGATION_MESSAGE) java.lang.RuntimeException: Method 'size' cannot be resolved in context cache.size() (line: 50) MethodCallExprContext{wrapped=cache.size()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/state/LoggingEvictionListener.java
Cannot solve method call builder.putBytes(taskClassLoaderHash.asBytes()) java.lang.RuntimeException: Method 'asBytes' cannot be resolved in context taskClassLoaderHash.asBytes() (line: 109) MethodCallExprContext{wrapped=taskClassLoaderHash.asBytes()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/state/TaskExecution.java
Cannot solve method call builder.putBytes(taskActionsClassLoaderHash.asBytes()) java.lang.RuntimeException: Method 'asBytes' cannot be resolved in context taskActionsClassLoaderHash.asBytes() (line: 110) MethodCallExprContext{wrapped=taskActionsClassLoaderHash.asBytes()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/state/TaskExecution.java
Cannot solve method call builder.putString(((Enum) value).name()) java.lang.RuntimeException: Method 'name' cannot be resolved in context ((Enum) value).name() (line: 195) MethodCallExprContext{wrapped=((Enum) value).name()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/state/TaskExecution.java
Cannot solve method call hasher.putBytes(getSnapshot().getHash().asBytes()) java.lang.RuntimeException: Method 'asBytes' cannot be resolved in context getSnapshot().getHash().asBytes() (line: 37) MethodCallExprContext{wrapped=getSnapshot().getHash().asBytes()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/state/AbstractNormalizedFileSnapshot.java
Cannot resolve field access null
Cannot solve field access FileLockManager.LockMode.None
Method 'cache' cannot be resolved in context cacheRepository.cache(gradle, "taskArtifacts") (line: 36) MethodCallExprContext{wrapped=cacheRepository.cache(gradle, "taskArtifacts")}. Parameter types: [ReferenceType{org.gradle.api.invocation.Gradle, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'cache' cannot be resolved in context cacheRepository.cache(gradle, "taskArtifacts") (line: 36) MethodCallExprContext{wrapped=cacheRepository.cache(gradle, "taskArtifacts")}. Parameter types: [ReferenceType{org.gradle.api.invocation.Gradle, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'cache' cannot be resolved in context cacheRepository.cache(gradle, "taskArtifacts") (line: 36) MethodCallExprContext{wrapped=cacheRepository.cache(gradle, "taskArtifacts")}. Parameter types: [ReferenceType{org.gradle.api.invocation.Gradle, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve field access ChangeType.REMOVED
Cannot solve field access ChangeType.ADDED
Cannot solve field access ChangeType.REPLACED
Cannot solve field access ChangeType.MODIFIED
Cannot solve method call capSizes.put(entry.getKey(), scaleCacheSize(entry.getValue())) java.lang.RuntimeException: Method 'scaleCacheSize' cannot be resolved in context scaleCacheSize(entry.getValue()) (line: 49) MethodCallExprContext{wrapped=scaleCacheSize(entry.getValue())}. Parameter types: [ReferenceType{Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/state/CacheCapSizer.java
Cannot solve method call LOG.info("In-memory cache of {}: Size{{}}, {}", cacheId, inMemoryCache.size(), inMemoryCache.stats()) java.lang.RuntimeException: Method 'size' cannot be resolved in context inMemoryCache.size() (line: 79) MethodCallExprContext{wrapped=inMemoryCache.size()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/state/InMemoryTaskArtifactCache.java
Method 'asMap' cannot be resolved in context cache.asMap() (line: 99) MethodCallExprContext{wrapped=cache.asMap()}. Parameter types: []
Unsolved symbol : SnapshotNormalizationStrategy
Unsolved symbol : SnapshotNormalizationStrategy
Unsolved symbol : SnapshotNormalizationStrategy
Unsolved symbol : SnapshotNormalizationStrategy
Cannot solve method call getRelativeSnapshot(fileDetails, snapshot, stringInterner) UnsolvedSymbolException{context='unknown', name='SnapshotNormalizationStrategy', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/state/TaskFilePropertySnapshotNormalizationStrategy.java
Unsolved symbol : SnapshotNormalizationStrategy
Unsolved symbol : SnapshotNormalizationStrategy
Unsolved symbol : SnapshotNormalizationStrategy
Unsolved symbol : SnapshotNormalizationStrategy
Cannot solve method call getRelativeSnapshot(fileDetails, fileDetails.getName(), snapshot, stringInterner) UnsolvedSymbolException{context='unknown', name='SnapshotNormalizationStrategy', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/state/TaskFilePropertySnapshotNormalizationStrategy.java
Unsolved symbol : SnapshotNormalizationStrategy
Unsolved symbol : SnapshotNormalizationStrategy
Cannot solve name expression ABSOLUTE
Cannot solve name expression ABSOLUTE
Cannot solve name expression RELATIVE
Cannot solve name expression RELATIVE
Cannot solve name expression NAME_ONLY
Cannot solve name expression NAME_ONLY
Cannot solve name expression NONE
Cannot solve name expression NONE
Cannot solve name expression pathSensitivity
Unsolved symbol : SnapshotNormalizationStrategy
Unsolved symbol : SnapshotNormalizationStrategy
Unsolved symbol : SnapshotNormalizationStrategy
Unsolved symbol : SnapshotNormalizationStrategy
Unsolved symbol : SnapshotNormalizationStrategy
Cannot solve method call getRelativeSnapshot(fileDetails, builder.toString(), snapshot, stringInterner) UnsolvedSymbolException{context='unknown', name='SnapshotNormalizationStrategy', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/state/TaskFilePropertySnapshotNormalizationStrategy.java
Unsolved symbol : SnapshotNormalizationStrategy
Unsolved symbol : SnapshotNormalizationStrategy
Unsolved symbol : SnapshotNormalizationStrategy
Unsolved symbol : SnapshotNormalizationStrategy
Unsolved symbol : SnapshotNormalizationStrategy
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call snapshotter.snapshot(fileDetails.details) UnsolvedSymbolException{context='unknown', name='details', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/state/DefaultFileCollectionSnapshotter.java
Error calculating the type of parameter fileDetails.details of method call snapshotter.snapshot(fileDetails.details)
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call snapshotNormalizationStrategy.getNormalizedSnapshot(missingFileDetails, MissingFileSnapshot.getInstance(), stringInterner) UnsolvedSymbolException{context='Method 'getInstance' with parameterTypes []', name='ReflectionClassDeclaration{clazz=MissingFileSnapshot}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/state/DefaultFileCollectionSnapshotter.java
Cannot solve method call snapshots.put(absolutePath, snapshotNormalizationStrategy.getNormalizedSnapshot(missingFileDetails, MissingFileSnapshot.getInstance(), stringInterner)) java.lang.RuntimeException: Error calculating the type of parameter MissingFileSnapshot.getInstance() of method call snapshotNormalizationStrategy.getNormalizedSnapshot(missingFileDetails, MissingFileSnapshot.getInstance(), stringInterner) /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/state/DefaultFileCollectionSnapshotter.java
Cannot resolve field access null
Cannot solve method call rootFiles.put(details.path, details) UnsolvedSymbolException{context='unknown', name='path', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/state/DefaultFileCollectionSnapshotter.java
Cannot solve name expression RegularFile
Cannot solve name expression details
Cannot solve name expression fileTreeElements
Cannot solve name expression Directory
Cannot solve name expression details
Cannot solve name expression fileTreeElements
Cannot solve name expression file
Cannot solve name expression directoryFileTreeFactory
Cannot solve method call visitDirectoryTree(directoryFileTreeFactory.create(file)) java.lang.RuntimeException: Error calculating the type of parameter file of method call directoryFileTreeFactory.create(file) /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/state/DefaultFileCollectionSnapshotter.java
Cannot solve name expression Missing
Cannot solve name expression details
Cannot solve name expression missingFiles
Cannot resolve field access null
Cannot solve field access ChangeType.MODIFIED
Cannot solve field access ChangeType.REMOVED
Cannot solve field access ChangeType.ADDED
Cannot solve field access ChangeType.MODIFIED
Cannot solve method call Lists.newArrayList(unaccountedForPreviousSnapshots.entries()) java.lang.RuntimeException: Method 'entries' cannot be resolved in context unaccountedForPreviousSnapshots.entries() (line: 154) MethodCallExprContext{wrapped=unaccountedForPreviousSnapshots.entries()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/state/OrderInsensitiveTaskFilePropertyCompareStrategy.java
Cannot solve field access ChangeType.REMOVED
Cannot solve field access ChangeType.MODIFIED
Cannot solve field access ChangeType.ADDED
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
Cannot solve field access TaskFilePropertyCompareStrategy.OUTPUT
Cannot solve method call builder.putBytes(snapshot.getHash().asBytes()) java.lang.RuntimeException: Method 'asBytes' cannot be resolved in context snapshot.getHash().asBytes() (line: 42) MethodCallExprContext{wrapped=snapshot.getHash().asBytes()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/state/IgnoredPathFileSnapshot.java
Cannot solve method call String.format("Failed to capture snapshot of %s files for task '%s' property '%s' during up-to-date check.", title.toLowerCase(), taskName, propertySpec.getPropertyName()) java.lang.RuntimeException: Method 'toLowerCase' cannot be resolved in context title.toLowerCase() (line: 87) MethodCallExprContext{wrapped=title.toLowerCase()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/rules/AbstractNamedFileSnapshotTaskStateChanges.java
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
Cannot solve method call Iterators.concat(Iterables.transform(getCurrent().entrySet(), new Function<Map.Entry<String, FileCollectionSnapshot>, Iterator<TaskStateChange>>() {

    @Override
    public Iterator<TaskStateChange> apply(Map.Entry<String, FileCollectionSnapshot> entry) {
        String propertyName = entry.getKey();
        FileCollectionSnapshot currentSnapshot = entry.getValue();
        FileCollectionSnapshot previousSnapshot = getPrevious().get(propertyName);
        String propertyTitle = title + " property '" + propertyName + "'";
        return currentSnapshot.iterateContentChangesSince(previousSnapshot, propertyTitle);
    }
}).iterator()) UnsolvedSymbolException{context='Method 'transform' with parameterTypes [ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{java.util.Map.Entry, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.Entry.K=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.Entry.V=ReferenceType{org.gradle.api.internal.changedetection.state.FileCollectionSnapshot, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}}}, ReferenceType{Function, typeParametersMap=TypeParametersMap{nameToValue={empty.Equivalence.Wrapper<Method>=ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=ReferenceType{org.gradle.api.internal.changedetection.rules.TaskStateChange, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, empty.Method=ReferenceType{java.util.Map.Entry, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.Entry.K=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.Entry.V=ReferenceType{org.gradle.api.internal.changedetection.state.FileCollectionSnapshot, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/rules/AbstractNamedFileSnapshotTaskStateChanges.java
Cannot solve field access ChangeType.ADDED
Cannot solve field access ChangeType.MODIFIED
Cannot solve field access ChangeType.REMOVED
Cannot solve method call classLoaderHierarchyHasher.getStrictHash(taskClass.getClassLoader()) java.lang.RuntimeException: Method 'getClassLoader' cannot be resolved in context taskClass.getClassLoader() (line: 42) MethodCallExprContext{wrapped=taskClass.getClassLoader()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/rules/TaskTypeTaskStateChanges.java
Cannot solve method call hasher.putBytes(actionLoaderHash.asBytes()) java.lang.RuntimeException: Method 'asBytes' cannot be resolved in context actionLoaderHash.asBytes() (line: 63) MethodCallExprContext{wrapped=actionLoaderHash.asBytes()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/rules/TaskTypeTaskStateChanges.java
Cannot solve method call createSnapshot(snapshotter, fileCollectionFactory.fixed("Discovered input files", getPrevious().getElements())) java.lang.RuntimeException: Method 'fixed' cannot be resolved in context fileCollectionFactory.fixed("Discovered input files", getPrevious().getElements()) (line: 60) MethodCallExprContext{wrapped=fileCollectionFactory.fixed("Discovered input files", getPrevious().getElements())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/rules/DiscoveredInputsTaskStateChanges.java
Cannot solve method call createSnapshot(snapshotter, fileCollectionFactory.fixed("Discovered input files", discoveredFiles)) java.lang.RuntimeException: Method 'fixed' cannot be resolved in context fileCollectionFactory.fixed("Discovered input files", discoveredFiles) (line: 76) MethodCallExprContext{wrapped=fileCollectionFactory.fixed("Discovered input files", discoveredFiles)}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/rules/DiscoveredInputsTaskStateChanges.java
Cannot solve field access TaskFilePropertyCompareStrategy.UNORDERED
Cannot solve field access TaskFilePropertySnapshotNormalizationStrategy.ABSOLUTE
Cannot solve method call snapshotter.snapshot(fileCollection, TaskFilePropertyCompareStrategy.UNORDERED, TaskFilePropertySnapshotNormalizationStrategy.ABSOLUTE) UnsolvedSymbolException{context='unknown', name='SnapshotNormalizationStrategy', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/rules/DiscoveredInputsTaskStateChanges.java
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
Cannot solve method call current.setOutputFilesSnapshot(builder.build()) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 2 /repo/subprojects/core/src/main/java/org/gradle/api/internal/changedetection/rules/OutputFilesTaskStateChanges.java
Cannot resolve field access null
Cannot solve field access ExtensibleDynamicObject.Location.AfterConvention
Cannot solve method call registerServiceOn(modelRegistry, "serviceRegistry", SERVICE_REGISTRY_MODEL_TYPE, services, instanceDescriptorFor("serviceRegistry")) java.lang.RuntimeException: Method 'instanceDescriptorFor' cannot be resolved in context instanceDescriptorFor("serviceRegistry") (line: 282) MethodCallExprContext{wrapped=instanceDescriptorFor("serviceRegistry")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/DefaultProject.java
Cannot resolve field access null
Cannot solve field access ExtensibleDynamicObject.Location.BeforeConvention
Method 'substring' cannot be resolved in context getParent().getPath().substring(1) (line: 394) MethodCallExprContext{wrapped=getParent().getPath().substring(1)}. Parameter types: [PrimitiveTypeUsage{name='int'}]
Cannot solve method call taskContainer.create(addMaps(options, singletonMap(Task.TASK_NAME, task))) java.lang.RuntimeException: Method 'addMaps' cannot be resolved in context addMaps(options, singletonMap(Task.TASK_NAME, task)) (line: 968) MethodCallExprContext{wrapped=addMaps(options, singletonMap(Task.TASK_NAME, task))}. Parameter types: [ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/DefaultProject.java
Cannot solve method call taskContainer.create(addMaps(options, singletonMap(Task.TASK_NAME, task))) java.lang.RuntimeException: Method 'addMaps' cannot be resolved in context addMaps(options, singletonMap(Task.TASK_NAME, task)) (line: 976) MethodCallExprContext{wrapped=addMaps(options, singletonMap(Task.TASK_NAME, task))}. Parameter types: [ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/DefaultProject.java
Error calculating the type of parameter addMaps(options, singletonMap(Task.TASK_NAME, task)) of method call taskContainer.create(addMaps(options, singletonMap(Task.TASK_NAME, task)))
Cannot solve method call TransformedModelDslBacking.isTransformedBlock(modelRules) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/DefaultProject.java
Cannot solve method call new NonTransformedModelDslBacking(modelRegistry).configure(modelRules) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/DefaultProject.java
Cannot solve method call ClosureBackedAction.execute(new TransformedModelDslBacking(modelRegistry, this.getRootProject().getFileResolver()), modelRules) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/DefaultProject.java
Method 'getProject' cannot be resolved in context antBuilder.getProject() (line: 40) MethodCallExprContext{wrapped=antBuilder.getProject()}. Parameter types: []
Method 'getProject' cannot be resolved in context antBuilder.getProject() (line: 41) MethodCallExprContext{wrapped=antBuilder.getProject()}. Parameter types: []
Method 'getProject' cannot be resolved in context antBuilder.getProject() (line: 41) MethodCallExprContext{wrapped=antBuilder.getProject()}. Parameter types: []
Method 'getProject' cannot be resolved in context antBuilder.getProject() (line: 41) MethodCallExprContext{wrapped=antBuilder.getProject()}. Parameter types: []
Method 'getProject' cannot be resolved in context antBuilder.getProject() (line: 42) MethodCallExprContext{wrapped=antBuilder.getProject()}. Parameter types: []
Cannot solve method call argNames.equals(ImmutableSet.of("name", "classname")) UnsolvedSymbolException{context='Method 'of' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.ImmutableSet}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/antbuilder/AntBuilderDelegate.java
Cannot solve method call DynamicObjectUtil.asDynamicObject(builder.getProperty("project")) java.lang.RuntimeException: Method 'getProperty' cannot be resolved in context builder.getProperty("project") (line: 81) MethodCallExprContext{wrapped=builder.getProperty("project")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/antbuilder/AntBuilderDelegate.java
Cannot solve method call project.invokeMethod("addTaskDefinition", name, antlibClassLoader.loadClass(className)) java.lang.RuntimeException: Method 'loadClass' cannot be resolved in context antlibClassLoader.loadClass(className) (line: 82) MethodCallExprContext{wrapped=antlibClassLoader.loadClass(className)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/antbuilder/AntBuilderDelegate.java
Cannot solve method call taskdef(Cast.<Map<String, String>>uncheckedCast(attributes)) UnsolvedSymbolException{context='Method 'uncheckedCast' with parameterTypes [ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class Cast {

    /**
     * Casts the given object to the given type, providing a better error message than the default.
     *
     * The standard {@link Class#cast(Object)} method produces unsatisfactory error messages on some platforms
     * when it fails. All this method does is provide a better, consistent, error message.
     *
     * This should be used whenever there is a chance the cast could fail. If in doubt, use this.
     *
     * @param outputType The type to cast the input to
     * @param object The object to be cast
     * @param <O> The type to be cast to
     * @param <I> The type of the object to be vast
     * @return The input object, cast to the output type
     */
    public static <O, I> O cast(Class<O> outputType, I object) {
        try {
            return outputType.cast(object);
        } catch (ClassCastException e) {
            throw new ClassCastException(String.format("Failed to cast object %s of type %s to target type %s", object, object.getClass().getName(), outputType.getName()));
        }
    }

    @SuppressWarnings("unchecked")
    public static <T> T uncheckedCast(Object object) {
        return (T) object;
    }
}}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/antbuilder/AntBuilderDelegate.java
Method 'getClassPath' cannot be resolved in context classPathRegistry.getClassPath("ANT") (line: 71) MethodCallExprContext{wrapped=classPathRegistry.getClassPath("ANT")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call Lists.newArrayList(classPathRegistry.getClassPath("ANT").getAsFiles()) java.lang.RuntimeException: Method 'getClassPath' cannot be resolved in context classPathRegistry.getClassPath("ANT") (line: 71) MethodCallExprContext{wrapped=classPathRegistry.getClassPath("ANT")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/antbuilder/DefaultIsolatedAntBuilder.java
Method 'getModule' cannot be resolved in context moduleRegistry.getModule("gradle-core") (line: 90) MethodCallExprContext{wrapped=moduleRegistry.getModule("gradle-core")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getModule' cannot be resolved in context moduleRegistry.getModule("gradle-logging") (line: 91) MethodCallExprContext{wrapped=moduleRegistry.getModule("gradle-logging")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call gradleCoreUrls.plus(moduleRegistry.getModule("gradle-logging").getImplementationClasspath()) java.lang.RuntimeException: Method 'getModule' cannot be resolved in context moduleRegistry.getModule("gradle-logging") (line: 91) MethodCallExprContext{wrapped=moduleRegistry.getModule("gradle-logging")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/antbuilder/DefaultIsolatedAntBuilder.java
Method 'getExternalModule' cannot be resolved in context moduleRegistry.getExternalModule("groovy-all") (line: 92) MethodCallExprContext{wrapped=moduleRegistry.getExternalModule("groovy-all")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call gradleCoreUrls.plus(moduleRegistry.getExternalModule("groovy-all").getClasspath()) java.lang.RuntimeException: Method 'getExternalModule' cannot be resolved in context moduleRegistry.getExternalModule("groovy-all") (line: 92) MethodCallExprContext{wrapped=moduleRegistry.getExternalModule("groovy-all")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/antbuilder/DefaultIsolatedAntBuilder.java
Method 'getModule' cannot be resolved in context moduleRegistry.getModule("gradle-base-services") (line: 95) MethodCallExprContext{wrapped=moduleRegistry.getModule("gradle-base-services")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call gradleCoreUrls.plus(moduleRegistry.getModule("gradle-base-services").getImplementationClasspath()) java.lang.RuntimeException: Method 'getModule' cannot be resolved in context moduleRegistry.getModule("gradle-base-services") (line: 95) MethodCallExprContext{wrapped=moduleRegistry.getModule("gradle-base-services")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/antbuilder/DefaultIsolatedAntBuilder.java
Cannot solve method call ClosureBackedAction.execute(delegate, antClosure) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/antbuilder/DefaultIsolatedAntBuilder.java
Method 'loadClass' cannot be resolved in context antAdapterLoader.loadClass(className) (line: 164) MethodCallExprContext{wrapped=antAdapterLoader.loadClass(className)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getMethod' cannot be resolved in context antBuilder.getClass().getMethod("getProject") (line: 176) MethodCallExprContext{wrapped=antBuilder.getClass().getMethod("getProject")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getDeclaredMethod' cannot be resolved in context antBuilder.getClass().getDeclaredMethod("close") (line: 205) MethodCallExprContext{wrapped=antBuilder.getClass().getDeclaredMethod("close")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve field access Mode.CLOSE_CLASSLOADER
Cannot solve method call messages.add(String.format("No value has been specified for property '%s'.", propertyName)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/taskfactory/TaskPropertyInfo.java
Cannot solve field access PathSensitivity.ABSOLUTE
Cannot solve method call sensitivity.value() java.lang.UnsupportedOperationException: com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnnotationDeclaration /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/taskfactory/PropertyAnnotationUtils.java
Method 'dir' cannot be resolved in context task.getOutputs().dir(futureValue) (line: 49) MethodCallExprContext{wrapped=task.getOutputs().dir(futureValue)}. Parameter types: [ReferenceType{java.util.concurrent.Callable, typeParametersMap=TypeParametersMap{nameToValue={java.util.concurrent.Callable.V=ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call getRelativeSnapshot(fileDetails, snapshot, stringInterner) UnsolvedSymbolException{context='unknown', name='SnapshotNormalizationStrategy', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/taskfactory/ClasspathPropertyAnnotationHandler.java
Method 'files' cannot be resolved in context task.getInputs().files(futureValue) (line: 59) MethodCallExprContext{wrapped=task.getInputs().files(futureValue)}. Parameter types: [ReferenceType{java.util.concurrent.Callable, typeParametersMap=TypeParametersMap{nameToValue={java.util.concurrent.Callable.V=ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'files' cannot be resolved in context task.getInputs().files(futureValue) (line: 59) MethodCallExprContext{wrapped=task.getInputs().files(futureValue)}. Parameter types: [ReferenceType{java.util.concurrent.Callable, typeParametersMap=TypeParametersMap{nameToValue={java.util.concurrent.Callable.V=ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'files' cannot be resolved in context task.getInputs().files(futureValue) (line: 59) MethodCallExprContext{wrapped=task.getInputs().files(futureValue)}. Parameter types: [ReferenceType{java.util.concurrent.Callable, typeParametersMap=TypeParametersMap{nameToValue={java.util.concurrent.Callable.V=ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call taskClassInfo.setCacheable(type.isAnnotationPresent(CacheableTask.class)) java.lang.RuntimeException: Method 'isAnnotationPresent' cannot be resolved in context type.isAnnotationPresent(CacheableTask.class) (line: 55) MethodCallExprContext{wrapped=type.isAnnotationPresent(CacheableTask.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.tasks.CacheableTask, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/taskfactory/DefaultTaskClassInfoStore.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call infoStore.getTaskClassInfo(Cast.<Class<? extends Task>>uncheckedCast(task)) UnsolvedSymbolException{context='Method 'uncheckedCast' with parameterTypes [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=null, boundedType=null}}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class Cast {

    /**
     * Casts the given object to the given type, providing a better error message than the default.
     *
     * The standard {@link Class#cast(Object)} method produces unsatisfactory error messages on some platforms
     * when it fails. All this method does is provide a better, consistent, error message.
     *
     * This should be used whenever there is a chance the cast could fail. If in doubt, use this.
     *
     * @param outputType The type to cast the input to
     * @param object The object to be cast
     * @param <O> The type to be cast to
     * @param <I> The type of the object to be vast
     * @return The input object, cast to the output type
     */
    public static <O, I> O cast(Class<O> outputType, I object) {
        try {
            return outputType.cast(object);
        } catch (ClassCastException e) {
            throw new ClassCastException(String.format("Failed to cast object %s of type %s to target type %s", object, object.getClass().getName(), outputType.getName()));
        }
    }

    @SuppressWarnings("unchecked")
    public static <T> T uncheckedCast(Object object) {
        return (T) object;
    }
}}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/taskfactory/TaskPropertyValidationAccess.java
Cannot solve method call String.format("Task type '%s' declares property that is not annotated: '%s'.", task.getName(), nonAnnotatedPropertyName) java.lang.RuntimeException: Method 'getName' cannot be resolved in context task.getName() (line: 33) MethodCallExprContext{wrapped=task.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/taskfactory/TaskPropertyValidationAccess.java
Cannot resolve field access null
Cannot solve method call problems.put(String.format("Task type '%s' declares property that is not annotated: '%s'.", task.getName(), nonAnnotatedPropertyName), Boolean.FALSE) java.lang.RuntimeException: Error calculating the type of parameter task.getName() of method call String.format("Task type '%s' declares property that is not annotated: '%s'.", task.getName(), nonAnnotatedPropertyName) /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/taskfactory/TaskPropertyValidationAccess.java
Cannot solve method call task.getOutputs().namedDirectories(Cast.<Callable<Map<?, ?>>>uncheckedCast(futureValue)) UnsolvedSymbolException{context='Method 'uncheckedCast' with parameterTypes [ReferenceType{java.util.concurrent.Callable, typeParametersMap=TypeParametersMap{nameToValue={java.util.concurrent.Callable.V=ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class Cast {

    /**
     * Casts the given object to the given type, providing a better error message than the default.
     *
     * The standard {@link Class#cast(Object)} method produces unsatisfactory error messages on some platforms
     * when it fails. All this method does is provide a better, consistent, error message.
     *
     * This should be used whenever there is a chance the cast could fail. If in doubt, use this.
     *
     * @param outputType The type to cast the input to
     * @param object The object to be cast
     * @param <O> The type to be cast to
     * @param <I> The type of the object to be vast
     * @return The input object, cast to the output type
     */
    public static <O, I> O cast(Class<O> outputType, I object) {
        try {
            return outputType.cast(object);
        } catch (ClassCastException e) {
            throw new ClassCastException(String.format("Failed to cast object %s of type %s to target type %s", object, object.getClass().getName(), outputType.getName()));
        }
    }

    @SuppressWarnings("unchecked")
    public static <T> T uncheckedCast(Object object) {
        return (T) object;
    }
}}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/taskfactory/OutputDirectoriesPropertyAnnotationHandler.java
Cannot solve method call messages.add(String.format("Directory '%s' specified for property '%s' is not a directory.", fileValue, propertyName)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/taskfactory/InputDirectoryPropertyAnnotationHandler.java
Cannot solve method call messages.add(String.format("Directory '%s' specified for property '%s' does not exist.", fileValue, propertyName)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/taskfactory/InputDirectoryPropertyAnnotationHandler.java
Method 'dir' cannot be resolved in context task.getInputs().dir(futureValue) (line: 51) MethodCallExprContext{wrapped=task.getInputs().dir(futureValue)}. Parameter types: [ReferenceType{java.util.concurrent.Callable, typeParametersMap=TypeParametersMap{nameToValue={java.util.concurrent.Callable.V=ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'dir' cannot be resolved in context task.getInputs().dir(futureValue) (line: 51) MethodCallExprContext{wrapped=task.getInputs().dir(futureValue)}. Parameter types: [ReferenceType{java.util.concurrent.Callable, typeParametersMap=TypeParametersMap{nameToValue={java.util.concurrent.Callable.V=ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Error calculating the type of parameter context.isAnnotationPresent(SkipWhenEmpty.class) of method call task.getInputs().dir(futureValue).withPropertyName(context.getName()).skipWhenEmpty(context.isAnnotationPresent(SkipWhenEmpty.class))
Error calculating the type of parameter context.isAnnotationPresent(OrderSensitive.class) of method call task.getInputs().dir(futureValue).withPropertyName(context.getName()).skipWhenEmpty(context.isAnnotationPresent(SkipWhenEmpty.class)).orderSensitive(context.isAnnotationPresent(OrderSensitive.class))
Cannot solve method call messages.add(String.format("File '%s' specified for property '%s' is not a file.", fileValue, propertyName)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/taskfactory/InputFilePropertyAnnotationHandler.java
Cannot solve method call messages.add(String.format("File '%s' specified for property '%s' does not exist.", fileValue, propertyName)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/taskfactory/InputFilePropertyAnnotationHandler.java
Method 'files' cannot be resolved in context task.getInputs().files(futureValue) (line: 48) MethodCallExprContext{wrapped=task.getInputs().files(futureValue)}. Parameter types: [ReferenceType{java.util.concurrent.Callable, typeParametersMap=TypeParametersMap{nameToValue={java.util.concurrent.Callable.V=ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'files' cannot be resolved in context task.getInputs().files(futureValue) (line: 48) MethodCallExprContext{wrapped=task.getInputs().files(futureValue)}. Parameter types: [ReferenceType{java.util.concurrent.Callable, typeParametersMap=TypeParametersMap{nameToValue={java.util.concurrent.Callable.V=ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getValue' cannot be resolved in context property.getValue(task) (line: 50) MethodCallExprContext{wrapped=property.getValue(task)}. Parameter types: [ReferenceType{org.gradle.api.internal.TaskInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call propertyValues.add(property.getValue(task)) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context property.getValue(task) (line: 62) MethodCallExprContext{wrapped=property.getValue(task)}. Parameter types: [ReferenceType{org.gradle.api.internal.TaskInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/taskfactory/TaskClassValidator.java
Cannot solve method call task.getOutputs().namedFiles(Cast.<Callable<Map<?, ?>>>uncheckedCast(futureValue)) UnsolvedSymbolException{context='Method 'uncheckedCast' with parameterTypes [ReferenceType{java.util.concurrent.Callable, typeParametersMap=TypeParametersMap{nameToValue={java.util.concurrent.Callable.V=ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class Cast {

    /**
     * Casts the given object to the given type, providing a better error message than the default.
     *
     * The standard {@link Class#cast(Object)} method produces unsatisfactory error messages on some platforms
     * when it fails. All this method does is provide a better, consistent, error message.
     *
     * This should be used whenever there is a chance the cast could fail. If in doubt, use this.
     *
     * @param outputType The type to cast the input to
     * @param object The object to be cast
     * @param <O> The type to be cast to
     * @param <I> The type of the object to be vast
     * @return The input object, cast to the output type
     */
    public static <O, I> O cast(Class<O> outputType, I object) {
        try {
            return outputType.cast(object);
        } catch (ClassCastException e) {
            throw new ClassCastException(String.format("Failed to cast object %s of type %s to target type %s", object, object.getClass().getName(), outputType.getName()));
        }
    }

    @SuppressWarnings("unchecked")
    public static <T> T uncheckedCast(Object object) {
        return (T) object;
    }
}}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/taskfactory/OutputFilesPropertyAnnotationHandler.java
Cannot solve method call parseProperties(entry.parent, entry.type, validatedPropertiesBuilder, nonAnnotatedPropertiesBuilder, queue) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/taskfactory/DefaultTaskClassValidatorExtractor.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call getFields(type) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/taskfactory/DefaultTaskClassValidatorExtractor.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve field access PropertyAccessorType.SETTER
Cannot solve method call Types.walkTypeHierarchy(type, IGNORED_SUPER_CLASSES, new Types.TypeVisitor<T>() {

    @Override
    public void visitType(Class<? super T> type) {
        Map<String, Field> fields = getFields(type);
        Method[] methods = type.getDeclaredMethods();
        for (Method method : methods) {
            PropertyAccessorType accessorType = PropertyAccessorType.of(method);
            if (accessorType == null || accessorType == PropertyAccessorType.SETTER || method.isBridge() || GroovyMethods.isObjectMethod(method)) {
                continue;
            }
            String fieldName = accessorType.propertyNameFor(method);
            Field field = fields.get(fieldName);
            String propertyName = parent != null ? parent.getName() + '.' + fieldName : fieldName;
            DefaultTaskPropertyActionContext propertyContext = propertyContexts.get(propertyName);
            if (propertyContext == null) {
                propertyContext = new DefaultTaskPropertyActionContext(parent, propertyName, method);
                propertyContexts.put(propertyName, propertyContext);
            }
            propertyContext.addAnnotations(method.getDeclaredAnnotations());
            if (field != null) {
                propertyContext.setInstanceVariableField(field);
                propertyContext.addAnnotations(field.getDeclaredAnnotations());
            }
        }
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/taskfactory/DefaultTaskClassValidatorExtractor.java
Cannot solve method call createProperty(propertyContext, nonAnnotatedPropertiesBuilder) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/taskfactory/DefaultTaskClassValidatorExtractor.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Method 'file' cannot be resolved in context task.getOutputs().file(futureValue) (line: 47) MethodCallExprContext{wrapped=task.getOutputs().file(futureValue)}. Parameter types: [ReferenceType{java.util.concurrent.Callable, typeParametersMap=TypeParametersMap{nameToValue={java.util.concurrent.Callable.V=ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'file' cannot be resolved in context task.getOutputs().file(futureValue) (line: 47) MethodCallExprContext{wrapped=task.getOutputs().file(futureValue)}. Parameter types: [ReferenceType{java.util.concurrent.Callable, typeParametersMap=TypeParametersMap{nameToValue={java.util.concurrent.Callable.V=ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call String.format("Cannot create task of type '%s' as it does not implement the Task interface.", type.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context type.getSimpleName() (line: 108) MethodCallExprContext{wrapped=type.getSimpleName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/taskfactory/TaskFactory.java
Cannot solve method call String.format("Could not create task of type '%s'.", type.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context type.getSimpleName() (line: 123) MethodCallExprContext{wrapped=type.getSimpleName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/taskfactory/TaskFactory.java
Method 'files' cannot be resolved in context task.getInputs().files(futureValue) (line: 36) MethodCallExprContext{wrapped=task.getInputs().files(futureValue)}. Parameter types: [ReferenceType{java.util.concurrent.Callable, typeParametersMap=TypeParametersMap{nameToValue={java.util.concurrent.Callable.V=ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'files' cannot be resolved in context task.getInputs().files(futureValue) (line: 36) MethodCallExprContext{wrapped=task.getInputs().files(futureValue)}. Parameter types: [ReferenceType{java.util.concurrent.Callable, typeParametersMap=TypeParametersMap{nameToValue={java.util.concurrent.Callable.V=ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Error calculating the type of parameter context.isAnnotationPresent(SkipWhenEmpty.class) of method call task.getInputs().files(futureValue).withPropertyName(context.getName()).skipWhenEmpty(context.isAnnotationPresent(SkipWhenEmpty.class))
Error calculating the type of parameter context.isAnnotationPresent(OrderSensitive.class) of method call task.getInputs().files(futureValue).withPropertyName(context.getName()).skipWhenEmpty(context.isAnnotationPresent(SkipWhenEmpty.class)).orderSensitive(context.isAnnotationPresent(OrderSensitive.class))
Cannot solve method call String.format("FAILED (%s)", failure.getMessage()) java.lang.RuntimeException: Method 'getMessage' cannot be resolved in context failure.getMessage() (line: 73) MethodCallExprContext{wrapped=failure.getMessage()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/ProjectStateInternal.java
Error calculating the type of parameter getProject() of method call PropertyHelper.getPropertyHelper(getProject())
Method 'getProject' cannot be resolved in context getProject() (line: 61) MethodCallExprContext{wrapped=getProject()}. Parameter types: []
Method 'getProject' cannot be resolved in context getProject() (line: 61) MethodCallExprContext{wrapped=getProject()}. Parameter types: []
Method 'getProject' cannot be resolved in context getProject() (line: 62) MethodCallExprContext{wrapped=getProject()}. Parameter types: []
Method 'getProject' cannot be resolved in context getProject() (line: 62) MethodCallExprContext{wrapped=getProject()}. Parameter types: []
Method 'getProject' cannot be resolved in context getProject() (line: 69) MethodCallExprContext{wrapped=getProject()}. Parameter types: []
Method 'getProject' cannot be resolved in context getProject() (line: 81) MethodCallExprContext{wrapped=getProject()}. Parameter types: []
Method 'getProject' cannot be resolved in context getProject() (line: 84) MethodCallExprContext{wrapped=getProject()}. Parameter types: []
Method 'getAntProject' cannot be resolved in context getAntProject() (line: 100) MethodCallExprContext{wrapped=getAntProject()}. Parameter types: []
Method 'getAntProject' cannot be resolved in context getAntProject() (line: 100) MethodCallExprContext{wrapped=getAntProject()}. Parameter types: []
Method 'getAntProject' cannot be resolved in context getAntProject() (line: 101) MethodCallExprContext{wrapped=getAntProject()}. Parameter types: []
Method 'getAntProject' cannot be resolved in context getAntProject() (line: 102) MethodCallExprContext{wrapped=getAntProject()}. Parameter types: []
Method 'getAntProject' cannot be resolved in context getAntProject() (line: 109) MethodCallExprContext{wrapped=getAntProject()}. Parameter types: []
Method 'getAntProject' cannot be resolved in context getAntProject() (line: 104) MethodCallExprContext{wrapped=getAntProject()}. Parameter types: []
Method 'getAntProject' cannot be resolved in context getAntProject() (line: 113) MethodCallExprContext{wrapped=getAntProject()}. Parameter types: []
Method 'getAntProject' cannot be resolved in context getAntProject() (line: 113) MethodCallExprContext{wrapped=getAntProject()}. Parameter types: []
Method 'getAntProject' cannot be resolved in context getAntProject() (line: 116) MethodCallExprContext{wrapped=getAntProject()}. Parameter types: []
Method 'getAntProject' cannot be resolved in context getAntProject() (line: 116) MethodCallExprContext{wrapped=getAntProject()}. Parameter types: []
Method 'getAntProject' cannot be resolved in context getAntProject() (line: 119) MethodCallExprContext{wrapped=getAntProject()}. Parameter types: []
Method 'getAntProject' cannot be resolved in context getAntProject() (line: 119) MethodCallExprContext{wrapped=getAntProject()}. Parameter types: []
Cannot solve method call taskNamer.transform(target.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context target.getName() (line: 120) MethodCallExprContext{wrapped=target.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/DefaultAntBuilder.java
Cannot solve method call Sets.newHashSetWithExpectedSize(taskDependencyNames.size()) java.lang.RuntimeException: Method 'size' cannot be resolved in context taskDependencyNames.size() (line: 182) MethodCallExprContext{wrapped=taskDependencyNames.size()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/DefaultAntBuilder.java
Method 'getAntProject' cannot be resolved in context getAntProject() (line: 51) MethodCallExprContext{wrapped=getAntProject()}. Parameter types: []
Method 'getAntProject' cannot be resolved in context getAntProject() (line: 52) MethodCallExprContext{wrapped=getAntProject()}. Parameter types: []
Method 'getReferences' cannot be resolved in context project.getReferences() (line: 121) MethodCallExprContext{wrapped=project.getReferences()}. Parameter types: []
Method 'getTask' cannot be resolved in context event.getTask() (line: 76) MethodCallExprContext{wrapped=event.getTask()}. Parameter types: []
Method 'append' cannot be resolved in context message.append("[ant:") (line: 77) MethodCallExprContext{wrapped=message.append("[ant:")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context message.append("[ant:") (line: 77) MethodCallExprContext{wrapped=message.append("[ant:")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call getLogLevelForMessagePriority(event.getPriority()) java.lang.RuntimeException: Method 'getPriority' cannot be resolved in context event.getPriority() (line: 82) MethodCallExprContext{wrapped=event.getPriority()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/ant/AntLoggingAdapter.java
Cannot solve method call logger.log(level, message.toString(), event.getException()) java.lang.RuntimeException: Method 'getException' cannot be resolved in context event.getException() (line: 85) MethodCallExprContext{wrapped=event.getException()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/project/ant/AntLoggingAdapter.java
Cannot solve field access LogLevel.LIFECYCLE
Cannot solve field access LogLevel.LIFECYCLE
Cannot solve field access LogLevel.INFO
Cannot solve field access LogLevel.LIFECYCLE
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call type.cast(factoryClosure.call(name)) java.lang.RuntimeException: Method 'call' cannot be resolved in context factoryClosure.call(name) (line: 113) MethodCallExprContext{wrapped=factoryClosure.call(name)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/FactoryNamedDomainObjectContainer.java
Cannot solve method call uncapitalize(toCamelCase(cacheName)) com.github.javaparser.symbolsolver.logic.ConfilictingGenericTypesException: No matching between ReferenceType{CharSequence, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual) /repo/subprojects/core/src/main/java/org/gradle/api/internal/cache/MinimalPersistentCache.java
Cannot resolve field access null
Cannot solve field access FileLockManager.LockMode.None
Cannot resolve field access null
Cannot solve field access FileLockManager.LockMode.None
Cannot solve method call uncapitalize(toCamelCase(cacheName)) com.github.javaparser.symbolsolver.logic.ConfilictingGenericTypesException: No matching between ReferenceType{CharSequence, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual) /repo/subprojects/core/src/main/java/org/gradle/api/internal/cache/SingleOperationPersistentStore.java
Cannot resolve field access null
Cannot solve field access FileLockManager.LockMode.Exclusive
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call JavaReflectionUtil.method(ClassLoader.class, Class.class, "defineClass", String.class, byte[].class, Integer.TYPE, Integer.TYPE) UnsolvedSymbolException{context='unknown', name='TYPE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call ImmutableSet.of(Byte.TYPE, Boolean.TYPE, Character.TYPE, Short.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE) UnsolvedSymbolException{context='unknown', name='TYPE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call Type.getType(GroovySystem.class) UnsolvedSymbolException{context='unknown', name='GroovySystem', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call Type.getType(MetaClassRegistry.class) UnsolvedSymbolException{context='unknown', name='MetaClassRegistry', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call Type.getType(Boolean.TYPE) UnsolvedSymbolException{context='unknown', name='TYPE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call Type.getMethodDescriptor(Type.VOID_TYPE, OBJECT_TYPE) UnsolvedSymbolException{context='unknown', name='VOID_TYPE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call Type.getMethodDescriptor(Type.VOID_TYPE, OBJECT_TYPE, CLASS_TYPE, DYNAMIC_OBJECT_TYPE) UnsolvedSymbolException{context='unknown', name='VOID_TYPE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call Type.getMethodDescriptor(Type.VOID_TYPE, CONVENTION_AWARE_TYPE, CONVENTION_TYPE) UnsolvedSymbolException{context='unknown', name='VOID_TYPE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call Type.getType("L" + typeName.replaceAll("\\.", "/") + ";") java.lang.RuntimeException: Method 'replaceAll' cannot be resolved in context typeName.replaceAll("\\.", "/") (line: 135) MethodCallExprContext{wrapped=typeName.replaceAll("\\.", "/")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call interfaceTypes.add(CONVENTION_AWARE_TYPE.getInternalName()) java.lang.RuntimeException: Method 'getInternalName' cannot be resolved in context CONVENTION_AWARE_TYPE.getInternalName() (line: 145) MethodCallExprContext{wrapped=CONVENTION_AWARE_TYPE.getInternalName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call interfaceTypes.add(EXTENSION_AWARE_TYPE.getInternalName()) java.lang.RuntimeException: Method 'getInternalName' cannot be resolved in context EXTENSION_AWARE_TYPE.getInternalName() (line: 149) MethodCallExprContext{wrapped=EXTENSION_AWARE_TYPE.getInternalName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call interfaceTypes.add(HAS_CONVENTION_TYPE.getInternalName()) java.lang.RuntimeException: Method 'getInternalName' cannot be resolved in context HAS_CONVENTION_TYPE.getInternalName() (line: 150) MethodCallExprContext{wrapped=HAS_CONVENTION_TYPE.getInternalName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call interfaceTypes.add(DYNAMIC_OBJECT_AWARE_TYPE.getInternalName()) java.lang.RuntimeException: Method 'getInternalName' cannot be resolved in context DYNAMIC_OBJECT_AWARE_TYPE.getInternalName() (line: 153) MethodCallExprContext{wrapped=DYNAMIC_OBJECT_AWARE_TYPE.getInternalName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call interfaceTypes.add(GROOVY_OBJECT_TYPE.getInternalName()) java.lang.RuntimeException: Method 'getInternalName' cannot be resolved in context GROOVY_OBJECT_TYPE.getInternalName() (line: 154) MethodCallExprContext{wrapped=GROOVY_OBJECT_TYPE.getInternalName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call visitor.visit(V1_5, ACC_PUBLIC, generatedType.getInternalName(), null, superclassType.getInternalName(), interfaceTypes.toArray(EMPTY_STRINGS)) UnsolvedSymbolException{context='Solving V1_5', name='V1_5', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call paramTypes.add(Type.getType(paramType)) UnsolvedSymbolException{context='Method 'getType' with parameterTypes [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=null, boundedType=null}}}}]', name='ReflectionClassDeclaration{clazz=org.objectweb.asm.Type}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call Type.getMethodDescriptor(VOID_TYPE, paramTypes.toArray(EMPTY_TYPES)) UnsolvedSymbolException{context='Solving VOID_TYPE', name='VOID_TYPE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitMethod(Opcodes.ACC_PUBLIC, "<init>", methodDescriptor, signature(constructor), EMPTY_STRINGS) UnsolvedSymbolException{context='unknown', name='ACC_PUBLIC', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call methodVisitor.visitAnnotation(Type.getType(annotation.annotationType()).getDescriptor(), retention != null && retention.value() == RetentionPolicy.RUNTIME) UnsolvedSymbolException{context='Method 'getType' with parameterTypes [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=ReferenceType{java.lang.annotation.Annotation, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}]', name='ReflectionClassDeclaration{clazz=org.objectweb.asm.Type}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Type.getType(constructor.getParameterTypes()[i]).getOpcode(Opcodes.ILOAD), i + 1) java.lang.RuntimeException: Error calculating the type of parameter Opcodes.ILOAD of method call Type.getType(constructor.getParameterTypes()[i]).getOpcode(Opcodes.ILOAD) /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL, superclassType.getInternalName(), "<init>", methodDescriptor, false) UnsolvedSymbolException{context='unknown', name='INVOKESPECIAL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitInsn(Opcodes.RETURN) UnsolvedSymbolException{context='unknown', name='RETURN', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitField(Opcodes.ACC_PRIVATE, DYNAMIC_OBJECT_HELPER_FIELD, fieldSignature, null, null) UnsolvedSymbolException{context='unknown', name='ACC_PRIVATE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, generatedType.getInternalName(), "getAsDynamicObject", Type.getMethodDescriptor(getAsDynamicObject), false) UnsolvedSymbolException{context='unknown', name='INVOKEVIRTUAL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitTypeInsn(Opcodes.CHECKCAST, EXTENSIBLE_DYNAMIC_OBJECT_HELPER_TYPE.getInternalName()) UnsolvedSymbolException{context='unknown', name='CHECKCAST', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, EXTENSIBLE_DYNAMIC_OBJECT_HELPER_TYPE.getInternalName(), "getConvention", RETURN_CONVENTION, false) UnsolvedSymbolException{context='unknown', name='INVOKEVIRTUAL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call addGetter(HasConvention.class.getDeclaredMethod("getConvention"), new MethodCodeBody() {

    public void add(MethodVisitor visitor) throws Exception {
        // GENERATE ((MixInExtensibleDynamicObject)getAsDynamicObject()).getConvention()
        visitor.visitVarInsn(Opcodes.ALOAD, 0);
        visitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, generatedType.getInternalName(), "getAsDynamicObject", Type.getMethodDescriptor(getAsDynamicObject), false);
        visitor.visitTypeInsn(Opcodes.CHECKCAST, EXTENSIBLE_DYNAMIC_OBJECT_HELPER_TYPE.getInternalName());
        visitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, EXTENSIBLE_DYNAMIC_OBJECT_HELPER_TYPE.getInternalName(), "getConvention", RETURN_CONVENTION, false);
    }
}) java.lang.RuntimeException: Method 'getDeclaredMethod' cannot be resolved in context HasConvention.class.getDeclaredMethod("getConvention") (line: 206) MethodCallExprContext{wrapped=HasConvention.class.getDeclaredMethod("getConvention")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, generatedType.getInternalName(), "getConvention", RETURN_CONVENTION, false) UnsolvedSymbolException{context='unknown', name='INVOKEVIRTUAL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call addGetter(ExtensionAware.class.getDeclaredMethod("getExtensions"), new MethodCodeBody() {

    public void add(MethodVisitor visitor) throws Exception {
        // GENERATE getConvention()
        visitor.visitVarInsn(Opcodes.ALOAD, 0);
        visitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, generatedType.getInternalName(), "getConvention", RETURN_CONVENTION, false);
    }
}) java.lang.RuntimeException: Method 'getDeclaredMethod' cannot be resolved in context ExtensionAware.class.getDeclaredMethod("getExtensions") (line: 222) MethodCallExprContext{wrapped=ExtensionAware.class.getDeclaredMethod("getExtensions")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitTypeInsn(Opcodes.NEW, NON_EXTENSIBLE_DYNAMIC_OBJECT_HELPER_TYPE.getInternalName()) UnsolvedSymbolException{context='unknown', name='NEW', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitInsn(Opcodes.DUP) UnsolvedSymbolException{context='unknown', name='DUP', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitMethodInsn(Opcodes.INVOKESPECIAL, NON_EXTENSIBLE_DYNAMIC_OBJECT_HELPER_TYPE.getInternalName(), "<init>", RETURN_VOID_FROM_OBJECT, false) UnsolvedSymbolException{context='unknown', name='INVOKESPECIAL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitTypeInsn(Opcodes.NEW, EXTENSIBLE_DYNAMIC_OBJECT_HELPER_TYPE.getInternalName()) UnsolvedSymbolException{context='unknown', name='NEW', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitInsn(Opcodes.DUP) UnsolvedSymbolException{context='unknown', name='DUP', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, generatedType.getInternalName(), "getClass", RETURN_CLASS, false) UnsolvedSymbolException{context='unknown', name='INVOKEVIRTUAL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, CLASS_TYPE.getInternalName(), "getSuperclass", RETURN_CLASS, false) UnsolvedSymbolException{context='unknown', name='INVOKEVIRTUAL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitInsn(Opcodes.ACONST_NULL) UnsolvedSymbolException{context='unknown', name='ACONST_NULL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitMethodInsn(Opcodes.INVOKESPECIAL, Type.getType(type).getInternalName(), "getAsDynamicObject", Type.getMethodDescriptor(DYNAMIC_OBJECT_TYPE), false) UnsolvedSymbolException{context='unknown', name='INVOKESPECIAL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitMethodInsn(Opcodes.INVOKESPECIAL, EXTENSIBLE_DYNAMIC_OBJECT_HELPER_TYPE.getInternalName(), "<init>", RETURN_VOID_FROM_OBJECT_CLASS_DYNAMIC_OBJECT, false) UnsolvedSymbolException{context='unknown', name='INVOKESPECIAL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitField(Opcodes.ACC_PRIVATE, MAPPING_FIELD, CONVENTION_MAPPING_FIELD_DESCRIPTOR, null, null) UnsolvedSymbolException{context='unknown', name='ACC_PRIVATE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitTypeInsn(Opcodes.NEW, CONVENTION_AWARE_HELPER_TYPE.getInternalName()) UnsolvedSymbolException{context='unknown', name='NEW', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitInsn(Opcodes.DUP) UnsolvedSymbolException{context='unknown', name='DUP', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, generatedType.getInternalName(), "getConvention", RETURN_CONVENTION, false) UnsolvedSymbolException{context='unknown', name='INVOKEVIRTUAL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitMethodInsn(Opcodes.INVOKESPECIAL, CONVENTION_AWARE_HELPER_TYPE.getInternalName(), "<init>", RETURN_VOID_FROM_CONVENTION_AWARE_CONVENTION, false) UnsolvedSymbolException{context='unknown', name='INVOKESPECIAL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call addLazyGetter(IConventionAware.class.getDeclaredMethod("getConventionMapping"), MAPPING_FIELD, CONVENTION_MAPPING_TYPE, initConventionAwareHelper) java.lang.RuntimeException: Method 'getDeclaredMethod' cannot be resolved in context IConventionAware.class.getDeclaredMethod("getConventionMapping") (line: 330) MethodCallExprContext{wrapped=IConventionAware.class.getDeclaredMethod("getConventionMapping")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitField(Opcodes.ACC_PRIVATE, META_CLASS_FIELD, META_CLASS_TYPE_DESCRIPTOR, null, null) UnsolvedSymbolException{context='unknown', name='ACC_PRIVATE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call Type.getMethodDescriptor(GroovySystem.class.getDeclaredMethod("getMetaClassRegistry")) UnsolvedSymbolException{context='unknown', name='GroovySystem', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitMethodInsn(Opcodes.INVOKESTATIC, GROOVY_SYSTEM_TYPE.getInternalName(), "getMetaClassRegistry", getMetaClassRegistryDesc, false) UnsolvedSymbolException{context='unknown', name='INVOKESTATIC', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call Type.getMethodDescriptor(Object.class.getDeclaredMethod("getClass")) java.lang.RuntimeException: Method 'getDeclaredMethod' cannot be resolved in context Object.class.getDeclaredMethod("getClass") (line: 357) MethodCallExprContext{wrapped=Object.class.getDeclaredMethod("getClass")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, OBJECT_TYPE.getInternalName(), "getClass", getClassDesc, false) UnsolvedSymbolException{context='unknown', name='INVOKEVIRTUAL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call Type.getMethodDescriptor(MetaClassRegistry.class.getDeclaredMethod("getMetaClass", Class.class)) UnsolvedSymbolException{context='unknown', name='MetaClassRegistry', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, META_CLASS_REGISTRY_TYPE.getInternalName(), "getMetaClass", getMetaClassDesc, true) UnsolvedSymbolException{context='unknown', name='INVOKEINTERFACE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call addLazyGetter(GroovyObject.class.getDeclaredMethod("getMetaClass"), META_CLASS_FIELD, META_CLASS_TYPE, initMetaClass) java.lang.RuntimeException: Method 'getDeclaredMethod' cannot be resolved in context GroovyObject.class.getDeclaredMethod("getMetaClass") (line: 367) MethodCallExprContext{wrapped=GroovyObject.class.getDeclaredMethod("getMetaClass")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitVarInsn(Opcodes.ALOAD, 1) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitFieldInsn(Opcodes.PUTFIELD, generatedType.getInternalName(), META_CLASS_FIELD, META_CLASS_TYPE_DESCRIPTOR) UnsolvedSymbolException{context='unknown', name='PUTFIELD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitMethod(Opcodes.ACC_PUBLIC, method.getName(), methodDescriptor, null, EMPTY_STRINGS) UnsolvedSymbolException{context='unknown', name='ACC_PUBLIC', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitInsn(Opcodes.RETURN) UnsolvedSymbolException{context='unknown', name='RETURN', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitFieldInsn(Opcodes.GETFIELD, generatedType.getInternalName(), fieldName, fieldType.getDescriptor()) UnsolvedSymbolException{context='unknown', name='GETFIELD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitVarInsn(Opcodes.ASTORE, 1) UnsolvedSymbolException{context='unknown', name='ASTORE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitVarInsn(Opcodes.ALOAD, 1) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitJumpInsn(Opcodes.IFNONNULL, returnValue) UnsolvedSymbolException{context='unknown', name='IFNONNULL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitVarInsn(Opcodes.ASTORE, 1) UnsolvedSymbolException{context='unknown', name='ASTORE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitVarInsn(Opcodes.ALOAD, 1) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitFieldInsn(Opcodes.PUTFIELD, generatedType.getInternalName(), fieldName, fieldType.getDescriptor()) UnsolvedSymbolException{context='unknown', name='PUTFIELD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitVarInsn(Opcodes.ALOAD, 1) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitMethod(Opcodes.ACC_PUBLIC, methodName, methodDescriptor, null, EMPTY_STRINGS) UnsolvedSymbolException{context='unknown', name='ACC_PUBLIC', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitInsn(Opcodes.ARETURN) UnsolvedSymbolException{context='unknown', name='ARETURN', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call Type.getMethodDescriptor(DynamicObjectAware.class.getDeclaredMethod("getAsDynamicObject")) java.lang.RuntimeException: Method 'getDeclaredMethod' cannot be resolved in context DynamicObjectAware.class.getDeclaredMethod("getAsDynamicObject") (line: 442) MethodCallExprContext{wrapped=DynamicObjectAware.class.getDeclaredMethod("getAsDynamicObject")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, generatedType.getInternalName(), "getAsDynamicObject", getAsDynamicObjectDesc, false) UnsolvedSymbolException{context='unknown', name='INVOKEVIRTUAL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 1) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, DYNAMIC_OBJECT_TYPE.getInternalName(), "getProperty", getPropertyDesc, true) UnsolvedSymbolException{context='unknown', name='INVOKEINTERFACE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitMethod(Opcodes.ACC_PUBLIC, "hasProperty", methodDescriptor, null, EMPTY_STRINGS) UnsolvedSymbolException{context='unknown', name='ACC_PUBLIC', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call Type.getMethodDescriptor(DynamicObjectAware.class.getDeclaredMethod("getAsDynamicObject")) java.lang.RuntimeException: Method 'getDeclaredMethod' cannot be resolved in context DynamicObjectAware.class.getDeclaredMethod("getAsDynamicObject") (line: 464) MethodCallExprContext{wrapped=DynamicObjectAware.class.getDeclaredMethod("getAsDynamicObject")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, generatedType.getInternalName(), "getAsDynamicObject", getAsDynamicObjectDesc, false) UnsolvedSymbolException{context='unknown', name='INVOKEVIRTUAL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 1) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, DYNAMIC_OBJECT_TYPE.getInternalName(), "hasProperty", getPropertyDesc, true) UnsolvedSymbolException{context='unknown', name='INVOKEINTERFACE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitInsn(Opcodes.IRETURN) UnsolvedSymbolException{context='unknown', name='IRETURN', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call Type.getMethodDescriptor(DynamicObjectAware.class.getDeclaredMethod("getAsDynamicObject")) java.lang.RuntimeException: Method 'getDeclaredMethod' cannot be resolved in context DynamicObjectAware.class.getDeclaredMethod("getAsDynamicObject") (line: 487) MethodCallExprContext{wrapped=DynamicObjectAware.class.getDeclaredMethod("getAsDynamicObject")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, generatedType.getInternalName(), "getAsDynamicObject", getAsDynamicObjectDesc, false) UnsolvedSymbolException{context='unknown', name='INVOKEVIRTUAL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 1) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 2) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call Type.getMethodDescriptor(DynamicObject.class.getDeclaredMethod("setProperty", String.class, Object.class)) java.lang.RuntimeException: Method 'getDeclaredMethod' cannot be resolved in context DynamicObject.class.getDeclaredMethod("setProperty", String.class, Object.class) (line: 492) MethodCallExprContext{wrapped=DynamicObject.class.getDeclaredMethod("setProperty", String.class, Object.class)}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, DYNAMIC_OBJECT_TYPE.getInternalName(), "setProperty", setPropertyDesc, true) UnsolvedSymbolException{context='unknown', name='INVOKEINTERFACE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call addSetter(GroovyObject.class.getDeclaredMethod("setProperty", String.class, Object.class), new MethodCodeBody() {

    public void add(MethodVisitor methodVisitor) throws Exception {
        // GENERATE getAsDynamicObject().setProperty(name, value)
        methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
        String getAsDynamicObjectDesc = Type.getMethodDescriptor(DynamicObjectAware.class.getDeclaredMethod("getAsDynamicObject"));
        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, generatedType.getInternalName(), "getAsDynamicObject", getAsDynamicObjectDesc, false);
        methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);
        methodVisitor.visitVarInsn(Opcodes.ALOAD, 2);
        String setPropertyDesc = Type.getMethodDescriptor(DynamicObject.class.getDeclaredMethod("setProperty", String.class, Object.class));
        methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, DYNAMIC_OBJECT_TYPE.getInternalName(), "setProperty", setPropertyDesc, true);
    // END
    }
}) java.lang.RuntimeException: Method 'getDeclaredMethod' cannot be resolved in context GroovyObject.class.getDeclaredMethod("setProperty", String.class, Object.class) (line: 480) MethodCallExprContext{wrapped=GroovyObject.class.getDeclaredMethod("setProperty", String.class, Object.class)}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call Type.getMethodDescriptor(DynamicObjectAware.class.getDeclaredMethod("getAsDynamicObject")) java.lang.RuntimeException: Method 'getDeclaredMethod' cannot be resolved in context DynamicObjectAware.class.getDeclaredMethod("getAsDynamicObject") (line: 511) MethodCallExprContext{wrapped=DynamicObjectAware.class.getDeclaredMethod("getAsDynamicObject")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, generatedType.getInternalName(), "getAsDynamicObject", getAsDynamicObjectDesc, false) UnsolvedSymbolException{context='unknown', name='INVOKEVIRTUAL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 1) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 2) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitTypeInsn(Opcodes.INSTANCEOF, OBJECT_ARRAY_TYPE.getDescriptor()) UnsolvedSymbolException{context='unknown', name='INSTANCEOF', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitJumpInsn(Opcodes.IFEQ, notArray) UnsolvedSymbolException{context='unknown', name='IFEQ', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 2) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, OBJECT_ARRAY_TYPE.getDescriptor()) UnsolvedSymbolException{context='unknown', name='CHECKCAST', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitJumpInsn(Opcodes.GOTO, end) UnsolvedSymbolException{context='unknown', name='GOTO', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitInsn(Opcodes.ICONST_1) UnsolvedSymbolException{context='unknown', name='ICONST_1', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, OBJECT_TYPE.getInternalName()) UnsolvedSymbolException{context='unknown', name='ANEWARRAY', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitInsn(Opcodes.DUP) UnsolvedSymbolException{context='unknown', name='DUP', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitInsn(Opcodes.ICONST_0) UnsolvedSymbolException{context='unknown', name='ICONST_0', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 2) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitInsn(Opcodes.AASTORE) UnsolvedSymbolException{context='unknown', name='AASTORE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, DYNAMIC_OBJECT_TYPE.getInternalName(), "invokeMethod", invokeMethodDesc, true) UnsolvedSymbolException{context='unknown', name='INVOKEINTERFACE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call addGetter(GroovyObject.class.getDeclaredMethod("invokeMethod", String.class, Object.class), new MethodCodeBody() {

    public void add(MethodVisitor methodVisitor) throws Exception {
        String invokeMethodDesc = Type.getMethodDescriptor(OBJECT_TYPE, STRING_TYPE, OBJECT_ARRAY_TYPE);
        // GENERATE getAsDynamicObject().invokeMethod(name, (args instanceof Object[]) ? args : new Object[] { args })
        methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
        String getAsDynamicObjectDesc = Type.getMethodDescriptor(DynamicObjectAware.class.getDeclaredMethod("getAsDynamicObject"));
        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, generatedType.getInternalName(), "getAsDynamicObject", getAsDynamicObjectDesc, false);
        methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);
        // GENERATE (args instanceof Object[]) ? args : new Object[] { args }
        methodVisitor.visitVarInsn(Opcodes.ALOAD, 2);
        methodVisitor.visitTypeInsn(Opcodes.INSTANCEOF, OBJECT_ARRAY_TYPE.getDescriptor());
        Label end = new Label();
        Label notArray = new Label();
        methodVisitor.visitJumpInsn(Opcodes.IFEQ, notArray);
        // Generate args
        methodVisitor.visitVarInsn(Opcodes.ALOAD, 2);
        methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, OBJECT_ARRAY_TYPE.getDescriptor());
        methodVisitor.visitJumpInsn(Opcodes.GOTO, end);
        // Generate new Object[] { args }
        methodVisitor.visitLabel(notArray);
        methodVisitor.visitInsn(Opcodes.ICONST_1);
        methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, OBJECT_TYPE.getInternalName());
        methodVisitor.visitInsn(Opcodes.DUP);
        methodVisitor.visitInsn(Opcodes.ICONST_0);
        methodVisitor.visitVarInsn(Opcodes.ALOAD, 2);
        methodVisitor.visitInsn(Opcodes.AASTORE);
        methodVisitor.visitLabel(end);
        methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, DYNAMIC_OBJECT_TYPE.getInternalName(), "invokeMethod", invokeMethodDesc, true);
    }
}) java.lang.RuntimeException: Method 'getDeclaredMethod' cannot be resolved in context GroovyObject.class.getDeclaredMethod("invokeMethod", String.class, Object.class) (line: 502) MethodCallExprContext{wrapped=GroovyObject.class.getDeclaredMethod("invokeMethod", String.class, Object.class)}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call Type.getDescriptor(property.getType()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context property.getType() (line: 547) MethodCallExprContext{wrapped=property.getType()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call visitor.visitField(Opcodes.ACC_PRIVATE, flagName, Type.getDescriptor(property.getType()), null, null) UnsolvedSymbolException{context='unknown', name='ACC_PRIVATE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call Type.getType(property.getType()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context property.getType() (line: 555) MethodCallExprContext{wrapped=property.getType()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitMethod(Opcodes.ACC_PUBLIC, getterName, methodDescriptor, signature(getter), EMPTY_STRINGS) UnsolvedSymbolException{context='unknown', name='ACC_PUBLIC', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitFieldInsn(Opcodes.GETFIELD, generatedType.getInternalName(), propFieldName, serviceType.getDescriptor()) UnsolvedSymbolException{context='unknown', name='GETFIELD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitJumpInsn(Opcodes.IFNONNULL, alreadyLoaded) UnsolvedSymbolException{context='unknown', name='IFNONNULL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, generatedType.getInternalName(), "getServices", Type.getMethodDescriptor(SERVICE_REGISTRY_TYPE), false) UnsolvedSymbolException{context='unknown', name='INVOKEVIRTUAL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call methodVisitor.visitFieldInsn(GETSTATIC, generatedType.getInternalName(), constantFieldName, JAVA_REFLECT_TYPE_DESCRIPTOR) UnsolvedSymbolException{context='Solving GETSTATIC', name='GETSTATIC', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call methodVisitor.visitLdcInsn(Type.getType((Class) genericReturnType)) UnsolvedSymbolException{context='Method 'getType' with parameterTypes [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=org.objectweb.asm.Type}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, SERVICE_REGISTRY_TYPE.getInternalName(), "get", GET_METHOD_DESCRIPTOR, true) UnsolvedSymbolException{context='unknown', name='INVOKEINTERFACE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, serviceType.getInternalName()) UnsolvedSymbolException{context='unknown', name='CHECKCAST', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitFieldInsn(Opcodes.PUTFIELD, generatedType.getInternalName(), propFieldName, serviceType.getDescriptor()) UnsolvedSymbolException{context='unknown', name='PUTFIELD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitFieldInsn(Opcodes.GETFIELD, generatedType.getInternalName(), propFieldName, serviceType.getDescriptor()) UnsolvedSymbolException{context='unknown', name='GETFIELD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call returnType.getOpcode(Opcodes.IRETURN) UnsolvedSymbolException{context='unknown', name='IRETURN', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call methodVisitor.visitInsn(returnType.getOpcode(Opcodes.IRETURN)) java.lang.RuntimeException: Error calculating the type of parameter Opcodes.IRETURN of method call returnType.getOpcode(Opcodes.IRETURN) /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call Type.getType(property.getType()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context property.getType() (line: 617) MethodCallExprContext{wrapped=property.getType()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitMethod(Opcodes.ACC_PUBLIC, setter.getName(), methodDescriptor, signature(setter), EMPTY_STRINGS) UnsolvedSymbolException{context='unknown', name='ACC_PUBLIC', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 1) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitFieldInsn(Opcodes.PUTFIELD, generatedType.getInternalName(), propFieldName, serviceType.getDescriptor()) UnsolvedSymbolException{context='unknown', name='PUTFIELD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitInsn(Opcodes.RETURN) UnsolvedSymbolException{context='unknown', name='RETURN', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call visitor.visitField(Opcodes.ACC_PRIVATE, flagName, Type.BOOLEAN_TYPE.getDescriptor(), null, null) UnsolvedSymbolException{context='unknown', name='ACC_PRIVATE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitMethod(Opcodes.ACC_PUBLIC, getterName, methodDescriptor, null, EMPTY_STRINGS) UnsolvedSymbolException{context='unknown', name='ACC_PUBLIC', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitFieldInsn(Opcodes.GETFIELD, generatedType.getInternalName(), MAPPING_FIELD, CONVENTION_MAPPING_FIELD_DESCRIPTOR) UnsolvedSymbolException{context='unknown', name='GETFIELD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitJumpInsn(Opcodes.IFNONNULL, useConvention) UnsolvedSymbolException{context='unknown', name='IFNONNULL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL, superclassType.getInternalName(), getterName, methodDescriptor, false) UnsolvedSymbolException{context='unknown', name='INVOKESPECIAL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call returnType.getOpcode(Opcodes.IRETURN) UnsolvedSymbolException{context='unknown', name='IRETURN', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call methodVisitor.visitInsn(returnType.getOpcode(Opcodes.IRETURN)) java.lang.RuntimeException: Error calculating the type of parameter Opcodes.IRETURN of method call returnType.getOpcode(Opcodes.IRETURN) /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, CONVENTION_AWARE_TYPE.getInternalName(), "getConventionMapping", Type.getMethodDescriptor(CONVENTION_MAPPING_TYPE), true) UnsolvedSymbolException{context='unknown', name='INVOKEINTERFACE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL, superclassType.getInternalName(), getterName, methodDescriptor, false) UnsolvedSymbolException{context='unknown', name='INVOKESPECIAL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call Type.getType(JavaReflectionUtil.getWrapperTypeForPrimitiveType(getter.getReturnType())) UnsolvedSymbolException{context='Method 'getWrapperTypeForPrimitiveType' with parameterTypes [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public class JavaReflectionUtil {

    private static final WeakHashMap<Class<?>, ConcurrentMap<String, Boolean>> PROPERTY_CACHE = new WeakHashMap<Class<?>, ConcurrentMap<String, Boolean>>();

    /**
     * Locates the readable properties of the given type. Searches only public properties.
     */
    public static <T> Map<String, PropertyAccessor> readableProperties(Class<T> target) {
        HashMap<String, PropertyAccessor> properties = new HashMap<String, PropertyAccessor>();
        for (Method method : target.getMethods()) {
            if (method.getName().startsWith("get") && isGetter(method)) {
                String propertyName = method.getName().substring(3);
                propertyName = Character.toLowerCase(propertyName.charAt(0)) + propertyName.substring(1);
                properties.put(propertyName, new GetterMethodBackedPropertyAccessor<T, Object>(propertyName, Object.class, method));
            } else if (method.getName().startsWith("is") && isBooleanGetter(method)) {
                String propertyName = method.getName().substring(2);
                propertyName = Character.toLowerCase(propertyName.charAt(0)) + propertyName.substring(1);
                properties.put(propertyName, new GetterMethodBackedPropertyAccessor<T, Object>(propertyName, Object.class, method));
            }
        }
        return properties;
    }

    /**
     * Locates the property with the given name as a readable property. Searches only public properties.
     *
     * @throws NoSuchPropertyException when the given property does not exist.
     */
    public static <T, F> PropertyAccessor<T, F> readableProperty(Class<T> target, Class<F> returnType, String property) throws NoSuchPropertyException {
        final Method getterMethod = findGetterMethod(target, property);
        if (getterMethod == null) {
            throw new NoSuchPropertyException(String.format("Could not find getter method for property '%s' on class %s.", property, target.getSimpleName()));
        }
        return new GetterMethodBackedPropertyAccessor<T, F>(property, returnType, getterMethod);
    }

    /**
     * Locates the property with the given name as a readable property. Searches only public properties.
     *
     * @throws NoSuchPropertyException when the given property does not exist.
     */
    public static <T, F> PropertyAccessor<T, F> readableProperty(T target, Class<F> returnType, String property) throws NoSuchPropertyException {
        @SuppressWarnings("unchecked") Class<T> targetClass = (Class<T>) target.getClass();
        return readableProperty(targetClass, returnType, property);
    }

    /**
     * Locates the field with the given name as a readable property.  Searches only public fields.
     *
     * @throws NoSuchPropertyException
     */
    public static <T, F> PropertyAccessor<T, F> readableField(Class<T> target, Class<F> fieldType, String fieldName) throws NoSuchPropertyException {
        Field field = findField(target, fieldName);
        if (field == null) {
            throw new NoSuchPropertyException(String.format("Could not find field '%s' on class %s.", fieldName, target.getSimpleName()));
        }
        return new FieldBackedPropertyAccessor<T, F>(fieldName, fieldType, field);
    }

    /**
     * Locates the field with the given name as a readable property.  Searches only public fields.
     *
     * @throws NoSuchPropertyException
     */
    public static <T, F> PropertyAccessor<T, F> readableField(T target, Class<F> fieldType, String fieldName) throws NoSuchPropertyException {
        @SuppressWarnings("unchecked") Class<T> targetClass = (Class<T>) target.getClass();
        return readableField(targetClass, fieldType, fieldName);
    }

    private static Method findGetterMethod(Class<?> target, String property) {
        Method[] methods = target.getMethods();
        String getter = toMethodName("get", property);
        String iser = toMethodName("is", property);
        for (Method method : methods) {
            String methodName = method.getName();
            if (getter.equals(methodName) && isGetter(method)) {
                return method;
            }
            if (iser.equals(methodName) && isBooleanGetter(method)) {
                return method;
            }
        }
        return null;
    }

    private static boolean isGetter(Method method) {
        return method.getParameterTypes().length == 0 && !Modifier.isStatic(method.getModifiers()) && !method.getReturnType().equals(Void.TYPE);
    }

    private static boolean isBooleanGetter(Method method) {
        Class<?> returnType = method.getReturnType();
        return method.getParameterTypes().length == 0 && !Modifier.isStatic(method.getModifiers()) && (returnType.equals(Boolean.TYPE) || returnType.equals(Boolean.class));
    }

    /**
     * Locates the property with the given name as a writable property. Searches only public properties.
     *
     * @throws NoSuchPropertyException when the given property does not exist.
     */
    public static PropertyMutator writeableProperty(Class<?> target, String property) throws NoSuchPropertyException {
        PropertyMutator mutator = writeablePropertyIfExists(target, property);
        if (mutator != null) {
            return mutator;
        }
        throw new NoSuchPropertyException(String.format("Could not find setter method for property '%s' on class %s.", property, target.getSimpleName()));
    }

    /**
     * Locates the property with the given name as a writable property. Searches only public properties.
     *
     * Returns null if no such property exists.
     */
    public static PropertyMutator writeablePropertyIfExists(Class<?> target, String property) throws NoSuchPropertyException {
        String setterName = toMethodName("set", property);
        for (final Method method : target.getMethods()) {
            if (!method.getName().equals(setterName)) {
                continue;
            }
            if (method.getParameterTypes().length != 1) {
                continue;
            }
            if (Modifier.isStatic(method.getModifiers())) {
                continue;
            }
            return new MethodBackedPropertyMutator(property, method);
        }
        return null;
    }

    /**
     * Locates the field with the given name as a writable property. Searches only public properties.
     *
     * @throws NoSuchPropertyException when the given property does not exist.
     */
    public static PropertyMutator writeableField(Class<?> target, String fieldName) throws NoSuchPropertyException {
        Field field = findField(target, fieldName);
        if (field != null) {
            return new FieldBackedPropertyMutator(fieldName, field);
        }
        throw new NoSuchPropertyException(String.format("Could not find writeable field '%s' on class %s.", fieldName, target.getSimpleName()));
    }

    private static Field findField(Class<?> target, String fieldName) {
        Field[] fields = target.getFields();
        for (Field field : fields) {
            if (fieldName.equals(field.getName())) {
                return field;
            }
        }
        return null;
    }

    private static String toMethodName(String prefix, String propertyName) {
        return prefix + Character.toUpperCase(propertyName.charAt(0)) + propertyName.substring(1);
    }

    public static Class<?> getWrapperTypeForPrimitiveType(Class<?> type) {
        if (type == Character.TYPE) {
            return Character.class;
        } else if (type == Boolean.TYPE) {
            return Boolean.class;
        } else if (type == Long.TYPE) {
            return Long.class;
        } else if (type == Integer.TYPE) {
            return Integer.class;
        } else if (type == Short.TYPE) {
            return Short.class;
        } else if (type == Byte.TYPE) {
            return Byte.class;
        } else if (type == Float.TYPE) {
            return Float.class;
        } else if (type == Double.TYPE) {
            return Double.class;
        }
        throw new IllegalArgumentException(String.format("Don't know the wrapper type for primitive type %s.", type));
    }

    /**
     * Locates the given method. Searches all methods, including private methods.
     */
    public static <T, R> JavaMethod<T, R> method(Class<T> target, Class<R> returnType, String name, Class<?>... paramTypes) throws NoSuchMethodException {
        return new JavaMethod<T, R>(target, returnType, name, paramTypes);
    }

    /**
     * Locates the given static method. Searches all methods, including private methods.
     */
    public static <T, R> JavaMethod<T, R> staticMethod(Class<T> target, Class<R> returnType, String name, Class<?>... paramTypes) throws NoSuchMethodException {
        return new JavaMethod<T, R>(target, returnType, name, true, paramTypes);
    }

    /**
     * Locates the given method. Searches all methods, including private methods.
     */
    public static <T, R> JavaMethod<T, R> method(T target, Class<R> returnType, String name, Class<?>... paramTypes) throws NoSuchMethodException {
        @SuppressWarnings("unchecked") Class<T> targetClass = (Class<T>) target.getClass();
        return method(targetClass, returnType, name, paramTypes);
    }

    /**
     * Locates the given method. Searches all methods, including private methods.
     */
    public static <T, R> JavaMethod<T, R> method(Class<R> returnType, Method method) throws NoSuchMethodException {
        return new JavaMethod<T, R>(returnType, method);
    }

    public static Method findMethod(Class<?> target, Spec<Method> predicate) {
        List<Method> methods = findAllMethodsInternal(target, predicate, new MultiMap<String, Method>(), new ArrayList<Method>(1), true);
        return methods.isEmpty() ? null : methods.get(0);
    }

    public static List<Method> findAllMethods(Class<?> target, Spec<Method> predicate) {
        return findAllMethodsInternal(target, predicate, new MultiMap<String, Method>(), new ArrayList<Method>(), false);
    }

    // Not hasProperty() because that's awkward with Groovy objects implementing it
    public static boolean propertyExists(Object target, String propertyName) {
        Class<?> targetType = target.getClass();
        ConcurrentMap<String, Boolean> cached;
        synchronized (PROPERTY_CACHE) {
            cached = PROPERTY_CACHE.get(targetType);
            if (cached == null) {
                cached = new ConcurrentHashMap<String, Boolean>();
                PROPERTY_CACHE.put(targetType, cached);
            }
        }
        Boolean res = cached.get(propertyName);
        if (res != null) {
            return res;
        }
        Method getterMethod = findGetterMethod(target.getClass(), propertyName);
        if (getterMethod == null) {
            if (findField(targetType, propertyName) == null) {
                cached.putIfAbsent(propertyName, false);
                return false;
            }
        }
        cached.putIfAbsent(propertyName, true);
        return true;
    }

    private static class MultiMap<K, V> extends HashMap<K, List<V>> {

        @Override
        public List<V> get(Object key) {
            if (!containsKey(key)) {
                @SuppressWarnings("unchecked") K keyCast = (K) key;
                put(keyCast, new LinkedList<V>());
            }
            return super.get(key);
        }
    }

    private static List<Method> findAllMethodsInternal(Class<?> target, Spec<Method> predicate, MultiMap<String, Method> seen, List<Method> collector, boolean stopAtFirst) {
        for (final Method method : target.getDeclaredMethods()) {
            List<Method> seenWithName = seen.get(method.getName());
            Method override = CollectionUtils.findFirst(seenWithName, new Spec<Method>() {

                public boolean isSatisfiedBy(Method potentionOverride) {
                    return potentionOverride.getName().equals(method.getName()) && Arrays.equals(potentionOverride.getParameterTypes(), method.getParameterTypes());
                }
            });
            if (override == null) {
                seenWithName.add(method);
                if (predicate.isSatisfiedBy(method)) {
                    collector.add(method);
                    if (stopAtFirst) {
                        return collector;
                    }
                }
            }
        }
        Class<?> parent = target.getSuperclass();
        if (parent != null) {
            return findAllMethodsInternal(parent, predicate, seen, collector, stopAtFirst);
        }
        return collector;
    }

    public static <A extends Annotation> A getAnnotation(Class<?> type, Class<A> annotationType) {
        return getAnnotation(type, annotationType, true);
    }

    private static <A extends Annotation> A getAnnotation(Class<?> type, Class<A> annotationType, boolean checkType) {
        A annotation;
        if (checkType) {
            annotation = type.getAnnotation(annotationType);
            if (annotation != null) {
                return annotation;
            }
        }
        if (annotationType.getAnnotation(Inherited.class) != null) {
            for (Class<?> anInterface : type.getInterfaces()) {
                annotation = getAnnotation(anInterface, annotationType, true);
                if (annotation != null) {
                    return annotation;
                }
            }
        }
        if (type.isInterface() || type.equals(Object.class)) {
            return null;
        } else {
            return getAnnotation(type.getSuperclass(), annotationType, false);
        }
    }

    public static <T> Factory<T> factory(final Instantiator instantiator, final Class<? extends T> type, final Object... args) {
        return new InstantiatingFactory<T>(instantiator, type, args);
    }

    public static boolean hasDefaultToString(Object object) {
        try {
            return object.getClass().getMethod("toString").getDeclaringClass() == Object.class;
        } catch (java.lang.NoSuchMethodException e) {
            throw new UncheckedException(e);
        }
    }

    private static class GetterMethodBackedPropertyAccessor<T, F> implements PropertyAccessor<T, F> {

        private final String property;

        private final Method method;

        private final Class<F> returnType;

        public GetterMethodBackedPropertyAccessor(String property, Class<F> returnType, Method method) {
            this.property = property;
            this.method = method;
            this.returnType = returnType;
        }

        @Override
        public String toString() {
            return "property " + method.getDeclaringClass().getSimpleName() + "." + property;
        }

        public String getName() {
            return property;
        }

        public Class<F> getType() {
            return returnType;
        }

        public F getValue(T target) {
            try {
                return returnType.cast(method.invoke(target));
            } catch (InvocationTargetException e) {
                throw UncheckedException.unwrapAndRethrow(e);
            } catch (Exception e) {
                throw UncheckedException.throwAsUncheckedException(e);
            }
        }
    }

    private static class FieldBackedPropertyAccessor<T, F> implements PropertyAccessor<T, F> {

        private final String property;

        private final Field field;

        private final Class<F> fieldType;

        public FieldBackedPropertyAccessor(String property, Class<F> fieldType, Field field) {
            this.property = property;
            this.field = field;
            this.fieldType = fieldType;
        }

        @Override
        public String getName() {
            return property;
        }

        @Override
        public Class<F> getType() {
            return fieldType;
        }

        @Override
        public F getValue(T target) {
            try {
                return fieldType.cast(field.get(target));
            } catch (IllegalAccessException e) {
                throw UncheckedException.throwAsUncheckedException(e);
            }
        }
    }

    private static class MethodBackedPropertyMutator implements PropertyMutator {

        private final String property;

        private final Method method;

        public MethodBackedPropertyMutator(String property, Method method) {
            this.property = property;
            this.method = method;
        }

        @Override
        public String toString() {
            return "property " + method.getDeclaringClass().getSimpleName() + "." + property;
        }

        public String getName() {
            return property;
        }

        public Class<?> getType() {
            return method.getParameterTypes()[0];
        }

        public void setValue(Object target, Object value) {
            try {
                method.invoke(target, value);
            } catch (InvocationTargetException e) {
                throw UncheckedException.unwrapAndRethrow(e);
            } catch (Exception e) {
                throw UncheckedException.throwAsUncheckedException(e);
            }
        }
    }

    private static class FieldBackedPropertyMutator implements PropertyMutator {

        private final String name;

        private final Field field;

        public FieldBackedPropertyMutator(String name, Field field) {
            this.name = name;
            this.field = field;
        }

        @Override
        public String toString() {
            return "field " + field.getDeclaringClass().getSimpleName() + "." + name;
        }

        public String getName() {
            return name;
        }

        public Class<?> getType() {
            return field.getType();
        }

        public void setValue(Object target, Object value) {
            try {
                field.set(target, value);
            } catch (IllegalAccessException e) {
                throw UncheckedException.throwAsUncheckedException(e);
            }
        }
    }

    private static class InstantiatingFactory<T> implements Factory<T> {

        private final Instantiator instantiator;

        private final Class<? extends T> type;

        private final Object[] args;

        public InstantiatingFactory(Instantiator instantiator, Class<? extends T> type, Object... args) {
            this.instantiator = instantiator;
            this.type = type;
            this.args = args;
        }

        public T create() {
            return instantiator.newInstance(type, args);
        }
    }
}}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, boxedType.getInternalName(), "valueOf", valueOfMethodDescriptor, false) UnsolvedSymbolException{context='unknown', name='INVOKESTATIC', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call methodVisitor.visitLdcInsn(property.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context property.getName() (line: 681) MethodCallExprContext{wrapped=property.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call methodVisitor.visitFieldInsn(Opcodes.GETFIELD, generatedType.getInternalName(), flagName, Type.BOOLEAN_TYPE.getDescriptor()) UnsolvedSymbolException{context='unknown', name='GETFIELD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call ConventionMapping.class.getMethod("getConventionValue", Object.class, String.class, Boolean.TYPE) UnsolvedSymbolException{context='unknown', name='TYPE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call Type.getMethodDescriptor(ConventionMapping.class.getMethod("getConventionValue", Object.class, String.class, Boolean.TYPE)) java.lang.RuntimeException: Error calculating the type of parameter Boolean.TYPE of method call ConventionMapping.class.getMethod("getConventionValue", Object.class, String.class, Boolean.TYPE) /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, CONVENTION_MAPPING_TYPE.getInternalName(), "getConventionValue", getConventionValueDesc, true) UnsolvedSymbolException{context='unknown', name='INVOKEINTERFACE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Method 'getElementType' cannot be resolved in context returnType.getElementType() (line: 699) MethodCallExprContext{wrapped=returnType.getElementType()}. Parameter types: []
Cannot solve method call methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, getter.getReturnType().isArray() ? "[" + returnType.getElementType().getDescriptor() : returnType.getInternalName()) UnsolvedSymbolException{context='unknown', name='CHECKCAST', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, boxedType.getInternalName()) UnsolvedSymbolException{context='unknown', name='CHECKCAST', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, boxedType.getInternalName(), getter.getReturnType().getName() + "Value", valueMethodDescriptor, false) UnsolvedSymbolException{context='unknown', name='INVOKEVIRTUAL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call returnType.getOpcode(Opcodes.IRETURN) UnsolvedSymbolException{context='unknown', name='IRETURN', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call methodVisitor.visitInsn(returnType.getOpcode(Opcodes.IRETURN)) java.lang.RuntimeException: Error calculating the type of parameter Opcodes.IRETURN of method call returnType.getOpcode(Opcodes.IRETURN) /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitMethod(Opcodes.ACC_PUBLIC, setter.getName(), setterDescriptor, null, EMPTY_STRINGS) UnsolvedSymbolException{context='unknown', name='ACC_PUBLIC', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call paramType.getOpcode(Opcodes.ILOAD) UnsolvedSymbolException{context='unknown', name='ILOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call methodVisitor.visitVarInsn(paramType.getOpcode(Opcodes.ILOAD), 1) java.lang.RuntimeException: Error calculating the type of parameter Opcodes.ILOAD of method call paramType.getOpcode(Opcodes.ILOAD) /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL, superclassType.getInternalName(), setter.getName(), setterDescriptor, false) UnsolvedSymbolException{context='unknown', name='INVOKESPECIAL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call methodVisitor.visitFieldInsn(Opcodes.PUTFIELD, generatedType.getInternalName(), propFieldName(property), Type.BOOLEAN_TYPE.getDescriptor()) UnsolvedSymbolException{context='unknown', name='PUTFIELD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call returnType.getOpcode(Opcodes.IRETURN) UnsolvedSymbolException{context='unknown', name='IRETURN', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call methodVisitor.visitInsn(returnType.getOpcode(Opcodes.IRETURN)) java.lang.RuntimeException: Error calculating the type of parameter Opcodes.IRETURN of method call returnType.getOpcode(Opcodes.IRETURN) /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call Type.getMethodDescriptor(Type.VOID_TYPE, paramType) UnsolvedSymbolException{context='unknown', name='VOID_TYPE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitMethod(Opcodes.ACC_PUBLIC, property.getName(), setMethodDescriptor, null, EMPTY_STRINGS) UnsolvedSymbolException{context='unknown', name='ACC_PUBLIC', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call paramType.getOpcode(Opcodes.ILOAD) UnsolvedSymbolException{context='unknown', name='ILOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call methodVisitor.visitVarInsn(paramType.getOpcode(Opcodes.ILOAD), 1) java.lang.RuntimeException: Error calculating the type of parameter Opcodes.ILOAD of method call paramType.getOpcode(Opcodes.ILOAD) /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, generatedType.getInternalName(), setter.getName(), setterDescriptor, false) UnsolvedSymbolException{context='unknown', name='INVOKEVIRTUAL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitInsn(Opcodes.RETURN) UnsolvedSymbolException{context='unknown', name='RETURN', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitMethod(Opcodes.ACC_PUBLIC, method.getName(), methodDescriptor, null, EMPTY_STRINGS) UnsolvedSymbolException{context='unknown', name='ACC_PUBLIC', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call paramType.getOpcode(Opcodes.ILOAD) UnsolvedSymbolException{context='unknown', name='ILOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call methodVisitor.visitVarInsn(paramType.getOpcode(Opcodes.ILOAD), 1) java.lang.RuntimeException: Error calculating the type of parameter Opcodes.ILOAD of method call paramType.getOpcode(Opcodes.ILOAD) /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL, superclassType.getInternalName(), method.getName(), methodDescriptor, false) UnsolvedSymbolException{context='unknown', name='INVOKESPECIAL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call methodVisitor.visitFieldInsn(Opcodes.PUTFIELD, generatedType.getInternalName(), propFieldName(property), Type.BOOLEAN_TYPE.getDescriptor()) UnsolvedSymbolException{context='unknown', name='PUTFIELD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call returnType.getOpcode(Opcodes.IRETURN) UnsolvedSymbolException{context='unknown', name='IRETURN', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call methodVisitor.visitInsn(returnType.getOpcode(Opcodes.IRETURN)) java.lang.RuntimeException: Error calculating the type of parameter Opcodes.IRETURN of method call returnType.getOpcode(Opcodes.IRETURN) /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call visitor.visitMethod(Opcodes.ACC_PUBLIC, method.getName(), methodDescriptor, null, EMPTY_STRINGS) UnsolvedSymbolException{context='unknown', name='ACC_PUBLIC', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call closurisedParameterTypes[stackVar - 1].getOpcode(Opcodes.ILOAD) UnsolvedSymbolException{context='unknown', name='ILOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call methodVisitor.visitVarInsn(closurisedParameterTypes[stackVar - 1].getOpcode(Opcodes.ILOAD), stackVar) java.lang.RuntimeException: Error calculating the type of parameter Opcodes.ILOAD of method call closurisedParameterTypes[stackVar - 1].getOpcode(Opcodes.ILOAD) /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, numParams) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, CONFIGURE_UTIL_TYPE.getInternalName(), "configureUsing", methodDescriptor, false) UnsolvedSymbolException{context='unknown', name='INVOKESTATIC', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call Type.getMethodDescriptor(Type.getType(method.getReturnType()), originalParameterTypes) UnsolvedSymbolException{context='Method 'getType' with parameterTypes [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}]', name='ReflectionClassDeclaration{clazz=org.objectweb.asm.Type}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, generatedType.getInternalName(), method.getName(), methodDescriptor, false) UnsolvedSymbolException{context='unknown', name='INVOKEVIRTUAL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call returnType.getOpcode(Opcodes.IRETURN) UnsolvedSymbolException{context='unknown', name='IRETURN', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call methodVisitor.visitInsn(returnType.getOpcode(Opcodes.IRETURN)) java.lang.RuntimeException: Error calculating the type of parameter Opcodes.IRETURN of method call returnType.getOpcode(Opcodes.IRETURN) /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call visitor.visitAnnotation(Type.getType(annotation.annotationType()).getDescriptor(), visible) UnsolvedSymbolException{context='Method 'getType' with parameterTypes [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=ReferenceType{java.lang.annotation.Annotation, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}]', name='ReflectionClassDeclaration{clazz=org.objectweb.asm.Type}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call PRIMITIVE_TYPES.contains(returnType.getComponentType()) java.lang.RuntimeException: Method 'getComponentType' cannot be resolved in context returnType.getComponentType() (line: 850) MethodCallExprContext{wrapped=returnType.getComponentType()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call annotationVisitor.visitAnnotation(name, Type.getType(returnType).getDescriptor()) UnsolvedSymbolException{context='Method 'getType' with parameterTypes [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=null, boundedType=null}}}}]', name='ReflectionClassDeclaration{clazz=org.objectweb.asm.Type}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call annotationVisitor.visit(name, Type.getType(clazz)) UnsolvedSymbolException{context='Method 'getType' with parameterTypes [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=null, boundedType=null}}}}]', name='ReflectionClassDeclaration{clazz=org.objectweb.asm.Type}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call visitArrayElements(arrayVisitor, returnType.getComponentType(), elements) java.lang.RuntimeException: Method 'getComponentType' cannot be resolved in context returnType.getComponentType() (line: 853) MethodCallExprContext{wrapped=returnType.getComponentType()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call annotationVisitor.visitEnum(name, Type.getType(returnType).getDescriptor(), getAnnotationParameterValue(annotation, method).toString()) UnsolvedSymbolException{context='Method 'getType' with parameterTypes [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=null, boundedType=null}}}}]', name='ReflectionClassDeclaration{clazz=org.objectweb.asm.Type}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call arrayVisitor.visitAnnotation(null, Type.getType(arrayElementType).getDescriptor()) UnsolvedSymbolException{context='Method 'getType' with parameterTypes [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=org.objectweb.asm.Type}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call arrayVisitor.visit(null, Type.getType(clazz)) UnsolvedSymbolException{context='Method 'getType' with parameterTypes [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=null, boundedType=null}}}}]', name='ReflectionClassDeclaration{clazz=org.objectweb.asm.Type}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call DEFINE_CLASS_METHOD.invoke(type.getClassLoader(), typeName, bytecode, 0, bytecode.length) java.lang.RuntimeException: Method 'getClassLoader' cannot be resolved in context type.getClassLoader() (line: 908) MethodCallExprContext{wrapped=type.getClassLoader()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call visitor.visitMethod(ACC_STATIC, "<clinit>", "()V", null, null) UnsolvedSymbolException{context='Solving ACC_STATIC', name='ACC_STATIC', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call mv.visitInsn(RETURN) UnsolvedSymbolException{context='Solving RETURN', name='RETURN', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call mv.visitInsn(Opcodes.ICONST_0) UnsolvedSymbolException{context='unknown', name='ICONST_0', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call mv.visitTypeInsn(Opcodes.ANEWARRAY, CLASS_TYPE.getInternalName()) UnsolvedSymbolException{context='unknown', name='ANEWARRAY', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, CLASS_TYPE.getInternalName(), "getDeclaredMethod", GET_DECLARED_METHOD_DESCRIPTOR, false) UnsolvedSymbolException{context='unknown', name='INVOKEVIRTUAL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot resolve field access null
Cannot solve method call mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, METHOD_TYPE.getInternalName(), "getGenericReturnType", Type.getMethodDescriptor(JAVA_LANG_REFLECT_TYPE), false) UnsolvedSymbolException{context='unknown', name='INVOKEVIRTUAL', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call mv.visitFieldInsn(PUTSTATIC, generatedType.getInternalName(), returnType.fieldName, JAVA_REFLECT_TYPE_DESCRIPTOR) UnsolvedSymbolException{context='Solving PUTSTATIC', name='PUTSTATIC', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AsmBackedClassGenerator.java
Cannot solve method call Character.isJavaIdentifierStart(propertyName.codePointAt(0)) java.lang.RuntimeException: Method 'codePointAt' cannot be resolved in context propertyName.codePointAt(0) (line: 33) MethodCallExprContext{wrapped=propertyName.codePointAt(0)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/AbstractTaskPropertyBuilder.java
Cannot solve field access TaskExecutionOutcome.EXECUTED
Cannot solve method call String.format("%s failed with an exception.", StringUtils.capitalize(description)) UnsolvedSymbolException{context='Method 'capitalize' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=org.apache.commons.lang.StringUtils}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/TaskStateInternal.java
Cannot resolve field access null
Cannot solve method call outputStream.setLongFileMode(TarOutputStream.LONGFILE_POSIX) UnsolvedSymbolException{context='unknown', name='LONGFILE_POSIX', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/cache/TarTaskOutputPacker.java
Cannot resolve field access null
Cannot solve method call outputStream.setBigNumberMode(TarOutputStream.BIGNUMBER_POSIX) UnsolvedSymbolException{context='unknown', name='BIGNUMBER_POSIX', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/cache/TarTaskOutputPacker.java
Empty name expression DIRECTORY
Cannot solve method call entry.setMode(UnixStat.DIR_FLAG | dirDetails.getMode()) UnsolvedSymbolException{context='unknown', name='DIR_FLAG', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/cache/TarTaskOutputPacker.java
Empty name expression FILE
Cannot solve method call entry.setMode(UnixStat.FILE_FLAG | mode) UnsolvedSymbolException{context='unknown', name='FILE_FLAG', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/cache/TarTaskOutputPacker.java
Cannot solve field access OutputType.DIRECTORY
Cannot solve method call fileSystem.chmod(outputFile, entry.getMode() & 0777) java.lang.RuntimeException: Method 'getMode' cannot be resolved in context entry.getMode() (line: 191) MethodCallExprContext{wrapped=entry.getMode()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/cache/TarTaskOutputPacker.java
Method 'getModTime' cannot be resolved in context entry.getModTime() (line: 192) MethodCallExprContext{wrapped=entry.getModTime()}. Parameter types: []
Cannot solve method call outputFile.setLastModified(entry.getModTime().getTime()) java.lang.RuntimeException: Method 'getModTime' cannot be resolved in context entry.getModTime() (line: 192) MethodCallExprContext{wrapped=entry.getModTime()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/cache/TarTaskOutputPacker.java
Cannot solve method call hasher.putString(charSequence, Charsets.UTF_8) UnsolvedSymbolException{context='unknown', name='UTF_8', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/cache/DefaultTaskCacheKeyBuilder.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call Maps.toMap(Arrays.asList(TaskExecutionOutcome.values()), Functions.constant(0)) UnsolvedSymbolException{context='Solving Functions', name='Functions', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/cache/statistics/TaskExecutionStatistics.java
Cannot solve method call TaskPropertyUtils.ensurePropertiesHaveNames(filePropertiesInternal) java.lang.UnsupportedOperationException /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskOutputs.java
Cannot solve method call Iterables.concat(Iterables.transform(filePropertiesInternal, new Function<BasePropertySpec, Iterable<? extends TaskOutputFilePropertySpec>>() {

    @Override
    public Iterable<? extends TaskOutputFilePropertySpec> apply(BasePropertySpec propertySpec) {
        if (propertySpec instanceof CompositePropertySpec) {
            return (CompositePropertySpec) propertySpec;
        } else {
            return Collections.singleton((TaskOutputFilePropertySpec) propertySpec);
        }
    }
})) UnsolvedSymbolException{context='Method 'transform' with parameterTypes [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{org.gradle.api.internal.tasks.DefaultTaskOutputs.BasePropertySpec, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{Function, typeParametersMap=TypeParametersMap{nameToValue={empty.Equivalence.Wrapper<Method>=ReferenceType{Iterable, typeParametersMap=TypeParametersMap{nameToValue={empty.BlockDoc=WildcardUsage{type=EXTENDS, boundedType=ReferenceType{org.gradle.api.internal.tasks.TaskOutputFilePropertySpec, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}, empty.Method=ReferenceType{org.gradle.api.internal.tasks.DefaultTaskOutputs.BasePropertySpec, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskOutputs.java
Cannot solve field access OutputType.FILE
Cannot solve field access OutputType.DIRECTORY
Cannot solve field access OutputType.FILE
Cannot solve method call Callables.<Map<?, ?>>returning(ImmutableMap.copyOf(paths)) UnsolvedSymbolException{context='Method 'copyOf' with parameterTypes [ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=WildcardUsage{type=null, boundedType=null}, java.util.Map.V=WildcardUsage{type=null, boundedType=null}}}}]', name='ReflectionClassDeclaration{clazz=ImmutableMap}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskOutputs.java
Cannot solve field access OutputType.FILE
Cannot solve field access OutputType.DIRECTORY
Cannot solve method call Callables.<Map<?, ?>>returning(ImmutableMap.copyOf(paths)) UnsolvedSymbolException{context='Method 'copyOf' with parameterTypes [ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=WildcardUsage{type=null, boundedType=null}, java.util.Map.V=WildcardUsage{type=null, boundedType=null}}}}]', name='ReflectionClassDeclaration{clazz=ImmutableMap}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskOutputs.java
Cannot solve field access OutputType.DIRECTORY
Cannot solve field access TaskFilePropertySnapshotNormalizationStrategy.ABSOLUTE
Cannot solve method call TaskFilePropertySnapshotNormalizationStrategy.valueOf(sensitivity) UnsolvedSymbolException{context='unknown', name='SnapshotNormalizationStrategy', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskOutputs.java
Cannot solve method call DeprecationLogger.nagUserOfDiscontinuedMethod("chaining of the " + method, String.format("Use '%s' on TaskOutputs directly instead.", method)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskOutputs.java
Method 'getTaskOutputs' cannot be resolved in context getTaskOutputs("upToDateWhen(Closure)") (line: 334) MethodCallExprContext{wrapped=getTaskOutputs("upToDateWhen(Closure)")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getTaskOutputs' cannot be resolved in context getTaskOutputs("upToDateWhen(Spec)") (line: 339) MethodCallExprContext{wrapped=getTaskOutputs("upToDateWhen(Spec)")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getTaskOutputs' cannot be resolved in context getTaskOutputs("cacheIf(Spec)") (line: 344) MethodCallExprContext{wrapped=getTaskOutputs("cacheIf(Spec)")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getTaskOutputs' cannot be resolved in context getTaskOutputs("getHasOutput()") (line: 349) MethodCallExprContext{wrapped=getTaskOutputs("getHasOutput()")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getTaskOutputs' cannot be resolved in context getTaskOutputs("getFiles()") (line: 354) MethodCallExprContext{wrapped=getTaskOutputs("getFiles()")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getTaskOutputs' cannot be resolved in context getTaskOutputs("files(Object...)") (line: 360) MethodCallExprContext{wrapped=getTaskOutputs("files(Object...)")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getTaskOutputs' cannot be resolved in context getTaskOutputs("file(Object)") (line: 365) MethodCallExprContext{wrapped=getTaskOutputs("file(Object)")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getTaskOutputs' cannot be resolved in context getTaskOutputs("dir(Object)") (line: 370) MethodCallExprContext{wrapped=getTaskOutputs("dir(Object)")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call type.cast(create(GUtil.map(Task.TASK_NAME, name, Task.TASK_TYPE, type))) com.github.javaparser.symbolsolver.logic.ConfilictingGenericTypesException: No matching between ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{Map, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual) /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskContainer.java
Cannot solve method call type.cast(create(GUtil.map(Task.TASK_NAME, name, Task.TASK_TYPE, type, Task.TASK_OVERWRITE, true))) com.github.javaparser.symbolsolver.logic.ConfilictingGenericTypesException: No matching between ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{Map, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual) /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskContainer.java
Cannot resolve field access null
Cannot solve method call project.getTasks().findByName(StringUtils.substringAfterLast(path, Project.PATH_SEPARATOR)) UnsolvedSymbolException{context='Method 'substringAfterLast' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=org.apache.commons.lang.StringUtils}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskContainer.java
Cannot solve method call String.format("Task reference '%s' could not be resolved in %s.", reference.getName(), project) UnsolvedSymbolException{context='Solving project', name='project', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskContainer.java
Cannot solve method call String.format("Task with path '%s' not found in %s.", path, project) UnsolvedSymbolException{context='Solving project', name='project', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskContainer.java
Cannot solve method call Sets.newTreeSet(modelNode.getLinkNames()) java.lang.RuntimeException: Method 'getLinkNames' cannot be resolved in context modelNode.getLinkNames() (line: 196) MethodCallExprContext{wrapped=modelNode.getLinkNames()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskContainer.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call realizeTask(MODEL_PATH.child(task.getName()), ModelNode.State.GraphClosed) UnsolvedSymbolException{context='Solving MODEL_PATH', name='MODEL_PATH', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskContainer.java
Cannot resolve field access null
Cannot solve method call realizeTask(MODEL_PATH.child(name), ModelNode.State.Initialized) UnsolvedSymbolException{context='Solving MODEL_PATH', name='MODEL_PATH', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskContainer.java
Cannot resolve field access null
Error calculating the type of parameter ModelActionRole.Create of method call ModelRegistrations.of(path).action(ModelActionRole.Create, new TaskCreator<T>(placeholderName, taskType, configure, taskModelType))
Error calculating the type of parameter ModelActionRole.Create of method call ModelRegistrations.of(path).action(ModelActionRole.Create, new TaskCreator<T>(placeholderName, taskType, configure, taskModelType))
Error calculating the type of parameter ModelActionRole.Create of method call ModelRegistrations.of(path).action(ModelActionRole.Create, new TaskCreator<T>(placeholderName, taskType, configure, taskModelType))
Cannot solve method call modelNode.addLink(ModelRegistrations.of(path).action(ModelActionRole.Create, new TaskCreator<T>(placeholderName, taskType, configure, taskModelType)).withProjection(new UnmanagedModelProjection<T>(taskModelType)).descriptor(new SimpleModelRuleDescriptor("tasks.addPlaceholderAction(" + placeholderName + ")")).build()) java.lang.RuntimeException: Error calculating the type of parameter ModelActionRole.Create of method call ModelRegistrations.of(path).action(ModelActionRole.Create, new TaskCreator<T>(placeholderName, taskType, configure, taskModelType)) /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskContainer.java
Cannot solve method call Collections.singleton(getType()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context getType() (line: 265) MethodCallExprContext{wrapped=getType()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskContainer.java
Cannot solve method call type.cast(taskFactory.create(name, TaskInternal.class)) java.lang.RuntimeException: Method 'create' cannot be resolved in context taskFactory.create(name, TaskInternal.class) (line: 278) MethodCallExprContext{wrapped=taskFactory.create(name, TaskInternal.class)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.internal.TaskInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskContainer.java
Cannot solve method call taskFactory.create(name, type.asSubclass(TaskInternal.class)) java.lang.RuntimeException: Method 'asSubclass' cannot be resolved in context type.asSubclass(TaskInternal.class) (line: 280) MethodCallExprContext{wrapped=type.asSubclass(TaskInternal.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.internal.TaskInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskContainer.java
Cannot solve method call type.cast(taskFactory.create(name, type.asSubclass(TaskInternal.class))) java.lang.RuntimeException: Error calculating the type of parameter type.asSubclass(TaskInternal.class) of method call taskFactory.create(name, type.asSubclass(TaskInternal.class)) /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskContainer.java
Method 'getParent' cannot be resolved in context mutableModelNode.getParent() (line: 299) MethodCallExprContext{wrapped=mutableModelNode.getParent()}. Parameter types: []
Cannot resolve field access null
Cannot solve field access ModelNode.State.SelfClosed
Cannot resolve field access null
Cannot solve field access ModelNode.State.GraphClosed
Cannot solve method call optionValues.value() java.lang.UnsupportedOperationException: com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnnotationDeclaration /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/options/OptionReader.java
Cannot solve method call CollectionUtils.toList(optionValues.value()) java.lang.UnsupportedOperationException: com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnnotationDeclaration@47ec8ef7 /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/options/OptionReader.java
Error calculating the type of parameter optionValues.value() of method call CollectionUtils.toList(optionValues.value())
Cannot resolve field access null
Cannot solve method call String.format("@OptionValues annotation not supported on method '%s' in class '%s'. Supported method must be non-static, return a Collection<String> and take no parameters.", method.getName(), type.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context type.getName() (line: 147) MethodCallExprContext{wrapped=type.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/options/OptionReader.java
Cannot solve method call methods.add(JavaReflectionUtil.method(Collection.class, method)) UnsolvedSymbolException{context='Method 'method' with parameterTypes [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{java.lang.reflect.Method, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=public class JavaReflectionUtil {

    private static final WeakHashMap<Class<?>, ConcurrentMap<String, Boolean>> PROPERTY_CACHE = new WeakHashMap<Class<?>, ConcurrentMap<String, Boolean>>();

    /**
     * Locates the readable properties of the given type. Searches only public properties.
     */
    public static <T> Map<String, PropertyAccessor> readableProperties(Class<T> target) {
        HashMap<String, PropertyAccessor> properties = new HashMap<String, PropertyAccessor>();
        for (Method method : target.getMethods()) {
            if (method.getName().startsWith("get") && isGetter(method)) {
                String propertyName = method.getName().substring(3);
                propertyName = Character.toLowerCase(propertyName.charAt(0)) + propertyName.substring(1);
                properties.put(propertyName, new GetterMethodBackedPropertyAccessor<T, Object>(propertyName, Object.class, method));
            } else if (method.getName().startsWith("is") && isBooleanGetter(method)) {
                String propertyName = method.getName().substring(2);
                propertyName = Character.toLowerCase(propertyName.charAt(0)) + propertyName.substring(1);
                properties.put(propertyName, new GetterMethodBackedPropertyAccessor<T, Object>(propertyName, Object.class, method));
            }
        }
        return properties;
    }

    /**
     * Locates the property with the given name as a readable property. Searches only public properties.
     *
     * @throws NoSuchPropertyException when the given property does not exist.
     */
    public static <T, F> PropertyAccessor<T, F> readableProperty(Class<T> target, Class<F> returnType, String property) throws NoSuchPropertyException {
        final Method getterMethod = findGetterMethod(target, property);
        if (getterMethod == null) {
            throw new NoSuchPropertyException(String.format("Could not find getter method for property '%s' on class %s.", property, target.getSimpleName()));
        }
        return new GetterMethodBackedPropertyAccessor<T, F>(property, returnType, getterMethod);
    }

    /**
     * Locates the property with the given name as a readable property. Searches only public properties.
     *
     * @throws NoSuchPropertyException when the given property does not exist.
     */
    public static <T, F> PropertyAccessor<T, F> readableProperty(T target, Class<F> returnType, String property) throws NoSuchPropertyException {
        @SuppressWarnings("unchecked") Class<T> targetClass = (Class<T>) target.getClass();
        return readableProperty(targetClass, returnType, property);
    }

    /**
     * Locates the field with the given name as a readable property.  Searches only public fields.
     *
     * @throws NoSuchPropertyException
     */
    public static <T, F> PropertyAccessor<T, F> readableField(Class<T> target, Class<F> fieldType, String fieldName) throws NoSuchPropertyException {
        Field field = findField(target, fieldName);
        if (field == null) {
            throw new NoSuchPropertyException(String.format("Could not find field '%s' on class %s.", fieldName, target.getSimpleName()));
        }
        return new FieldBackedPropertyAccessor<T, F>(fieldName, fieldType, field);
    }

    /**
     * Locates the field with the given name as a readable property.  Searches only public fields.
     *
     * @throws NoSuchPropertyException
     */
    public static <T, F> PropertyAccessor<T, F> readableField(T target, Class<F> fieldType, String fieldName) throws NoSuchPropertyException {
        @SuppressWarnings("unchecked") Class<T> targetClass = (Class<T>) target.getClass();
        return readableField(targetClass, fieldType, fieldName);
    }

    private static Method findGetterMethod(Class<?> target, String property) {
        Method[] methods = target.getMethods();
        String getter = toMethodName("get", property);
        String iser = toMethodName("is", property);
        for (Method method : methods) {
            String methodName = method.getName();
            if (getter.equals(methodName) && isGetter(method)) {
                return method;
            }
            if (iser.equals(methodName) && isBooleanGetter(method)) {
                return method;
            }
        }
        return null;
    }

    private static boolean isGetter(Method method) {
        return method.getParameterTypes().length == 0 && !Modifier.isStatic(method.getModifiers()) && !method.getReturnType().equals(Void.TYPE);
    }

    private static boolean isBooleanGetter(Method method) {
        Class<?> returnType = method.getReturnType();
        return method.getParameterTypes().length == 0 && !Modifier.isStatic(method.getModifiers()) && (returnType.equals(Boolean.TYPE) || returnType.equals(Boolean.class));
    }

    /**
     * Locates the property with the given name as a writable property. Searches only public properties.
     *
     * @throws NoSuchPropertyException when the given property does not exist.
     */
    public static PropertyMutator writeableProperty(Class<?> target, String property) throws NoSuchPropertyException {
        PropertyMutator mutator = writeablePropertyIfExists(target, property);
        if (mutator != null) {
            return mutator;
        }
        throw new NoSuchPropertyException(String.format("Could not find setter method for property '%s' on class %s.", property, target.getSimpleName()));
    }

    /**
     * Locates the property with the given name as a writable property. Searches only public properties.
     *
     * Returns null if no such property exists.
     */
    public static PropertyMutator writeablePropertyIfExists(Class<?> target, String property) throws NoSuchPropertyException {
        String setterName = toMethodName("set", property);
        for (final Method method : target.getMethods()) {
            if (!method.getName().equals(setterName)) {
                continue;
            }
            if (method.getParameterTypes().length != 1) {
                continue;
            }
            if (Modifier.isStatic(method.getModifiers())) {
                continue;
            }
            return new MethodBackedPropertyMutator(property, method);
        }
        return null;
    }

    /**
     * Locates the field with the given name as a writable property. Searches only public properties.
     *
     * @throws NoSuchPropertyException when the given property does not exist.
     */
    public static PropertyMutator writeableField(Class<?> target, String fieldName) throws NoSuchPropertyException {
        Field field = findField(target, fieldName);
        if (field != null) {
            return new FieldBackedPropertyMutator(fieldName, field);
        }
        throw new NoSuchPropertyException(String.format("Could not find writeable field '%s' on class %s.", fieldName, target.getSimpleName()));
    }

    private static Field findField(Class<?> target, String fieldName) {
        Field[] fields = target.getFields();
        for (Field field : fields) {
            if (fieldName.equals(field.getName())) {
                return field;
            }
        }
        return null;
    }

    private static String toMethodName(String prefix, String propertyName) {
        return prefix + Character.toUpperCase(propertyName.charAt(0)) + propertyName.substring(1);
    }

    public static Class<?> getWrapperTypeForPrimitiveType(Class<?> type) {
        if (type == Character.TYPE) {
            return Character.class;
        } else if (type == Boolean.TYPE) {
            return Boolean.class;
        } else if (type == Long.TYPE) {
            return Long.class;
        } else if (type == Integer.TYPE) {
            return Integer.class;
        } else if (type == Short.TYPE) {
            return Short.class;
        } else if (type == Byte.TYPE) {
            return Byte.class;
        } else if (type == Float.TYPE) {
            return Float.class;
        } else if (type == Double.TYPE) {
            return Double.class;
        }
        throw new IllegalArgumentException(String.format("Don't know the wrapper type for primitive type %s.", type));
    }

    /**
     * Locates the given method. Searches all methods, including private methods.
     */
    public static <T, R> JavaMethod<T, R> method(Class<T> target, Class<R> returnType, String name, Class<?>... paramTypes) throws NoSuchMethodException {
        return new JavaMethod<T, R>(target, returnType, name, paramTypes);
    }

    /**
     * Locates the given static method. Searches all methods, including private methods.
     */
    public static <T, R> JavaMethod<T, R> staticMethod(Class<T> target, Class<R> returnType, String name, Class<?>... paramTypes) throws NoSuchMethodException {
        return new JavaMethod<T, R>(target, returnType, name, true, paramTypes);
    }

    /**
     * Locates the given method. Searches all methods, including private methods.
     */
    public static <T, R> JavaMethod<T, R> method(T target, Class<R> returnType, String name, Class<?>... paramTypes) throws NoSuchMethodException {
        @SuppressWarnings("unchecked") Class<T> targetClass = (Class<T>) target.getClass();
        return method(targetClass, returnType, name, paramTypes);
    }

    /**
     * Locates the given method. Searches all methods, including private methods.
     */
    public static <T, R> JavaMethod<T, R> method(Class<R> returnType, Method method) throws NoSuchMethodException {
        return new JavaMethod<T, R>(returnType, method);
    }

    public static Method findMethod(Class<?> target, Spec<Method> predicate) {
        List<Method> methods = findAllMethodsInternal(target, predicate, new MultiMap<String, Method>(), new ArrayList<Method>(1), true);
        return methods.isEmpty() ? null : methods.get(0);
    }

    public static List<Method> findAllMethods(Class<?> target, Spec<Method> predicate) {
        return findAllMethodsInternal(target, predicate, new MultiMap<String, Method>(), new ArrayList<Method>(), false);
    }

    // Not hasProperty() because that's awkward with Groovy objects implementing it
    public static boolean propertyExists(Object target, String propertyName) {
        Class<?> targetType = target.getClass();
        ConcurrentMap<String, Boolean> cached;
        synchronized (PROPERTY_CACHE) {
            cached = PROPERTY_CACHE.get(targetType);
            if (cached == null) {
                cached = new ConcurrentHashMap<String, Boolean>();
                PROPERTY_CACHE.put(targetType, cached);
            }
        }
        Boolean res = cached.get(propertyName);
        if (res != null) {
            return res;
        }
        Method getterMethod = findGetterMethod(target.getClass(), propertyName);
        if (getterMethod == null) {
            if (findField(targetType, propertyName) == null) {
                cached.putIfAbsent(propertyName, false);
                return false;
            }
        }
        cached.putIfAbsent(propertyName, true);
        return true;
    }

    private static class MultiMap<K, V> extends HashMap<K, List<V>> {

        @Override
        public List<V> get(Object key) {
            if (!containsKey(key)) {
                @SuppressWarnings("unchecked") K keyCast = (K) key;
                put(keyCast, new LinkedList<V>());
            }
            return super.get(key);
        }
    }

    private static List<Method> findAllMethodsInternal(Class<?> target, Spec<Method> predicate, MultiMap<String, Method> seen, List<Method> collector, boolean stopAtFirst) {
        for (final Method method : target.getDeclaredMethods()) {
            List<Method> seenWithName = seen.get(method.getName());
            Method override = CollectionUtils.findFirst(seenWithName, new Spec<Method>() {

                public boolean isSatisfiedBy(Method potentionOverride) {
                    return potentionOverride.getName().equals(method.getName()) && Arrays.equals(potentionOverride.getParameterTypes(), method.getParameterTypes());
                }
            });
            if (override == null) {
                seenWithName.add(method);
                if (predicate.isSatisfiedBy(method)) {
                    collector.add(method);
                    if (stopAtFirst) {
                        return collector;
                    }
                }
            }
        }
        Class<?> parent = target.getSuperclass();
        if (parent != null) {
            return findAllMethodsInternal(parent, predicate, seen, collector, stopAtFirst);
        }
        return collector;
    }

    public static <A extends Annotation> A getAnnotation(Class<?> type, Class<A> annotationType) {
        return getAnnotation(type, annotationType, true);
    }

    private static <A extends Annotation> A getAnnotation(Class<?> type, Class<A> annotationType, boolean checkType) {
        A annotation;
        if (checkType) {
            annotation = type.getAnnotation(annotationType);
            if (annotation != null) {
                return annotation;
            }
        }
        if (annotationType.getAnnotation(Inherited.class) != null) {
            for (Class<?> anInterface : type.getInterfaces()) {
                annotation = getAnnotation(anInterface, annotationType, true);
                if (annotation != null) {
                    return annotation;
                }
            }
        }
        if (type.isInterface() || type.equals(Object.class)) {
            return null;
        } else {
            return getAnnotation(type.getSuperclass(), annotationType, false);
        }
    }

    public static <T> Factory<T> factory(final Instantiator instantiator, final Class<? extends T> type, final Object... args) {
        return new InstantiatingFactory<T>(instantiator, type, args);
    }

    public static boolean hasDefaultToString(Object object) {
        try {
            return object.getClass().getMethod("toString").getDeclaringClass() == Object.class;
        } catch (java.lang.NoSuchMethodException e) {
            throw new UncheckedException(e);
        }
    }

    private static class GetterMethodBackedPropertyAccessor<T, F> implements PropertyAccessor<T, F> {

        private final String property;

        private final Method method;

        private final Class<F> returnType;

        public GetterMethodBackedPropertyAccessor(String property, Class<F> returnType, Method method) {
            this.property = property;
            this.method = method;
            this.returnType = returnType;
        }

        @Override
        public String toString() {
            return "property " + method.getDeclaringClass().getSimpleName() + "." + property;
        }

        public String getName() {
            return property;
        }

        public Class<F> getType() {
            return returnType;
        }

        public F getValue(T target) {
            try {
                return returnType.cast(method.invoke(target));
            } catch (InvocationTargetException e) {
                throw UncheckedException.unwrapAndRethrow(e);
            } catch (Exception e) {
                throw UncheckedException.throwAsUncheckedException(e);
            }
        }
    }

    private static class FieldBackedPropertyAccessor<T, F> implements PropertyAccessor<T, F> {

        private final String property;

        private final Field field;

        private final Class<F> fieldType;

        public FieldBackedPropertyAccessor(String property, Class<F> fieldType, Field field) {
            this.property = property;
            this.field = field;
            this.fieldType = fieldType;
        }

        @Override
        public String getName() {
            return property;
        }

        @Override
        public Class<F> getType() {
            return fieldType;
        }

        @Override
        public F getValue(T target) {
            try {
                return fieldType.cast(field.get(target));
            } catch (IllegalAccessException e) {
                throw UncheckedException.throwAsUncheckedException(e);
            }
        }
    }

    private static class MethodBackedPropertyMutator implements PropertyMutator {

        private final String property;

        private final Method method;

        public MethodBackedPropertyMutator(String property, Method method) {
            this.property = property;
            this.method = method;
        }

        @Override
        public String toString() {
            return "property " + method.getDeclaringClass().getSimpleName() + "." + property;
        }

        public String getName() {
            return property;
        }

        public Class<?> getType() {
            return method.getParameterTypes()[0];
        }

        public void setValue(Object target, Object value) {
            try {
                method.invoke(target, value);
            } catch (InvocationTargetException e) {
                throw UncheckedException.unwrapAndRethrow(e);
            } catch (Exception e) {
                throw UncheckedException.throwAsUncheckedException(e);
            }
        }
    }

    private static class FieldBackedPropertyMutator implements PropertyMutator {

        private final String name;

        private final Field field;

        public FieldBackedPropertyMutator(String name, Field field) {
            this.name = name;
            this.field = field;
        }

        @Override
        public String toString() {
            return "field " + field.getDeclaringClass().getSimpleName() + "." + name;
        }

        public String getName() {
            return name;
        }

        public Class<?> getType() {
            return field.getType();
        }

        public void setValue(Object target, Object value) {
            try {
                field.set(target, value);
            } catch (IllegalAccessException e) {
                throw UncheckedException.throwAsUncheckedException(e);
            }
        }
    }

    private static class InstantiatingFactory<T> implements Factory<T> {

        private final Instantiator instantiator;

        private final Class<? extends T> type;

        private final Object[] args;

        public InstantiatingFactory(Instantiator instantiator, Class<? extends T> type, Object... args) {
            this.instantiator = instantiator;
            this.type = type;
            this.args = args;
        }

        public T create() {
            return instantiator.newInstance(type, args);
        }
    }
}}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/options/OptionReader.java
Cannot solve method call option.option() java.lang.UnsupportedOperationException: com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnnotationDeclaration /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/options/FieldOptionElement.java
Cannot solve method call option.option() java.lang.UnsupportedOperationException: com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnnotationDeclaration /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/options/FieldOptionElement.java
Cannot resolve field access null
Cannot solve method call option.option() java.lang.UnsupportedOperationException: com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnnotationDeclaration /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/options/MethodOptionElement.java
Cannot solve method call String.format("No option name set on '%s' in class '%s'.", getElementName(), getDeclaredClass().getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context getDeclaredClass().getName() (line: 37) MethodCallExprContext{wrapped=getDeclaredClass().getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/options/MethodOptionElement.java
Cannot solve method call option.option() java.lang.UnsupportedOperationException: com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnnotationDeclaration /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/options/MethodOptionElement.java
Cannot solve method call createNotationParserOrFail(optionValueNotationParserFactory, option.option(), optionType, method.getDeclaringClass()) java.lang.UnsupportedOperationException: com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnnotationDeclaration@34ef2951 /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/options/MethodOptionElement.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call String.format("Don't know how to convert strings to type '%s'.", targetType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context targetType.getName() (line: 38) MethodCallExprContext{wrapped=targetType.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/options/OptionValueNotationParserFactory.java
Method 'append' cannot be resolved in context new CompareToBuilder().append(getOrder(), o.getOrder()) (line: 89) MethodCallExprContext{wrapped=new CompareToBuilder().append(getOrder(), o.getOrder())}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}]
Method 'append' cannot be resolved in context new CompareToBuilder().append(getOrder(), o.getOrder()) (line: 89) MethodCallExprContext{wrapped=new CompareToBuilder().append(getOrder(), o.getOrder())}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}]
Cannot solve method call option.order() java.lang.UnsupportedOperationException: com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnnotationDeclaration /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/options/AbstractOptionElement.java
Cannot solve method call String.format("No description set on option '%s' at for class '%s'.", optionName, declaringClass.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context declaringClass.getName() (line: 57) MethodCallExprContext{wrapped=declaringClass.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/options/AbstractOptionElement.java
Cannot solve method call option.description() java.lang.UnsupportedOperationException: com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnnotationDeclaration /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/options/AbstractOptionElement.java
Cannot solve method call String.format("Option '%s' cannot be casted to type '%s' in class '%s'.", optionName, optionType.getName(), declaringClass.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context optionType.getName() (line: 87) MethodCallExprContext{wrapped=optionType.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/options/AbstractOptionElement.java
Cannot resolve field access null
Cannot resolve field access null
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call messages.add(String.format("Cannot write to file '%s' specified for property '%s' as it is a directory.", file, propertyName)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/TaskOutputsUtil.java
Cannot solve method call messages.add(String.format("Cannot write to file '%s' specified for property '%s', as ancestor '%s' is not a directory.", file, propertyName, candidate)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/TaskOutputsUtil.java
Cannot solve method call messages.add(String.format("Directory '%s' specified for property '%s' is not a directory.", directory, propertyName)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/TaskOutputsUtil.java
Cannot solve method call messages.add(String.format("Cannot write to directory '%s' specified for property '%s', as ancestor '%s' is not a directory.", directory, propertyName, candidate)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/TaskOutputsUtil.java
Cannot solve name expression ADDED
Cannot solve name expression method
Cannot solve name expression listname
Cannot solve name expression String
Cannot solve method call String.format("%s.%s", listname, "add()") UnsolvedSymbolException{context='unknown', name='ObservableList.ElementEvent', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/TaskMutator.java
Cannot solve name expression UPDATED
Cannot solve name expression method
Cannot solve name expression listname
Cannot solve name expression String
Cannot solve method call String.format("%s.%s", listname, "set(int, Object)") UnsolvedSymbolException{context='unknown', name='ObservableList.ElementEvent', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/TaskMutator.java
Cannot solve name expression REMOVED
Cannot solve name expression method
Cannot solve name expression listname
Cannot solve name expression String
Cannot solve method call String.format("%s.%s", listname, "remove()") UnsolvedSymbolException{context='unknown', name='ObservableList.ElementEvent', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/TaskMutator.java
Cannot solve name expression CLEARED
Cannot solve name expression method
Cannot solve name expression listname
Cannot solve name expression String
Cannot solve method call String.format("%s.%s", listname, "clear()") UnsolvedSymbolException{context='unknown', name='ObservableList.ElementEvent', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/TaskMutator.java
Cannot solve name expression MULTI_ADD
Cannot solve name expression method
Cannot solve name expression listname
Cannot solve name expression String
Cannot solve method call String.format("%s.%s", listname, "addAll()") UnsolvedSymbolException{context='unknown', name='ObservableList.ElementEvent', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/TaskMutator.java
Cannot solve name expression MULTI_REMOVE
Cannot solve name expression method
Cannot solve name expression listname
Cannot solve name expression String
Cannot solve method call String.format("%s.%s", listname, "removeAll()") UnsolvedSymbolException{context='unknown', name='ObservableList.ElementEvent', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/TaskMutator.java
Cannot solve method call taskInputsListener.onExecute(task, Cast.cast(FileCollectionInternal.class, task.getInputs().getFiles())) UnsolvedSymbolException{context='Method 'cast' with parameterTypes [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.internal.file.FileCollectionInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{org.gradle.api.file.FileCollection, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class Cast {

    /**
     * Casts the given object to the given type, providing a better error message than the default.
     *
     * The standard {@link Class#cast(Object)} method produces unsatisfactory error messages on some platforms
     * when it fails. All this method does is provide a better, consistent, error message.
     *
     * This should be used whenever there is a chance the cast could fail. If in doubt, use this.
     *
     * @param outputType The type to cast the input to
     * @param object The object to be cast
     * @param <O> The type to be cast to
     * @param <I> The type of the object to be vast
     * @return The input object, cast to the output type
     */
    public static <O, I> O cast(Class<O> outputType, I object) {
        try {
            return outputType.cast(object);
        } catch (ClassCastException e) {
            throw new ClassCastException(String.format("Failed to cast object %s of type %s to target type %s", object, object.getClass().getName(), outputType.getName()));
        }
    }

    @SuppressWarnings("unchecked")
    public static <T> T uncheckedCast(Object object) {
        return (T) object;
    }
}}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/execution/SkipEmptySourceFilesTaskExecuter.java
Cannot solve field access TaskExecutionOutcome.UP_TO_DATE
Cannot solve field access TaskExecutionOutcome.EXECUTED
Cannot solve field access TaskExecutionOutcome.UP_TO_DATE
Cannot solve field access TaskExecutionOutcome.UP_TO_DATE
Cannot solve method call taskInputsListener.onExecute(task, Cast.cast(FileCollectionInternal.class, sourceFiles)) UnsolvedSymbolException{context='Method 'cast' with parameterTypes [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.internal.file.FileCollectionInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{org.gradle.api.file.FileCollection, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class Cast {

    /**
     * Casts the given object to the given type, providing a better error message than the default.
     *
     * The standard {@link Class#cast(Object)} method produces unsatisfactory error messages on some platforms
     * when it fails. All this method does is provide a better, consistent, error message.
     *
     * This should be used whenever there is a chance the cast could fail. If in doubt, use this.
     *
     * @param outputType The type to cast the input to
     * @param object The object to be cast
     * @param <O> The type to be cast to
     * @param <I> The type of the object to be vast
     * @return The input object, cast to the output type
     */
    public static <O, I> O cast(Class<O> outputType, I object) {
        try {
            return outputType.cast(object);
        } catch (ClassCastException e) {
            throw new ClassCastException(String.format("Failed to cast object %s of type %s to target type %s", object, object.getClass().getName(), outputType.getName()));
        }
    }

    @SuppressWarnings("unchecked")
    public static <T> T uncheckedCast(Object object) {
        return (T) object;
    }
}}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/execution/SkipEmptySourceFilesTaskExecuter.java
Cannot solve field access TaskExecutionOutcome.UP_TO_DATE
Cannot solve field access TaskExecutionOutcome.FROM_CACHE
Cannot solve field access TaskExecutionOutcome.UP_TO_DATE
Cannot solve field access TaskExecutionOutcome.EXECUTED
Cannot solve method call LOGGER.debug("Action stopped by some action with message: {}", e.getMessage()) java.lang.RuntimeException: Method 'getMessage' cannot be resolved in context e.getMessage() (line: 79) MethodCallExprContext{wrapped=e.getMessage()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/execution/ExecuteActionsTaskExecuter.java
Cannot solve method call LOGGER.info("Execution stopped by some action with message: {}", e.getMessage()) java.lang.RuntimeException: Method 'getMessage' cannot be resolved in context e.getMessage() (line: 81) MethodCallExprContext{wrapped=e.getMessage()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/execution/ExecuteActionsTaskExecuter.java
Cannot solve field access TaskExecutionOutcome.EXECUTED
Cannot solve field access TaskExecutionOutcome.UP_TO_DATE
Cannot solve field access TaskExecutionOutcome.SKIPPED
Cannot solve method call context.add(resolver.resolveTask(dependency.toString())) java.lang.RuntimeException: Method 'resolveTask' cannot be resolved in context resolver.resolveTask(dependency.toString()) (line: 108) MethodCallExprContext{wrapped=resolver.resolveTask(dependency.toString())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskDependency.java
Cannot solve method call addAllFirst(queue, toArray(iterable, Object.class)) java.lang.RuntimeException: Method 'toArray' cannot be resolved in context toArray(iterable, Object.class) (line: 92) MethodCallExprContext{wrapped=toArray(iterable, Object.class)}. Parameter types: [ReferenceType{Iterable, typeParametersMap=TypeParametersMap{nameToValue={empty.BlockDoc=WildcardUsage{type=null, boundedType=null}}}}, ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskDependency.java
Cannot resolve field access null
Cannot solve method call ensurePropertiesHaveNames(filePropertiesInternal) java.lang.UnsupportedOperationException /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskInputs.java
Cannot solve method call TaskFilePropertySnapshotNormalizationStrategy.valueOf(sensitivity) UnsolvedSymbolException{context='unknown', name='SnapshotNormalizationStrategy', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskInputs.java
Cannot solve method call withSnapshotNormalizationStrategy(TaskFilePropertySnapshotNormalizationStrategy.valueOf(sensitivity)) UnsolvedSymbolException{context='unknown', name='SnapshotNormalizationStrategy', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskInputs.java
Cannot solve method call DeprecationLogger.nagUserOfDiscontinuedMethod("chaining of the " + method, String.format("Please use the %s method on TaskInputs directly instead.", method)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskInputs.java
Method 'getTaskInputs' cannot be resolved in context getTaskInputs("getHasInputs()") (line: 326) MethodCallExprContext{wrapped=getTaskInputs("getHasInputs()")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getTaskInputs' cannot be resolved in context getTaskInputs("getFiles()") (line: 331) MethodCallExprContext{wrapped=getTaskInputs("getFiles()")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getTaskInputs' cannot be resolved in context getTaskInputs("files(Object...)") (line: 336) MethodCallExprContext{wrapped=getTaskInputs("files(Object...)")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getTaskInputs' cannot be resolved in context getTaskInputs("file(Object)") (line: 341) MethodCallExprContext{wrapped=getTaskInputs("file(Object)")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getTaskInputs' cannot be resolved in context getTaskInputs("dir(Object)") (line: 346) MethodCallExprContext{wrapped=getTaskInputs("dir(Object)")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getTaskInputs' cannot be resolved in context getTaskInputs("getProperties()") (line: 351) MethodCallExprContext{wrapped=getTaskInputs("getProperties()")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getTaskInputs' cannot be resolved in context getTaskInputs("property(String, Object)") (line: 356) MethodCallExprContext{wrapped=getTaskInputs("property(String, Object)")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getTaskInputs' cannot be resolved in context getTaskInputs("properties(Map)") (line: 361) MethodCallExprContext{wrapped=getTaskInputs("properties(Map)")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getTaskInputs' cannot be resolved in context getTaskInputs("getHasSourceFiles()") (line: 366) MethodCallExprContext{wrapped=getTaskInputs("getHasSourceFiles()")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getTaskInputs' cannot be resolved in context getTaskInputs("getSourceFiles()") (line: 371) MethodCallExprContext{wrapped=getTaskInputs("getSourceFiles()")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getTaskInputs' cannot be resolved in context getTaskInputs("source(Object...)") (line: 377) MethodCallExprContext{wrapped=getTaskInputs("source(Object...)")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getTaskInputs' cannot be resolved in context getTaskInputs("source(Object)") (line: 383) MethodCallExprContext{wrapped=getTaskInputs("source(Object)")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getTaskInputs' cannot be resolved in context getTaskInputs("sourceDir(Object)") (line: 389) MethodCallExprContext{wrapped=getTaskInputs("sourceDir(Object)")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot resolve field access null
Cannot solve method call ModelReference.of(TaskContainerInternal.MODEL_PATH, DEFAULT_TASK_CONTAINER_MODEL_TYPE) UnsolvedSymbolException{context='unknown', name='MODEL_PATH', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskContainerFactory.java
Cannot solve method call ChildNodeInitializerStrategyAccessors.of(NodeBackedModelMap.createUsingParentNode(new Transformer<NamedEntityInstantiator<Task>, MutableModelNode>() {

    @Override
    public NamedEntityInstantiator<Task> transform(MutableModelNode modelNode) {
        return modelNode.getPrivateData(DEFAULT_TASK_CONTAINER_MODEL_TYPE).getEntityInstantiator();
    }
})) UnsolvedSymbolException{context='Method 'createUsingParentNode' with parameterTypes [ReferenceType{org.gradle.api.Transformer, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.api.Transformer.IN=ReferenceType{org.gradle.model.internal.core.MutableModelNode, typeParametersMap=TypeParametersMap{nameToValue={}}}, org.gradle.api.Transformer.OUT=ReferenceType{org.gradle.model.internal.core.NamedEntityInstantiator, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.core.NamedEntityInstantiator.T=ReferenceType{org.gradle.api.Task, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=// TODO - mix Groovy DSL support in
public class NodeBackedModelMap<T> extends ModelMapGroovyView<T> implements ManagedInstance {

    private static final ElementFilter NO_PARENT = new ElementFilter(ModelType.UNTYPED) {

        @Override
        public boolean apply(MutableModelNode node) {
            return true;
        }

        @Override
        public boolean isSatisfiedBy(ModelType<?> element) {
            return true;
        }

        @Override
        public void validateCanBindAction(MutableModelNode node, ModelAction action) {
        }

        @Override
        public void validateCanCreateElement(ModelPath path, ModelType<?> type) {
        }
    };

    private final ModelType<T> elementType;

    private final ModelRuleDescriptor sourceDescriptor;

    private final MutableModelNode modelNode;

    private final ModelViewState viewState;

    private final ChildNodeInitializerStrategy<? super T> creatorStrategy;

    private final ElementFilter elementFilter;

    private final ModelType<?> publicType;

    // Note: used by generated subtypes
    public NodeBackedModelMap(ModelType<?> publicType, ModelType<T> elementType, ModelRuleDescriptor sourceDescriptor, MutableModelNode modelNode, ModelViewState viewState, ChildNodeInitializerStrategy<? super T> creatorStrategy) {
        this(publicType, elementType, sourceDescriptor, modelNode, viewState, NO_PARENT, creatorStrategy);
    }

    private NodeBackedModelMap(ModelType<?> publicType, ModelType<T> elementType, ModelRuleDescriptor sourceDescriptor, MutableModelNode modelNode, ModelViewState viewState, ElementFilter parentFilter, ChildNodeInitializerStrategy<? super T> creatorStrategy) {
        this.publicType = publicType;
        this.viewState = viewState;
        this.creatorStrategy = creatorStrategy;
        this.elementType = elementType;
        this.modelNode = modelNode;
        this.sourceDescriptor = sourceDescriptor;
        this.elementFilter = parentFilter.withType(elementType);
    }

    public static <T> ChildNodeInitializerStrategy<T> createUsingRegistry(final NodeInitializerRegistry nodeInitializerRegistry) {
        return new ChildNodeInitializerStrategy<T>() {

            @Override
            public <S extends T> NodeInitializer initializer(ModelType<S> type, Spec<ModelType<?>> constraints) {
                return nodeInitializerRegistry.getNodeInitializer(forExtensibleType(type, constraints));
            }
        };
    }

    public static <T> ChildNodeInitializerStrategy<T> createUsingParentNode(final ModelType<T> baseItemModelType) {
        return createUsingParentNode(new Transformer<NamedEntityInstantiator<T>, MutableModelNode>() {

            @Override
            public NamedEntityInstantiator<T> transform(MutableModelNode modelNode) {
                return modelNode.getPrivateData(instantiatorTypeOf(baseItemModelType));
            }
        });
    }

    public static <T> ChildNodeInitializerStrategy<T> createUsingParentNode(final Transformer<? extends NamedEntityInstantiator<T>, ? super MutableModelNode> instantiatorTransform) {
        return new ChildNodeInitializerStrategy<T>() {

            @Override
            public <S extends T> NodeInitializer initializer(final ModelType<S> type, Spec<ModelType<?>> constraints) {
                return new NodeInitializer() {

                    @Override
                    public Multimap<ModelActionRole, ModelAction> getActions(ModelReference<?> subject, ModelRuleDescriptor descriptor) {
                        return ImmutableSetMultimap.<ModelActionRole, ModelAction>builder().put(ModelActionRole.Discover, AddProjectionsAction.of(subject, descriptor, UnmanagedModelProjection.of(type), new ModelElementProjection(type))).put(ModelActionRole.Create, DirectNodeNoInputsModelAction.of(subject, descriptor, new Action<MutableModelNode>() {

                            @Override
                            public void execute(MutableModelNode modelNode) {
                                NamedEntityInstantiator<T> instantiator = instantiatorTransform.transform(modelNode.getParent());
                                S item = instantiator.create(modelNode.getPath().getName(), type.getConcreteClass());
                                modelNode.setPrivateData(type, item);
                            }
                        })).build();
                    }
                };
            }
        };
    }

    private static <I> ModelType<NamedEntityInstantiator<I>> instantiatorTypeOf(ModelType<I> type) {
        return new ModelType.Builder<NamedEntityInstantiator<I>>() {
        }.where(new ModelType.Parameter<I>() {
        }, type).build();
    }

    @Override
    public String getName() {
        return modelNode.getPath().getName();
    }

    @Override
    public MutableModelNode getBackingNode() {
        return modelNode;
    }

    @Override
    public ModelType<?> getManagedType() {
        return ModelType.of(this.getClass());
    }

    private <E> void mutateChildren(ModelActionRole role, ModelType<E> filterType, String operation, Action<? super E> configAction) {
        viewState.assertCanMutate();
        ModelRuleDescriptor descriptor = sourceDescriptor.append(operation);
        ModelReference<E> subject = ModelReference.of(filterType);
        modelNode.applyTo(allLinks(elementFilter.withType(filterType)), role, NoInputsModelAction.of(subject, descriptor, configAction));
    }

    private <E> void mutateChildren(ModelActionRole role, ModelType<E> filterType, DeferredModelAction configAction) {
        viewState.assertCanMutate();
        ModelReference<E> subject = ModelReference.of(filterType);
        modelNode.defineRulesFor(allLinks(elementFilter.withType(filterType)), role, new DeferredActionWrapper<E>(subject, role, configAction));
    }

    @Override
    public <S> void afterEach(Class<S> type, Action<? super S> configAction) {
        mutateChildren(ModelActionRole.Finalize, ModelType.of(type), "afterEach()", configAction);
    }

    // Called from transformed DSL rules
    public <S> void afterEach(Class<S> type, DeferredModelAction configAction) {
        mutateChildren(ModelActionRole.Finalize, ModelType.of(type), configAction);
    }

    @Override
    public void afterEach(Action<? super T> configAction) {
        mutateChildren(ModelActionRole.Finalize, elementType, "afterEach()", configAction);
    }

    // Called from transformed DSL rules
    public void afterEach(DeferredModelAction configAction) {
        mutateChildren(ModelActionRole.Finalize, elementType, configAction);
    }

    @Override
    public void all(Action<? super T> configAction) {
        mutateChildren(ModelActionRole.Mutate, elementType, "all()", configAction);
    }

    // Called from transformed DSL rules
    public void all(DeferredModelAction configAction) {
        mutateChildren(ModelActionRole.Initialize, elementType, configAction);
    }

    @Override
    public void beforeEach(Action<? super T> configAction) {
        mutateChildren(ModelActionRole.Defaults, elementType, "beforeEach()", configAction);
    }

    // Called from transformed DSL rules
    public void beforeEach(DeferredModelAction configAction) {
        mutateChildren(ModelActionRole.Defaults, elementType, configAction);
    }

    @Override
    public <S> void beforeEach(Class<S> type, Action<? super S> configAction) {
        mutateChildren(ModelActionRole.Defaults, ModelType.of(type), "beforeEach()", configAction);
    }

    // Called from transformed DSL rules
    public <S> void beforeEach(Class<S> type, DeferredModelAction configAction) {
        mutateChildren(ModelActionRole.Defaults, ModelType.of(type), configAction);
    }

    @Override
    public boolean containsKey(Object name) {
        if (!(name instanceof String)) {
            viewState.assertCanReadChildren();
            return false;
        }
        viewState.assertCanReadChild((String) name);
        return modelNode.hasLink((String) name, elementFilter);
    }

    @Override
    public boolean containsValue(Object item) {
        throw new UnsupportedOperationException("Not implemented yet.");
    }

    @Override
    public void create(final String name) {
        doCreate(name, elementType, (Action<? super T>) null);
    }

    @Override
    public void create(String name, Action<? super T> configAction) {
        doCreate(name, elementType, configAction);
    }

    // Called from transformed DSL rules
    public void create(String name, DeferredModelAction configAction) {
        doCreate(name, elementType, configAction);
    }

    @Override
    public <S extends T> void create(String name, Class<S> type) {
        doCreate(name, ModelType.of(type), (Action<? super T>) null);
    }

    @Override
    public <S extends T> void create(String name, Class<S> type, Action<? super S> configAction) {
        doCreate(name, ModelType.of(type), configAction);
    }

    // Called from transformed DSL rules
    public <S extends T> void create(String name, Class<S> type, DeferredModelAction configAction) {
        doCreate(name, ModelType.of(type), configAction);
    }

    @Override
    public void put(String name, T instance) {
        Class<T> type = Cast.uncheckedCast(instance.getClass());
        ModelRuleDescriptor descriptor = sourceDescriptor.append("put()");
        if (instance instanceof ManagedInstance) {
            ManagedInstance target = (ManagedInstance) instance;
            modelNode.addReference(name, target.getManagedType(), target.getBackingNode(), descriptor);
        } else {
            modelNode.addLink(ModelRegistrations.unmanagedInstance(ModelReference.of(modelNode.getPath().child(name), type), Factories.constant(instance)).descriptor(descriptor).build());
        }
    }

    private <S extends T> void doCreate(String name, ModelType<S> type, final DeferredModelAction action) {
        ModelPath childPath = modelNode.getPath().child(name);
        doCreate(childPath, type, action.getDescriptor(), DirectNodeNoInputsModelAction.of(ModelReference.of(childPath, type), action.getDescriptor(), new Action<MutableModelNode>() {

            @Override
            public void execute(MutableModelNode node) {
                action.execute(node, ModelActionRole.Initialize);
            }
        }));
    }

    private <S extends T> void doCreate(String name, ModelType<S> type, @Nullable Action<? super S> initAction) {
        ModelPath childPath = modelNode.getPath().child(name);
        ModelRuleDescriptor descriptor = sourceDescriptor.append("create(%s)", name);
        if (initAction != null) {
            doCreate(childPath, type, descriptor, NoInputsModelAction.of(ModelReference.of(childPath, type), descriptor, initAction));
        } else {
            doCreate(childPath, type, descriptor, null);
        }
    }

    private <S extends T> void doCreate(ModelPath childPath, ModelType<S> type, ModelRuleDescriptor descriptor, @Nullable ModelAction initAction) {
        viewState.assertCanMutate();
        elementFilter.validateCanCreateElement(childPath, type);
        NodeInitializer nodeInitializer = creatorStrategy.initializer(type, elementFilter);
        ModelRegistrations.Builder builder = ModelRegistrations.of(childPath, nodeInitializer).descriptor(descriptor);
        if (initAction != null) {
            builder.action(ModelActionRole.Initialize, initAction);
        }
        ModelRegistration registration = builder.build();
        modelNode.addLink(registration);
    }

    @Nullable
    @Override
    public T get(Object name) {
        return get((String) name);
    }

    @Nullable
    @Override
    public T get(String name) {
        // TODO - lock this down
        MutableModelNode link = modelNode.getLink(name);
        if (link == null) {
            return null;
        }
        viewState.assertCanReadChild(name);
        link.ensureUsable();
        if (!elementFilter.apply(link)) {
            return null;
        }
        if (viewState.isCanMutate()) {
            return link.asMutable(elementType, sourceDescriptor).getInstance();
        } else {
            return link.asImmutable(elementType, sourceDescriptor).getInstance();
        }
    }

    @Override
    public boolean isEmpty() {
        return size() == 0;
    }

    @Override
    public Set<String> keySet() {
        viewState.assertCanReadChildren();
        return ImmutableSet.copyOf(modelNode.getLinkNames(elementFilter));
    }

    @Override
    public int size() {
        viewState.assertCanReadChildren();
        return modelNode.getLinkCount(elementFilter);
    }

    @Override
    public void named(String name, Action<? super T> configAction) {
        viewState.assertCanMutate();
        ModelRuleDescriptor descriptor = sourceDescriptor.append("named(%s)", name);
        ModelReference<T> subject = ModelReference.of(modelNode.getPath().child(name), elementType);
        modelNode.applyToLink(ModelActionRole.Mutate, new FilteringActionWrapper<T>(elementFilter, subject, NoInputsModelAction.of(subject, descriptor, configAction)));
    }

    @Override
    public void named(String name, Class<? extends RuleSource> ruleSource) {
        viewState.assertCanMutate();
        ModelRuleDescriptor descriptor = sourceDescriptor.append("named(%s, %s)", name, ruleSource.getName());
        ModelReference<T> subject = ModelReference.of(modelNode.getPath().child(name), elementType);
        modelNode.defineRulesForLink(ModelActionRole.Defaults, new FilteringActionWrapper<T>(elementFilter, subject, DirectNodeNoInputsModelAction.of(subject, descriptor, new ApplyRuleSource(ruleSource))));
    }

    // Called from transformed DSL rules
    public void named(String name, final DeferredModelAction action) {
        viewState.assertCanMutate();
        ModelReference<T> subject = ModelReference.of(modelNode.getPath().child(name), elementType);
        modelNode.applyToLink(ModelActionRole.Initialize, new FilteringActionWrapper<T>(elementFilter, subject, new DeferredActionWrapper<T>(subject, ModelActionRole.Mutate, action)));
    }

    @Override
    public String getDisplayName() {
        return publicType.getDisplayName() + " '" + modelNode.getPath() + "'";
    }

    @Override
    public Collection<T> values() {
        Iterable<T> values = Iterables.transform(keySet(), new Function<String, T>() {

            public T apply(@Nullable String name) {
                return get(name);
            }
        });
        return Lists.newArrayList(values);
    }

    @Override
    public Iterator<T> iterator() {
        viewState.assertCanReadChildren();
        return Iterators.transform(keySet().iterator(), new Function<String, T>() {

            @Override
            public T apply(@Nullable String name) {
                return get(name);
            }
        });
    }

    @Override
    public <S> void withType(Class<S> type, Action<? super S> configAction) {
        mutateChildren(ModelActionRole.Mutate, ModelType.of(type), "withType()", configAction);
    }

    // Called from transformed DSL rules
    public <S> void withType(Class<S> type, DeferredModelAction configAction) {
        mutateChildren(ModelActionRole.Mutate, ModelType.of(type), configAction);
    }

    @Override
    public <S> void withType(Class<S> type, Class<? extends RuleSource> rules) {
        viewState.assertCanMutate();
        modelNode.applyTo(allLinks(elementFilter.withType(type)), rules);
    }

    @Override
    public <S> ModelMap<S> withType(Class<S> typeClass) {
        ModelType<S> type = ModelType.of(typeClass);
        return withType(type);
    }

    public <S> ModelMap<S> withType(ModelType<S> type) {
        if (type.equals(elementType)) {
            return uncheckedCast(this);
        }
        ChildNodeInitializerStrategy<S> creatorStrategy1 = uncheckedCast(this.creatorStrategy);
        return new NodeBackedModelMap<S>(publicType, type, sourceDescriptor, modelNode, viewState, elementFilter, creatorStrategy1);
    }

    @Override
    public Void methodMissing(String name, Object argsObj) {
        Object[] args = (Object[]) argsObj;
        if (args.length == 2 && args[0] instanceof Class<?> && args[1] instanceof DeferredModelAction) {
            // Called from transformed DSL rules
            Class<? extends T> itemType = uncheckedCast(args[0]);
            DeferredModelAction action = uncheckedCast(args[1]);
            doCreate(name, ModelType.of(itemType), action);
            return null;
        }
        if (args.length == 1 && args[0] instanceof DeferredModelAction) {
            // Called from transformed DSL rules
            DeferredModelAction action = uncheckedCast(args[0]);
            named(name, action);
            return null;
        }
        return super.methodMissing(name, argsObj);
    }

    private abstract static class ElementFilter implements Predicate<MutableModelNode>, Spec<ModelType<?>> {

        protected final ModelType<?> elementType;

        public ElementFilter(ModelType<?> elementType) {
            this.elementType = elementType;
        }

        public ElementFilter withType(Class<?> elementType) {
            return withType(ModelType.of(elementType));
        }

        public ElementFilter withType(ModelType<?> elementType) {
            if (this.elementType.equals(elementType)) {
                return this;
            } else {
                return new ChainedElementFilter(this, elementType);
            }
        }

        public abstract void validateCanBindAction(MutableModelNode node, ModelAction action);

        public abstract void validateCanCreateElement(ModelPath path, ModelType<?> type);
    }

    private static class ChainedElementFilter extends ElementFilter {

        private final ElementFilter parent;

        public ChainedElementFilter(ElementFilter parent, ModelType<?> elementType) {
            super(elementType);
            this.parent = parent;
        }

        @Override
        public boolean isSatisfiedBy(ModelType<?> element) {
            return elementType.isAssignableFrom(element) && parent.isSatisfiedBy(element);
        }

        @Override
        public boolean apply(MutableModelNode node) {
            node.ensureAtLeast(ModelNode.State.Discovered);
            return node.canBeViewedAs(elementType) && parent.apply(node);
        }

        @Override
        public void validateCanBindAction(MutableModelNode node, ModelAction action) {
            node.ensureAtLeast(ModelNode.State.Discovered);
            if (!node.canBeViewedAs(elementType)) {
                throw new InvalidModelRuleException(action.getDescriptor(), new ModelRuleBindingException(IncompatibleTypeReferenceReporter.of(node, elementType, action.getSubject().getDescription(), true).asString()));
            }
            parent.validateCanBindAction(node, action);
        }

        @Override
        public void validateCanCreateElement(ModelPath path, ModelType<?> type) {
            if (!elementType.isAssignableFrom(type)) {
                throw new IllegalArgumentException(String.format("Cannot create '%s' with type '%s' as this is not a subtype of '%s'.", path, type, elementType));
            }
            parent.validateCanCreateElement(path, type);
        }
    }

    private static class DeferredActionWrapper<T> extends AbstractModelAction<T> {

        private final ModelActionRole role;

        private final DeferredModelAction action;

        public DeferredActionWrapper(ModelReference<T> subject, ModelActionRole role, DeferredModelAction action) {
            super(subject, action.getDescriptor(), Collections.<ModelReference<?>>emptyList());
            this.role = role;
            this.action = action;
        }

        @Override
        public void execute(MutableModelNode node, List<ModelView<?>> inputs) {
            action.execute(node, role);
        }
    }

    private static class FilteringActionWrapper<T> extends AbstractModelAction<T> {

        private final ElementFilter elementFilter;

        private final ModelAction delegate;

        public FilteringActionWrapper(ElementFilter elementFilter, ModelReference<T> subject, ModelAction delegate) {
            super(subject, delegate.getDescriptor(), delegate.getInputs());
            this.elementFilter = elementFilter;
            this.delegate = delegate;
        }

        @Override
        public void execute(MutableModelNode modelNode, List<ModelView<?>> inputs) {
            elementFilter.validateCanBindAction(modelNode, delegate);
            delegate.execute(modelNode, inputs);
        }
    }

    private static class ApplyRuleSource implements Action<MutableModelNode> {

        private final ModelType<? extends RuleSource> rules;

        public ApplyRuleSource(Class<? extends RuleSource> rules) {
            this.rules = ModelType.of(rules);
        }

        @Override
        public void execute(MutableModelNode node) {
            node.applyToSelf(rules.getConcreteClass());
        }
    }
}}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskContainerFactory.java
Cannot solve method call ModelMapModelProjection.unmanaged(TASK_MODEL_TYPE, ChildNodeInitializerStrategyAccessors.of(NodeBackedModelMap.createUsingParentNode(new Transformer<NamedEntityInstantiator<Task>, MutableModelNode>() {

    @Override
    public NamedEntityInstantiator<Task> transform(MutableModelNode modelNode) {
        return modelNode.getPrivateData(DEFAULT_TASK_CONTAINER_MODEL_TYPE).getEntityInstantiator();
    }
}))) java.lang.RuntimeException: Error calculating the type of parameter NodeBackedModelMap.createUsingParentNode(new Transformer<NamedEntityInstantiator<Task>, MutableModelNode>() {

    @Override
    public NamedEntityInstantiator<Task> transform(MutableModelNode modelNode) {
        return modelNode.getPrivateData(DEFAULT_TASK_CONTAINER_MODEL_TYPE).getEntityInstantiator();
    }
}) of method call ChildNodeInitializerStrategyAccessors.of(NodeBackedModelMap.createUsingParentNode(new Transformer<NamedEntityInstantiator<Task>, MutableModelNode>() {

    @Override
    public NamedEntityInstantiator<Task> transform(MutableModelNode modelNode) {
        return modelNode.getPrivateData(DEFAULT_TASK_CONTAINER_MODEL_TYPE).getEntityInstantiator();
    }
})) /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskContainerFactory.java
Cannot solve method call registrationBuilder.withProjection(ModelMapModelProjection.unmanaged(TASK_MODEL_TYPE, ChildNodeInitializerStrategyAccessors.of(NodeBackedModelMap.createUsingParentNode(new Transformer<NamedEntityInstantiator<Task>, MutableModelNode>() {

    @Override
    public NamedEntityInstantiator<Task> transform(MutableModelNode modelNode) {
        return modelNode.getPrivateData(DEFAULT_TASK_CONTAINER_MODEL_TYPE).getEntityInstantiator();
    }
})))) java.lang.RuntimeException: Error calculating the type of parameter ChildNodeInitializerStrategyAccessors.of(NodeBackedModelMap.createUsingParentNode(new Transformer<NamedEntityInstantiator<Task>, MutableModelNode>() {

    @Override
    public NamedEntityInstantiator<Task> transform(MutableModelNode modelNode) {
        return modelNode.getPrivateData(DEFAULT_TASK_CONTAINER_MODEL_TYPE).getEntityInstantiator();
    }
})) of method call ModelMapModelProjection.unmanaged(TASK_MODEL_TYPE, ChildNodeInitializerStrategyAccessors.of(NodeBackedModelMap.createUsingParentNode(new Transformer<NamedEntityInstantiator<Task>, MutableModelNode>() {

    @Override
    public NamedEntityInstantiator<Task> transform(MutableModelNode modelNode) {
        return modelNode.getPrivateData(DEFAULT_TASK_CONTAINER_MODEL_TYPE).getEntityInstantiator();
    }
}))) /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskContainerFactory.java
Error calculating the type of parameter ModelMapModelProjection.unmanaged(TASK_MODEL_TYPE, ChildNodeInitializerStrategyAccessors.of(NodeBackedModelMap.createUsingParentNode(new Transformer<NamedEntityInstantiator<Task>, MutableModelNode>() {

    @Override
    public NamedEntityInstantiator<Task> transform(MutableModelNode modelNode) {
        return modelNode.getPrivateData(DEFAULT_TASK_CONTAINER_MODEL_TYPE).getEntityInstantiator();
    }
}))) of method call registrationBuilder.withProjection(ModelMapModelProjection.unmanaged(TASK_MODEL_TYPE, ChildNodeInitializerStrategyAccessors.of(NodeBackedModelMap.createUsingParentNode(new Transformer<NamedEntityInstantiator<Task>, MutableModelNode>() {

    @Override
    public NamedEntityInstantiator<Task> transform(MutableModelNode modelNode) {
        return modelNode.getPrivateData(DEFAULT_TASK_CONTAINER_MODEL_TYPE).getEntityInstantiator();
    }
}))))
Error calculating the type of parameter ModelMapModelProjection.unmanaged(TASK_MODEL_TYPE, ChildNodeInitializerStrategyAccessors.of(NodeBackedModelMap.createUsingParentNode(new Transformer<NamedEntityInstantiator<Task>, MutableModelNode>() {

    @Override
    public NamedEntityInstantiator<Task> transform(MutableModelNode modelNode) {
        return modelNode.getPrivateData(DEFAULT_TASK_CONTAINER_MODEL_TYPE).getEntityInstantiator();
    }
}))) of method call registrationBuilder.withProjection(ModelMapModelProjection.unmanaged(TASK_MODEL_TYPE, ChildNodeInitializerStrategyAccessors.of(NodeBackedModelMap.createUsingParentNode(new Transformer<NamedEntityInstantiator<Task>, MutableModelNode>() {

    @Override
    public NamedEntityInstantiator<Task> transform(MutableModelNode modelNode) {
        return modelNode.getPrivateData(DEFAULT_TASK_CONTAINER_MODEL_TYPE).getEntityInstantiator();
    }
}))))
Cannot solve method call modelRegistry.register(registrationBuilder.withProjection(ModelMapModelProjection.unmanaged(TASK_MODEL_TYPE, ChildNodeInitializerStrategyAccessors.of(NodeBackedModelMap.createUsingParentNode(new Transformer<NamedEntityInstantiator<Task>, MutableModelNode>() {

    @Override
    public NamedEntityInstantiator<Task> transform(MutableModelNode modelNode) {
        return modelNode.getPrivateData(DEFAULT_TASK_CONTAINER_MODEL_TYPE).getEntityInstantiator();
    }
})))).withProjection(UnmanagedModelProjection.of(TASK_CONTAINER_MODEL_TYPE)).build()) java.lang.RuntimeException: Error calculating the type of parameter ModelMapModelProjection.unmanaged(TASK_MODEL_TYPE, ChildNodeInitializerStrategyAccessors.of(NodeBackedModelMap.createUsingParentNode(new Transformer<NamedEntityInstantiator<Task>, MutableModelNode>() {

    @Override
    public NamedEntityInstantiator<Task> transform(MutableModelNode modelNode) {
        return modelNode.getPrivateData(DEFAULT_TASK_CONTAINER_MODEL_TYPE).getEntityInstantiator();
    }
}))) of method call registrationBuilder.withProjection(ModelMapModelProjection.unmanaged(TASK_MODEL_TYPE, ChildNodeInitializerStrategyAccessors.of(NodeBackedModelMap.createUsingParentNode(new Transformer<NamedEntityInstantiator<Task>, MutableModelNode>() {

    @Override
    public NamedEntityInstantiator<Task> transform(MutableModelNode modelNode) {
        return modelNode.getPrivateData(DEFAULT_TASK_CONTAINER_MODEL_TYPE).getEntityInstantiator();
    }
})))) /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskContainerFactory.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve field access ModelNode.State.Created
Cannot solve method call modelRegistry.atStateOrLater(TaskContainerInternal.MODEL_PATH, ModelNode.State.Created) UnsolvedSymbolException{context='unknown', name='MODEL_PATH', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskContainerFactory.java
Cannot solve field access ModelActionRole.Initialize
Cannot resolve field access null
Cannot solve method call modelNode.getParent().getPrivateData(TaskContainerInternal.MODEL_TYPE) UnsolvedSymbolException{context='unknown', name='MODEL_TYPE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskContainerFactory.java
Cannot resolve field access null
Cannot solve method call mutableModelNode.getPrivateData(TaskContainerInternal.MODEL_TYPE) UnsolvedSymbolException{context='unknown', name='MODEL_TYPE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/tasks/DefaultTaskContainerFactory.java
Cannot solve method call type.cast(constructor.newInstance(resolvedParameters)) java.lang.RuntimeException: Object[] java.lang.Object /repo/subprojects/core/src/main/java/org/gradle/api/internal/DependencyInjectingInstantiator.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call String.format("Too many parameters provided for constructor for class %s. Expected %s, received %s.", type.getName(), parameterTypes.length, parameters.length) java.lang.RuntimeException: Method 'getName' cannot be resolved in context type.getName() (line: 68) MethodCallExprContext{wrapped=type.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/DependencyInjectingInstantiator.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call String.format("Unexpected parameter provided for constructor for class %s.", type.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context type.getName() (line: 85) MethodCallExprContext{wrapped=type.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/DependencyInjectingInstantiator.java
Cannot solve method call isPackagePrivate(type.getModifiers()) java.lang.RuntimeException: Method 'getModifiers' cannot be resolved in context type.getModifiers() (line: 109) MethodCallExprContext{wrapped=type.getModifiers()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/DependencyInjectingInstantiator.java
Cannot solve method call String.format("Type %s is not a class.", type.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context type.getName() (line: 122) MethodCallExprContext{wrapped=type.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/DependencyInjectingInstantiator.java
Cannot solve method call Modifier.isStatic(type.getModifiers()) java.lang.RuntimeException: Method 'getModifiers' cannot be resolved in context type.getModifiers() (line: 124) MethodCallExprContext{wrapped=type.getModifiers()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/DependencyInjectingInstantiator.java
Cannot solve method call String.format("Class %s is a non-static inner class.", type.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context type.getName() (line: 125) MethodCallExprContext{wrapped=type.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/DependencyInjectingInstantiator.java
Cannot solve method call Modifier.isAbstract(type.getModifiers()) java.lang.RuntimeException: Method 'getModifiers' cannot be resolved in context type.getModifiers() (line: 127) MethodCallExprContext{wrapped=type.getModifiers()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/DependencyInjectingInstantiator.java
Cannot solve method call String.format("Class %s is an abstract class.", type.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context type.getName() (line: 128) MethodCallExprContext{wrapped=type.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/DependencyInjectingInstantiator.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call constructor.getAnnotation(Inject.class) UnsolvedSymbolException{context='unknown', name='Inject', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/DependencyInjectingInstantiator.java
Cannot solve method call String.format("Class %s has no constructor that is annotated with @Inject.", type.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context type.getName() (line: 150) MethodCallExprContext{wrapped=type.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/DependencyInjectingInstantiator.java
Cannot solve method call String.format("Class %s has multiple constructors that are annotated with @Inject.", type.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context type.getName() (line: 153) MethodCallExprContext{wrapped=type.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/DependencyInjectingInstantiator.java
Cannot solve method call setMetaClass(GroovySystem.getMetaClassRegistry().getMetaClass(DomNode.class), DomNode.class) UnsolvedSymbolException{context='Solving GroovySystem', name='GroovySystem', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/DomNode.java
Cannot resolve field access null
Cannot solve method call conventionMapping.map(property, mapping) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/api/internal/ConventionTask.java
Cannot solve method call conventionMapping.map(property, mapping) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/api/internal/ConventionTask.java
Cannot resolve field access null
Cannot solve method call String.format("Cannot create a %s named '%s' because this container " + "does not support creating elements by name alone. Please specify which subtype of %s to create. " + "Known subtypes are: %s", getTypeDisplayName(), name, getTypeDisplayName(), namedEntityInstantiator.getSupportedTypeNames()) java.lang.RuntimeException: Method 'getTypeDisplayName' cannot be resolved in context getTypeDisplayName() (line: 51) MethodCallExprContext{wrapped=getTypeDisplayName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/DefaultPolymorphicDomainObjectContainer.java
Cannot solve method call namedEntityInstantiator.create(name, getType()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context getType() (line: 46) MethodCallExprContext{wrapped=getType()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/DefaultPolymorphicDomainObjectContainer.java
Cannot solve method call Cast.uncheckedCast(getType()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context getType() (line: 63) MethodCallExprContext{wrapped=getType()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/DefaultPolymorphicDomainObjectContainer.java
Cannot solve method call registerFactory(castType, factory) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/api/internal/DefaultPolymorphicDomainObjectContainer.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call registerFactory(type, new NamedDomainObjectFactory<U>() {

    public U create(String name) {
        return factory.call(name);
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/api/internal/DefaultPolymorphicDomainObjectContainer.java
Method 'getInstantiator' cannot be resolved in context getInstantiator() (line: 84) MethodCallExprContext{wrapped=getInstantiator()}. Parameter types: []
Method 'getInstantiator' cannot be resolved in context getInstantiator() (line: 83) MethodCallExprContext{wrapped=getInstantiator()}. Parameter types: []
Cannot solve method call registerFactory(type, new NamedDomainObjectFactory<U>() {

    boolean named = Named.class.isAssignableFrom(implementationType);

    public U create(String name) {
        return named ? getInstantiator().newInstance(implementationType, name) : getInstantiator().newInstance(implementationType);
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/api/internal/DefaultPolymorphicDomainObjectContainer.java
Method 'getModule' cannot be resolved in context moduleRegistry.getModule("gradle-test-kit") (line: 65) MethodCallExprContext{wrapped=moduleRegistry.getModule("gradle-test-kit")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getExternalModule' cannot be resolved in context moduleRegistry.getExternalModule("groovy-all") (line: 69) MethodCallExprContext{wrapped=moduleRegistry.getExternalModule("groovy-all")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call Modifier.isPrivate(type.getModifiers()) java.lang.RuntimeException: Method 'getModifiers' cannot be resolved in context type.getModifiers() (line: 84) MethodCallExprContext{wrapped=type.getModifiers()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/AbstractClassGenerator.java
Cannot solve method call String.format("Cannot create a proxy class for private class '%s'.", type.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context type.getSimpleName() (line: 86) MethodCallExprContext{wrapped=type.getSimpleName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/AbstractClassGenerator.java
Cannot solve method call Modifier.isAbstract(type.getModifiers()) java.lang.RuntimeException: Method 'getModifiers' cannot be resolved in context type.getModifiers() (line: 88) MethodCallExprContext{wrapped=type.getModifiers()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/AbstractClassGenerator.java
Cannot solve method call String.format("Cannot create a proxy class for abstract class '%s'.", type.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context type.getSimpleName() (line: 90) MethodCallExprContext{wrapped=type.getSimpleName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/AbstractClassGenerator.java
Cannot solve method call String.format("Could not generate a proxy class for class %s.", type.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context type.getName() (line: 201) MethodCallExprContext{wrapped=type.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/AbstractClassGenerator.java
Cannot solve method call findClosureOverload(method, classMetaData.closureMethods.get(method.getName())) java.lang.RuntimeException: Method 'get' cannot be resolved in context classMetaData.closureMethods.get(method.getName()) (line: 225) MethodCallExprContext{wrapped=classMetaData.closureMethods.get(method.getName())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/AbstractClassGenerator.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call method.getAnnotation(Inject.class) UnsolvedSymbolException{context='unknown', name='Inject', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AbstractClassGenerator.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Method 'get' cannot be resolved in context getters.get(0) (line: 379) MethodCallExprContext{wrapped=getters.get(0)}. Parameter types: [PrimitiveTypeUsage{name='int'}]
Method 'get' cannot be resolved in context setters.get(0) (line: 381) MethodCallExprContext{wrapped=setters.get(0)}. Parameter types: [PrimitiveTypeUsage{name='int'}]
Cannot solve method call method.getAnnotation(Inject.class) UnsolvedSymbolException{context='unknown', name='Inject', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AbstractClassGenerator.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
No matching between ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{CharSequence, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual)
No matching between ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{CharSequence, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual)
Cannot resolve field access null
Cannot solve method call transformer.setResolveStrategy(Closure.DELEGATE_FIRST) UnsolvedSymbolException{context='unknown', name='DELEGATE_FIRST', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/ChainingTransformer.java
Cannot solve method call LOGGER.debug("Eager creation of script class loader for {}. This may result in performance issues.", scriptResource.getDisplayName()) java.lang.RuntimeException: Method 'getDisplayName' cannot be resolved in context scriptResource.getDisplayName() (line: 123) MethodCallExprContext{wrapped=scriptResource.getDisplayName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/initialization/DefaultScriptHandler.java
Cannot solve method call ownLoader.equals(clazz.getClassLoader()) java.lang.RuntimeException: Method 'getClassLoader' cannot be resolved in context clazz.getClassLoader() (line: 158) MethodCallExprContext{wrapped=clazz.getClassLoader()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/initialization/DefaultClassLoaderScope.java
Cannot solve field access Type.SCRIPT
Cannot solve field access Type.TEST_TASK_CLASSPATH
Cannot solve method call combinedHash.putBytes(hasher.hash(file).asBytes()) java.lang.RuntimeException: Method 'asBytes' cannot be resolved in context hasher.hash(file).asBytes() (line: 64) MethodCallExprContext{wrapped=hasher.hash(file).asBytes()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/initialization/loadercache/HashClassPathSnapshotter.java
Cannot solve method call hash(combinedHash, visitedFilePaths, visitedDirs, Iterators.forArray(file.listFiles())) UnsolvedSymbolException{context='Method 'forArray' with parameterTypes [ResolvedArrayType{ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterators}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/initialization/loadercache/HashClassPathSnapshotter.java
Cannot solve method call localClassLoader.equals(clazz.getClassLoader()) java.lang.RuntimeException: Method 'getClassLoader' cannot be resolved in context clazz.getClassLoader() (line: 50) MethodCallExprContext{wrapped=clazz.getClassLoader()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/initialization/RootClassLoaderScope.java
Cannot solve method call exportClassLoader.equals(clazz.getClassLoader()) java.lang.RuntimeException: Method 'getClassLoader' cannot be resolved in context clazz.getClassLoader() (line: 50) MethodCallExprContext{wrapped=clazz.getClassLoader()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/initialization/RootClassLoaderScope.java
Method 'getModule' cannot be resolved in context moduleRegistry.getModule("gradle-launcher") (line: 33) MethodCallExprContext{wrapped=moduleRegistry.getModule("gradle-launcher")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getModule' cannot be resolved in context moduleRegistry.getModule("gradle-installation-beacon") (line: 39) MethodCallExprContext{wrapped=moduleRegistry.getModule("gradle-installation-beacon")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getExternalModule' cannot be resolved in context moduleRegistry.getExternalModule("commons-cli") (line: 42) MethodCallExprContext{wrapped=moduleRegistry.getExternalModule("commons-cli")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getExternalModule' cannot be resolved in context moduleRegistry.getExternalModule("ant") (line: 46) MethodCallExprContext{wrapped=moduleRegistry.getExternalModule("ant")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call classpath.plus(moduleRegistry.getExternalModule("ant").getClasspath()) java.lang.RuntimeException: Method 'getExternalModule' cannot be resolved in context moduleRegistry.getExternalModule("ant") (line: 46) MethodCallExprContext{wrapped=moduleRegistry.getExternalModule("ant")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/DefaultClassPathProvider.java
Method 'getExternalModule' cannot be resolved in context moduleRegistry.getExternalModule("ant-launcher") (line: 47) MethodCallExprContext{wrapped=moduleRegistry.getExternalModule("ant-launcher")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call classpath.plus(moduleRegistry.getExternalModule("ant-launcher").getClasspath()) java.lang.RuntimeException: Method 'getExternalModule' cannot be resolved in context moduleRegistry.getExternalModule("ant-launcher") (line: 47) MethodCallExprContext{wrapped=moduleRegistry.getExternalModule("ant-launcher")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/DefaultClassPathProvider.java
Cannot solve method call Sets.newTreeSet(Lists.transform(candidateConfigurations, CONFIG_NAME)) UnsolvedSymbolException{context='Method 'transform' with parameterTypes [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{org.gradle.api.artifacts.Configuration, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{Function, typeParametersMap=TypeParametersMap{nameToValue={empty.Equivalence.Wrapper<Method>=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, empty.Method=ReferenceType{org.gradle.api.artifacts.Configuration, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Lists}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/artifacts/dependencies/DefaultProjectDependency.java
Cannot solve method call ClosureBackedAction.of(configureClosure) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/api/internal/artifacts/dependencies/AbstractModuleDependency.java
Cannot solve method call artifact(ClosureBackedAction.of(configureClosure)) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/api/internal/artifacts/dependencies/AbstractModuleDependency.java
Method 'candidate' cannot be resolved in context visitor.candidate("Maps with 'group' and/or 'module'") (line: 39) MethodCallExprContext{wrapped=visitor.candidate("Maps with 'group' and/or 'module'")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot resolve field access null
Cannot solve method call configureClosure.setResolveStrategy(Closure.DELEGATE_FIRST) UnsolvedSymbolException{context='unknown', name='DELEGATE_FIRST', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/artifacts/dsl/dependencies/ModuleFactoryDelegate.java
Cannot resolve field access null
Cannot solve field access DependencyFactory.ClassPathNotation.GRADLE_API
Cannot resolve field access null
Cannot solve field access DependencyFactory.ClassPathNotation.GRADLE_TEST_KIT
Cannot resolve field access null
Cannot solve field access DependencyFactory.ClassPathNotation.LOCAL_GROOVY
Cannot solve method call String.format("Not a registered component type: %s.", componentType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context componentType.getName() (line: 40) MethodCallExprContext{wrapped=componentType.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/component/DefaultComponentTypeRegistry.java
Cannot solve method call String.format("Artifact type %s is not registered for component type %s.", artifact.getName(), componentType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context artifact.getName() (line: 56) MethodCallExprContext{wrapped=artifact.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/component/DefaultComponentTypeRegistry.java
Cannot solve method call String.format("Artifact type %s is already registered for component type %s.", artifact.getName(), componentType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context artifact.getName() (line: 63) MethodCallExprContext{wrapped=artifact.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/component/DefaultComponentTypeRegistry.java
Empty name expression BeforeConvention
Empty name expression AfterConvention
Cannot solve method call setObjects(delegates.toArray(new DynamicObject[0])) java.lang.RuntimeException: org.gradle.internal.metaobject.DynamicObject[] T[] /repo/subprojects/core/src/main/java/org/gradle/api/internal/ExtensibleDynamicObject.java
Method 'getCollections' cannot be resolved in context getStore().getCollections() (line: 92) MethodCallExprContext{wrapped=getStore().getCollections()}. Parameter types: []
Cannot solve method call String.format("Cannot apply plugin of class '%s' to '%s' (class: %s) as it does not implement PluginAware", pluginClass.getName(), target.toString(), target.getClass().getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context pluginClass.getName() (line: 125) MethodCallExprContext{wrapped=pluginClass.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/plugins/DefaultObjectConfigurationAction.java
Cannot resolve field access null
Cannot solve method call types.add(clazz.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context clazz.getSimpleName() (line: 94) MethodCallExprContext{wrapped=clazz.getSimpleName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/plugins/ExtensionsStorage.java
Method 'getClass' cannot be resolved in context extension.getClass() (line: 122) MethodCallExprContext{wrapped=extension.getClass()}. Parameter types: []
Cannot solve method call Cast.uncheckedCast(Optional.of(withId)) UnsolvedSymbolException{context='Method 'of' with parameterTypes [ReferenceType{org.gradle.api.internal.plugins.PluginImplementation, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.api.internal.plugins.PluginImplementation.T=ReferenceType{CacheLoader, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=Optional}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/plugins/DefaultPluginRegistry.java
Cannot solve method call UncheckedException.throwAsUncheckedException(e.getCause()) UnsolvedSymbolException{context='unknown', name='UncheckedExecutionException', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/plugins/DefaultPluginRegistry.java
Method 'toType' cannot be resolved in context toType(object, DynamicObjectAware.class) (line: 49) MethodCallExprContext{wrapped=toType(object, DynamicObjectAware.class)}. Parameter types: [ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.internal.DynamicObjectAware, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'toType' cannot be resolved in context toType(object, HasConvention.class) (line: 56) MethodCallExprContext{wrapped=toType(object, HasConvention.class)}. Parameter types: [ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.internal.HasConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'toType' cannot be resolved in context toType(object, ExtensionAware.class) (line: 63) MethodCallExprContext{wrapped=toType(object, ExtensionAware.class)}. Parameter types: [ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.ExtensionAware, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'toType' cannot be resolved in context toType(object, IConventionAware.class) (line: 70) MethodCallExprContext{wrapped=toType(object, IConventionAware.class)}. Parameter types: [ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.internal.IConventionAware, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call String.format("Cannot create DslObject for '%s' (class: %s) as it does not implement '%s' (it is not a DSL object)", delegate, delegate.getClass().getSimpleName(), type.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context type.getName() (line: 88) MethodCallExprContext{wrapped=type.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/plugins/DslObject.java
Cannot solve field access Type.IMPERATIVE_CLASS
Cannot solve field access Type.HYBRID_IMPERATIVE_AND_RULES_CLASS
Cannot solve field access Type.PURE_RULE_SOURCE_CLASS
Cannot solve field access Type.UNKNOWN
Cannot solve method call String.format("Cannot apply model rules of plugin '%s' as the target '%s' is not model rule aware", clazz.getName(), target.toString()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context clazz.getName() (line: 39) MethodCallExprContext{wrapped=clazz.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/plugins/ImperativeOnlyPluginApplicator.java
Cannot solve method call String.format("Could not find any convention object of type %s.", type.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context type.getSimpleName() (line: 72) MethodCallExprContext{wrapped=type.getSimpleName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/plugins/DefaultConvention.java
Cannot solve method call values.add(type.cast(object)) java.lang.RuntimeException: Method 'cast' cannot be resolved in context type.cast(object) (line: 81) MethodCallExprContext{wrapped=type.cast(object)}. Parameter types: [ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/plugins/DefaultConvention.java
Cannot solve method call String.format("Found multiple convention objects of type %s.", type.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context type.getSimpleName() (line: 89) MethodCallExprContext{wrapped=type.getSimpleName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/plugins/DefaultConvention.java
Cannot solve method call properties.putAll(extensionsStorage.getAsMap()) java.lang.RuntimeException: Method 'getAsMap' cannot be resolved in context extensionsStorage.getAsMap() (line: 172) MethodCallExprContext{wrapped=extensionsStorage.getAsMap()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/plugins/DefaultConvention.java
Cannot solve method call result.result(extensionsStorage.configureExtension(name, args)) java.lang.RuntimeException: Method 'configureExtension' cannot be resolved in context extensionsStorage.configureExtension(name, args) (line: 215) MethodCallExprContext{wrapped=extensionsStorage.configureExtension(name, args)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ResolvedArrayType{ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/plugins/DefaultConvention.java
Cannot solve method call String.format("Could not create plugin of type '%s'.", type.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context type.getSimpleName() (line: 61) MethodCallExprContext{wrapped=type.getSimpleName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/plugins/DefaultPluginManager.java
Cannot solve method call addImperativePlugin(pluginRegistry.inspect(type)) java.lang.RuntimeException: Method 'inspect' cannot be resolved in context pluginRegistry.inspect(type) (line: 73) MethodCallExprContext{wrapped=pluginRegistry.inspect(type)}. Parameter types: [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=TypeVariable {org.gradle.api.internal.plugins.DefaultPluginManager.addImperativePlugin(Class<P>).P}}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/plugins/DefaultPluginManager.java
Cannot solve method call doApply(pluginRegistry.inspect(type)) java.lang.RuntimeException: Method 'inspect' cannot be resolved in context pluginRegistry.inspect(type) (line: 116) MethodCallExprContext{wrapped=pluginRegistry.inspect(type)}. Parameter types: [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=null, boundedType=null}}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/plugins/DefaultPluginManager.java
Cannot resolve field access null
Method 'getType' cannot be resolved in context plugin.getType() (line: 126) MethodCallExprContext{wrapped=plugin.getType()}. Parameter types: []
Cannot solve method call action.execute(pluginWithId.asAppliedPlugin()) java.lang.RuntimeException: Method 'asAppliedPlugin' cannot be resolved in context pluginWithId.asAppliedPlugin() (line: 213) MethodCallExprContext{wrapped=pluginWithId.asAppliedPlugin()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/plugins/DefaultPluginManager.java
Cannot resolve field access null
Cannot solve method call String.format("'%s' does not implement the Plugin interface.", type.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context type.getName() (line: 142) MethodCallExprContext{wrapped=type.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/plugins/DefaultPluginContainer.java
Method 'getEventRegister' cannot be resolved in context getEventRegister() (line: 48) MethodCallExprContext{wrapped=getEventRegister()}. Parameter types: []
Method 'getEventRegister' cannot be resolved in context getEventRegister() (line: 48) MethodCallExprContext{wrapped=getEventRegister()}. Parameter types: []
Method 'getEventRegister' cannot be resolved in context getEventRegister() (line: 59) MethodCallExprContext{wrapped=getEventRegister()}. Parameter types: []
Method 'getEventRegister' cannot be resolved in context getEventRegister() (line: 59) MethodCallExprContext{wrapped=getEventRegister()}. Parameter types: []
Method 'getEventRegister' cannot be resolved in context getEventRegister() (line: 83) MethodCallExprContext{wrapped=getEventRegister()}. Parameter types: []
Method 'getEventRegister' cannot be resolved in context getEventRegister() (line: 83) MethodCallExprContext{wrapped=getEventRegister()}. Parameter types: []
Method 'getEventRegister' cannot be resolved in context getEventRegister() (line: 85) MethodCallExprContext{wrapped=getEventRegister()}. Parameter types: []
Method 'getEventRegister' cannot be resolved in context getEventRegister() (line: 85) MethodCallExprContext{wrapped=getEventRegister()}. Parameter types: []
Method 'getEventRegister' cannot be resolved in context getEventRegister() (line: 95) MethodCallExprContext{wrapped=getEventRegister()}. Parameter types: []
Method 'getEventRegister' cannot be resolved in context getEventRegister() (line: 95) MethodCallExprContext{wrapped=getEventRegister()}. Parameter types: []
Method 'getEventRegister' cannot be resolved in context getEventRegister() (line: 183) MethodCallExprContext{wrapped=getEventRegister()}. Parameter types: []
Method 'getEventRegister' cannot be resolved in context getEventRegister() (line: 183) MethodCallExprContext{wrapped=getEventRegister()}. Parameter types: []
Method 'getEventRegister' cannot be resolved in context getEventRegister() (line: 190) MethodCallExprContext{wrapped=getEventRegister()}. Parameter types: []
Method 'getEventRegister' cannot be resolved in context getEventRegister() (line: 190) MethodCallExprContext{wrapped=getEventRegister()}. Parameter types: []
Method 'getEventRegister' cannot be resolved in context getEventRegister() (line: 199) MethodCallExprContext{wrapped=getEventRegister()}. Parameter types: []
Method 'getEventRegister' cannot be resolved in context getEventRegister() (line: 199) MethodCallExprContext{wrapped=getEventRegister()}. Parameter types: []
Method 'getEventRegister' cannot be resolved in context getEventRegister() (line: 201) MethodCallExprContext{wrapped=getEventRegister()}. Parameter types: []
Method 'getEventRegister' cannot be resolved in context getEventRegister() (line: 201) MethodCallExprContext{wrapped=getEventRegister()}. Parameter types: []
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Method 'getModule' cannot be resolved in context moduleRegistry.getModule("gradle-core") (line: 38) MethodCallExprContext{wrapped=moduleRegistry.getModule("gradle-core")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Error calculating the type of parameter Charsets.UTF_8 of method call Hashing.md5().hashString(DefaultHasher.class.getName(), Charsets.UTF_8)
Cannot solve name expression value
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression convention
Cannot solve name expression value
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression convention
Cannot solve name expression conventionAwareObject
Cannot solve name expression value
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call map(propertyName, new Value<Object>() {

    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {
        switch(value.getMaximumNumberOfParameters()) {
            case 0:
                return value.call();
            case 1:
                return value.call(convention);
            default:
                return value.call(convention, conventionAwareObject);
        }
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/api/internal/ConventionAwareHelper.java
Cannot solve method call map(propertyName, new Value<Object>() {

    public Object getValue(Convention convention, IConventionAware conventionAwareObject) {
        return uncheckedCall(value);
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/api/internal/ConventionAwareHelper.java
Cannot solve method call map(name, (Closure) value) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/api/internal/ConventionAwareHelper.java
Method 'trim' cannot be resolved in context classpathEntry.trim() (line: 74) MethodCallExprContext{wrapped=classpathEntry.trim()}. Parameter types: []
Method 'plus' cannot be resolved in context new EffectiveClassPath(classLoader).plus(additionalModuleClassPath) (line: 53) MethodCallExprContext{wrapped=new EffectiveClassPath(classLoader).plus(additionalModuleClassPath)}. Parameter types: [ReferenceType{org.gradle.internal.classpath.ClassPath, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call Pattern.compile(Pattern.quote(name) + "-\\d.+\\.jar") UnsolvedSymbolException{context='Method 'quote' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=java.util.regex.Pattern}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/classpath/DefaultModuleRegistry.java
Cannot resolve field access null
Method 'getFactory' cannot be resolved in context services.getFactory(org.gradle.internal.logging.LoggingManagerInternal.class) (line: 402) MethodCallExprContext{wrapped=services.getFactory(org.gradle.internal.logging.LoggingManagerInternal.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{LoggingManagerInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot resolve field access null
Cannot solve method call closure.setResolveStrategy(Closure.DELEGATE_FIRST) UnsolvedSymbolException{context='unknown', name='DELEGATE_FIRST', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/AbstractTask.java
Cannot solve method call String.format(" include %s", GUtil.toString(patternSet.getIncludes())) UnsolvedSymbolException{context='Method 'toString' with parameterTypes [ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public class GUtil {

    private static final Pattern WORD_SEPARATOR = Pattern.compile("\\W+");

    private static final Pattern UPPER_LOWER = Pattern.compile("(?m)([A-Z]*)([a-z0-9]*)");

    public static <T extends Collection> T flatten(Object[] elements, T addTo, boolean flattenMaps) {
        return flatten(asList(elements), addTo, flattenMaps);
    }

    public static <T extends Collection> T flatten(Object[] elements, T addTo) {
        return flatten(asList(elements), addTo);
    }

    public static <T extends Collection> T flatten(Collection elements, T addTo) {
        return flatten(elements, addTo, true);
    }

    public static <T extends Collection> T flattenElements(Object... elements) {
        Collection<T> out = new LinkedList<T>();
        flatten(elements, out, true);
        return (T) out;
    }

    public static <T extends Collection> T flatten(Collection elements, T addTo, boolean flattenMapsAndArrays) {
        return flatten(elements, addTo, flattenMapsAndArrays, flattenMapsAndArrays);
    }

    public static <T extends Collection> T flatten(Collection elements, T addTo, boolean flattenMaps, boolean flattenArrays) {
        Iterator iter = elements.iterator();
        while (iter.hasNext()) {
            Object element = iter.next();
            if (element instanceof Collection) {
                flatten((Collection) element, addTo, flattenMaps, flattenArrays);
            } else if ((element instanceof Map) && flattenMaps) {
                flatten(((Map) element).values(), addTo, flattenMaps, flattenArrays);
            } else if ((element.getClass().isArray()) && flattenArrays) {
                flatten(asList((Object[]) element), addTo, flattenMaps, flattenArrays);
            } else {
                addTo.add(element);
            }
        }
        return addTo;
    }

    /**
     * Flattens input collections (including arrays *but* not maps). If input is not a collection wraps it in a collection and returns it.
     *
     * @param input any object
     * @return collection of flattened input or single input wrapped in a collection.
     */
    public static Collection collectionize(Object input) {
        if (input == null) {
            return emptyList();
        } else if (input instanceof Collection) {
            Collection out = new LinkedList();
            flatten((Collection) input, out, false, true);
            return out;
        } else if (input.getClass().isArray()) {
            Collection out = new LinkedList();
            flatten(asList((Object[]) input), out, false, true);
            return out;
        } else {
            return asList(input);
        }
    }

    public static List flatten(Collection elements, boolean flattenMapsAndArrays) {
        return flatten(elements, new ArrayList(), flattenMapsAndArrays);
    }

    public static List flatten(Collection elements) {
        return flatten(elements, new ArrayList());
    }

    public static String asPath(Iterable<?> collection) {
        return CollectionUtils.join(File.pathSeparator, collection);
    }

    public static List<String> prefix(String prefix, Collection<String> strings) {
        List<String> prefixed = new ArrayList<String>();
        for (String string : strings) {
            prefixed.add(prefix + string);
        }
        return prefixed;
    }

    public static boolean isTrue(Object object) {
        if (object == null) {
            return false;
        }
        if (object instanceof Collection) {
            return ((Collection) object).size() > 0;
        } else if (object instanceof String) {
            return ((String) object).length() > 0;
        }
        return true;
    }

    public static <T> T elvis(T object, T defaultValue) {
        return isTrue(object) ? object : defaultValue;
    }

    public static <V, T extends Collection<? super V>> T addToCollection(T dest, boolean failOnNull, Iterable<? extends V>... srcs) {
        for (Iterable<? extends V> src : srcs) {
            for (V v : src) {
                if (failOnNull && v == null) {
                    throw new IllegalArgumentException("Illegal null value provided in this collection: " + src);
                }
                dest.add(v);
            }
        }
        return dest;
    }

    public static <V, T extends Collection<? super V>> T addToCollection(T dest, Iterable<? extends V>... srcs) {
        return addToCollection(dest, false, srcs);
    }

    public static Comparator<String> caseInsensitive() {
        return new Comparator<String>() {

            public int compare(String o1, String o2) {
                int diff = o1.compareToIgnoreCase(o2);
                if (diff != 0) {
                    return diff;
                }
                return o1.compareTo(o2);
            }
        };
    }

    public static Map addMaps(Map map1, Map map2) {
        HashMap map = new HashMap();
        map.putAll(map1);
        map.putAll(map2);
        return map;
    }

    public static void addToMap(Map<String, String> dest, Map<?, ?> src) {
        for (Map.Entry<?, ?> entry : src.entrySet()) {
            dest.put(entry.getKey().toString(), entry.getValue().toString());
        }
    }

    public static Properties loadProperties(File propertyFile) {
        try {
            FileInputStream inputStream = new FileInputStream(propertyFile);
            try {
                return loadProperties(inputStream);
            } finally {
                inputStream.close();
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static Properties loadProperties(URL url) {
        try {
            URLConnection uc = url.openConnection();
            uc.setUseCaches(false);
            return loadProperties(uc.getInputStream());
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static Properties loadProperties(InputStream inputStream) {
        Properties properties = new Properties();
        try {
            properties.load(inputStream);
            inputStream.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
        return properties;
    }

    public static void saveProperties(Properties properties, File propertyFile) {
        try {
            FileOutputStream propertiesFileOutputStream = new FileOutputStream(propertyFile);
            try {
                properties.store(propertiesFileOutputStream, null);
            } finally {
                propertiesFileOutputStream.close();
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static void saveProperties(Properties properties, OutputStream outputStream) {
        try {
            try {
                properties.store(outputStream, null);
            } finally {
                outputStream.close();
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static void savePropertiesNoDateComment(Properties properties, OutputStream outputStream) {
        saveProperties(properties, new LineBufferingOutputStream(new SkipFirstTextStream(new WriterTextStream(new OutputStreamWriter(outputStream, Charsets.ISO_8859_1)))));
    }

    public static Map map(Object... objects) {
        Map map = new HashMap();
        assert objects.length % 2 == 0;
        for (int i = 0; i < objects.length; i += 2) {
            map.put(objects[i], objects[i + 1]);
        }
        return map;
    }

    public static String toString(Iterable<?> names) {
        Formatter formatter = new Formatter();
        boolean first = true;
        for (Object name : names) {
            if (first) {
                formatter.format("'%s'", name);
                first = false;
            } else {
                formatter.format(", '%s'", name);
            }
        }
        return formatter.toString();
    }

    /**
     * Converts an arbitrary string to a camel-case string which can be used in a Java identifier. Eg, with_underscores -> withUnderscores
     */
    public static String toCamelCase(CharSequence string) {
        if (string == null) {
            return null;
        }
        StringBuilder builder = new StringBuilder();
        Matcher matcher = WORD_SEPARATOR.matcher(string);
        int pos = 0;
        while (matcher.find()) {
            builder.append(StringUtils.capitalize(string.subSequence(pos, matcher.start()).toString()));
            pos = matcher.end();
        }
        builder.append(StringUtils.capitalize(string.subSequence(pos, string.length()).toString()));
        return builder.toString();
    }

    public static String toLowerCamelCase(CharSequence string) {
        String camelCase = toCamelCase(string);
        if (camelCase == null) {
            return null;
        }
        if (camelCase.length() == 0) {
            return "";
        }
        return ((Character) camelCase.charAt(0)).toString().toLowerCase() + camelCase.subSequence(1, camelCase.length());
    }

    /**
     * Converts an arbitrary string to upper case identifier with words separated by _. Eg, camelCase -> CAMEL_CASE
     */
    public static String toConstant(CharSequence string) {
        if (string == null) {
            return null;
        }
        return toWords(string, '_').toUpperCase();
    }

    /**
     * Converts an arbitrary string to space-separated words. Eg, camelCase -> camel case, with_underscores -> with underscores
     */
    public static String toWords(CharSequence string) {
        return toWords(string, ' ');
    }

    public static String toWords(CharSequence string, char separator) {
        if (string == null) {
            return null;
        }
        StringBuilder builder = new StringBuilder();
        int pos = 0;
        Matcher matcher = UPPER_LOWER.matcher(string);
        while (pos < string.length()) {
            matcher.find(pos);
            if (matcher.end() == pos) {
                // Not looking at a match
                pos++;
                continue;
            }
            if (builder.length() > 0) {
                builder.append(separator);
            }
            String group1 = matcher.group(1).toLowerCase();
            String group2 = matcher.group(2);
            if (group2.length() == 0) {
                builder.append(group1);
            } else {
                if (group1.length() > 1) {
                    builder.append(group1.substring(0, group1.length() - 1));
                    builder.append(separator);
                    builder.append(group1.substring(group1.length() - 1));
                } else {
                    builder.append(group1);
                }
                builder.append(group2);
            }
            pos = matcher.end();
        }
        return builder.toString();
    }

    public static byte[] serialize(Object object) {
        StreamByteBuffer buffer = new StreamByteBuffer();
        serialize(object, buffer.getOutputStream());
        return buffer.readAsByteArray();
    }

    public static void serialize(Object object, OutputStream outputStream) {
        try {
            ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);
            objectOutputStream.writeObject(object);
            objectOutputStream.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static <T> Comparator<T> last(final Comparator<? super T> comparator, final T lastValue) {
        return new Comparator<T>() {

            public int compare(T o1, T o2) {
                boolean o1Last = comparator.compare(o1, lastValue) == 0;
                boolean o2Last = comparator.compare(o2, lastValue) == 0;
                if (o1Last && o2Last) {
                    return 0;
                }
                if (o1Last && !o2Last) {
                    return 1;
                }
                if (!o1Last && o2Last) {
                    return -1;
                }
                return comparator.compare(o1, o2);
            }
        };
    }

    /**
     * Calls the given callable converting any thrown exception to an unchecked exception via {@link UncheckedException#throwAsUncheckedException(Throwable)}
     *
     * @param callable The callable to call
     * @param <T> Callable's return type
     * @return The value returned by {@link Callable#call()}
     */
    public static <T> T uncheckedCall(Callable<T> callable) {
        try {
            return callable.call();
        } catch (Exception e) {
            throw UncheckedException.throwAsUncheckedException(e);
        }
    }
}}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/collections/DirectoryFileTree.java
Cannot solve method call String.format(" exclude %s", GUtil.toString(patternSet.getExcludes())) UnsolvedSymbolException{context='Method 'toString' with parameterTypes [ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public class GUtil {

    private static final Pattern WORD_SEPARATOR = Pattern.compile("\\W+");

    private static final Pattern UPPER_LOWER = Pattern.compile("(?m)([A-Z]*)([a-z0-9]*)");

    public static <T extends Collection> T flatten(Object[] elements, T addTo, boolean flattenMaps) {
        return flatten(asList(elements), addTo, flattenMaps);
    }

    public static <T extends Collection> T flatten(Object[] elements, T addTo) {
        return flatten(asList(elements), addTo);
    }

    public static <T extends Collection> T flatten(Collection elements, T addTo) {
        return flatten(elements, addTo, true);
    }

    public static <T extends Collection> T flattenElements(Object... elements) {
        Collection<T> out = new LinkedList<T>();
        flatten(elements, out, true);
        return (T) out;
    }

    public static <T extends Collection> T flatten(Collection elements, T addTo, boolean flattenMapsAndArrays) {
        return flatten(elements, addTo, flattenMapsAndArrays, flattenMapsAndArrays);
    }

    public static <T extends Collection> T flatten(Collection elements, T addTo, boolean flattenMaps, boolean flattenArrays) {
        Iterator iter = elements.iterator();
        while (iter.hasNext()) {
            Object element = iter.next();
            if (element instanceof Collection) {
                flatten((Collection) element, addTo, flattenMaps, flattenArrays);
            } else if ((element instanceof Map) && flattenMaps) {
                flatten(((Map) element).values(), addTo, flattenMaps, flattenArrays);
            } else if ((element.getClass().isArray()) && flattenArrays) {
                flatten(asList((Object[]) element), addTo, flattenMaps, flattenArrays);
            } else {
                addTo.add(element);
            }
        }
        return addTo;
    }

    /**
     * Flattens input collections (including arrays *but* not maps). If input is not a collection wraps it in a collection and returns it.
     *
     * @param input any object
     * @return collection of flattened input or single input wrapped in a collection.
     */
    public static Collection collectionize(Object input) {
        if (input == null) {
            return emptyList();
        } else if (input instanceof Collection) {
            Collection out = new LinkedList();
            flatten((Collection) input, out, false, true);
            return out;
        } else if (input.getClass().isArray()) {
            Collection out = new LinkedList();
            flatten(asList((Object[]) input), out, false, true);
            return out;
        } else {
            return asList(input);
        }
    }

    public static List flatten(Collection elements, boolean flattenMapsAndArrays) {
        return flatten(elements, new ArrayList(), flattenMapsAndArrays);
    }

    public static List flatten(Collection elements) {
        return flatten(elements, new ArrayList());
    }

    public static String asPath(Iterable<?> collection) {
        return CollectionUtils.join(File.pathSeparator, collection);
    }

    public static List<String> prefix(String prefix, Collection<String> strings) {
        List<String> prefixed = new ArrayList<String>();
        for (String string : strings) {
            prefixed.add(prefix + string);
        }
        return prefixed;
    }

    public static boolean isTrue(Object object) {
        if (object == null) {
            return false;
        }
        if (object instanceof Collection) {
            return ((Collection) object).size() > 0;
        } else if (object instanceof String) {
            return ((String) object).length() > 0;
        }
        return true;
    }

    public static <T> T elvis(T object, T defaultValue) {
        return isTrue(object) ? object : defaultValue;
    }

    public static <V, T extends Collection<? super V>> T addToCollection(T dest, boolean failOnNull, Iterable<? extends V>... srcs) {
        for (Iterable<? extends V> src : srcs) {
            for (V v : src) {
                if (failOnNull && v == null) {
                    throw new IllegalArgumentException("Illegal null value provided in this collection: " + src);
                }
                dest.add(v);
            }
        }
        return dest;
    }

    public static <V, T extends Collection<? super V>> T addToCollection(T dest, Iterable<? extends V>... srcs) {
        return addToCollection(dest, false, srcs);
    }

    public static Comparator<String> caseInsensitive() {
        return new Comparator<String>() {

            public int compare(String o1, String o2) {
                int diff = o1.compareToIgnoreCase(o2);
                if (diff != 0) {
                    return diff;
                }
                return o1.compareTo(o2);
            }
        };
    }

    public static Map addMaps(Map map1, Map map2) {
        HashMap map = new HashMap();
        map.putAll(map1);
        map.putAll(map2);
        return map;
    }

    public static void addToMap(Map<String, String> dest, Map<?, ?> src) {
        for (Map.Entry<?, ?> entry : src.entrySet()) {
            dest.put(entry.getKey().toString(), entry.getValue().toString());
        }
    }

    public static Properties loadProperties(File propertyFile) {
        try {
            FileInputStream inputStream = new FileInputStream(propertyFile);
            try {
                return loadProperties(inputStream);
            } finally {
                inputStream.close();
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static Properties loadProperties(URL url) {
        try {
            URLConnection uc = url.openConnection();
            uc.setUseCaches(false);
            return loadProperties(uc.getInputStream());
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static Properties loadProperties(InputStream inputStream) {
        Properties properties = new Properties();
        try {
            properties.load(inputStream);
            inputStream.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
        return properties;
    }

    public static void saveProperties(Properties properties, File propertyFile) {
        try {
            FileOutputStream propertiesFileOutputStream = new FileOutputStream(propertyFile);
            try {
                properties.store(propertiesFileOutputStream, null);
            } finally {
                propertiesFileOutputStream.close();
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static void saveProperties(Properties properties, OutputStream outputStream) {
        try {
            try {
                properties.store(outputStream, null);
            } finally {
                outputStream.close();
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static void savePropertiesNoDateComment(Properties properties, OutputStream outputStream) {
        saveProperties(properties, new LineBufferingOutputStream(new SkipFirstTextStream(new WriterTextStream(new OutputStreamWriter(outputStream, Charsets.ISO_8859_1)))));
    }

    public static Map map(Object... objects) {
        Map map = new HashMap();
        assert objects.length % 2 == 0;
        for (int i = 0; i < objects.length; i += 2) {
            map.put(objects[i], objects[i + 1]);
        }
        return map;
    }

    public static String toString(Iterable<?> names) {
        Formatter formatter = new Formatter();
        boolean first = true;
        for (Object name : names) {
            if (first) {
                formatter.format("'%s'", name);
                first = false;
            } else {
                formatter.format(", '%s'", name);
            }
        }
        return formatter.toString();
    }

    /**
     * Converts an arbitrary string to a camel-case string which can be used in a Java identifier. Eg, with_underscores -> withUnderscores
     */
    public static String toCamelCase(CharSequence string) {
        if (string == null) {
            return null;
        }
        StringBuilder builder = new StringBuilder();
        Matcher matcher = WORD_SEPARATOR.matcher(string);
        int pos = 0;
        while (matcher.find()) {
            builder.append(StringUtils.capitalize(string.subSequence(pos, matcher.start()).toString()));
            pos = matcher.end();
        }
        builder.append(StringUtils.capitalize(string.subSequence(pos, string.length()).toString()));
        return builder.toString();
    }

    public static String toLowerCamelCase(CharSequence string) {
        String camelCase = toCamelCase(string);
        if (camelCase == null) {
            return null;
        }
        if (camelCase.length() == 0) {
            return "";
        }
        return ((Character) camelCase.charAt(0)).toString().toLowerCase() + camelCase.subSequence(1, camelCase.length());
    }

    /**
     * Converts an arbitrary string to upper case identifier with words separated by _. Eg, camelCase -> CAMEL_CASE
     */
    public static String toConstant(CharSequence string) {
        if (string == null) {
            return null;
        }
        return toWords(string, '_').toUpperCase();
    }

    /**
     * Converts an arbitrary string to space-separated words. Eg, camelCase -> camel case, with_underscores -> with underscores
     */
    public static String toWords(CharSequence string) {
        return toWords(string, ' ');
    }

    public static String toWords(CharSequence string, char separator) {
        if (string == null) {
            return null;
        }
        StringBuilder builder = new StringBuilder();
        int pos = 0;
        Matcher matcher = UPPER_LOWER.matcher(string);
        while (pos < string.length()) {
            matcher.find(pos);
            if (matcher.end() == pos) {
                // Not looking at a match
                pos++;
                continue;
            }
            if (builder.length() > 0) {
                builder.append(separator);
            }
            String group1 = matcher.group(1).toLowerCase();
            String group2 = matcher.group(2);
            if (group2.length() == 0) {
                builder.append(group1);
            } else {
                if (group1.length() > 1) {
                    builder.append(group1.substring(0, group1.length() - 1));
                    builder.append(separator);
                    builder.append(group1.substring(group1.length() - 1));
                } else {
                    builder.append(group1);
                }
                builder.append(group2);
            }
            pos = matcher.end();
        }
        return builder.toString();
    }

    public static byte[] serialize(Object object) {
        StreamByteBuffer buffer = new StreamByteBuffer();
        serialize(object, buffer.getOutputStream());
        return buffer.readAsByteArray();
    }

    public static void serialize(Object object, OutputStream outputStream) {
        try {
            ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);
            objectOutputStream.writeObject(object);
            objectOutputStream.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static <T> Comparator<T> last(final Comparator<? super T> comparator, final T lastValue) {
        return new Comparator<T>() {

            public int compare(T o1, T o2) {
                boolean o1Last = comparator.compare(o1, lastValue) == 0;
                boolean o2Last = comparator.compare(o2, lastValue) == 0;
                if (o1Last && o2Last) {
                    return 0;
                }
                if (o1Last && !o2Last) {
                    return 1;
                }
                if (!o1Last && o2Last) {
                    return -1;
                }
                return comparator.compare(o1, o2);
            }
        };
    }

    /**
     * Calls the given callable converting any thrown exception to an unchecked exception via {@link UncheckedException#throwAsUncheckedException(Throwable)}
     *
     * @param callable The callable to call
     * @param <T> Callable's return type
     * @return The value returned by {@link Callable#call()}
     */
    public static <T> T uncheckedCall(Callable<T> callable) {
        try {
            return callable.call();
        } catch (Exception e) {
            throw UncheckedException.throwAsUncheckedException(e);
        }
    }
}}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/collections/DirectoryFileTree.java
Cannot solve method call String.format("files %s", GUtil.toString(files)) UnsolvedSymbolException{context='Method 'toString' with parameterTypes [ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public class GUtil {

    private static final Pattern WORD_SEPARATOR = Pattern.compile("\\W+");

    private static final Pattern UPPER_LOWER = Pattern.compile("(?m)([A-Z]*)([a-z0-9]*)");

    public static <T extends Collection> T flatten(Object[] elements, T addTo, boolean flattenMaps) {
        return flatten(asList(elements), addTo, flattenMaps);
    }

    public static <T extends Collection> T flatten(Object[] elements, T addTo) {
        return flatten(asList(elements), addTo);
    }

    public static <T extends Collection> T flatten(Collection elements, T addTo) {
        return flatten(elements, addTo, true);
    }

    public static <T extends Collection> T flattenElements(Object... elements) {
        Collection<T> out = new LinkedList<T>();
        flatten(elements, out, true);
        return (T) out;
    }

    public static <T extends Collection> T flatten(Collection elements, T addTo, boolean flattenMapsAndArrays) {
        return flatten(elements, addTo, flattenMapsAndArrays, flattenMapsAndArrays);
    }

    public static <T extends Collection> T flatten(Collection elements, T addTo, boolean flattenMaps, boolean flattenArrays) {
        Iterator iter = elements.iterator();
        while (iter.hasNext()) {
            Object element = iter.next();
            if (element instanceof Collection) {
                flatten((Collection) element, addTo, flattenMaps, flattenArrays);
            } else if ((element instanceof Map) && flattenMaps) {
                flatten(((Map) element).values(), addTo, flattenMaps, flattenArrays);
            } else if ((element.getClass().isArray()) && flattenArrays) {
                flatten(asList((Object[]) element), addTo, flattenMaps, flattenArrays);
            } else {
                addTo.add(element);
            }
        }
        return addTo;
    }

    /**
     * Flattens input collections (including arrays *but* not maps). If input is not a collection wraps it in a collection and returns it.
     *
     * @param input any object
     * @return collection of flattened input or single input wrapped in a collection.
     */
    public static Collection collectionize(Object input) {
        if (input == null) {
            return emptyList();
        } else if (input instanceof Collection) {
            Collection out = new LinkedList();
            flatten((Collection) input, out, false, true);
            return out;
        } else if (input.getClass().isArray()) {
            Collection out = new LinkedList();
            flatten(asList((Object[]) input), out, false, true);
            return out;
        } else {
            return asList(input);
        }
    }

    public static List flatten(Collection elements, boolean flattenMapsAndArrays) {
        return flatten(elements, new ArrayList(), flattenMapsAndArrays);
    }

    public static List flatten(Collection elements) {
        return flatten(elements, new ArrayList());
    }

    public static String asPath(Iterable<?> collection) {
        return CollectionUtils.join(File.pathSeparator, collection);
    }

    public static List<String> prefix(String prefix, Collection<String> strings) {
        List<String> prefixed = new ArrayList<String>();
        for (String string : strings) {
            prefixed.add(prefix + string);
        }
        return prefixed;
    }

    public static boolean isTrue(Object object) {
        if (object == null) {
            return false;
        }
        if (object instanceof Collection) {
            return ((Collection) object).size() > 0;
        } else if (object instanceof String) {
            return ((String) object).length() > 0;
        }
        return true;
    }

    public static <T> T elvis(T object, T defaultValue) {
        return isTrue(object) ? object : defaultValue;
    }

    public static <V, T extends Collection<? super V>> T addToCollection(T dest, boolean failOnNull, Iterable<? extends V>... srcs) {
        for (Iterable<? extends V> src : srcs) {
            for (V v : src) {
                if (failOnNull && v == null) {
                    throw new IllegalArgumentException("Illegal null value provided in this collection: " + src);
                }
                dest.add(v);
            }
        }
        return dest;
    }

    public static <V, T extends Collection<? super V>> T addToCollection(T dest, Iterable<? extends V>... srcs) {
        return addToCollection(dest, false, srcs);
    }

    public static Comparator<String> caseInsensitive() {
        return new Comparator<String>() {

            public int compare(String o1, String o2) {
                int diff = o1.compareToIgnoreCase(o2);
                if (diff != 0) {
                    return diff;
                }
                return o1.compareTo(o2);
            }
        };
    }

    public static Map addMaps(Map map1, Map map2) {
        HashMap map = new HashMap();
        map.putAll(map1);
        map.putAll(map2);
        return map;
    }

    public static void addToMap(Map<String, String> dest, Map<?, ?> src) {
        for (Map.Entry<?, ?> entry : src.entrySet()) {
            dest.put(entry.getKey().toString(), entry.getValue().toString());
        }
    }

    public static Properties loadProperties(File propertyFile) {
        try {
            FileInputStream inputStream = new FileInputStream(propertyFile);
            try {
                return loadProperties(inputStream);
            } finally {
                inputStream.close();
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static Properties loadProperties(URL url) {
        try {
            URLConnection uc = url.openConnection();
            uc.setUseCaches(false);
            return loadProperties(uc.getInputStream());
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static Properties loadProperties(InputStream inputStream) {
        Properties properties = new Properties();
        try {
            properties.load(inputStream);
            inputStream.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
        return properties;
    }

    public static void saveProperties(Properties properties, File propertyFile) {
        try {
            FileOutputStream propertiesFileOutputStream = new FileOutputStream(propertyFile);
            try {
                properties.store(propertiesFileOutputStream, null);
            } finally {
                propertiesFileOutputStream.close();
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static void saveProperties(Properties properties, OutputStream outputStream) {
        try {
            try {
                properties.store(outputStream, null);
            } finally {
                outputStream.close();
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static void savePropertiesNoDateComment(Properties properties, OutputStream outputStream) {
        saveProperties(properties, new LineBufferingOutputStream(new SkipFirstTextStream(new WriterTextStream(new OutputStreamWriter(outputStream, Charsets.ISO_8859_1)))));
    }

    public static Map map(Object... objects) {
        Map map = new HashMap();
        assert objects.length % 2 == 0;
        for (int i = 0; i < objects.length; i += 2) {
            map.put(objects[i], objects[i + 1]);
        }
        return map;
    }

    public static String toString(Iterable<?> names) {
        Formatter formatter = new Formatter();
        boolean first = true;
        for (Object name : names) {
            if (first) {
                formatter.format("'%s'", name);
                first = false;
            } else {
                formatter.format(", '%s'", name);
            }
        }
        return formatter.toString();
    }

    /**
     * Converts an arbitrary string to a camel-case string which can be used in a Java identifier. Eg, with_underscores -> withUnderscores
     */
    public static String toCamelCase(CharSequence string) {
        if (string == null) {
            return null;
        }
        StringBuilder builder = new StringBuilder();
        Matcher matcher = WORD_SEPARATOR.matcher(string);
        int pos = 0;
        while (matcher.find()) {
            builder.append(StringUtils.capitalize(string.subSequence(pos, matcher.start()).toString()));
            pos = matcher.end();
        }
        builder.append(StringUtils.capitalize(string.subSequence(pos, string.length()).toString()));
        return builder.toString();
    }

    public static String toLowerCamelCase(CharSequence string) {
        String camelCase = toCamelCase(string);
        if (camelCase == null) {
            return null;
        }
        if (camelCase.length() == 0) {
            return "";
        }
        return ((Character) camelCase.charAt(0)).toString().toLowerCase() + camelCase.subSequence(1, camelCase.length());
    }

    /**
     * Converts an arbitrary string to upper case identifier with words separated by _. Eg, camelCase -> CAMEL_CASE
     */
    public static String toConstant(CharSequence string) {
        if (string == null) {
            return null;
        }
        return toWords(string, '_').toUpperCase();
    }

    /**
     * Converts an arbitrary string to space-separated words. Eg, camelCase -> camel case, with_underscores -> with underscores
     */
    public static String toWords(CharSequence string) {
        return toWords(string, ' ');
    }

    public static String toWords(CharSequence string, char separator) {
        if (string == null) {
            return null;
        }
        StringBuilder builder = new StringBuilder();
        int pos = 0;
        Matcher matcher = UPPER_LOWER.matcher(string);
        while (pos < string.length()) {
            matcher.find(pos);
            if (matcher.end() == pos) {
                // Not looking at a match
                pos++;
                continue;
            }
            if (builder.length() > 0) {
                builder.append(separator);
            }
            String group1 = matcher.group(1).toLowerCase();
            String group2 = matcher.group(2);
            if (group2.length() == 0) {
                builder.append(group1);
            } else {
                if (group1.length() > 1) {
                    builder.append(group1.substring(0, group1.length() - 1));
                    builder.append(separator);
                    builder.append(group1.substring(group1.length() - 1));
                } else {
                    builder.append(group1);
                }
                builder.append(group2);
            }
            pos = matcher.end();
        }
        return builder.toString();
    }

    public static byte[] serialize(Object object) {
        StreamByteBuffer buffer = new StreamByteBuffer();
        serialize(object, buffer.getOutputStream());
        return buffer.readAsByteArray();
    }

    public static void serialize(Object object, OutputStream outputStream) {
        try {
            ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);
            objectOutputStream.writeObject(object);
            objectOutputStream.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static <T> Comparator<T> last(final Comparator<? super T> comparator, final T lastValue) {
        return new Comparator<T>() {

            public int compare(T o1, T o2) {
                boolean o1Last = comparator.compare(o1, lastValue) == 0;
                boolean o2Last = comparator.compare(o2, lastValue) == 0;
                if (o1Last && o2Last) {
                    return 0;
                }
                if (o1Last && !o2Last) {
                    return 1;
                }
                if (!o1Last && o2Last) {
                    return -1;
                }
                return comparator.compare(o1, o2);
            }
        };
    }

    /**
     * Calls the given callable converting any thrown exception to an unchecked exception via {@link UncheckedException#throwAsUncheckedException(Throwable)}
     *
     * @param callable The callable to call
     * @param <T> Callable's return type
     * @return The value returned by {@link Callable#call()}
     */
    public static <T> T uncheckedCall(Callable<T> callable) {
        try {
            return callable.call();
        } catch (Exception e) {
            throw UncheckedException.throwAsUncheckedException(e);
        }
    }
}}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/collections/ListBackedFileSet.java
Cannot resolve field access null
Cannot solve method call Files.walkFileTree(rootDir.toPath(), EnumSet.of(FileVisitOption.FOLLOW_LINKS), Integer.MAX_VALUE, new java.nio.file.FileVisitor<Path>() {

    @Override
    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
        FileVisitDetails details = getFileVisitDetails(dir, attrs, true);
        if (directoryDetailsHolder.size() == 0 || isAllowed(details, spec)) {
            directoryDetailsHolder.push(details);
            if (directoryDetailsHolder.size() > 1 && !postfix) {
                visitor.visitDir(details);
            }
            return checkStopFlag();
        } else {
            return FileVisitResult.SKIP_SUBTREE;
        }
    }

    private FileVisitResult checkStopFlag() {
        return stopFlag.get() ? FileVisitResult.TERMINATE : FileVisitResult.CONTINUE;
    }

    @Override
    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
        FileVisitDetails details = getFileVisitDetails(file, attrs, false);
        if (isAllowed(details, spec)) {
            if (attrs.isSymbolicLink()) {
                // when FileVisitOption.FOLLOW_LINKS, we only get here when link couldn't be followed
                throw new GradleException(String.format("Could not list contents of '%s'. Couldn't follow symbolic link.", file));
            }
            visitor.visitFile(details);
        }
        return checkStopFlag();
    }

    private FileVisitDetails getFileVisitDetails(Path file, BasicFileAttributes attrs, boolean isDirectory) {
        File child = file.toFile();
        FileVisitDetails dirDetails = directoryDetailsHolder.peek();
        RelativePath childPath = dirDetails != null ? dirDetails.getRelativePath().append(!isDirectory, child.getName()) : rootPath;
        return new DefaultFileVisitDetails(child, childPath, stopFlag, fileSystem, fileSystem, isDirectory, attrs.lastModifiedTime().toMillis(), attrs.size());
    }

    @Override
    public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
        if (exc != null && !(exc instanceof FileSystemLoopException)) {
            throw new GradleException(String.format("Could not read path '%s'.", file), exc);
        }
        return checkStopFlag();
    }

    @Override
    public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
        if (exc != null) {
            if (!(exc instanceof FileSystemLoopException)) {
                throw new GradleException(String.format("Could not read directory path '%s'.", dir), exc);
            }
        } else {
            if (postfix) {
                FileVisitDetails details = directoryDetailsHolder.peek();
                if (directoryDetailsHolder.size() > 1 && details != null) {
                    visitor.visitDir(details);
                }
            }
        }
        directoryDetailsHolder.pop();
        return checkStopFlag();
    }
}) UnsolvedSymbolException{context='unknown', name='MAX_VALUE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/collections/jdk7/Jdk7DirectoryWalker.java
Cannot resolve field access null
Cannot solve method call file.getAbsolutePath().substring(prefix.length()) java.lang.RuntimeException: Method 'length' cannot be resolved in context prefix.length() (line: 36) MethodCallExprContext{wrapped=prefix.length()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/collections/DirectoryTrees.java
Cannot solve method call RelativePath.parse(true, file.getAbsolutePath().substring(prefix.length())) java.lang.RuntimeException: Error calculating the type of parameter prefix.length() of method call file.getAbsolutePath().substring(prefix.length()) /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/collections/DirectoryTrees.java
Cannot solve method call Arrays.asList(includePattern.split("[/\\\\]")) java.lang.RuntimeException: Method 'split' cannot be resolved in context includePattern.split("[/\\\\]") (line: 62) MethodCallExprContext{wrapped=includePattern.split("[/\\\\]")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/collections/SingleIncludePatternFileTree.java
No matching between ReferenceType{Iterable, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual)
Cannot solve method call builder.add(baseDir, new PatternSet().include(includePattern).exclude(excludeSpec)) com.github.javaparser.symbolsolver.logic.ConfilictingGenericTypesException: No matching between ReferenceType{groovy.lang.Closure, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual) /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/collections/SingleIncludePatternFileTree.java
Cannot resolve field access null
Cannot solve method call result.add(Cast.cast(FileCollectionInternal.class, fileCollection)) UnsolvedSymbolException{context='Method 'cast' with parameterTypes [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.internal.file.FileCollectionInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{org.gradle.api.file.FileCollection, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class Cast {

    /**
     * Casts the given object to the given type, providing a better error message than the default.
     *
     * The standard {@link Class#cast(Object)} method produces unsatisfactory error messages on some platforms
     * when it fails. All this method does is provide a better, consistent, error message.
     *
     * This should be used whenever there is a chance the cast could fail. If in doubt, use this.
     *
     * @param outputType The type to cast the input to
     * @param object The object to be cast
     * @param <O> The type to be cast to
     * @param <I> The type of the object to be vast
     * @return The input object, cast to the output type
     */
    public static <O, I> O cast(Class<O> outputType, I object) {
        try {
            return outputType.cast(object);
        } catch (ClassCastException e) {
            throw new ClassCastException(String.format("Failed to cast object %s of type %s to target type %s", object, object.getClass().getName(), outputType.getName()));
        }
    }

    @SuppressWarnings("unchecked")
    public static <T> T uncheckedCast(Object object) {
        return (T) object;
    }
}}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/collections/DefaultFileCollectionResolveContext.java
Cannot solve method call result.add(Cast.cast(FileTreeInternal.class, fileTree)) UnsolvedSymbolException{context='Method 'cast' with parameterTypes [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.internal.file.FileTreeInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{org.gradle.api.file.FileTree, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class Cast {

    /**
     * Casts the given object to the given type, providing a better error message than the default.
     *
     * The standard {@link Class#cast(Object)} method produces unsatisfactory error messages on some platforms
     * when it fails. All this method does is provide a better, consistent, error message.
     *
     * This should be used whenever there is a chance the cast could fail. If in doubt, use this.
     *
     * @param outputType The type to cast the input to
     * @param object The object to be cast
     * @param <O> The type to be cast to
     * @param <I> The type of the object to be vast
     * @return The input object, cast to the output type
     */
    public static <O, I> O cast(Class<O> outputType, I object) {
        try {
            return outputType.cast(object);
        } catch (ClassCastException e) {
            throw new ClassCastException(String.format("Failed to cast object %s of type %s to target type %s", object, object.getClass().getName(), outputType.getName()));
        }
    }

    @SuppressWarnings("unchecked")
    public static <T> T uncheckedCast(Object object) {
        return (T) object;
    }
}}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/collections/DefaultFileCollectionResolveContext.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call candidate.regionMatches(!caseSensitive, candidate.length() - suffixLength, suffix, 0, suffixLength) java.lang.RuntimeException: Method 'length' cannot be resolved in context candidate.length() (line: 41) MethodCallExprContext{wrapped=candidate.length()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/pattern/HasSuffixPatternStep.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call dynamicObject.invokeMethod("gradleFileResource", ImmutableMap.of("file", file.getAbsolutePath(), "name", name)) UnsolvedSymbolException{context='Method 'of' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=ImmutableMap}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/AntFileTreeBuilder.java
Cannot solve method call Iterables.concat(files, Iterables.transform(trees, new Function<DirectoryTree, File>() {

    @Override
    public File apply(DirectoryTree input) {
        return input.getDir();
    }
})) UnsolvedSymbolException{context='Method 'transform' with parameterTypes [ReferenceType{ImmutableCollection, typeParametersMap=TypeParametersMap{nameToValue={empty.File=ReferenceType{org.gradle.api.internal.file.ImmutableDirectoryTree, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{Function, typeParametersMap=TypeParametersMap{nameToValue={empty.Equivalence.Wrapper<Method>=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}, empty.Method=ReferenceType{org.gradle.api.file.DirectoryTree, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/FileSystemSubset.java
Cannot solve method call FileUtils.calculateRoots(Iterables.concat(files, Iterables.transform(trees, new Function<DirectoryTree, File>() {

    @Override
    public File apply(DirectoryTree input) {
        return input.getDir();
    }
}))) java.lang.RuntimeException: Error calculating the type of parameter Iterables.transform(trees, new Function<DirectoryTree, File>() {

    @Override
    public File apply(DirectoryTree input) {
        return input.getDir();
    }
}) of method call Iterables.concat(files, Iterables.transform(trees, new Function<DirectoryTree, File>() {

    @Override
    public File apply(DirectoryTree input) {
        return input.getDir();
    }
})) /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/FileSystemSubset.java
Method 'append' cannot be resolved in context sb.append("Files: ") (line: 98) MethodCallExprContext{wrapped=sb.append("Files: ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context sb.append(" Trees: ") (line: 99) MethodCallExprContext{wrapped=sb.append(" Trees: ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot resolve field access null
Method 'matcher' cannot be resolved in context URI_SCHEME.matcher(original) (line: 56) MethodCallExprContext{wrapped=URI_SCHEME.matcher(original)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call Arrays.asList(StringUtils.split(baseDir.getAbsolutePath(), "/" + File.separator)) UnsolvedSymbolException{context='Method 'split' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=org.apache.commons.lang.StringUtils}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/BaseDirFileResolver.java
Cannot solve method call Arrays.asList(StringUtils.split(targetFile.getAbsolutePath(), "/" + File.separator)) UnsolvedSymbolException{context='Method 'split' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=org.apache.commons.lang.StringUtils}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/BaseDirFileResolver.java
Cannot solve method call Lists.newLinkedList(FluentIterable.from(fileTrees).filter(new Predicate<DirectoryFileTree>() {

    @Override
    public boolean apply(DirectoryFileTree input) {
        return input.getDir().exists();
    }
})) UnsolvedSymbolException{context='Solving FluentIterable', name='FluentIterable', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/AntFileCollectionMatchingTaskBuilder.java
Cannot solve method call dynamicObject.invokeMethod("and", new Closure<Void>(this) {

    public Object doCall(Object ignore) {
        dynamicObject.invokeMethod("gradleBaseDirSelector", Collections.singletonMap("baseDir", fileTree.getDir()));
        fileTree.getPatterns().addToAntBuilder(node, null);
        return null;
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/AntFileCollectionMatchingTaskBuilder.java
Cannot solve method call dynamicObject.invokeMethod("or", new Closure<Void>(this) {

    public Object doCall(Object ignore) {
        for (final DirectoryFileTree fileTree : existing) {
            dynamicObject.invokeMethod("and", new Closure<Void>(this) {

                public Object doCall(Object ignore) {
                    dynamicObject.invokeMethod("gradleBaseDirSelector", Collections.singletonMap("baseDir", fileTree.getDir()));
                    fileTree.getPatterns().addToAntBuilder(node, null);
                    return null;
                }
            });
        }
        return null;
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/AntFileCollectionMatchingTaskBuilder.java
Cannot resolve field access null
Cannot solve method call fileCollection.addToAntBuilder(builder, nodeName, AntType.ResourceCollection) UnsolvedSymbolException{context='unknown', name='ResourceCollection', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/CompositeFileCollection.java
Cannot solve field access State.NORMAL
Cannot solve field access State.EOF
Cannot solve field access State.SKIP_LINE
Cannot solve field access State.NORMAL
Cannot solve field access State.SKIP_LINE
Cannot solve field access State.NORMAL
Cannot solve field access State.EOF
Method 'getRelativePath' cannot be resolved in context details.getRelativePath() (line: 65) MethodCallExprContext{wrapped=details.getRelativePath()}. Parameter types: []
Cannot solve method call maybeVisit(details.getRelativePath().getParent(), details.isIncludeEmptyDirs(), action) java.lang.RuntimeException: Method 'getRelativePath' cannot be resolved in context details.getRelativePath() (line: 65) MethodCallExprContext{wrapped=details.getRelativePath()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/copy/NormalizingCopyActionDecorator.java
Cannot solve method call maybeVisit(path, details.isIncludeEmptyDirs(), action) java.lang.RuntimeException: Method 'isIncludeEmptyDirs' cannot be resolved in context details.isIncludeEmptyDirs() (line: 75) MethodCallExprContext{wrapped=details.isIncludeEmptyDirs()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/copy/NormalizingCopyActionDecorator.java
Method 'iterator' cannot be resolved in context patterns.iterator() (line: 268) MethodCallExprContext{wrapped=patterns.iterator()}. Parameter types: []
Cannot solve method call Specs.union(matchers.toArray(new Spec[matchers.size()])) java.lang.RuntimeException: org.gradle.api.specs.Spec[] T[] /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/copy/DefaultCopySpec.java
Method 'iterator' cannot be resolved in context patterns.iterator() (line: 285) MethodCallExprContext{wrapped=patterns.iterator()}. Parameter types: []
Cannot solve method call Specs.union(matchers.toArray(new Spec[matchers.size()])) java.lang.RuntimeException: org.gradle.api.specs.Spec[] T[] /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/copy/DefaultCopySpec.java
Method 'resolveFilesAsTree' cannot be resolved in context fileResolver.resolveFilesAsTree(sourcePaths) (line: 525) MethodCallExprContext{wrapped=fileResolver.resolveFilesAsTree(sourcePaths)}. Parameter types: [ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call fileResolver.compositeFileTree(builder.build()) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/copy/DefaultCopySpec.java
Cannot solve field access DuplicatesStrategy.INCLUDE
Method 'append' cannot be resolved in context path.append("$") (line: 718) MethodCallExprContext{wrapped=path.append("$")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'candidate' cannot be resolved in context visitor.candidate("String or CharSequence instances") (line: 32) MethodCallExprContext{wrapped=visitor.candidate("String or CharSequence instances")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'candidate' cannot be resolved in context visitor.candidate("Boolean values") (line: 33) MethodCallExprContext{wrapped=visitor.candidate("Boolean values")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'candidate' cannot be resolved in context visitor.candidate("Boolean values") (line: 33) MethodCallExprContext{wrapped=visitor.candidate("Boolean values")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'candidate' cannot be resolved in context visitor.candidate("Number values") (line: 34) MethodCallExprContext{wrapped=visitor.candidate("Number values")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'candidate' cannot be resolved in context visitor.candidate("Number values") (line: 34) MethodCallExprContext{wrapped=visitor.candidate("Number values")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot resolve field access null
Cannot resolve field access null
Cannot solve field access DuplicatesStrategy.EXCLUDE
Cannot solve field access DuplicatesStrategy.FAIL
Cannot solve field access DuplicatesStrategy.WARN
Method 'getDestPath' cannot be resolved in context specResolver.getDestPath() (line: 120) MethodCallExprContext{wrapped=specResolver.getDestPath()}. Parameter types: []
Cannot resolve field access null
Cannot solve method call visit(DefaultGroovyMethods.asType(closure, FileVisitor.class)) UnsolvedSymbolException{context='Method 'asType' with parameterTypes [ReferenceType{groovy.lang.Closure, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.file.FileVisitor, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=org.codehaus.groovy.runtime.DefaultGroovyMethods}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/AbstractFileTree.java
Cannot solve method call String.format("tar entry %s!%s", resource.getDisplayName(), entry.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context entry.getName() (line: 129) MethodCallExprContext{wrapped=entry.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/archive/TarFileTree.java
Method 'getModTime' cannot be resolved in context entry.getModTime() (line: 145) MethodCallExprContext{wrapped=entry.getModTime()}. Parameter types: []
Method 'getName' cannot be resolved in context entry.getName() (line: 168) MethodCallExprContext{wrapped=entry.getName()}. Parameter types: []
Cannot solve method call entriesByName.put(entry.getName(), entry) java.lang.RuntimeException: Method 'getName' cannot be resolved in context entry.getName() (line: 83) MethodCallExprContext{wrapped=entry.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/archive/ZipFileTree.java
Cannot solve method call String.format("zip entry %s!%s", zipFile, entry.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context entry.getName() (line: 120) MethodCallExprContext{wrapped=entry.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/archive/ZipFileTree.java
Method 'getName' cannot be resolved in context entry.getName() (line: 156) MethodCallExprContext{wrapped=entry.getName()}. Parameter types: []
Method 'getCause' cannot be resolved in context e.getCause() (line: 70) MethodCallExprContext{wrapped=e.getCause()}. Parameter types: []
Cannot solve method call String.format("%s\n\nTo build this archive, please enable the zip64 extension.\nSee: %s", e.getCause().getMessage(), documentationRegistry.getDslRefForProperty(Zip.class, "zip64")) java.lang.RuntimeException: Method 'getCause' cannot be resolved in context e.getCause() (line: 70) MethodCallExprContext{wrapped=e.getCause()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/archive/ZipCopyAction.java
Cannot solve method call archiveEntry.setUnixMode(UnixStat.FILE_FLAG | fileDetails.getMode()) UnsolvedSymbolException{context='unknown', name='FILE_FLAG', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/archive/ZipCopyAction.java
Cannot solve method call archiveEntry.setUnixMode(UnixStat.DIR_FLAG | dirDetails.getMode()) UnsolvedSymbolException{context='unknown', name='DIR_FLAG', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/archive/ZipCopyAction.java
Cannot resolve field access null
Cannot solve method call tarOutStr.setLongFileMode(TarOutputStream.LONGFILE_GNU) UnsolvedSymbolException{context='unknown', name='LONGFILE_GNU', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/archive/TarCopyAction.java
Cannot solve method call archiveEntry.setMode(UnixStat.FILE_FLAG | fileDetails.getMode()) UnsolvedSymbolException{context='unknown', name='FILE_FLAG', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/archive/TarCopyAction.java
Cannot solve method call archiveEntry.setMode(UnixStat.DIR_FLAG | dirDetails.getMode()) UnsolvedSymbolException{context='unknown', name='DIR_FLAG', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/archive/TarCopyAction.java
Cannot solve field access PathValidation.NONE
Cannot solve field access PathValidation.NONE
Empty name expression NONE
Empty name expression EXISTS
Empty name expression FILE
Empty name expression DIRECTORY
Cannot resolve field access null
Cannot solve method call Collections.singletonMap("file", AntUtil.maskFilename(file.getAbsolutePath())) UnsolvedSymbolException{context='Method 'maskFilename' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=public class AntUtil {

    /**
     * @return Factory method to create new Project instances
     */
    public static Project createProject() {
        final Project project = new Project();
        final ProjectHelper helper = ProjectHelper.getProjectHelper();
        project.addReference(ProjectHelper.PROJECTHELPER_REFERENCE, helper);
        // import checks that stack is not empty
        helper.getImportStack().addElement("AntBuilder");
        project.addBuildListener(new AntLoggingAdapter());
        project.init();
        project.getBaseDir();
        return project;
    }

    public static void execute(Task task) {
        task.setProject(createProject());
        task.execute();
    }

    /**
     * Masks a string against Ant property expansion.
     * This needs to be used when adding a File as String property
     * via {@link groovy.util.AntBuilder}.
     * @param string to mask
     * @return The masked String
     */
    public static String maskFilename(String string) {
        return string.replaceAll("\\$", "\\$\\$");
    }
}}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/AntFileCollectionBuilder.java
Cannot solve method call dynamicObject.invokeMethod("file", Collections.singletonMap("file", AntUtil.maskFilename(file.getAbsolutePath()))) java.lang.RuntimeException: Error calculating the type of parameter AntUtil.maskFilename(file.getAbsolutePath()) of method call Collections.singletonMap("file", AntUtil.maskFilename(file.getAbsolutePath())) /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/AntFileCollectionBuilder.java
Cannot solve method call Collections.singletonMap("dir", AntUtil.maskFilename(tree.getDir().getAbsolutePath())) UnsolvedSymbolException{context='Method 'maskFilename' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=public class AntUtil {

    /**
     * @return Factory method to create new Project instances
     */
    public static Project createProject() {
        final Project project = new Project();
        final ProjectHelper helper = ProjectHelper.getProjectHelper();
        project.addReference(ProjectHelper.PROJECTHELPER_REFERENCE, helper);
        // import checks that stack is not empty
        helper.getImportStack().addElement("AntBuilder");
        project.addBuildListener(new AntLoggingAdapter());
        project.init();
        project.getBaseDir();
        return project;
    }

    public static void execute(Task task) {
        task.setProject(createProject());
        task.execute();
    }

    /**
     * Masks a string against Ant property expansion.
     * This needs to be used when adding a File as String property
     * via {@link groovy.util.AntBuilder}.
     * @param string to mask
     * @return The masked String
     */
    public static String maskFilename(String string) {
        return string.replaceAll("\\$", "\\$\\$");
    }
}}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/AntFileSetBuilder.java
Cannot solve method call dynamicObject.invokeMethod(nodeName == null ? "fileset" : nodeName, Collections.singletonMap("dir", AntUtil.maskFilename(tree.getDir().getAbsolutePath())), new Closure<Void>(this) {

    public Object doCall(Object ignore) {
        return tree.getPatternSet().addToAntBuilder(node, null);
    }
}) java.lang.RuntimeException: Error calculating the type of parameter AntUtil.maskFilename(tree.getDir().getAbsolutePath()) of method call Collections.singletonMap("dir", AntUtil.maskFilename(tree.getDir().getAbsolutePath())) /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/AntFileSetBuilder.java
Object[] Object
Method 'candidate' cannot be resolved in context visitor.candidate("A String or CharSequence path") (line: 51) MethodCallExprContext{wrapped=visitor.candidate("A String or CharSequence path")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'candidate' cannot be resolved in context visitor.candidate("A String or CharSequence URI") (line: 52) MethodCallExprContext{wrapped=visitor.candidate("A String or CharSequence URI")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call uriDecode(notationString.substring(5)) java.lang.RuntimeException: Method 'substring' cannot be resolved in context notationString.substring(5) (line: 81) MethodCallExprContext{wrapped=notationString.substring(5)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/FileOrUriNotationConverter.java
Cannot solve method call normalisedStr.startsWith(rootPath.replace(File.separatorChar, '/')) java.lang.RuntimeException: Method 'replace' cannot be resolved in context rootPath.replace(File.separatorChar, '/') (line: 91) MethodCallExprContext{wrapped=rootPath.replace(File.separatorChar, '/')}. Parameter types: [PrimitiveTypeUsage{name='char'}, PrimitiveTypeUsage{name='char'}] /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/FileOrUriNotationConverter.java
Method 'matcher' cannot be resolved in context URI_SCHEME.matcher(notationString) (line: 97) MethodCallExprContext{wrapped=URI_SCHEME.matcher(notationString)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call matcher.appendReplacement(builder, String.valueOf((char) (Integer.parseInt(val, 16)))) UnsolvedSymbolException{context='Method 'valueOf' with parameterTypes [PrimitiveTypeUsage{name='char'}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/FileOrUriNotationConverter.java
Cannot solve method call sourceTrees.add(Cast.cast(FileTreeInternal.class, source)) UnsolvedSymbolException{context='Method 'cast' with parameterTypes [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.internal.file.FileTreeInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{org.gradle.api.file.FileCollection, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class Cast {

    /**
     * Casts the given object to the given type, providing a better error message than the default.
     *
     * The standard {@link Class#cast(Object)} method produces unsatisfactory error messages on some platforms
     * when it fails. All this method does is provide a better, consistent, error message.
     *
     * This should be used whenever there is a chance the cast could fail. If in doubt, use this.
     *
     * @param outputType The type to cast the input to
     * @param object The object to be cast
     * @param <O> The type to be cast to
     * @param <I> The type of the object to be vast
     * @return The input object, cast to the output type
     */
    public static <O, I> O cast(Class<O> outputType, I object) {
        try {
            return outputType.cast(object);
        } catch (ClassCastException e) {
            throw new ClassCastException(String.format("Failed to cast object %s of type %s to target type %s", object, object.getClass().getName(), outputType.getName()));
        }
    }

    @SuppressWarnings("unchecked")
    public static <T> T uncheckedCast(Object object) {
        return (T) object;
    }
}}'} /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/UnionFileTree.java
Cannot solve field access Compression.BZIP2
Cannot solve field access Compression.GZIP
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call addToAntBuilder(node, childNodeName, AntType.ResourceCollection) UnsolvedSymbolException{context='unknown', name='ResourceCollection', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/AbstractFileCollection.java
Cannot solve method call String.format("Cannot convert %s to type %s, as this type is not supported.", getDisplayName(), type.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context type.getSimpleName() (line: 178) MethodCallExprContext{wrapped=type.getSimpleName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/file/AbstractFileCollection.java
Cannot solve method call String.format("Cannot create a %s because this type is not known to %s. Known types are: %s", type.getSimpleName(), displayName, getSupportedTypeNames()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context type.getSimpleName() (line: 49) MethodCallExprContext{wrapped=type.getSimpleName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/DefaultPolymorphicNamedEntityInstantiator.java
Cannot solve method call names.add(clazz.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context clazz.getSimpleName() (line: 58) MethodCallExprContext{wrapped=clazz.getSimpleName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/DefaultPolymorphicNamedEntityInstantiator.java
Cannot solve method call String.format("Cannot register a factory for type %s because it is not a subtype of container element type %s.", type.getSimpleName(), baseType.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context type.getSimpleName() (line: 67) MethodCallExprContext{wrapped=type.getSimpleName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/DefaultPolymorphicNamedEntityInstantiator.java
Cannot solve method call String.format("Cannot register a factory for type %s because a factory for this type is already registered.", type.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context type.getSimpleName() (line: 71) MethodCallExprContext{wrapped=type.getSimpleName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/DefaultPolymorphicNamedEntityInstantiator.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call result.result(_container.create(name, (Class) params[0], ConfigureUtil.configureUsing((Closure) params[1]))) java.lang.RuntimeException: T ? super U /repo/subprojects/core/src/main/java/org/gradle/api/internal/PolymorphicDomainObjectContainerConfigureDelegate.java
Cannot solve method call LOG.debug("Removed ClassInfo from {} loaded by {}", clazz.getName(), clazz.getClassLoader()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context clazz.getName() (line: 77) MethodCallExprContext{wrapped=clazz.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/classloading/LeakyOnJava7GroovySystemLoader.java
Cannot solve method call LOG.debug("Removed ClassInfo from {} loaded by {}", clazz.getName(), clazz.getClassLoader()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context clazz.getName() (line: 101) MethodCallExprContext{wrapped=clazz.getName()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/internal/classloading/LeakyOnJava7GroovySystemLoader.java
Cannot resolve field access null
Method 'files' cannot be resolved in context getProject().files(copy) (line: 58) MethodCallExprContext{wrapped=getProject().files(copy)}. Parameter types: [ReferenceType{java.util.ArrayList, typeParametersMap=TypeParametersMap{nameToValue={java.util.ArrayList.E=ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Index: 0, Size: 0
Object[] Object
Cannot solve field access Compression.NONE
Cannot solve method call getConventionMapping().map("extension", new Callable<Object>() {

    public Object call() throws Exception {
        return getCompression().getDefaultExtension();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/api/tasks/bundling/Tar.java
Empty name expression BZIP2
Empty name expression GZIP
Cannot solve field access ZipEntryCompression.DEFLATED
Empty name expression DEFLATED
Cannot resolve field access null
Empty name expression STORED
Cannot resolve field access null
Cannot solve method call withNode.execute(getDelegate()) java.lang.RuntimeException: Method 'getDelegate' cannot be resolved in context getDelegate() (line: 48) MethodCallExprContext{wrapped=getDelegate()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/api/tasks/util/internal/PatternSetAntBuilderDelegate.java
Cannot solve method call Arrays.asList(DirectoryScanner.getDefaultExcludes()) UnsolvedSymbolException{context='Solving DirectoryScanner', name='DirectoryScanner', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/api/tasks/util/internal/PatternSpecFactory.java
Cannot solve method call Cast.uncheckedCast(specInstanceCache.get(key, new Callable<Spec<FileTreeElement>>() {

    @Override
    public Spec<FileTreeElement> call() throws Exception {
        Spec<FileTreeElement> spec = CachingPatternSpecFactory.super.createSpec(patterns, include, caseSensitive);
        return new CachingSpec(key, spec);
    }
})) java.lang.RuntimeException: Method 'get' cannot be resolved in context specInstanceCache.get(key, new Callable<Spec<FileTreeElement>>() {

    @Override
    public Spec<FileTreeElement> call() throws Exception {
        Spec<FileTreeElement> spec = CachingPatternSpecFactory.super.createSpec(patterns, include, caseSensitive);
        return new CachingSpec(key, spec);
    }
}) (line: 50) MethodCallExprContext{wrapped=specInstanceCache.get(key, new Callable<Spec<FileTreeElement>>() {

    @Override
    public Spec<FileTreeElement> call() throws Exception {
        Spec<FileTreeElement> spec = CachingPatternSpecFactory.super.createSpec(patterns, include, caseSensitive);
        return new CachingSpec(key, spec);
    }
})}. Parameter types: [ReferenceType{org.gradle.api.tasks.util.internal.CachingPatternSpecFactory.SpecKey, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.util.concurrent.Callable, typeParametersMap=TypeParametersMap{nameToValue={java.util.concurrent.Callable.V=ReferenceType{org.gradle.api.specs.Spec, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.api.specs.Spec.T=ReferenceType{org.gradle.api.file.FileTreeElement, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}}}] /repo/subprojects/core/src/main/java/org/gradle/api/tasks/util/internal/CachingPatternSpecFactory.java
Cannot solve field access PathSensitivity.RELATIVE
Method 'files' cannot be resolved in context getInputs().files(new Callable<FileTree>() {

    @Override
    public FileTree call() throws Exception {
        return resolver.getSource();
    }
}) (line: 68) MethodCallExprContext{wrapped=getInputs().files(new Callable<FileTree>() {

    @Override
    public FileTree call() throws Exception {
        return resolver.getSource();
    }
})}. Parameter types: [ReferenceType{java.util.concurrent.Callable, typeParametersMap=TypeParametersMap{nameToValue={java.util.concurrent.Callable.V=ReferenceType{org.gradle.api.file.FileTree, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'files' cannot be resolved in context getInputs().files(new Callable<FileTree>() {

    @Override
    public FileTree call() throws Exception {
        return resolver.getSource();
    }
}) (line: 68) MethodCallExprContext{wrapped=getInputs().files(new Callable<FileTree>() {

    @Override
    public FileTree call() throws Exception {
        return resolver.getSource();
    }
})}. Parameter types: [ReferenceType{java.util.concurrent.Callable, typeParametersMap=TypeParametersMap{nameToValue={java.util.concurrent.Callable.V=ReferenceType{org.gradle.api.file.FileTree, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'files' cannot be resolved in context getInputs().files(new Callable<FileTree>() {

    @Override
    public FileTree call() throws Exception {
        return resolver.getSource();
    }
}) (line: 68) MethodCallExprContext{wrapped=getInputs().files(new Callable<FileTree>() {

    @Override
    public FileTree call() throws Exception {
        return resolver.getSource();
    }
})}. Parameter types: [ReferenceType{java.util.concurrent.Callable, typeParametersMap=TypeParametersMap{nameToValue={java.util.concurrent.Callable.V=ReferenceType{org.gradle.api.file.FileTree, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getProject' cannot be resolved in context target.getProject() (line: 35) MethodCallExprContext{wrapped=target.getProject()}. Parameter types: []
Method 'getProject' cannot be resolved in context target.getProject() (line: 36) MethodCallExprContext{wrapped=target.getProject()}. Parameter types: []
Method 'getProject' cannot be resolved in context target.getProject() (line: 40) MethodCallExprContext{wrapped=target.getProject()}. Parameter types: []
Cannot solve method call setLifecycleLogLevel(AntMessagePriority.valueOf(logLevel)) UnsolvedSymbolException{context='Method 'valueOf' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserEnumDeclaration{wrappedNode=/**
 * Represents the normal Ant message priorities.
 */
public enum AntMessagePriority {

    DEBUG, VERBOSE, INFO, WARN, ERROR;

    public static AntMessagePriority from(int messagePriority) {
        switch(messagePriority) {
            case org.apache.tools.ant.Project.MSG_ERR:
                return ERROR;
            case org.apache.tools.ant.Project.MSG_WARN:
                return WARN;
            case org.apache.tools.ant.Project.MSG_INFO:
                return INFO;
            case org.apache.tools.ant.Project.MSG_VERBOSE:
                return VERBOSE;
            case org.apache.tools.ant.Project.MSG_DEBUG:
                return DEBUG;
            default:
                throw new IllegalArgumentException();
        }
    }
}}'} /repo/subprojects/core/src/main/java/org/gradle/api/AntBuilder.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Method 'matcher' cannot be resolved in context camelCasePattern.matcher(candidate) (line: 76) MethodCallExprContext{wrapped=camelCasePattern.matcher(candidate)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'matcher' cannot be resolved in context normalisedCamelCasePattern.matcher(candidate) (line: 80) MethodCallExprContext{wrapped=normalisedCamelCasePattern.matcher(candidate)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call StringUtils.getLevenshteinDistance(normalisedPattern, candidate.toUpperCase()) java.lang.RuntimeException: Method 'toUpperCase' cannot be resolved in context candidate.toUpperCase() (line: 84) MethodCallExprContext{wrapped=candidate.toUpperCase()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/util/NameMatcher.java
Cannot solve method call Math.min(3, pattern.length() / 2) java.lang.RuntimeException: Method 'length' cannot be resolved in context pattern.length() (line: 84) MethodCallExprContext{wrapped=pattern.length()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/util/NameMatcher.java
Cannot solve method call builder.append(Pattern.quote(prefix)) UnsolvedSymbolException{context='Method 'quote' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=java.util.regex.Pattern}'} /repo/subprojects/core/src/main/java/org/gradle/util/NameMatcher.java
Cannot solve method call name.substring(pos, name.length()) java.lang.RuntimeException: Method 'length' cannot be resolved in context name.length() (line: 118) MethodCallExprContext{wrapped=name.length()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/util/NameMatcher.java
Cannot solve method call Pattern.quote(name.substring(pos, name.length())) java.lang.RuntimeException: Error calculating the type of parameter name.length() of method call name.substring(pos, name.length()) /repo/subprojects/core/src/main/java/org/gradle/util/NameMatcher.java
Cannot solve method call builder.append(Pattern.quote(name.substring(pos, name.length()))) java.lang.RuntimeException: Error calculating the type of parameter name.substring(pos, name.length()) of method call Pattern.quote(name.substring(pos, name.length())) /repo/subprojects/core/src/main/java/org/gradle/util/NameMatcher.java
Cannot solve method call String.format("%s '%s' is ambiguous in %s. Candidates are: %s.", capItem, pattern, container, GUtil.toString(matches)) UnsolvedSymbolException{context='Method 'toString' with parameterTypes [ReferenceType{java.util.SortedSet, typeParametersMap=TypeParametersMap{nameToValue={java.util.SortedSet.E=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public class GUtil {

    private static final Pattern WORD_SEPARATOR = Pattern.compile("\\W+");

    private static final Pattern UPPER_LOWER = Pattern.compile("(?m)([A-Z]*)([a-z0-9]*)");

    public static <T extends Collection> T flatten(Object[] elements, T addTo, boolean flattenMaps) {
        return flatten(asList(elements), addTo, flattenMaps);
    }

    public static <T extends Collection> T flatten(Object[] elements, T addTo) {
        return flatten(asList(elements), addTo);
    }

    public static <T extends Collection> T flatten(Collection elements, T addTo) {
        return flatten(elements, addTo, true);
    }

    public static <T extends Collection> T flattenElements(Object... elements) {
        Collection<T> out = new LinkedList<T>();
        flatten(elements, out, true);
        return (T) out;
    }

    public static <T extends Collection> T flatten(Collection elements, T addTo, boolean flattenMapsAndArrays) {
        return flatten(elements, addTo, flattenMapsAndArrays, flattenMapsAndArrays);
    }

    public static <T extends Collection> T flatten(Collection elements, T addTo, boolean flattenMaps, boolean flattenArrays) {
        Iterator iter = elements.iterator();
        while (iter.hasNext()) {
            Object element = iter.next();
            if (element instanceof Collection) {
                flatten((Collection) element, addTo, flattenMaps, flattenArrays);
            } else if ((element instanceof Map) && flattenMaps) {
                flatten(((Map) element).values(), addTo, flattenMaps, flattenArrays);
            } else if ((element.getClass().isArray()) && flattenArrays) {
                flatten(asList((Object[]) element), addTo, flattenMaps, flattenArrays);
            } else {
                addTo.add(element);
            }
        }
        return addTo;
    }

    /**
     * Flattens input collections (including arrays *but* not maps). If input is not a collection wraps it in a collection and returns it.
     *
     * @param input any object
     * @return collection of flattened input or single input wrapped in a collection.
     */
    public static Collection collectionize(Object input) {
        if (input == null) {
            return emptyList();
        } else if (input instanceof Collection) {
            Collection out = new LinkedList();
            flatten((Collection) input, out, false, true);
            return out;
        } else if (input.getClass().isArray()) {
            Collection out = new LinkedList();
            flatten(asList((Object[]) input), out, false, true);
            return out;
        } else {
            return asList(input);
        }
    }

    public static List flatten(Collection elements, boolean flattenMapsAndArrays) {
        return flatten(elements, new ArrayList(), flattenMapsAndArrays);
    }

    public static List flatten(Collection elements) {
        return flatten(elements, new ArrayList());
    }

    public static String asPath(Iterable<?> collection) {
        return CollectionUtils.join(File.pathSeparator, collection);
    }

    public static List<String> prefix(String prefix, Collection<String> strings) {
        List<String> prefixed = new ArrayList<String>();
        for (String string : strings) {
            prefixed.add(prefix + string);
        }
        return prefixed;
    }

    public static boolean isTrue(Object object) {
        if (object == null) {
            return false;
        }
        if (object instanceof Collection) {
            return ((Collection) object).size() > 0;
        } else if (object instanceof String) {
            return ((String) object).length() > 0;
        }
        return true;
    }

    public static <T> T elvis(T object, T defaultValue) {
        return isTrue(object) ? object : defaultValue;
    }

    public static <V, T extends Collection<? super V>> T addToCollection(T dest, boolean failOnNull, Iterable<? extends V>... srcs) {
        for (Iterable<? extends V> src : srcs) {
            for (V v : src) {
                if (failOnNull && v == null) {
                    throw new IllegalArgumentException("Illegal null value provided in this collection: " + src);
                }
                dest.add(v);
            }
        }
        return dest;
    }

    public static <V, T extends Collection<? super V>> T addToCollection(T dest, Iterable<? extends V>... srcs) {
        return addToCollection(dest, false, srcs);
    }

    public static Comparator<String> caseInsensitive() {
        return new Comparator<String>() {

            public int compare(String o1, String o2) {
                int diff = o1.compareToIgnoreCase(o2);
                if (diff != 0) {
                    return diff;
                }
                return o1.compareTo(o2);
            }
        };
    }

    public static Map addMaps(Map map1, Map map2) {
        HashMap map = new HashMap();
        map.putAll(map1);
        map.putAll(map2);
        return map;
    }

    public static void addToMap(Map<String, String> dest, Map<?, ?> src) {
        for (Map.Entry<?, ?> entry : src.entrySet()) {
            dest.put(entry.getKey().toString(), entry.getValue().toString());
        }
    }

    public static Properties loadProperties(File propertyFile) {
        try {
            FileInputStream inputStream = new FileInputStream(propertyFile);
            try {
                return loadProperties(inputStream);
            } finally {
                inputStream.close();
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static Properties loadProperties(URL url) {
        try {
            URLConnection uc = url.openConnection();
            uc.setUseCaches(false);
            return loadProperties(uc.getInputStream());
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static Properties loadProperties(InputStream inputStream) {
        Properties properties = new Properties();
        try {
            properties.load(inputStream);
            inputStream.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
        return properties;
    }

    public static void saveProperties(Properties properties, File propertyFile) {
        try {
            FileOutputStream propertiesFileOutputStream = new FileOutputStream(propertyFile);
            try {
                properties.store(propertiesFileOutputStream, null);
            } finally {
                propertiesFileOutputStream.close();
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static void saveProperties(Properties properties, OutputStream outputStream) {
        try {
            try {
                properties.store(outputStream, null);
            } finally {
                outputStream.close();
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static void savePropertiesNoDateComment(Properties properties, OutputStream outputStream) {
        saveProperties(properties, new LineBufferingOutputStream(new SkipFirstTextStream(new WriterTextStream(new OutputStreamWriter(outputStream, Charsets.ISO_8859_1)))));
    }

    public static Map map(Object... objects) {
        Map map = new HashMap();
        assert objects.length % 2 == 0;
        for (int i = 0; i < objects.length; i += 2) {
            map.put(objects[i], objects[i + 1]);
        }
        return map;
    }

    public static String toString(Iterable<?> names) {
        Formatter formatter = new Formatter();
        boolean first = true;
        for (Object name : names) {
            if (first) {
                formatter.format("'%s'", name);
                first = false;
            } else {
                formatter.format(", '%s'", name);
            }
        }
        return formatter.toString();
    }

    /**
     * Converts an arbitrary string to a camel-case string which can be used in a Java identifier. Eg, with_underscores -> withUnderscores
     */
    public static String toCamelCase(CharSequence string) {
        if (string == null) {
            return null;
        }
        StringBuilder builder = new StringBuilder();
        Matcher matcher = WORD_SEPARATOR.matcher(string);
        int pos = 0;
        while (matcher.find()) {
            builder.append(StringUtils.capitalize(string.subSequence(pos, matcher.start()).toString()));
            pos = matcher.end();
        }
        builder.append(StringUtils.capitalize(string.subSequence(pos, string.length()).toString()));
        return builder.toString();
    }

    public static String toLowerCamelCase(CharSequence string) {
        String camelCase = toCamelCase(string);
        if (camelCase == null) {
            return null;
        }
        if (camelCase.length() == 0) {
            return "";
        }
        return ((Character) camelCase.charAt(0)).toString().toLowerCase() + camelCase.subSequence(1, camelCase.length());
    }

    /**
     * Converts an arbitrary string to upper case identifier with words separated by _. Eg, camelCase -> CAMEL_CASE
     */
    public static String toConstant(CharSequence string) {
        if (string == null) {
            return null;
        }
        return toWords(string, '_').toUpperCase();
    }

    /**
     * Converts an arbitrary string to space-separated words. Eg, camelCase -> camel case, with_underscores -> with underscores
     */
    public static String toWords(CharSequence string) {
        return toWords(string, ' ');
    }

    public static String toWords(CharSequence string, char separator) {
        if (string == null) {
            return null;
        }
        StringBuilder builder = new StringBuilder();
        int pos = 0;
        Matcher matcher = UPPER_LOWER.matcher(string);
        while (pos < string.length()) {
            matcher.find(pos);
            if (matcher.end() == pos) {
                // Not looking at a match
                pos++;
                continue;
            }
            if (builder.length() > 0) {
                builder.append(separator);
            }
            String group1 = matcher.group(1).toLowerCase();
            String group2 = matcher.group(2);
            if (group2.length() == 0) {
                builder.append(group1);
            } else {
                if (group1.length() > 1) {
                    builder.append(group1.substring(0, group1.length() - 1));
                    builder.append(separator);
                    builder.append(group1.substring(group1.length() - 1));
                } else {
                    builder.append(group1);
                }
                builder.append(group2);
            }
            pos = matcher.end();
        }
        return builder.toString();
    }

    public static byte[] serialize(Object object) {
        StreamByteBuffer buffer = new StreamByteBuffer();
        serialize(object, buffer.getOutputStream());
        return buffer.readAsByteArray();
    }

    public static void serialize(Object object, OutputStream outputStream) {
        try {
            ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);
            objectOutputStream.writeObject(object);
            objectOutputStream.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static <T> Comparator<T> last(final Comparator<? super T> comparator, final T lastValue) {
        return new Comparator<T>() {

            public int compare(T o1, T o2) {
                boolean o1Last = comparator.compare(o1, lastValue) == 0;
                boolean o2Last = comparator.compare(o2, lastValue) == 0;
                if (o1Last && o2Last) {
                    return 0;
                }
                if (o1Last && !o2Last) {
                    return 1;
                }
                if (!o1Last && o2Last) {
                    return -1;
                }
                return comparator.compare(o1, o2);
            }
        };
    }

    /**
     * Calls the given callable converting any thrown exception to an unchecked exception via {@link UncheckedException#throwAsUncheckedException(Throwable)}
     *
     * @param callable The callable to call
     * @param <T> Callable's return type
     * @return The value returned by {@link Callable#call()}
     */
    public static <T> T uncheckedCall(Callable<T> callable) {
        try {
            return callable.call();
        } catch (Exception e) {
            throw UncheckedException.throwAsUncheckedException(e);
        }
    }
}}'} /repo/subprojects/core/src/main/java/org/gradle/util/NameMatcher.java
Cannot solve method call String.format("%s '%s' not found in %s. Some candidates are: %s.", capItem, pattern, container, GUtil.toString(candidates)) UnsolvedSymbolException{context='Method 'toString' with parameterTypes [ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public class GUtil {

    private static final Pattern WORD_SEPARATOR = Pattern.compile("\\W+");

    private static final Pattern UPPER_LOWER = Pattern.compile("(?m)([A-Z]*)([a-z0-9]*)");

    public static <T extends Collection> T flatten(Object[] elements, T addTo, boolean flattenMaps) {
        return flatten(asList(elements), addTo, flattenMaps);
    }

    public static <T extends Collection> T flatten(Object[] elements, T addTo) {
        return flatten(asList(elements), addTo);
    }

    public static <T extends Collection> T flatten(Collection elements, T addTo) {
        return flatten(elements, addTo, true);
    }

    public static <T extends Collection> T flattenElements(Object... elements) {
        Collection<T> out = new LinkedList<T>();
        flatten(elements, out, true);
        return (T) out;
    }

    public static <T extends Collection> T flatten(Collection elements, T addTo, boolean flattenMapsAndArrays) {
        return flatten(elements, addTo, flattenMapsAndArrays, flattenMapsAndArrays);
    }

    public static <T extends Collection> T flatten(Collection elements, T addTo, boolean flattenMaps, boolean flattenArrays) {
        Iterator iter = elements.iterator();
        while (iter.hasNext()) {
            Object element = iter.next();
            if (element instanceof Collection) {
                flatten((Collection) element, addTo, flattenMaps, flattenArrays);
            } else if ((element instanceof Map) && flattenMaps) {
                flatten(((Map) element).values(), addTo, flattenMaps, flattenArrays);
            } else if ((element.getClass().isArray()) && flattenArrays) {
                flatten(asList((Object[]) element), addTo, flattenMaps, flattenArrays);
            } else {
                addTo.add(element);
            }
        }
        return addTo;
    }

    /**
     * Flattens input collections (including arrays *but* not maps). If input is not a collection wraps it in a collection and returns it.
     *
     * @param input any object
     * @return collection of flattened input or single input wrapped in a collection.
     */
    public static Collection collectionize(Object input) {
        if (input == null) {
            return emptyList();
        } else if (input instanceof Collection) {
            Collection out = new LinkedList();
            flatten((Collection) input, out, false, true);
            return out;
        } else if (input.getClass().isArray()) {
            Collection out = new LinkedList();
            flatten(asList((Object[]) input), out, false, true);
            return out;
        } else {
            return asList(input);
        }
    }

    public static List flatten(Collection elements, boolean flattenMapsAndArrays) {
        return flatten(elements, new ArrayList(), flattenMapsAndArrays);
    }

    public static List flatten(Collection elements) {
        return flatten(elements, new ArrayList());
    }

    public static String asPath(Iterable<?> collection) {
        return CollectionUtils.join(File.pathSeparator, collection);
    }

    public static List<String> prefix(String prefix, Collection<String> strings) {
        List<String> prefixed = new ArrayList<String>();
        for (String string : strings) {
            prefixed.add(prefix + string);
        }
        return prefixed;
    }

    public static boolean isTrue(Object object) {
        if (object == null) {
            return false;
        }
        if (object instanceof Collection) {
            return ((Collection) object).size() > 0;
        } else if (object instanceof String) {
            return ((String) object).length() > 0;
        }
        return true;
    }

    public static <T> T elvis(T object, T defaultValue) {
        return isTrue(object) ? object : defaultValue;
    }

    public static <V, T extends Collection<? super V>> T addToCollection(T dest, boolean failOnNull, Iterable<? extends V>... srcs) {
        for (Iterable<? extends V> src : srcs) {
            for (V v : src) {
                if (failOnNull && v == null) {
                    throw new IllegalArgumentException("Illegal null value provided in this collection: " + src);
                }
                dest.add(v);
            }
        }
        return dest;
    }

    public static <V, T extends Collection<? super V>> T addToCollection(T dest, Iterable<? extends V>... srcs) {
        return addToCollection(dest, false, srcs);
    }

    public static Comparator<String> caseInsensitive() {
        return new Comparator<String>() {

            public int compare(String o1, String o2) {
                int diff = o1.compareToIgnoreCase(o2);
                if (diff != 0) {
                    return diff;
                }
                return o1.compareTo(o2);
            }
        };
    }

    public static Map addMaps(Map map1, Map map2) {
        HashMap map = new HashMap();
        map.putAll(map1);
        map.putAll(map2);
        return map;
    }

    public static void addToMap(Map<String, String> dest, Map<?, ?> src) {
        for (Map.Entry<?, ?> entry : src.entrySet()) {
            dest.put(entry.getKey().toString(), entry.getValue().toString());
        }
    }

    public static Properties loadProperties(File propertyFile) {
        try {
            FileInputStream inputStream = new FileInputStream(propertyFile);
            try {
                return loadProperties(inputStream);
            } finally {
                inputStream.close();
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static Properties loadProperties(URL url) {
        try {
            URLConnection uc = url.openConnection();
            uc.setUseCaches(false);
            return loadProperties(uc.getInputStream());
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static Properties loadProperties(InputStream inputStream) {
        Properties properties = new Properties();
        try {
            properties.load(inputStream);
            inputStream.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
        return properties;
    }

    public static void saveProperties(Properties properties, File propertyFile) {
        try {
            FileOutputStream propertiesFileOutputStream = new FileOutputStream(propertyFile);
            try {
                properties.store(propertiesFileOutputStream, null);
            } finally {
                propertiesFileOutputStream.close();
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static void saveProperties(Properties properties, OutputStream outputStream) {
        try {
            try {
                properties.store(outputStream, null);
            } finally {
                outputStream.close();
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static void savePropertiesNoDateComment(Properties properties, OutputStream outputStream) {
        saveProperties(properties, new LineBufferingOutputStream(new SkipFirstTextStream(new WriterTextStream(new OutputStreamWriter(outputStream, Charsets.ISO_8859_1)))));
    }

    public static Map map(Object... objects) {
        Map map = new HashMap();
        assert objects.length % 2 == 0;
        for (int i = 0; i < objects.length; i += 2) {
            map.put(objects[i], objects[i + 1]);
        }
        return map;
    }

    public static String toString(Iterable<?> names) {
        Formatter formatter = new Formatter();
        boolean first = true;
        for (Object name : names) {
            if (first) {
                formatter.format("'%s'", name);
                first = false;
            } else {
                formatter.format(", '%s'", name);
            }
        }
        return formatter.toString();
    }

    /**
     * Converts an arbitrary string to a camel-case string which can be used in a Java identifier. Eg, with_underscores -> withUnderscores
     */
    public static String toCamelCase(CharSequence string) {
        if (string == null) {
            return null;
        }
        StringBuilder builder = new StringBuilder();
        Matcher matcher = WORD_SEPARATOR.matcher(string);
        int pos = 0;
        while (matcher.find()) {
            builder.append(StringUtils.capitalize(string.subSequence(pos, matcher.start()).toString()));
            pos = matcher.end();
        }
        builder.append(StringUtils.capitalize(string.subSequence(pos, string.length()).toString()));
        return builder.toString();
    }

    public static String toLowerCamelCase(CharSequence string) {
        String camelCase = toCamelCase(string);
        if (camelCase == null) {
            return null;
        }
        if (camelCase.length() == 0) {
            return "";
        }
        return ((Character) camelCase.charAt(0)).toString().toLowerCase() + camelCase.subSequence(1, camelCase.length());
    }

    /**
     * Converts an arbitrary string to upper case identifier with words separated by _. Eg, camelCase -> CAMEL_CASE
     */
    public static String toConstant(CharSequence string) {
        if (string == null) {
            return null;
        }
        return toWords(string, '_').toUpperCase();
    }

    /**
     * Converts an arbitrary string to space-separated words. Eg, camelCase -> camel case, with_underscores -> with underscores
     */
    public static String toWords(CharSequence string) {
        return toWords(string, ' ');
    }

    public static String toWords(CharSequence string, char separator) {
        if (string == null) {
            return null;
        }
        StringBuilder builder = new StringBuilder();
        int pos = 0;
        Matcher matcher = UPPER_LOWER.matcher(string);
        while (pos < string.length()) {
            matcher.find(pos);
            if (matcher.end() == pos) {
                // Not looking at a match
                pos++;
                continue;
            }
            if (builder.length() > 0) {
                builder.append(separator);
            }
            String group1 = matcher.group(1).toLowerCase();
            String group2 = matcher.group(2);
            if (group2.length() == 0) {
                builder.append(group1);
            } else {
                if (group1.length() > 1) {
                    builder.append(group1.substring(0, group1.length() - 1));
                    builder.append(separator);
                    builder.append(group1.substring(group1.length() - 1));
                } else {
                    builder.append(group1);
                }
                builder.append(group2);
            }
            pos = matcher.end();
        }
        return builder.toString();
    }

    public static byte[] serialize(Object object) {
        StreamByteBuffer buffer = new StreamByteBuffer();
        serialize(object, buffer.getOutputStream());
        return buffer.readAsByteArray();
    }

    public static void serialize(Object object, OutputStream outputStream) {
        try {
            ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);
            objectOutputStream.writeObject(object);
            objectOutputStream.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static <T> Comparator<T> last(final Comparator<? super T> comparator, final T lastValue) {
        return new Comparator<T>() {

            public int compare(T o1, T o2) {
                boolean o1Last = comparator.compare(o1, lastValue) == 0;
                boolean o2Last = comparator.compare(o2, lastValue) == 0;
                if (o1Last && o2Last) {
                    return 0;
                }
                if (o1Last && !o2Last) {
                    return 1;
                }
                if (!o1Last && o2Last) {
                    return -1;
                }
                return comparator.compare(o1, o2);
            }
        };
    }

    /**
     * Calls the given callable converting any thrown exception to an unchecked exception via {@link UncheckedException#throwAsUncheckedException(Throwable)}
     *
     * @param callable The callable to call
     * @param <T> Callable's return type
     * @return The value returned by {@link Callable#call()}
     */
    public static <T> T uncheckedCall(Callable<T> callable) {
        try {
            return callable.call();
        } catch (Exception e) {
            throw UncheckedException.throwAsUncheckedException(e);
        }
    }
}}'} /repo/subprojects/core/src/main/java/org/gradle/util/NameMatcher.java
Method 'append' cannot be resolved in context out.append(item) (line: 53) MethodCallExprContext{wrapped=out.append(item)}. Parameter types: [ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve field access JavaVersion.VERSION_1_9
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call missingKeys.removeAll(toStringList(properties.keySet())) java.lang.RuntimeException: Method 'toStringList' cannot be resolved in context toStringList(properties.keySet()) (line: 64) MethodCallExprContext{wrapped=toStringList(properties.keySet())}. Parameter types: [ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=WildcardUsage{type=null, boundedType=null}}}}] /repo/subprojects/core/src/main/java/org/gradle/util/ConfigureUtil.java
Cannot resolve field access null
Cannot solve method call new ClosureBackedAction<T>(configureClosure, Closure.DELEGATE_FIRST, false).execute(target) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/util/ConfigureUtil.java
Cannot solve method call configureClosure.rehydrate(target, closureDelegate, configureClosure.getThisObject()) java.lang.RuntimeException: Method 'getThisObject' cannot be resolved in context configureClosure.getThisObject() (line: 159) MethodCallExprContext{wrapped=configureClosure.getThisObject()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/util/ConfigureUtil.java
Cannot resolve field access null
Cannot solve method call new ClosureBackedAction<T>(withNewOwner, Closure.OWNER_ONLY, false).execute(target) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/core/src/main/java/org/gradle/util/ConfigureUtil.java
Cannot solve method call Character.isDigit(str.charAt(pos)) java.lang.RuntimeException: Method 'charAt' cannot be resolved in context str.charAt(pos) (line: 209) MethodCallExprContext{wrapped=str.charAt(pos)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/core/src/main/java/org/gradle/util/VersionNumber.java
Cannot solve method call Character.isDigit(str.charAt(pos + 1)) java.lang.RuntimeException: Method 'charAt' cannot be resolved in context str.charAt(pos + 1) (line: 213) MethodCallExprContext{wrapped=str.charAt(pos + 1)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/core/src/main/java/org/gradle/util/VersionNumber.java
Cannot resolve field access null
Cannot solve method call Integer.parseInt(str.substring(start, pos)) java.lang.RuntimeException: Method 'substring' cannot be resolved in context str.substring(start, pos) (line: 236) MethodCallExprContext{wrapped=str.substring(start, pos)}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}] /repo/subprojects/core/src/main/java/org/gradle/util/VersionNumber.java
Cannot solve method call project.addReference(ProjectHelper.PROJECTHELPER_REFERENCE, helper) UnsolvedSymbolException{context='unknown', name='PROJECTHELPER_REFERENCE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/util/AntUtil.java
Method 'stoppable' cannot be resolved in context stoppable(input) (line: 167) MethodCallExprContext{wrapped=stoppable(input)}. Parameter types: [ReferenceType{java.io.InputStream, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call checkEquality(entry.getValue(), oldMap.get(entry.getKey())) java.lang.RuntimeException: K java.lang.Object /repo/subprojects/core/src/main/java/org/gradle/util/DiffUtil.java
Method 'name' cannot be resolved in context e1.name() (line: 82) MethodCallExprContext{wrapped=e1.name()}. Parameter types: []
Cannot solve method call path.substring(0, path.length() - 1) java.lang.RuntimeException: Method 'length' cannot be resolved in context path.length() (line: 35) MethodCallExprContext{wrapped=path.length()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/util/Path.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call path.substring(prefix.length()) java.lang.RuntimeException: Method 'length' cannot be resolved in context prefix.length() (line: 160) MethodCallExprContext{wrapped=prefix.length()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/util/Path.java
Method 'append' cannot be resolved in context result.append(timeInMs / MS_PER_HOUR) (line: 67) MethodCallExprContext{wrapped=result.append(timeInMs / MS_PER_HOUR)}. Parameter types: [PrimitiveTypeUsage{name='long'}]
Method 'append' cannot be resolved in context result.append((timeInMs % MS_PER_HOUR) / MS_PER_MINUTE) (line: 70) MethodCallExprContext{wrapped=result.append((timeInMs % MS_PER_HOUR) / MS_PER_MINUTE)}. Parameter types: [PrimitiveTypeUsage{name='long'}]
Method 'append' cannot be resolved in context result.append((timeInMs % MS_PER_MINUTE) / 1000.0) (line: 72) MethodCallExprContext{wrapped=result.append((timeInMs % MS_PER_MINUTE) / 1000.0)}. Parameter types: [PrimitiveTypeUsage{name='double'}]
Cannot resolve field access null
Cannot solve method call Arrays.asList(parameters).subList(0, closure.getMaximumNumberOfParameters()) java.lang.RuntimeException: Method 'getMaximumNumberOfParameters' cannot be resolved in context closure.getMaximumNumberOfParameters() (line: 38) MethodCallExprContext{wrapped=closure.getMaximumNumberOfParameters()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/listener/ClosureBackedMethodInvocationDispatch.java
Error calculating the type of parameter closure.getMaximumNumberOfParameters() of method call Arrays.asList(parameters).subList(0, closure.getMaximumNumberOfParameters())
Cannot solve method call line.substring(7, line.length() - 2) java.lang.RuntimeException: Method 'length' cannot be resolved in context line.length() (line: 51) MethodCallExprContext{wrapped=line.length()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/configuration/DefaultImportsReader.java
Error calculating the type of parameter Charsets.UTF_8 of method call Resources.asCharSource(url, Charsets.UTF_8)
Cannot resolve field access null
Error calculating the type of parameter Charsets.UTF_8 of method call Resources.asCharSource(url, Charsets.UTF_8)
Cannot solve method call ImmutableList.copyOf(pluginsServiceLocator.getAll(ProjectConfigureAction.class)) java.lang.RuntimeException: Method 'getAll' cannot be resolved in context pluginsServiceLocator.getAll(ProjectConfigureAction.class) (line: 27) MethodCallExprContext{wrapped=pluginsServiceLocator.getAll(ProjectConfigureAction.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.configuration.project.ProjectConfigureAction, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/core/src/main/java/org/gradle/configuration/project/PluginsProjectConfigureActions.java
Cannot solve method call compiler.compile(scriptType, operation, targetScope.getLocalClassLoader(), ClosureCreationInterceptingVerifier.INSTANCE) UnsolvedSymbolException{context='unknown', name='INSTANCE', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/configuration/DefaultScriptPluginFactory.java
Method 'getLocation' cannot be resolved in context initScript.getResource().getLocation() (line: 44) MethodCallExprContext{wrapped=initScript.getResource().getLocation()}. Parameter types: []
Cannot solve method call LOGGER.error(String.format("Could not %s.", displayName), t) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/core/src/main/java/org/gradle/process/internal/streams/ExecOutputHandleRunner.java
Cannot solve method call allArgs.add(CollectionUtils.join(File.pathSeparator, classpath.getFiles())) UnsolvedSymbolException{context='Method 'join' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class CollectionUtils {

    /**
     * Returns null if the collection is empty otherwise expects a {@link #single(Iterable)} element to be found.
     */
    @Nullable
    public static <T> T findSingle(Collection<T> source) {
        return source.isEmpty() ? null : single(source);
    }

    /**
     * Returns the single element in the collection or throws.
     */
    public static <T> T single(Iterable<? extends T> source) {
        Iterator<? extends T> iterator = source.iterator();
        if (!iterator.hasNext()) {
            throw new NoSuchElementException("Expecting collection with single element, got none.");
        }
        T element = iterator.next();
        if (iterator.hasNext()) {
            throw new IllegalArgumentException("Expecting collection with single element, got multiple.");
        }
        return element;
    }

    public static <T> Collection<? extends T> checkedCast(Class<T> type, Collection<?> input) {
        for (Object o : input) {
            cast(type, o);
        }
        return Cast.uncheckedCast(input);
    }

    public static <T> T findFirst(Iterable<? extends T> source, Spec<? super T> filter) {
        for (T item : source) {
            if (filter.isSatisfiedBy(item)) {
                return item;
            }
        }
        return null;
    }

    public static <T> T findFirst(T[] source, Spec<? super T> filter) {
        for (T thing : source) {
            if (filter.isSatisfiedBy(thing)) {
                return thing;
            }
        }
        return null;
    }

    public static <T> T first(Iterable<? extends T> source) {
        return source.iterator().next();
    }

    public static <T> boolean any(Iterable<? extends T> source, Spec<? super T> filter) {
        return findFirst(source, filter) != null;
    }

    public static <T> boolean any(T[] source, Spec<? super T> filter) {
        return findFirst(source, filter) != null;
    }

    public static <T> Set<T> filter(Set<? extends T> set, Spec<? super T> filter) {
        return filter(set, new LinkedHashSet<T>(), filter);
    }

    public static <T> List<T> filter(List<? extends T> list, Spec<? super T> filter) {
        return filter(list, new LinkedList<T>(), filter);
    }

    public static <T> List<T> filter(T[] array, Spec<? super T> filter) {
        return filter(Arrays.asList(array), new LinkedList<T>(), filter);
    }

    /**
     * Returns a sorted copy of the provided collection of things. Uses the provided comparator to sort.
     */
    public static <T> List<T> sort(Iterable<? extends T> things, Comparator<? super T> comparator) {
        List<T> copy = toMutableList(things);
        Collections.sort(copy, comparator);
        return copy;
    }

    /**
     * Returns a sorted copy of the provided collection of things. Uses the natural ordering of the things.
     */
    public static <T extends Comparable> List<T> sort(Iterable<T> things) {
        List<T> copy = toMutableList(things);
        Collections.sort(copy);
        return copy;
    }

    public static <T, C extends Collection<T>> C filter(Iterable<? extends T> source, C destination, Spec<? super T> filter) {
        for (T item : source) {
            if (filter.isSatisfiedBy(item)) {
                destination.add(item);
            }
        }
        return destination;
    }

    public static <K, V> Map<K, V> filter(Map<K, V> map, Spec<Map.Entry<K, V>> filter) {
        return filter(map, new HashMap<K, V>(), filter);
    }

    public static <K, V> Map<K, V> filter(Map<K, V> map, Map<K, V> destination, Spec<Map.Entry<K, V>> filter) {
        for (Map.Entry<K, V> entry : map.entrySet()) {
            if (filter.isSatisfiedBy(entry)) {
                destination.put(entry.getKey(), entry.getValue());
            }
        }
        return destination;
    }

    public static <R, I> R[] collectArray(I[] list, Class<R> newType, Transformer<? extends R, ? super I> transformer) {
        @SuppressWarnings("unchecked") R[] destination = (R[]) Array.newInstance(newType, list.length);
        return collectArray(list, destination, transformer);
    }

    public static <R, I> R[] collectArray(I[] list, R[] destination, Transformer<? extends R, ? super I> transformer) {
        assert list.length <= destination.length;
        for (int i = 0; i < list.length; ++i) {
            destination[i] = transformer.transform(list[i]);
        }
        return destination;
    }

    public static <R, I> List<R> collect(List<? extends I> list, Transformer<? extends R, ? super I> transformer) {
        return collect(list, new ArrayList<R>(list.size()), transformer);
    }

    public static <R, I> List<R> collect(I[] list, Transformer<? extends R, ? super I> transformer) {
        return collect(Arrays.asList(list), transformer);
    }

    public static <R, I> Set<R> collect(Set<? extends I> set, Transformer<? extends R, ? super I> transformer) {
        return collect(set, new HashSet<R>(), transformer);
    }

    public static <R, I> List<R> collect(Iterable<? extends I> source, Transformer<? extends R, ? super I> transformer) {
        return collect(source, new LinkedList<R>(), transformer);
    }

    public static <R, I, C extends Collection<R>> C collect(Iterable<? extends I> source, C destination, Transformer<? extends R, ? super I> transformer) {
        for (I item : source) {
            destination.add(transformer.transform(item));
        }
        return destination;
    }

    public static List<String> toStringList(Iterable<?> iterable) {
        return collect(iterable, new LinkedList<String>(), Transformers.asString());
    }

    /**
     * Recursively unpacks all the given things into a flat list.
     *
     * Nulls are not removed, they are left intact.
     *
     * @param things The things to flatten
     * @return A flattened list of the given things
     */
    public static List<?> flattenCollections(Object... things) {
        return flattenCollections(Object.class, things);
    }

    /**
     * Recursively unpacks all the given things into a flat list, ensuring they are of a certain type.
     *
     * Nulls are not removed, they are left intact.
     *
     * If a non null object cannot be cast to the target type, a ClassCastException will be thrown.
     *
     * @param things The things to flatten
     * @param <T> The target type in the flattened list
     * @return A flattened list of the given things
     */
    public static <T> List<T> flattenCollections(Class<T> type, Object... things) {
        if (things == null) {
            return Collections.singletonList(null);
        } else if (things.length == 0) {
            return Collections.emptyList();
        } else if (things.length == 1) {
            Object thing = things[0];
            if (thing == null) {
                return Collections.singletonList(null);
            }
            if (thing.getClass().isArray()) {
                Object[] thingArray = (Object[]) thing;
                List<T> list = new ArrayList<T>(thingArray.length);
                for (Object thingThing : thingArray) {
                    list.addAll(flattenCollections(type, thingThing));
                }
                return list;
            }
            if (thing instanceof Collection) {
                Collection<?> collection = (Collection<?>) thing;
                List<T> list = new ArrayList<T>();
                for (Object element : collection) {
                    list.addAll(flattenCollections(type, element));
                }
                return list;
            }
            return Collections.singletonList(cast(type, thing));
        } else {
            List<T> list = new ArrayList<T>();
            for (Object thing : things) {
                list.addAll(flattenCollections(type, thing));
            }
            return list;
        }
    }

    public static <T> List<T> toList(Iterable<? extends T> things) {
        if (things instanceof List) {
            @SuppressWarnings("unchecked") List<T> castThings = (List<T>) things;
            return castThings;
        }
        return toMutableList(things);
    }

    public static <T> List<T> toList(Enumeration<? extends T> things) {
        AbstractList<T> list = new ArrayList<T>();
        while (things.hasMoreElements()) {
            list.add(things.nextElement());
        }
        return list;
    }

    private static <T> List<T> toMutableList(Iterable<? extends T> things) {
        if (things == null) {
            return new ArrayList<T>(0);
        }
        List<T> list = new ArrayList<T>();
        for (T thing : things) {
            list.add(thing);
        }
        return list;
    }

    public static <T> List<T> intersection(Collection<? extends Collection<T>> availableValuesByDescriptor) {
        List<T> result = new ArrayList<T>();
        Iterator<? extends Collection<T>> iterator = availableValuesByDescriptor.iterator();
        if (iterator.hasNext()) {
            Collection<T> firstSet = iterator.next();
            result.addAll(firstSet);
            while (iterator.hasNext()) {
                Collection<T> next = iterator.next();
                result.retainAll(next);
            }
        }
        return result;
    }

    public static <T> List<T> toList(T[] things) {
        if (things == null || things.length == 0) {
            return new ArrayList<T>(0);
        }
        List<T> list = new ArrayList<T>(things.length);
        Collections.addAll(list, things);
        return list;
    }

    public static <T> Set<T> toSet(Iterable<? extends T> things) {
        if (things == null) {
            return new HashSet<T>(0);
        }
        if (things instanceof Set) {
            @SuppressWarnings("unchecked") Set<T> castThings = (Set<T>) things;
            return castThings;
        }
        Set<T> set = new LinkedHashSet<T>();
        for (T thing : things) {
            set.add(thing);
        }
        return set;
    }

    public static <E> List<E> compact(List<E> list) {
        boolean foundAtLeastOneNull = false;
        List<E> compacted = null;
        int i = 0;
        for (E element : list) {
            if (element == null) {
                if (!foundAtLeastOneNull) {
                    compacted = new ArrayList<E>(list.size());
                    if (i > 0) {
                        compacted.addAll(list.subList(0, i));
                    }
                }
                foundAtLeastOneNull = true;
            } else if (foundAtLeastOneNull) {
                compacted.add(element);
            }
            ++i;
        }
        return foundAtLeastOneNull ? compacted : list;
    }

    public static <C extends Collection<String>> C stringize(Iterable<?> source, C destination) {
        return collect(source, destination, Transformers.asString());
    }

    public static List<String> stringize(Collection<?> source) {
        return stringize(source, new ArrayList<String>(source.size()));
    }

    public static <E> boolean replace(List<E> list, Spec<? super E> filter, Transformer<? extends E, ? super E> transformer) {
        boolean replaced = false;
        int i = 0;
        for (E it : list) {
            if (filter.isSatisfiedBy(it)) {
                list.set(i, transformer.transform(it));
                replaced = true;
            }
            ++i;
        }
        return replaced;
    }

    public static <K, V> void collectMap(Map<K, V> destination, Iterable<? extends V> items, Transformer<? extends K, ? super V> keyGenerator) {
        for (V item : items) {
            destination.put(keyGenerator.transform(item), item);
        }
    }

    /**
     * Given a set of values, derive a set of keys and return a map
     */
    public static <K, V> Map<K, V> collectMap(Iterable<? extends V> items, Transformer<? extends K, ? super V> keyGenerator) {
        Map<K, V> map = new LinkedHashMap<K, V>();
        collectMap(map, items, keyGenerator);
        return map;
    }

    public static <K, V> void collectMapValues(Map<K, V> destination, Iterable<? extends K> keys, Transformer<? extends V, ? super K> keyGenerator) {
        for (K item : keys) {
            destination.put(item, keyGenerator.transform(item));
        }
    }

    /**
     * Given a set of keys, derive a set of values and return a map
     */
    public static <K, V> Map<K, V> collectMapValues(Iterable<? extends K> keys, Transformer<? extends V, ? super K> keyGenerator) {
        Map<K, V> map = new LinkedHashMap<K, V>();
        collectMapValues(map, keys, keyGenerator);
        return map;
    }

    public static <T> boolean every(Iterable<? extends T> things, Spec<? super T> predicate) {
        for (T thing : things) {
            if (!predicate.isSatisfiedBy(thing)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Utility for adding an iterable to a collection.
     *
     * @param t1 The collection to add to
     * @param t2 The iterable to add each item of to the collection
     * @param <T> The element type of t1
     * @return t1
     */
    public static <T> Collection<T> addAll(Collection<T> t1, Iterable<? extends T> t2) {
        for (T t : t2) {
            t1.add(t);
        }
        return t1;
    }

    /**
     * Utility for adding an array to a collection.
     *
     * @param t1 The collection to add to
     * @param t2 The iterable to add each item of to the collection
     * @param <T> The element type of t1
     * @return t1
     */
    public static <T> Collection<T> addAll(Collection<T> t1, T... t2) {
        Collections.addAll(t1, t2);
        return t1;
    }

    /**
     * The result of diffing two sets.
     *
     * @param <T> The type of element the sets contain
     * @see CollectionUtils#diffSetsBy(java.util.Set, java.util.Set, org.gradle.api.Transformer)
     */
    public static class SetDiff<T> {

        public Set<T> leftOnly = new HashSet<T>();

        public Set<Pair<T, T>> common = new HashSet<Pair<T, T>>();

        public Set<T> rightOnly = new HashSet<T>();
    }

    /**
     * Provides a “diff report” of how the two sets are similar and how they are different, comparing the entries by some aspect.
     *
     * The transformer is used to generate the value to use to compare the entries by. That is, the entries are not compared by equals by an attribute or characteristic.
     *
     * The transformer is expected to produce a unique value for each entry in a single set. Behaviour is undefined if this condition is not met.
     *
     * @param left The set on the “left” side of the comparison.
     * @param right The set on the “right” side of the comparison.
     * @param compareBy Provides the value to compare entries from either side by
     * @param <T> The type of the entry objects
     * @return A representation of the difference
     */
    public static <T> SetDiff<T> diffSetsBy(Set<? extends T> left, Set<? extends T> right, Transformer<?, T> compareBy) {
        if (left == null) {
            throw new NullPointerException("'left' set is null");
        }
        if (right == null) {
            throw new NullPointerException("'right' set is null");
        }
        SetDiff<T> setDiff = new SetDiff<T>();
        Map<Object, T> indexedLeft = collectMap(left, compareBy);
        Map<Object, T> indexedRight = collectMap(right, compareBy);
        for (Map.Entry<Object, T> leftEntry : indexedLeft.entrySet()) {
            T rightValue = indexedRight.remove(leftEntry.getKey());
            if (rightValue == null) {
                setDiff.leftOnly.add(leftEntry.getValue());
            } else {
                Pair<T, T> pair = Pair.of(leftEntry.getValue(), rightValue);
                setDiff.common.add(pair);
            }
        }
        for (T rightValue : indexedRight.values()) {
            setDiff.rightOnly.add(rightValue);
        }
        return setDiff;
    }

    /**
     * Creates a string with {@code toString()} of each object with the given separator.
     *
     * <pre>
     * expect:
     * join(",", new Object[]{"a"}) == "a"
     * join(",", new Object[]{"a", "b", "c"}) == "a,b,c"
     * join(",", new Object[]{}) == ""
     * </pre>
     *
     * The {@code separator} must not be null and {@code objects} must not be null.
     *
     * @param separator The string by which to join each string representation
     * @param objects The objects to join the string representations of
     * @return The joined string
     */
    public static String join(String separator, Object[] objects) {
        return join(separator, objects == null ? null : Arrays.asList(objects));
    }

    /**
     * Creates a string with {@code toString()} of each object with the given separator.
     *
     * <pre>
     * expect:
     * join(",", ["a"]) == "a"
     * join(",", ["a", "b", "c"]) == "a,b,c"
     * join(",", []) == ""
     * </pre>
     *
     * The {@code separator} must not be null and {@code objects} must not be null.
     *
     * @param separator The string by which to join each string representation
     * @param objects The objects to join the string representations of
     * @return The joined string
     */
    public static String join(String separator, Iterable<?> objects) {
        if (separator == null) {
            throw new NullPointerException("The 'separator' cannot be null");
        }
        if (objects == null) {
            throw new NullPointerException("The 'objects' cannot be null");
        }
        StringBuilder string = new StringBuilder();
        Iterator<?> iterator = objects.iterator();
        if (iterator.hasNext()) {
            string.append(iterator.next().toString());
            while (iterator.hasNext()) {
                string.append(separator);
                string.append(iterator.next().toString());
            }
        }
        return string.toString();
    }

    /**
     * Partition given Collection into a Pair of Collections.
     *
     * <pre>Left</pre> Collection containing entries that satisfy the given predicate
     * <pre>Right</pre> Collection containing entries that do NOT satisfy the given predicate
     */
    public static <T> Pair<Collection<T>, Collection<T>> partition(Iterable<T> items, Spec<? super T> predicate) {
        Preconditions.checkNotNull(items, "Cannot partition null Collection");
        Preconditions.checkNotNull(predicate, "Cannot apply null Spec when partitioning");
        Collection<T> left = new LinkedList<T>();
        Collection<T> right = new LinkedList<T>();
        for (T item : items) {
            if (predicate.isSatisfiedBy(item)) {
                left.add(item);
            } else {
                right.add(item);
            }
        }
        return Pair.of(left, right);
    }

    public static class InjectionStep<T, I> {

        private final T target;

        private final I item;

        public InjectionStep(T target, I item) {
            this.target = target;
            this.item = item;
        }

        public T getTarget() {
            return target;
        }

        public I getItem() {
            return item;
        }
    }

    public static <T, I> T inject(T target, Iterable<? extends I> items, Action<InjectionStep<T, I>> action) {
        if (target == null) {
            throw new NullPointerException("The 'target' cannot be null");
        }
        if (items == null) {
            throw new NullPointerException("The 'items' cannot be null");
        }
        if (action == null) {
            throw new NullPointerException("The 'action' cannot be null");
        }
        for (I item : items) {
            action.execute(new InjectionStep<T, I>(target, item));
        }
        return target;
    }

    public static <K, V> ImmutableListMultimap<K, V> groupBy(Iterable<? extends V> iterable, Transformer<? extends K, V> grouper) {
        ImmutableListMultimap.Builder<K, V> builder = ImmutableListMultimap.builder();
        for (V element : iterable) {
            K key = grouper.transform(element);
            builder.put(key, element);
        }
        return builder.build();
    }

    public static <T> Iterable<? extends T> unpack(final Iterable<? extends Factory<? extends T>> factories) {
        return new Iterable<T>() {

            private final Iterator<? extends Factory<? extends T>> delegate = factories.iterator();

            public Iterator<T> iterator() {
                return new Iterator<T>() {

                    public boolean hasNext() {
                        return delegate.hasNext();
                    }

                    public T next() {
                        return delegate.next().create();
                    }

                    public void remove() {
                        throw new UnsupportedOperationException();
                    }
                };
            }
        };
    }

    @Nullable
    public static <T> List<T> nonEmptyOrNull(Iterable<T> iterable) {
        ImmutableList<T> list = ImmutableList.copyOf(iterable);
        return list.isEmpty() ? null : list;
    }

    public static <T> List<T> dedup(Iterable<T> source, final Equivalence<? super T> equivalence) {
        Iterable<Equivalence.Wrapper<T>> wrappers = Iterables.transform(source, new Function<T, Equivalence.Wrapper<T>>() {

            public Equivalence.Wrapper<T> apply(@Nullable T input) {
                return equivalence.wrap(input);
            }
        });
        Set<Equivalence.Wrapper<T>> deduped = ImmutableSet.copyOf(wrappers);
        return ImmutableList.copyOf(Iterables.transform(deduped, new Function<Equivalence.Wrapper<T>, T>() {

            public T apply(Equivalence.Wrapper<T> input) {
                return input.get();
            }
        }));
    }

    public static String asCommandLine(Iterable<String> arguments) {
        return Joiner.on(" ").join(collect(arguments, Transformers.asSafeCommandLineArgument()));
    }
}}'} /repo/subprojects/core/src/main/java/org/gradle/process/internal/JavaExecHandleBuilder.java
Cannot solve method call classpath.plus(fileResolver.resolveFiles(paths)) java.lang.RuntimeException: Object[] Object /repo/subprojects/core/src/main/java/org/gradle/process/internal/JavaExecHandleBuilder.java
Cannot solve method call actual.put(entry.getKey(), String.valueOf(entry.getValue())) UnsolvedSymbolException{context='Method 'valueOf' with parameterTypes [ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/core/src/main/java/org/gradle/process/internal/DefaultProcessForkOptions.java
unbounded wildcard
Cannot solve method call args.add("-D" + entry.getKey() + "=" + entry.getValue().toString()) java.lang.UnsupportedOperationException: unbounded wildcard /repo/subprojects/core/src/main/java/org/gradle/process/internal/JvmOptions.java
Method 'cache' cannot be resolved in context cacheRepository.cache("workerMain") (line: 79) MethodCallExprContext{wrapped=cacheRepository.cache("workerMain")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'cache' cannot be resolved in context cacheRepository.cache("workerMain") (line: 79) MethodCallExprContext{wrapped=cacheRepository.cache("workerMain")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot resolve field access null
Cannot solve method call classReader.accept(remappingVisitor, ClassReader.EXPAND_FRAMES) UnsolvedSymbolException{context='unknown', name='EXPAND_FRAMES', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/process/internal/worker/child/WorkerProcessClassPathProvider.java
Cannot solve method call Arrays.asList("-cp", Joiner.on(File.pathSeparator).join(classpath)) UnsolvedSymbolException{context='Method 'on' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=Joiner}'} /repo/subprojects/core/src/main/java/org/gradle/process/internal/worker/child/ApplicationClassesInSystemClassLoaderWorkerFactory.java
Cannot solve method call builder.setImplementationClasspath(ClasspathUtil.getClasspath(workerAction.getClass().getClassLoader())) UnsolvedSymbolException{context='Method 'getClasspath' with parameterTypes [ReferenceType{java.lang.ClassLoader, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=public class ClasspathUtil {

    public static void addUrl(URLClassLoader classLoader, Iterable<URL> classpathElements) {
        try {
            Set<URI> original = new HashSet<URI>();
            for (URL url : classLoader.getURLs()) {
                original.add(url.toURI());
            }
            JavaMethod<URLClassLoader, Object> method = JavaReflectionUtil.method(URLClassLoader.class, Object.class, "addURL", URL.class);
            for (URL classpathElement : classpathElements) {
                if (original.add(classpathElement.toURI())) {
                    method.invoke(classLoader, classpathElement);
                }
            }
        } catch (Throwable t) {
            throw new RuntimeException(String.format("Could not add URLs %s to class path for ClassLoader %s", classpathElements, classLoader), t);
        }
    }

    public static List<URL> getClasspath(ClassLoader classLoader) {
        final List<URL> implementationClassPath = new ArrayList<URL>();
        new ClassLoaderVisitor() {

            @Override
            public void visitClassPath(URL[] classPath) {
                implementationClassPath.addAll(Arrays.asList(classPath));
            }
        }.visit(classLoader);
        return implementationClassPath;
    }

    public static File getClasspathForClass(Class<?> targetClass) {
        URI location;
        try {
            CodeSource codeSource = targetClass.getProtectionDomain().getCodeSource();
            if (codeSource != null && codeSource.getLocation() != null) {
                location = codeSource.getLocation().toURI();
                if (location.getScheme().equals("file")) {
                    return new File(location);
                }
            }
            String resourceName = targetClass.getName().replace('.', '/') + ".class";
            URL resource = targetClass.getClassLoader().getResource(resourceName);
            if (resource != null) {
                return getClasspathForResource(resource, resourceName);
            }
            throw new GradleException(String.format("Cannot determine classpath for class %s.", targetClass.getName()));
        } catch (URISyntaxException e) {
            throw UncheckedException.throwAsUncheckedException(e);
        }
    }

    public static File getClasspathForResource(ClassLoader classLoader, String name) {
        if (classLoader == null) {
            return getClasspathForResource(ClassLoader.getSystemResource(name), name);
        } else {
            return getClasspathForResource(classLoader.getResource(name), name);
        }
    }

    public static File getClasspathForResource(URL resource, String name) {
        URI location;
        try {
            location = resource.toURI();
            String path = location.getPath();
            if (location.getScheme().equals("file")) {
                assert path.endsWith("/" + name);
                return new File(path.substring(0, path.length() - (name.length() + 1)));
            } else if (location.getScheme().equals("jar")) {
                String schemeSpecificPart = location.getRawSchemeSpecificPart();
                int pos = schemeSpecificPart.indexOf("!");
                if (pos > 0) {
                    assert schemeSpecificPart.substring(pos + 1).equals("/" + name);
                    URI jarFile = new URI(schemeSpecificPart.substring(0, pos));
                    if (jarFile.getScheme().equals("file")) {
                        return new File(jarFile.getPath());
                    }
                }
            }
        } catch (URISyntaxException e) {
            throw UncheckedException.throwAsUncheckedException(e);
        }
        throw new GradleException(String.format("Cannot determine classpath for resource '%s' from location '%s'.", name, location));
    }
}}'} /repo/subprojects/core/src/main/java/org/gradle/process/internal/worker/DefaultWorkerProcessFactory.java
Cannot solve field access LogLevel.LIFECYCLE
Cannot solve method call ClasspathUtil.getClasspath(workerImplementation.getClassLoader()) java.lang.RuntimeException: Method 'getClassLoader' cannot be resolved in context workerImplementation.getClassLoader() (line: 44) MethodCallExprContext{wrapped=workerImplementation.getClassLoader()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/process/internal/worker/DefaultSingleRequestWorkerProcessBuilder.java
Cannot solve method call builder.setImplementationClasspath(ClasspathUtil.getClasspath(workerImplementation.getClassLoader())) java.lang.RuntimeException: Error calculating the type of parameter workerImplementation.getClassLoader() of method call ClasspathUtil.getClasspath(workerImplementation.getClassLoader()) /repo/subprojects/core/src/main/java/org/gradle/process/internal/worker/DefaultSingleRequestWorkerProcessBuilder.java
Cannot solve method call connection.useJavaSerializationForParameters(workerImplementation.getClassLoader()) java.lang.RuntimeException: Method 'getClassLoader' cannot be resolved in context workerImplementation.getClassLoader() (line: 114) MethodCallExprContext{wrapped=workerImplementation.getClassLoader()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/process/internal/worker/DefaultSingleRequestWorkerProcessBuilder.java
Cannot solve method call Proxy.newProxyInstance(protocolType.getClassLoader(), new Class[] { protocolType }, new InvocationHandler() {

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Receiver receiver = new Receiver(getBaseName());
        try {
            WorkerProcess workerProcess = builder.build();
            workerProcess.start();
            ObjectConnection connection = workerProcess.getConnection();
            RequestProtocol requestProtocol = connection.addOutgoing(RequestProtocol.class);
            connection.addIncoming(ResponseProtocol.class, receiver);
            connection.useJavaSerializationForParameters(workerImplementation.getClassLoader());
            connection.connect();
            requestProtocol.runThenStop(method.getName(), method.getParameterTypes(), args);
            boolean hasResult = receiver.awaitNextResult();
            workerProcess.waitForStop();
            if (!hasResult) {
                // Reached the end of input, worker has exited without failing
                throw new IllegalStateException(String.format("No response was received from %s but the worker process has finished.", getBaseName()));
            }
        } catch (Exception e) {
            throw WorkerProcessException.runFailed(getBaseName(), e);
        }
        return receiver.getNextResult();
    }
}) java.lang.RuntimeException: Method 'getClassLoader' cannot be resolved in context protocolType.getClassLoader() (line: 104) MethodCallExprContext{wrapped=protocolType.getClassLoader()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/process/internal/worker/DefaultSingleRequestWorkerProcessBuilder.java
Cannot solve method call protocolType.cast(Proxy.newProxyInstance(protocolType.getClassLoader(), new Class[] { protocolType }, new InvocationHandler() {

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Receiver receiver = new Receiver(getBaseName());
        try {
            WorkerProcess workerProcess = builder.build();
            workerProcess.start();
            ObjectConnection connection = workerProcess.getConnection();
            RequestProtocol requestProtocol = connection.addOutgoing(RequestProtocol.class);
            connection.addIncoming(ResponseProtocol.class, receiver);
            connection.useJavaSerializationForParameters(workerImplementation.getClassLoader());
            connection.connect();
            requestProtocol.runThenStop(method.getName(), method.getParameterTypes(), args);
            boolean hasResult = receiver.awaitNextResult();
            workerProcess.waitForStop();
            if (!hasResult) {
                // Reached the end of input, worker has exited without failing
                throw new IllegalStateException(String.format("No response was received from %s but the worker process has finished.", getBaseName()));
            }
        } catch (Exception e) {
            throw WorkerProcessException.runFailed(getBaseName(), e);
        }
        return receiver.getNextResult();
    }
})) java.lang.RuntimeException: Error calculating the type of parameter protocolType.getClassLoader() of method call Proxy.newProxyInstance(protocolType.getClassLoader(), new Class[] { protocolType }, new InvocationHandler() {

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Receiver receiver = new Receiver(getBaseName());
        try {
            WorkerProcess workerProcess = builder.build();
            workerProcess.start();
            ObjectConnection connection = workerProcess.getConnection();
            RequestProtocol requestProtocol = connection.addOutgoing(RequestProtocol.class);
            connection.addIncoming(ResponseProtocol.class, receiver);
            connection.useJavaSerializationForParameters(workerImplementation.getClassLoader());
            connection.connect();
            requestProtocol.runThenStop(method.getName(), method.getParameterTypes(), args);
            boolean hasResult = receiver.awaitNextResult();
            workerProcess.waitForStop();
            if (!hasResult) {
                // Reached the end of input, worker has exited without failing
                throw new IllegalStateException(String.format("No response was received from %s but the worker process has finished.", getBaseName()));
            }
        } catch (Exception e) {
            throw WorkerProcessException.runFailed(getBaseName(), e);
        }
        return receiver.getNextResult();
    }
}) /repo/subprojects/core/src/main/java/org/gradle/process/internal/worker/DefaultSingleRequestWorkerProcessBuilder.java
Cannot solve method call ClasspathUtil.getClasspath(workerImplementation.getClassLoader()) java.lang.RuntimeException: Method 'getClassLoader' cannot be resolved in context workerImplementation.getClassLoader() (line: 55) MethodCallExprContext{wrapped=workerImplementation.getClassLoader()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/process/internal/worker/DefaultMultiRequestWorkerProcessBuilder.java
Cannot solve method call workerProcessBuilder.setImplementationClasspath(ClasspathUtil.getClasspath(workerImplementation.getClassLoader())) java.lang.RuntimeException: Error calculating the type of parameter workerImplementation.getClassLoader() of method call ClasspathUtil.getClasspath(workerImplementation.getClassLoader()) /repo/subprojects/core/src/main/java/org/gradle/process/internal/worker/DefaultMultiRequestWorkerProcessBuilder.java
Cannot solve method call workerProcess.getConnection().addIncoming(ResponseProtocol.class, receiver) UnsolvedSymbolException{context='Solving receiver', name='receiver', typeSolver=null} /repo/subprojects/core/src/main/java/org/gradle/process/internal/worker/DefaultMultiRequestWorkerProcessBuilder.java
Cannot solve method call workerProcess.getConnection().useJavaSerializationForParameters(workerImplementation.getClassLoader()) java.lang.RuntimeException: Method 'getClassLoader' cannot be resolved in context workerImplementation.getClassLoader() (line: 129) MethodCallExprContext{wrapped=workerImplementation.getClassLoader()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/process/internal/worker/DefaultMultiRequestWorkerProcessBuilder.java
Cannot solve method call Proxy.newProxyInstance(workerType.getClassLoader(), new Class[] { workerType }, new InvocationHandler() {

    private Receiver receiver = new Receiver(getBaseName());

    private RequestProtocol requestProtocol;

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if (method.equals(START_METHOD)) {
            try {
                workerProcess.start();
            } catch (Exception e) {
                throw WorkerProcessException.runFailed(getBaseName(), e);
            }
            workerProcess.getConnection().addIncoming(ResponseProtocol.class, receiver);
            workerProcess.getConnection().useJavaSerializationForParameters(workerImplementation.getClassLoader());
            requestProtocol = workerProcess.getConnection().addOutgoing(RequestProtocol.class);
            workerProcess.getConnection().connect();
            return null;
        }
        if (method.equals(STOP_METHOD)) {
            if (requestProtocol != null) {
                requestProtocol.stop();
            }
            try {
                return workerProcess.waitForStop();
            } finally {
                requestProtocol = null;
            }
        }
        requestProtocol.run(method.getName(), method.getParameterTypes(), args);
        boolean hasResult = receiver.awaitNextResult();
        if (!hasResult) {
            try {
                // Reached the end of input, worker has crashed or exited
                requestProtocol = null;
                workerProcess.waitForStop();
                // Worker didn't crash
                throw new IllegalStateException(String.format("No response was received from %s but the worker process has finished.", getBaseName()));
            } catch (Exception e) {
                throw WorkerProcessException.runFailed(getBaseName(), e);
            }
        }
        return receiver.getNextResult();
    }
}) java.lang.RuntimeException: Method 'getClassLoader' cannot be resolved in context workerType.getClassLoader() (line: 116) MethodCallExprContext{wrapped=workerType.getClassLoader()}. Parameter types: [] /repo/subprojects/core/src/main/java/org/gradle/process/internal/worker/DefaultMultiRequestWorkerProcessBuilder.java
Cannot solve method call workerType.cast(Proxy.newProxyInstance(workerType.getClassLoader(), new Class[] { workerType }, new InvocationHandler() {

    private Receiver receiver = new Receiver(getBaseName());

    private RequestProtocol requestProtocol;

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if (method.equals(START_METHOD)) {
            try {
                workerProcess.start();
            } catch (Exception e) {
                throw WorkerProcessException.runFailed(getBaseName(), e);
            }
            workerProcess.getConnection().addIncoming(ResponseProtocol.class, receiver);
            workerProcess.getConnection().useJavaSerializationForParameters(workerImplementation.getClassLoader());
            requestProtocol = workerProcess.getConnection().addOutgoing(RequestProtocol.class);
            workerProcess.getConnection().connect();
            return null;
        }
        if (method.equals(STOP_METHOD)) {
            if (requestProtocol != null) {
                requestProtocol.stop();
            }
            try {
                return workerProcess.waitForStop();
            } finally {
                requestProtocol = null;
            }
        }
        requestProtocol.run(method.getName(), method.getParameterTypes(), args);
        boolean hasResult = receiver.awaitNextResult();
        if (!hasResult) {
            try {
                // Reached the end of input, worker has crashed or exited
                requestProtocol = null;
                workerProcess.waitForStop();
                // Worker didn't crash
                throw new IllegalStateException(String.format("No response was received from %s but the worker process has finished.", getBaseName()));
            } catch (Exception e) {
                throw WorkerProcessException.runFailed(getBaseName(), e);
            }
        }
        return receiver.getNextResult();
    }
})) java.lang.RuntimeException: Error calculating the type of parameter workerType.getClassLoader() of method call Proxy.newProxyInstance(workerType.getClassLoader(), new Class[] { workerType }, new InvocationHandler() {

    private Receiver receiver = new Receiver(getBaseName());

    private RequestProtocol requestProtocol;

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if (method.equals(START_METHOD)) {
            try {
                workerProcess.start();
            } catch (Exception e) {
                throw WorkerProcessException.runFailed(getBaseName(), e);
            }
            workerProcess.getConnection().addIncoming(ResponseProtocol.class, receiver);
            workerProcess.getConnection().useJavaSerializationForParameters(workerImplementation.getClassLoader());
            requestProtocol = workerProcess.getConnection().addOutgoing(RequestProtocol.class);
            workerProcess.getConnection().connect();
            return null;
        }
        if (method.equals(STOP_METHOD)) {
            if (requestProtocol != null) {
                requestProtocol.stop();
            }
            try {
                return workerProcess.waitForStop();
            } finally {
                requestProtocol = null;
            }
        }
        requestProtocol.run(method.getName(), method.getParameterTypes(), args);
        boolean hasResult = receiver.awaitNextResult();
        if (!hasResult) {
            try {
                // Reached the end of input, worker has crashed or exited
                requestProtocol = null;
                workerProcess.waitForStop();
                // Worker didn't crash
                throw new IllegalStateException(String.format("No response was received from %s but the worker process has finished.", getBaseName()));
            } catch (Exception e) {
                throw WorkerProcessException.runFailed(getBaseName(), e);
            }
        }
        return receiver.getNextResult();
    }
}) /repo/subprojects/core/src/main/java/org/gradle/process/internal/worker/DefaultMultiRequestWorkerProcessBuilder.java
Method 'getConstructor' cannot be resolved in context workerClass.getConstructor(DataInputStream.class) (line: 61) MethodCallExprContext{wrapped=workerClass.getConstructor(DataInputStream.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{java.io.DataInputStream, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve field access ExecHandleState.INIT
Cannot solve method call executorFactory.create(String.format("Run %s", displayName)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/core/src/main/java/org/gradle/process/internal/DefaultExecHandle.java
Cannot solve field access ExecHandleState.STARTING
Cannot solve field access ExecHandleState.DETACHED
Cannot solve field access ExecHandleState.DETACHED
Cannot solve method call LOGGER.info("Starting process '{}'. Working directory: {} Command: {}", displayName, directory, command + ' ' + Joiner.on(' ').useForNull("null").join(arguments)) UnsolvedSymbolException{context='Method 'on' with parameterTypes [PrimitiveTypeUsage{name='char'}]', name='ReflectionClassDeclaration{clazz=Joiner}'} /repo/subprojects/core/src/main/java/org/gradle/process/internal/DefaultExecHandle.java
Cannot solve field access ExecHandleState.INIT
Cannot solve field access ExecHandleState.STARTING
Cannot solve field access ExecHandleState.STARTING
Cannot solve field access ExecHandleState.SUCCEEDED
Cannot solve field access ExecHandleState.FAILED
Cannot solve field access ExecHandleState.ABORTED
Cannot solve field access ExecHandleState.STARTED
Cannot solve field access ExecHandleState.DETACHED
Cannot solve field access ExecHandleState.SUCCEEDED
Cannot solve field access ExecHandleState.ABORTED
Cannot solve field access ExecHandleState.FAILED
Cannot solve field access ExecHandleState.DETACHED
Cannot solve field access ExecHandleState.DETACHED
Cannot solve field access ExecHandleState.STARTED
Cannot solve field access ExecHandleState.SUCCEEDED
Cannot solve field access ExecHandleState.FAILED
Cannot solve field access ExecHandleState.ABORTED
Cannot solve field access ExecHandleState.FAILED
Cannot resolve field access null
Cannot resolve field access null
Cannot solve field access ResourceOperation.Type.upload
Cannot solve method call createResourceOperation(destination.toString(), ResourceOperation.Type.upload, getClass(), resource.getContentLength()) java.lang.RuntimeException: Method 'getContentLength' cannot be resolved in context resource.getContentLength() (line: 36) MethodCallExprContext{wrapped=resource.getContentLength()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/resource/transfer/ProgressLoggingExternalResourceUploader.java
Cannot solve method call String.format("%s/%s %sed", getLengthText(totalProcessedBytes), contentLengthString, operationType) java.lang.RuntimeException: Method 'getLengthText' cannot be resolved in context getLengthText(totalProcessedBytes) (line: 62) MethodCallExprContext{wrapped=getLengthText(totalProcessedBytes)}. Parameter types: [PrimitiveTypeUsage{name='long'}] /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/resource/transfer/ResourceOperation.java
Cannot solve method call LOGGER.info("Found locally available resource with matching checksum: [{}, {}]", location, local.getFile()) java.lang.RuntimeException: Method 'getFile' cannot be resolved in context local.getFile() (line: 124) MethodCallExprContext{wrapped=local.getFile()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/resource/transfer/DefaultCacheAwareExternalResourceAccessor.java
Cannot resolve field access null
Cannot solve field access ResourceOperation.Type.download
Method 'getMetaData' cannot be resolved in context resource.getMetaData() (line: 55) MethodCallExprContext{wrapped=resource.getMetaData()}. Parameter types: []
Cannot solve method call createResourceOperation(location.toString(), ResourceOperation.Type.download, getClass(), resource.getMetaData().getContentLength()) java.lang.RuntimeException: Method 'getMetaData' cannot be resolved in context resource.getMetaData() (line: 55) MethodCallExprContext{wrapped=resource.getMetaData()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/resource/transfer/ProgressLoggingExternalResourceAccessor.java
Cannot solve method call cacheLockingManager.useCache(operationName("lookup from"), new Factory<V>() {

    public V create() {
        V found = getPersistentCache().get(key);
        if (found == null) {
            return null;
        } else if (found.isMissing() || found.getCachedFile().exists()) {
            return found;
        } else {
            clear(key);
            return null;
        }
    }
}) java.lang.RuntimeException: Method 'operationName' cannot be resolved in context operationName("lookup from") (line: 61) MethodCallExprContext{wrapped=operationName("lookup from")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/resource/cached/ivy/AbstractCachedIndex.java
Cannot solve method call cacheLockingManager.useCache(operationName("store into"), new Runnable() {

    public void run() {
        getPersistentCache().put(key, entry);
    }
}) java.lang.RuntimeException: Method 'operationName' cannot be resolved in context operationName("store into") (line: 77) MethodCallExprContext{wrapped=operationName("store into")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/resource/cached/ivy/AbstractCachedIndex.java
Cannot solve method call cacheLockingManager.useCache(operationName("clear from"), new Runnable() {

    public void run() {
        getPersistentCache().remove(key);
    }
}) java.lang.RuntimeException: Method 'operationName' cannot be resolved in context operationName("clear from") (line: 98) MethodCallExprContext{wrapped=operationName("clear from")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/resource/cached/ivy/AbstractCachedIndex.java
Cannot solve field access State.Unknown
Cannot solve field access State.Match
Cannot solve field access State.NoMatch
Cannot solve field access State.Match
Cannot solve field access State.Unknown
Cannot solve field access State.Unknown
Cannot solve field access State.Failed
Cannot solve field access State.Unknown
Cannot solve field access State.Unknown
Cannot solve field access State.Resolved
Cannot solve field access State.Missing
Cannot solve field access State.Failed
Cannot solve field access State.Unknown
Cannot solve field access State.Failed
Cannot solve field access State.Resolved
Cannot solve method call attempted(location.getDisplayName()) java.lang.RuntimeException: Method 'getDisplayName' cannot be resolved in context location.getDisplayName() (line: 36) MethodCallExprContext{wrapped=location.getDisplayName()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/resolve/result/DefaultResourceAwareResolveResult.java
Cannot solve field access State.Unknown
Cannot solve field access State.Unknown
Cannot solve field access State.Listed
Cannot solve field access State.Failed
Cannot solve method call builder.append(String.format("Could not find any version that matches %s.", selector)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.api.artifacts.ModuleVersionSelector, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/resolve/ModuleVersionNotFoundException.java
Cannot solve method call builder.append(String.format("%nVersions that do not match:")) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/resolve/ModuleVersionNotFoundException.java
Cannot solve method call builder.append(String.format("%nVersions rejected by component selection rules:")) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/resolve/ModuleVersionNotFoundException.java
Cannot solve method call builder.append(String.format("Could not find any matches for %s as no versions of %s:%s are available.", selector, selector.getGroup(), selector.getName())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.api.artifacts.ModuleVersionSelector, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/resolve/ModuleVersionNotFoundException.java
Cannot solve method call builder.append(String.format("Could not find %s.", id)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.api.artifacts.ModuleVersionIdentifier, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/resolve/ModuleVersionNotFoundException.java
Cannot solve method call builder.append(String.format("%n    %s", iterator.next())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/resolve/ModuleVersionNotFoundException.java
Cannot solve method call builder.append(String.format("%n    + %d more", values.size() - count)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, PrimitiveTypeUsage{name='int'}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/resolve/ModuleVersionNotFoundException.java
Cannot solve method call builder.append(String.format("%nSearched in the following locations:")) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/resolve/ModuleVersionNotFoundException.java
Cannot solve method call builder.append(String.format("%n    %s", location)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/resolve/ModuleVersionNotFoundException.java
Cannot solve method call builder.append(String.format("Could not find %s.", artifact.getDisplayName())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/resolve/ArtifactNotFoundException.java
Cannot solve method call builder.append(String.format("%nSearched in the following locations:")) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/resolve/ArtifactNotFoundException.java
Cannot solve method call String.format("%n    %s", location.replace("%", "%%")) java.lang.RuntimeException: Method 'replace' cannot be resolved in context location.replace("%", "%%") (line: 33) MethodCallExprContext{wrapped=location.replace("%", "%%")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/resolve/ArtifactNotFoundException.java
Cannot solve method call builder.append(String.format("%n    %s", location.replace("%", "%%"))) java.lang.RuntimeException: Error calculating the type of parameter location.replace("%", "%%") of method call String.format("%n    %s", location.replace("%", "%%")) /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/resolve/ArtifactNotFoundException.java
Cannot solve method call copy.setStackTrace(getStackTrace()) java.lang.RuntimeException: Method 'getStackTrace' cannot be resolved in context getStackTrace() (line: 100) MethodCallExprContext{wrapped=getStackTrace()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/resolve/ModuleVersionResolveException.java
Cannot solve method call formatter.format("%s%nRequired by:", super.getMessage()) java.lang.RuntimeException: Method 'getMessage' cannot be resolved in context super.getMessage() (line: 110) MethodCallExprContext{wrapped=super.getMessage()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/resolve/ModuleVersionResolveException.java
Cannot solve method call formatter.format("%n    %s", toString(path.get(0))) java.lang.UnsupportedOperationException: org.gradle.api.artifacts.component.ComponentIdentifier ? extends org.gradle.api.artifacts.component.ComponentIdentifier /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/resolve/ModuleVersionResolveException.java
Cannot solve method call formatter.format(" > %s", toString(path.get(i))) java.lang.UnsupportedOperationException: org.gradle.api.artifacts.component.ComponentIdentifier ? extends org.gradle.api.artifacts.component.ComponentIdentifier /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/resolve/ModuleVersionResolveException.java
Method 'getConstructor' cannot be resolved in context getClass().getConstructor(ComponentSelector.class, String.class) (line: 126) MethodCallExprContext{wrapped=getClass().getConstructor(ComponentSelector.class, String.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.artifacts.component.ComponentSelector, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call Collections.singleton(org.gradle.api.artifacts.Dependency.DEFAULT_CONFIGURATION) UnsolvedSymbolException{context='unknown', name='DEFAULT_CONFIGURATION', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/component/external/descriptor/MutableModuleDescriptorState.java
Cannot solve method call moduleDescriptorState.addArtifact(artifactName, Collections.singleton(org.gradle.api.artifacts.Dependency.DEFAULT_CONFIGURATION)) java.lang.RuntimeException: Error calculating the type of parameter org.gradle.api.artifacts.Dependency.DEFAULT_CONFIGURATION of method call Collections.singleton(org.gradle.api.artifacts.Dependency.DEFAULT_CONFIGURATION) /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/component/external/descriptor/MutableModuleDescriptorState.java
Cannot solve method call Collections.singleton(org.gradle.api.artifacts.Dependency.DEFAULT_CONFIGURATION) UnsolvedSymbolException{context='unknown', name='DEFAULT_CONFIGURATION', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/component/external/descriptor/MutableModuleDescriptorState.java
Cannot solve method call moduleDescriptorState.addArtifact(defaultArtifact, Collections.singleton(org.gradle.api.artifacts.Dependency.DEFAULT_CONFIGURATION)) java.lang.RuntimeException: Error calculating the type of parameter org.gradle.api.artifacts.Dependency.DEFAULT_CONFIGURATION of method call Collections.singleton(org.gradle.api.artifacts.Dependency.DEFAULT_CONFIGURATION) /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/component/external/descriptor/MutableModuleDescriptorState.java
Method 'substring' cannot be resolved in context conf2.substring(1) (line: 325) MethodCallExprContext{wrapped=conf2.substring(1)}. Parameter types: [PrimitiveTypeUsage{name='int'}]
Cannot solve method call targetPattern.substring(startFallback + 1, targetPattern.length() - 1) java.lang.RuntimeException: Method 'length' cannot be resolved in context targetPattern.length() (line: 153) MethodCallExprContext{wrapped=targetPattern.length()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/component/external/model/IvyDependencyMetadata.java
Cannot solve method call version.substring(1, version.length() - 1) java.lang.RuntimeException: Method 'length' cannot be resolved in context version.length() (line: 100) MethodCallExprContext{wrapped=version.length()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/component/external/model/DefaultIvyModulePublishMetadata.java
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
Cannot solve field access MavenScope.Test
Cannot solve field access MavenScope.System
Cannot solve method call result.add(findTargetConfiguration(fromComponent, fromConfiguration, targetComponent, "compile")) java.lang.RuntimeException: Method 'findTargetConfiguration' cannot be resolved in context findTargetConfiguration(fromComponent, fromConfiguration, targetComponent, "compile") (line: 107) MethodCallExprContext{wrapped=findTargetConfiguration(fromComponent, fromConfiguration, targetComponent, "compile")}. Parameter types: [ReferenceType{org.gradle.internal.component.model.ComponentResolveMetadata, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.internal.component.model.ConfigurationMetadata, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.internal.component.model.ComponentResolveMetadata, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/component/external/model/MavenDependencyMetadata.java
Cannot solve method call String.format("%s declares a dependency from configuration '%s' to configuration '%s' which is not declared in the descriptor for %s.", StringUtils.capitalize(fromComponent.getDisplayName()), fromConfiguration, toConfiguration, toComponent.getDisplayName()) UnsolvedSymbolException{context='Method 'capitalize' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=org.apache.commons.lang.StringUtils}'} /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/component/model/ConfigurationNotFoundException.java
Cannot solve method call Sets.newTreeSet(Lists.transform(candidateConfigurations, CONFIG_NAME)) UnsolvedSymbolException{context='Method 'transform' with parameterTypes [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{org.gradle.internal.component.model.ConfigurationMetadata, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{Function, typeParametersMap=TypeParametersMap{nameToValue={empty.Equivalence.Wrapper<Method>=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, empty.Method=ReferenceType{org.gradle.internal.component.model.ConfigurationMetadata, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Lists}'} /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/component/model/LocalComponentDependencyMetadata.java
Method 'append' cannot be resolved in context result.append(" (") (line: 44) MethodCallExprContext{wrapped=result.append(" (")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context result.append(" (") (line: 44) MethodCallExprContext{wrapped=result.append(" (")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call artifacts.addAll(allArtifacts.get(config)) java.lang.RuntimeException: Method 'get' cannot be resolved in context allArtifacts.get(config) (line: 255) MethodCallExprContext{wrapped=allArtifacts.get(config)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/component/local/model/DefaultLocalComponentMetadata.java
Cannot solve method call String.format(VALID_SINGLE_TYPES, inputType.getName(), className(validInputTypes.get(0))) java.lang.RuntimeException: Method 'getName' cannot be resolved in context inputType.getName() (line: 50) MethodCallExprContext{wrapped=inputType.getName()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/rules/DefaultRuleActionValidator.java
Cannot solve method call String.format(VALID_MULTIPLE_TYPES, inputType.getName(), CollectionUtils.collect(validInputTypes, new ClassNameTransformer())) java.lang.RuntimeException: Method 'getName' cannot be resolved in context inputType.getName() (line: 52) MethodCallExprContext{wrapped=inputType.getName()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/rules/DefaultRuleActionValidator.java
Cannot solve method call parseInputTypes(closure) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/rules/ClosureBackedRuleAction.java
Cannot resolve field access null
Cannot solve method call copy.setResolveStrategy(Closure.DELEGATE_FIRST) UnsolvedSymbolException{context='unknown', name='DELEGATE_FIRST', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/rules/ClosureBackedRuleAction.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot resolve field access null
Cannot solve method call String.format("First parameter of rule action closure must be of type '%s'.", subjectType.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context subjectType.getSimpleName() (line: 68) MethodCallExprContext{wrapped=subjectType.getSimpleName()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/rules/ClosureBackedRuleAction.java
Cannot resolve field access null
Cannot solve method call element.isAnnotationPresent(Mutate.class) java.lang.UnsupportedOperationException /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/rules/RuleSourceBackedRuleAction.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call problems.add(ruleMethod, String.format("First parameter of a rule method must be of type %s", subjectType)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.model.internal.type.ModelType, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.type.ModelType.T=TypeVariable {org.gradle.internal.rules.RuleSourceBackedRuleAction.create(org.gradle.model.internal.type.ModelType<T>, R).T}}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/dependency-management/src/main/java/org/gradle/internal/rules/RuleSourceBackedRuleAction.java
Cannot resolve field access null
Cannot solve method call IoActions.withResource(ImplementationDependencyRelocator.class.getResourceAsStream(type.getIdentifier() + "-relocated.txt"), new ErroringAction<InputStream>() {

    @Override
    protected void doExecute(InputStream thing) throws Exception {
        BufferedReader reader = new BufferedReader(new InputStreamReader(thing, Charset.forName("UTF-8")));
        String line;
        while ((line = reader.readLine()) != null) {
            line = line.trim();
            if (line.length() > 0) {
                builder.addWord(line);
            }
        }
    }
}) java.lang.RuntimeException: Method 'getResourceAsStream' cannot be resolved in context ImplementationDependencyRelocator.class.getResourceAsStream(type.getIdentifier() + "-relocated.txt") (line: 37) MethodCallExprContext{wrapped=ImplementationDependencyRelocator.class.getResourceAsStream(type.getIdentifier() + "-relocated.txt")}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/runtimeshaded/ImplementationDependencyRelocator.java
Method 'substring' cannot be resolved in context literal.substring(6) (line: 90) MethodCallExprContext{wrapped=literal.substring(6)}. Parameter types: [PrimitiveTypeUsage{name='int'}]
Cannot solve method call maybeRelocateResource(className.replace('.', '/')) java.lang.RuntimeException: Method 'replace' cannot be resolved in context className.replace('.', '/') (line: 91) MethodCallExprContext{wrapped=className.replace('.', '/')}. Parameter types: [PrimitiveTypeUsage{name='char'}, PrimitiveTypeUsage{name='char'}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/runtimeshaded/ImplementationDependencyRelocator.java
Cannot solve method call allProviders.getBytes(Charsets.UTF_8) UnsolvedSymbolException{context='unknown', name='UTF_8', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/runtimeshaded/RuntimeShadedJarCreator.java
Cannot solve method call writeEntry(outputStream, SERVICES_DIR_PREFIX + service.getKey(), allProviders.getBytes(Charsets.UTF_8)) java.lang.RuntimeException: Error calculating the type of parameter Charsets.UTF_8 of method call allProviders.getBytes(Charsets.UTF_8) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/runtimeshaded/RuntimeShadedJarCreator.java
Cannot solve method call zipEntry.getName().substring(SERVICES_DIR_PREFIX.length()) java.lang.RuntimeException: Method 'length' cannot be resolved in context SERVICES_DIR_PREFIX.length() (line: 226) MethodCallExprContext{wrapped=SERVICES_DIR_PREFIX.length()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/runtimeshaded/RuntimeShadedJarCreator.java
Method 'replaceAll' cannot be resolved in context new String(bytes, Charsets.UTF_8).replaceAll("(?m)^#.*", "") (line: 234) MethodCallExprContext{wrapped=new String(bytes, Charsets.UTF_8).replaceAll("(?m)^#.*", "")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call services.put(serviceType, Lists.newArrayList(serviceProvider)) UnsolvedSymbolException{context='Method 'newArrayList' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Lists}'} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/runtimeshaded/RuntimeShadedJarCreator.java
Cannot resolve field access null
Cannot solve method call classReader.accept(remappingVisitor, ClassReader.EXPAND_FRAMES) UnsolvedSymbolException{context='unknown', name='EXPAND_FRAMES', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/runtimeshaded/RuntimeShadedJarCreator.java
Cannot resolve field access null
Cannot solve method call remappedClassLiterals.put(remapping.getLiteral(), remapping.getLiteralReplacement().replace("/", ".")) java.lang.RuntimeException: Method 'replace' cannot be resolved in context remapping.getLiteralReplacement().replace("/", ".") (line: 368) MethodCallExprContext{wrapped=remapping.getLiteralReplacement().replace("/", ".")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/runtimeshaded/RuntimeShadedJarCreator.java
Cannot solve method call remapper.maybeRelocateResource(((String) cst).replace('.', '/')) java.lang.RuntimeException: Method 'replace' cannot be resolved in context ((String) cst).replace('.', '/') (line: 387) MethodCallExprContext{wrapped=((String) cst).replace('.', '/')}. Parameter types: [PrimitiveTypeUsage{name='char'}, PrimitiveTypeUsage{name='char'}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/runtimeshaded/RuntimeShadedJarCreator.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Method 'append' cannot be resolved in context sb.append(c) (line: 43) MethodCallExprContext{wrapped=sb.append(c)}. Parameter types: [PrimitiveTypeUsage{name='char'}]
Method 'append' cannot be resolved in context sb.append(transition.c) (line: 46) MethodCallExprContext{wrapped=sb.append(transition.c)}. Parameter types: [PrimitiveTypeUsage{name='char'}]
Cannot solve method call buffer.setLength(buffer.length() - 1) java.lang.RuntimeException: Method 'length' cannot be resolved in context buffer.length() (line: 96) MethodCallExprContext{wrapped=buffer.length()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/runtimeshaded/Trie.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve field access InternalState.UNRESOLVED
Cannot solve field access InternalState.UNRESOLVED
Cannot solve field access MutationType.DEPENDENCIES
Cannot solve field access MutationType.ARTIFACTS
Cannot solve field access InternalState.RESULTS_RESOLVED
Cannot solve field access InternalState.TASK_DEPENDENCIES_RESOLVED
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve field access MutationType.DEPENDENCIES
Cannot solve field access MutationType.DEPENDENCIES
Cannot solve field access MutationType.DEPENDENCIES
Cannot solve field access MutationType.DEPENDENCIES
Cannot solve field access MutationType.DEPENDENCIES
No matching between ReferenceType{org.gradle.api.artifacts.Dependency, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual)
Cannot solve field access InternalState.RESULTS_RESOLVED
Cannot solve field access InternalState.TASK_DEPENDENCIES_RESOLVED
Cannot solve field access InternalState.RESULTS_RESOLVED
Cannot solve field access InternalState.RESULTS_RESOLVED
Cannot solve field access InternalState.RESULTS_RESOLVED
Cannot solve field access InternalState.TASK_DEPENDENCIES_RESOLVED
Cannot solve field access InternalState.RESULTS_RESOLVED
Cannot solve field access InternalState.TASK_DEPENDENCIES_RESOLVED
Cannot solve field access InternalState.RESULTS_RESOLVED
Cannot solve field access InternalState.RESULTS_RESOLVED
Cannot solve field access InternalState.TASK_DEPENDENCIES_RESOLVED
Cannot solve field access MutationType.DEPENDENCIES
Cannot solve field access MutationType.DEPENDENCIES
Cannot solve method call ClosureBackedAction.of(closure) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/configurations/DefaultConfiguration.java
Cannot solve method call resolutionStrategy(ClosureBackedAction.of(closure)) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/configurations/DefaultConfiguration.java
Cannot solve field access MutationType.STRATEGY
Cannot solve field access InternalState.RESULTS_RESOLVED
Cannot solve field access InternalState.TASK_DEPENDENCIES_RESOLVED
Cannot solve field access MutationType.DEPENDENCIES
Cannot solve field access InternalState.RESULTS_RESOLVED
Cannot solve field access InternalState.TASK_DEPENDENCIES_RESOLVED
Cannot solve field access InternalState.TASK_DEPENDENCIES_RESOLVED
Cannot solve field access InternalState.RESULTS_RESOLVED
Cannot solve field access MutationType.STRATEGY
Cannot solve field access MutationType.STRATEGY
Cannot resolve field access null
Cannot solve field access MutationType.ATTRIBUTES
Cannot solve field access MutationType.ATTRIBUTES
Cannot solve field access InternalState.RESULTS_RESOLVED
Cannot resolve field access null
Method 'substring' cannot be resolved in context configurationName.substring(0, 1) (line: 38) MethodCallExprContext{wrapped=configurationName.substring(0, 1)}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}]
Cannot solve method call resolveProjectDependencies(context, dependencies.withType(ProjectDependency.class)) java.lang.RuntimeException: Method 'withType' cannot be resolved in context dependencies.withType(ProjectDependency.class) (line: 42) MethodCallExprContext{wrapped=dependencies.withType(ProjectDependency.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.artifacts.ProjectDependency, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/configurations/TasksFromProjectDependencies.java
Cannot solve method call CollectionUtils.collect(repositoryHandler, Transformers.cast(ResolutionAwareRepository.class)) UnsolvedSymbolException{context='Method 'cast' with parameterTypes [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.internal.artifacts.repositories.ResolutionAwareRepository, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * Utility transformers.
 */
public abstract class Transformers {

    /**
     * Creates a transformer that simply type casts the input to the given output type.
     *
     * @param outputType The type to cast the input to
     * @param <O> The type of the transformed object
     * @param <I> The type of the object to be transformed
     * @return A transformer that simply type casts the input to the given output type.
     */
    public static <O, I> Transformer<O, I> cast(Class<O> outputType) {
        return new CastingTransformer<O, I>(outputType);
    }

    // just returns the original object
    public static <T> Transformer<T, T> noOpTransformer() {
        return new Transformer<T, T>() {

            public T transform(T original) {
                return original;
            }
        };
    }

    private static class CastingTransformer<O, I> implements Transformer<O, I> {

        final Class<O> outputType;

        public CastingTransformer(Class<O> outputType) {
            this.outputType = outputType;
        }

        public O transform(I input) {
            return Cast.cast(outputType, input);
        }
    }

    public static <T> Transformer<String, T> asString() {
        return new ToStringTransformer<T>();
    }

    private static class ToStringTransformer<T> implements Transformer<String, T> {

        public String transform(T original) {
            return original == null ? null : original.toString();
        }
    }

    /**
     * Returns a transformer that names {@link Named} objects.
     *
     * Nulls are returned as null.
     *
     * @return The naming transformer.
     */
    public static Transformer<String, Named> name() {
        return name(Named.Namer.INSTANCE);
    }

    /**
     * Returns a transformer that names objects with the given {@link Namer}
     *
     * @param namer The namer to name the objects with
     * @param <T> The type of objects to be named
     * @return The naming transformer.
     */
    public static <T> Transformer<String, T> name(Namer<? super T> namer) {
        return new ToNameTransformer<T>(namer);
    }

    private static class ToNameTransformer<T> implements Transformer<String, T> {

        private final Namer<? super T> namer;

        public ToNameTransformer(Namer<? super T> namer) {
            this.namer = namer;
        }

        public String transform(T thing) {
            return thing == null ? null : namer.determineName(thing);
        }
    }

    /**
     * Transforms strings which may have spaces and which may have already been escaped with
     * quotes into safe command-line arguments.
     */
    public static Transformer<String, String> asSafeCommandLineArgument() {
        return new CommandLineArgumentTransformer();
    }

    private static class CommandLineArgumentTransformer implements Transformer<String, String> {

        private static final Pattern SINGLE_QUOTED = Pattern.compile("^'.*'$");

        private static final Pattern DOUBLE_QUOTED = Pattern.compile("^\".*\"$");

        private static final Pattern A_SINGLE_QUOTE = Pattern.compile("'");

        @Override
        public String transform(String input) {
            if (SINGLE_QUOTED.matcher(input).matches() || DOUBLE_QUOTED.matcher(input).matches() || !input.contains(" ")) {
                return input;
            } else {
                return wrapWithSingleQuotes(input);
            }
        }

        private String wrapWithSingleQuotes(String input) {
            return String.format("'%1$s'", escapeSingleQuotes(input));
        }

        private String escapeSingleQuotes(String input) {
            return A_SINGLE_QUOTE.matcher(input).replaceAll("\\\\'");
        }
    }

    /**
     * A getClass() transformer.
     *
     * @param <T> The type of the object
     * @return A getClass() transformer.
     */
    public static <T> Transformer<Class<T>, T> type() {
        return new Transformer<Class<T>, T>() {

            public Class<T> transform(T original) {
                @SuppressWarnings("unchecked") Class<T> aClass = (Class<T>) original.getClass();
                return aClass;
            }
        };
    }

    public static <R> Transformer<R, Object> toTransformer(final Factory<R> factory) {
        return new Transformer<R, Object>() {

            public R transform(Object original) {
                return factory.create();
            }
        };
    }

    public static <R, I> Transformer<R, I> toTransformer(final Action<? super I> action) {
        return new Transformer<R, I>() {

            public R transform(I original) {
                action.execute(original);
                return null;
            }
        };
    }

    /**
     * Converts a URL to a URI
     */
    public static Transformer<URL, URI> toURL() {
        return new Transformer<URL, URI>() {

            public URL transform(URI original) {
                try {
                    return original.toURL();
                } catch (MalformedURLException e) {
                    throw UncheckedException.throwAsUncheckedException(e);
                }
            }
        };
    }

    /**
     * Always returns the given argument.
     */
    public static <T, I> Transformer<T, I> constant(final T t) {
        return new Transformer<T, I>() {

            public T transform(I original) {
                return t;
            }
        };
    }
}}'} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/query/DefaultArtifactResolutionQuery.java
Index: 0, Size: 0
Cannot solve method call resolvePlaceholders(repoPath.trim()) java.lang.RuntimeException: Method 'trim' cannot be resolved in context repoPath.trim() (line: 52) MethodCallExprContext{wrapped=repoPath.trim()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/mvnsettings/DefaultLocalMavenRepositoryLocator.java
Cannot solve method call system.getEnv(placeholder.substring(4)) java.lang.RuntimeException: Method 'substring' cannot be resolved in context placeholder.substring(4) (line: 79) MethodCallExprContext{wrapped=placeholder.substring(4)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/mvnsettings/DefaultLocalMavenRepositoryLocator.java
Cannot solve method call matcher.appendReplacement(result, Matcher.quoteReplacement(replacement)) UnsolvedSymbolException{context='Method 'quoteReplacement' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=java.util.regex.Matcher}'} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/mvnsettings/DefaultLocalMavenRepositoryLocator.java
Cannot solve method call settingsBuildingRequest.setUserSettingsFile(mavenFileLocations.getUserSettingsFile()) java.lang.RuntimeException: Method 'getUserSettingsFile' cannot be resolved in context mavenFileLocations.getUserSettingsFile() (line: 34) MethodCallExprContext{wrapped=mavenFileLocations.getUserSettingsFile()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/mvnsettings/DefaultMavenSettingsProvider.java
Cannot solve method call settingsBuildingRequest.setGlobalSettingsFile(mavenFileLocations.getGlobalSettingsFile()) java.lang.RuntimeException: Method 'getGlobalSettingsFile' cannot be resolved in context mavenFileLocations.getGlobalSettingsFile() (line: 35) MethodCallExprContext{wrapped=mavenFileLocations.getGlobalSettingsFile()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/mvnsettings/DefaultMavenSettingsProvider.java
Method 'resolveFiles' cannot be resolved in context fileResolver.resolveFiles(dirs) (line: 60) MethodCallExprContext{wrapped=fileResolver.resolveFiles(dirs)}. Parameter types: [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getCredentialsPublicType' cannot be resolved in context getCredentialsPublicType(credentials.getClass()) (line: 65) MethodCallExprContext{wrapped=getCredentialsPublicType(credentials.getClass())}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}]
Cannot solve method call String.format("Given credentials type '%s' does not match actual type '%s'", credentialsType.getName(), getCredentialsPublicType(credentials.getClass()).getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context credentialsType.getName() (line: 65) MethodCallExprContext{wrapped=credentialsType.getName()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/AuthenticationSupporter.java
Cannot solve method call String.format("Unknown credentials type: '%s' (supported types: %s and %s).", publicType.getName(), PasswordCredentials.class.getName(), AwsCredentials.class.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context publicType.getName() (line: 139) MethodCallExprContext{wrapped=publicType.getName()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/AuthenticationSupporter.java
Cannot solve method call String.format("Unknown credentials implementation type: '%s' (supported types: %s and %s).", implType.getName(), DefaultPasswordCredentials.class.getName(), DefaultAwsCredentials.class.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context implType.getName() (line: 149) MethodCallExprContext{wrapped=implType.getName()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/AuthenticationSupporter.java
Method 'getRegisteredSchemes' cannot be resolved in context authenticationSchemeRegistry.getRegisteredSchemes() (line: 113) MethodCallExprContext{wrapped=authenticationSchemeRegistry.getRegisteredSchemes()}. Parameter types: []
Cannot solve method call validSchemes.addAll(registeredProtocol.getSupportedProtocols()) java.lang.RuntimeException: Method 'getSupportedProtocols' cannot be resolved in context registeredProtocol.getSupportedProtocols() (line: 73) MethodCallExprContext{wrapped=registeredProtocol.getSupportedProtocols()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/transport/RepositoryTransportFactory.java
Method 'getSupportedProtocols' cannot be resolved in context protocolRegistration.getSupportedProtocols() (line: 148) MethodCallExprContext{wrapped=protocolRegistration.getSupportedProtocols()}. Parameter types: []
Cannot solve method call String.format("Credentials must be an instance of '%s'.", type.getCanonicalName()) java.lang.RuntimeException: Method 'getCanonicalName' cannot be resolved in context type.getCanonicalName() (line: 176) MethodCallExprContext{wrapped=type.getCanonicalName()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/transport/RepositoryTransportFactory.java
Cannot solve method call mavenMetadataLoader.load(metadataLocation.getUri()) java.lang.RuntimeException: Method 'getUri' cannot be resolved in context metadataLocation.getUri() (line: 47) MethodCallExprContext{wrapped=metadataLocation.getUri()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/MavenVersionLister.java
Cannot solve field access ArtifactType.IVY_DESCRIPTOR
Cannot solve method call result.resolved(findOptionalArtifacts(module, "javadoc", "javadoc")) java.lang.RuntimeException: Method 'findOptionalArtifacts' cannot be resolved in context findOptionalArtifacts(module, "javadoc", "javadoc") (line: 154) MethodCallExprContext{wrapped=findOptionalArtifacts(module, "javadoc", "javadoc")}. Parameter types: [ReferenceType{org.gradle.internal.component.external.model.IvyModuleResolveMetadata, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/IvyResolver.java
Cannot solve method call result.resolved(findOptionalArtifacts(module, "source", "sources")) java.lang.RuntimeException: Method 'findOptionalArtifacts' cannot be resolved in context findOptionalArtifacts(module, "source", "sources") (line: 160) MethodCallExprContext{wrapped=findOptionalArtifacts(module, "source", "sources")}. Parameter types: [ReferenceType{org.gradle.internal.component.external.model.IvyModuleResolveMetadata, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/IvyResolver.java
Cannot solve method call repository.getResourceMetaData(location.getUri(), true) java.lang.RuntimeException: Method 'getUri' cannot be resolved in context location.getUri() (line: 80) MethodCallExprContext{wrapped=location.getUri()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/DefaultExternalResourceArtifactResolver.java
Cannot solve method call resourceAccessor.getResource(location.getUri(), new CacheAwareExternalResourceAccessor.ResourceFileStore() {

    public LocallyAvailableResource moveIntoCache(File downloadedResource) {
        return fileStore.move(artifact.getId(), downloadedResource);
    }
}, localCandidates) java.lang.RuntimeException: Method 'getUri' cannot be resolved in context location.getUri() (line: 97) MethodCallExprContext{wrapped=location.getUri()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/DefaultExternalResourceArtifactResolver.java
Cannot solve method call "metadata/versioning/snapshot/timestamp".equals(getContext()) java.lang.RuntimeException: Method 'getContext' cannot be resolved in context getContext() (line: 75) MethodCallExprContext{wrapped=getContext()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/MavenMetadataLoader.java
Cannot solve method call "metadata/versioning/snapshot/buildNumber".equals(getContext()) java.lang.RuntimeException: Method 'getContext' cannot be resolved in context getContext() (line: 78) MethodCallExprContext{wrapped=getContext()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/MavenMetadataLoader.java
Cannot solve method call "metadata/versioning/versions/version".equals(getContext()) java.lang.RuntimeException: Method 'getContext' cannot be resolved in context getContext() (line: 81) MethodCallExprContext{wrapped=getContext()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/MavenMetadataLoader.java
Method 'getText' cannot be resolved in context getText() (line: 82) MethodCallExprContext{wrapped=getText()}. Parameter types: []
Cannot solve method call mavenMetadata.versions.add(getText().trim()) java.lang.RuntimeException: Method 'getText' cannot be resolved in context getText() (line: 82) MethodCallExprContext{wrapped=getText()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/MavenMetadataLoader.java
Cannot solve method call artifactSet.add(DefaultIvyArtifactName.of(moduleName, "jar", "jar")) UnsolvedSymbolException{context='Method 'of' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=public class DefaultIvyArtifactName implements IvyArtifactName {

    private static final Interner<DefaultIvyArtifactName> INSTANCES_INTERNER = Interners.newWeakInterner();

    private final String name;

    private final String type;

    private final String extension;

    private final String classifier;

    private String displayName;

    private int hashCode;

    public static DefaultIvyArtifactName forPublishArtifact(PublishArtifact publishArtifact) {
        String name = publishArtifact.getName();
        if (name == null) {
            name = publishArtifact.getFile().getName();
        }
        String classifier = GUtil.elvis(publishArtifact.getClassifier(), null);
        return of(name, publishArtifact.getType(), publishArtifact.getExtension(), classifier);
    }

    private DefaultIvyArtifactName(String name, String type, @Nullable String extension, @Nullable String classifier) {
        this.name = name;
        this.type = type;
        this.extension = extension;
        this.classifier = classifier;
        this.hashCode = calculateHashCode();
    }

    public static DefaultIvyArtifactName of(String name, String type, @Nullable String extension, @Nullable String classifier) {
        DefaultIvyArtifactName instance = new DefaultIvyArtifactName(name, type, extension, classifier);
        return INSTANCES_INTERNER.intern(instance);
    }

    public static DefaultIvyArtifactName of(String name, String type, @Nullable String extension) {
        return of(name, type, extension, null);
    }

    @Override
    public String toString() {
        if (displayName == null) {
            displayName = createDisplayName();
        }
        return displayName;
    }

    protected String createDisplayName() {
        StringBuilder result = new StringBuilder();
        result.append(name);
        if (GUtil.isTrue(classifier)) {
            result.append("-");
            result.append(classifier);
        }
        if (GUtil.isTrue(extension)) {
            result.append(".");
            result.append(extension);
        }
        return result.toString();
    }

    @Override
    public int hashCode() {
        return hashCode;
    }

    private int calculateHashCode() {
        return Objects.hashCode(name, type, extension, classifier);
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj == null || obj.getClass() != getClass()) {
            return false;
        }
        DefaultIvyArtifactName other = (DefaultIvyArtifactName) obj;
        if (hashCode() != other.hashCode()) {
            return false;
        }
        return equal(name, other.name) && equal(type, other.type) && equal(extension, other.extension) && equal(classifier, other.classifier);
    }

    public String getName() {
        return name;
    }

    public String getType() {
        return type;
    }

    public String getExtension() {
        return extension;
    }

    public String getClassifier() {
        return classifier;
    }
}}'} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/ExternalResourceResolver.java
Cannot solve method call String.format("inconsistent module metadata found. Descriptor: %s Errors: %s", metadata.getId(), Joiner.on(SystemProperties.getInstance().getLineSeparator()).join(errors)) UnsolvedSymbolException{context='Method 'on' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=Joiner}'} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/ExternalResourceResolver.java
Method 'getLocalResource' cannot be resolved in context artifactResource.getLocalResource() (line: 291) MethodCallExprContext{wrapped=artifactResource.getLocalResource()}. Parameter types: []
Cannot solve field access ArtifactType.JAVADOC
Cannot solve field access ArtifactType.SOURCES
Cannot solve method call maybeSubstituteTimestamp(artifact, getBase().getPath()) java.lang.RuntimeException: Method 'getPath' cannot be resolved in context getBase().getPath() (line: 45) MethodCallExprContext{wrapped=getBase().getPath()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/M2ResourcePattern.java
Method 'getRoot' cannot be resolved in context getBase().getRoot() (line: 46) MethodCallExprContext{wrapped=getBase().getRoot()}. Parameter types: []
Method 'replaceFirst' cannot be resolved in context pattern.replaceFirst("\\-\\[revision\\]", "-" + snapshotId.getTimestampedVersion()) (line: 52) MethodCallExprContext{wrapped=pattern.replaceFirst("\\-\\[revision\\]", "-" + snapshotId.getTimestampedVersion())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call substituteTokens(getBase().getPath(), attributes) java.lang.RuntimeException: Method 'getPath' cannot be resolved in context getBase().getPath() (line: 61) MethodCallExprContext{wrapped=getBase().getPath()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/M2ResourcePattern.java
Method 'getRoot' cannot be resolved in context getBase().getRoot() (line: 61) MethodCallExprContext{wrapped=getBase().getRoot()}. Parameter types: []
Cannot solve method call pattern.substring(0, pattern.length() - MavenPattern.M2_PER_MODULE_PATTERN.length() - 1) java.lang.RuntimeException: Method 'length' cannot be resolved in context pattern.length() (line: 69) MethodCallExprContext{wrapped=pattern.length()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/M2ResourcePattern.java
Method 'getRoot' cannot be resolved in context getBase().getRoot() (line: 70) MethodCallExprContext{wrapped=getBase().getRoot()}. Parameter types: []
Cannot solve method call pattern.substring(0, pattern.length() - MavenPattern.M2_PER_MODULE_VERSION_PATTERN.length() - 1) java.lang.RuntimeException: Method 'length' cannot be resolved in context pattern.length() (line: 78) MethodCallExprContext{wrapped=pattern.length()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/M2ResourcePattern.java
Method 'getRoot' cannot be resolved in context getBase().getRoot() (line: 79) MethodCallExprContext{wrapped=getBase().getRoot()}. Parameter types: []
Cannot solve method call attributes.get(IvyPatternHelper.ORGANISATION_KEY) UnsolvedSymbolException{context='unknown', name='ORGANISATION_KEY', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/M2ResourcePattern.java
Cannot solve method call attributes.put(IvyPatternHelper.ORGANISATION_KEY, org.replace(".", "/")) UnsolvedSymbolException{context='unknown', name='ORGANISATION_KEY', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/M2ResourcePattern.java
Cannot solve method call attributes.put(IvyPatternHelper.ARTIFACT_KEY, ivyArtifact.getName()) UnsolvedSymbolException{context='unknown', name='ARTIFACT_KEY', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/AbstractResourcePattern.java
Cannot solve method call attributes.put(IvyPatternHelper.TYPE_KEY, ivyArtifact.getType()) UnsolvedSymbolException{context='unknown', name='TYPE_KEY', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/AbstractResourcePattern.java
Cannot solve method call attributes.put(IvyPatternHelper.EXT_KEY, ivyArtifact.getExtension()) UnsolvedSymbolException{context='unknown', name='EXT_KEY', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/AbstractResourcePattern.java
Cannot solve method call attributes.put(IvyPatternHelper.ORGANISATION_KEY, module.getGroup()) UnsolvedSymbolException{context='unknown', name='ORGANISATION_KEY', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/AbstractResourcePattern.java
Cannot solve method call attributes.put(IvyPatternHelper.MODULE_KEY, module.getName()) UnsolvedSymbolException{context='unknown', name='MODULE_KEY', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/AbstractResourcePattern.java
Cannot solve method call attributes.put(IvyPatternHelper.ORGANISATION_KEY, componentIdentifier.getGroup()) UnsolvedSymbolException{context='unknown', name='ORGANISATION_KEY', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/AbstractResourcePattern.java
Cannot solve method call attributes.put(IvyPatternHelper.MODULE_KEY, componentIdentifier.getModule()) UnsolvedSymbolException{context='unknown', name='MODULE_KEY', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/AbstractResourcePattern.java
Cannot solve method call attributes.put(IvyPatternHelper.REVISION_KEY, componentIdentifier.getVersion()) UnsolvedSymbolException{context='unknown', name='REVISION_KEY', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/AbstractResourcePattern.java
Cannot solve method call pattern.substring(0, pattern.indexOf(REVISION_TOKEN)) java.lang.RuntimeException: Method 'indexOf' cannot be resolved in context pattern.indexOf(REVISION_TOKEN) (line: 70) MethodCallExprContext{wrapped=pattern.indexOf(REVISION_TOKEN)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/ResourceVersionLister.java
Method 'getRoot' cannot be resolved in context versionListPattern.getRoot() (line: 77) MethodCallExprContext{wrapped=versionListPattern.getRoot()}. Parameter types: []
Cannot solve method call repository.list(parent.getUri()) java.lang.RuntimeException: Method 'getUri' cannot be resolved in context parent.getUri() (line: 83) MethodCallExprContext{wrapped=parent.getUri()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/ResourceVersionLister.java
Method 'getRoot' cannot be resolved in context versionListPattern.getRoot() (line: 72) MethodCallExprContext{wrapped=versionListPattern.getRoot()}. Parameter types: []
Method 'substring' cannot be resolved in context pattern.substring(startToken - 1, startToken) (line: 123) MethodCallExprContext{wrapped=pattern.substring(startToken - 1, startToken)}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}]
Method 'substring' cannot be resolved in context pattern.substring(endToken, endToken + 1) (line: 128) MethodCallExprContext{wrapped=pattern.substring(endToken, endToken + 1)}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}]
Cannot solve method call repository.list(parent.getUri()) java.lang.RuntimeException: Method 'getUri' cannot be resolved in context parent.getUri() (line: 141) MethodCallExprContext{wrapped=parent.getUri()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/ResourceVersionLister.java
Cannot solve field access ArtifactType.MAVEN_POM
Cannot solve method call parseMavenMetadata(metadataLocation.getUri()) java.lang.RuntimeException: Method 'getUri' cannot be resolved in context metadataLocation.getUri() (line: 166) MethodCallExprContext{wrapped=metadataLocation.getUri()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/MavenResolver.java
Cannot solve method call result.resolved(findOptionalArtifacts(module, "javadoc", "javadoc")) java.lang.RuntimeException: Method 'findOptionalArtifacts' cannot be resolved in context findOptionalArtifacts(module, "javadoc", "javadoc") (line: 267) MethodCallExprContext{wrapped=findOptionalArtifacts(module, "javadoc", "javadoc")}. Parameter types: [ReferenceType{org.gradle.internal.component.external.model.MavenModuleResolveMetadata, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/MavenResolver.java
Cannot solve method call result.resolved(findOptionalArtifacts(module, "source", "sources")) java.lang.RuntimeException: Method 'findOptionalArtifacts' cannot be resolved in context findOptionalArtifacts(module, "source", "sources") (line: 272) MethodCallExprContext{wrapped=findOptionalArtifacts(module, "source", "sources")}. Parameter types: [ReferenceType{org.gradle.internal.component.external.model.MavenModuleResolveMetadata, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/MavenResolver.java
Cannot solve method call substituteTokens(getBase().getPath(), attributes) java.lang.RuntimeException: Method 'getPath' cannot be resolved in context getBase().getPath() (line: 45) MethodCallExprContext{wrapped=getBase().getPath()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/IvyResourcePattern.java
Method 'getRoot' cannot be resolved in context getBase().getRoot() (line: 45) MethodCallExprContext{wrapped=getBase().getRoot()}. Parameter types: []
Cannot solve method call substituteTokens(getBase().getPath(), attributes) java.lang.RuntimeException: Method 'getPath' cannot be resolved in context getBase().getPath() (line: 50) MethodCallExprContext{wrapped=getBase().getPath()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/resolver/IvyResourcePattern.java
Method 'getRoot' cannot be resolved in context getBase().getRoot() (line: 50) MethodCallExprContext{wrapped=getBase().getRoot()}. Parameter types: []
Cannot solve method call additionalUrls.addAll(Lists.newArrayList(urls)) UnsolvedSymbolException{context='Method 'newArrayList' with parameterTypes [ResolvedArrayType{ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Lists}'} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/repositories/DefaultMavenArtifactRepository.java
Method 'candidate' cannot be resolved in context visitor.candidate("Maps") (line: 51) MethodCallExprContext{wrapped=visitor.candidate("Maps")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'candidate' cannot be resolved in context visitor.candidate("String or CharSequence values") (line: 62) MethodCallExprContext{wrapped=visitor.candidate("String or CharSequence values")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call newSelector(parsed.getGroup(), parsed.getName(), parsed.getVersion()) java.lang.RuntimeException: Method 'getGroup' cannot be resolved in context parsed.getGroup() (line: 80) MethodCallExprContext{wrapped=parsed.getGroup()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/dsl/ModuleVersionSelectorParsers.java
Cannot solve method call result.converted(newSelector(parsed.getGroup(), parsed.getName(), parsed.getVersion())) java.lang.RuntimeException: Error calculating the type of parameter parsed.getGroup() of method call newSelector(parsed.getGroup(), parsed.getName(), parsed.getVersion()) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/dsl/ModuleVersionSelectorParsers.java
Cannot solve method call newSelector(parsed.getGroup(), parsed.getName(), parsed.getVersion()) java.lang.RuntimeException: Method 'getGroup' cannot be resolved in context parsed.getGroup() (line: 83) MethodCallExprContext{wrapped=parsed.getGroup()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/dsl/ComponentSelectorParsers.java
Cannot solve method call result.converted(newSelector(parsed.getGroup(), parsed.getName(), parsed.getVersion())) java.lang.RuntimeException: Error calculating the type of parameter parsed.getGroup() of method call newSelector(parsed.getGroup(), parsed.getName(), parsed.getVersion()) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/dsl/ComponentSelectorParsers.java
Cannot solve method call assignValue(count, moduleNotation.substring(idx, cur)) java.lang.RuntimeException: Method 'substring' cannot be resolved in context moduleNotation.substring(idx, cur) (line: 44) MethodCallExprContext{wrapped=moduleNotation.substring(idx, cur)}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/dsl/ParsedModuleStringNotation.java
Method 'candidate' cannot be resolved in context visitor.candidate("Instances of AbstractArchiveTask") (line: 59) MethodCallExprContext{wrapped=visitor.candidate("Instances of AbstractArchiveTask")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call instantiator.newInstance(DefaultPublishArtifact.class, artifactFile.getName(), artifactFile.getExtension(), artifactFile.getExtension() == null ? "" : artifactFile.getExtension(), artifactFile.getClassifier(), null, file, new Task[0]) java.lang.RuntimeException: Method 'getName' cannot be resolved in context artifactFile.getName() (line: 89) MethodCallExprContext{wrapped=artifactFile.getName()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/dsl/PublishArtifactNotationParserFactory.java
Method 'getArtifacts' cannot be resolved in context configuration.getArtifacts() (line: 44) MethodCallExprContext{wrapped=configuration.getArtifacts()}. Parameter types: []
Cannot solve method call ruleActionAdapter.createFromClosure(ComponentMetadataDetails.class, rule) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/dsl/DefaultComponentMetadataHandler.java
Cannot solve method call createAllSpecRuleAction(ruleActionAdapter.createFromClosure(ComponentMetadataDetails.class, rule)) java.lang.RuntimeException: Error calculating the type of parameter rule of method call ruleActionAdapter.createFromClosure(ComponentMetadataDetails.class, rule) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/dsl/DefaultComponentMetadataHandler.java
Cannot solve method call addRule(createAllSpecRuleAction(ruleActionAdapter.createFromClosure(ComponentMetadataDetails.class, rule))) java.lang.RuntimeException: Error calculating the type of parameter ruleActionAdapter.createFromClosure(ComponentMetadataDetails.class, rule) of method call createAllSpecRuleAction(ruleActionAdapter.createFromClosure(ComponentMetadataDetails.class, rule)) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/dsl/DefaultComponentMetadataHandler.java
Cannot solve method call createAllSpecRuleAction(ruleActionAdapter.createFromRuleSource(ComponentMetadataDetails.class, ruleSource)) java.lang.RuntimeException: Method 'createFromRuleSource' cannot be resolved in context ruleActionAdapter.createFromRuleSource(ComponentMetadataDetails.class, ruleSource) (line: 117) MethodCallExprContext{wrapped=ruleActionAdapter.createFromRuleSource(ComponentMetadataDetails.class, ruleSource)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.artifacts.ComponentMetadataDetails, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/dsl/DefaultComponentMetadataHandler.java
Cannot solve method call addRule(createAllSpecRuleAction(ruleActionAdapter.createFromRuleSource(ComponentMetadataDetails.class, ruleSource))) java.lang.RuntimeException: Error calculating the type of parameter ruleActionAdapter.createFromRuleSource(ComponentMetadataDetails.class, ruleSource) of method call createAllSpecRuleAction(ruleActionAdapter.createFromRuleSource(ComponentMetadataDetails.class, ruleSource)) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/dsl/DefaultComponentMetadataHandler.java
Cannot solve method call ruleActionAdapter.createFromClosure(ComponentMetadataDetails.class, rule) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/dsl/DefaultComponentMetadataHandler.java
Cannot solve method call createSpecRuleActionForModule(id, ruleActionAdapter.createFromClosure(ComponentMetadataDetails.class, rule)) java.lang.RuntimeException: Error calculating the type of parameter rule of method call ruleActionAdapter.createFromClosure(ComponentMetadataDetails.class, rule) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/dsl/DefaultComponentMetadataHandler.java
Cannot solve method call addRule(createSpecRuleActionForModule(id, ruleActionAdapter.createFromClosure(ComponentMetadataDetails.class, rule))) java.lang.RuntimeException: Error calculating the type of parameter ruleActionAdapter.createFromClosure(ComponentMetadataDetails.class, rule) of method call createSpecRuleActionForModule(id, ruleActionAdapter.createFromClosure(ComponentMetadataDetails.class, rule)) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/dsl/DefaultComponentMetadataHandler.java
Cannot solve method call createSpecRuleActionForModule(id, ruleActionAdapter.createFromRuleSource(ComponentMetadataDetails.class, ruleSource)) java.lang.RuntimeException: Method 'createFromRuleSource' cannot be resolved in context ruleActionAdapter.createFromRuleSource(ComponentMetadataDetails.class, ruleSource) (line: 129) MethodCallExprContext{wrapped=ruleActionAdapter.createFromRuleSource(ComponentMetadataDetails.class, ruleSource)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.artifacts.ComponentMetadataDetails, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/dsl/DefaultComponentMetadataHandler.java
Cannot solve method call addRule(createSpecRuleActionForModule(id, ruleActionAdapter.createFromRuleSource(ComponentMetadataDetails.class, ruleSource))) java.lang.RuntimeException: Error calculating the type of parameter ruleActionAdapter.createFromRuleSource(ComponentMetadataDetails.class, ruleSource) of method call createSpecRuleActionForModule(id, ruleActionAdapter.createFromRuleSource(ComponentMetadataDetails.class, ruleSource)) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/dsl/DefaultComponentMetadataHandler.java
Cannot solve method call format("Cannot declare module replacement %s->%s because it introduces a cycle: %s", source, target, Joiner.on("->").join(visited) + "->" + source) UnsolvedSymbolException{context='Method 'on' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=Joiner}'} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/dsl/ComponentModuleMetadataContainer.java
Cannot solve method call action.transform(IvyContext.getContext().getIvy()) UnsolvedSymbolException{context='Solving IvyContext', name='IvyContext', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/DefaultIvyContextManager.java
Method 'getSettings' cannot be resolved in context ivy.getSettings() (line: 91) MethodCallExprContext{wrapped=ivy.getSettings()}. Parameter types: []
Method 'getSettings' cannot be resolved in context ivy.getSettings() (line: 91) MethodCallExprContext{wrapped=ivy.getSettings()}. Parameter types: []
Method 'getSettings' cannot be resolved in context ivy.getSettings() (line: 92) MethodCallExprContext{wrapped=ivy.getSettings()}. Parameter types: []
Cannot solve field access CacheLayout.META_DATA
Cannot resolve field access null
Cannot solve field access FileLockManager.LockMode.None
Cannot resolve field access null
Cannot solve field access CacheBuilder.LockTarget.CacheDirectory
Cannot solve field access CacheLayout.ROOT
Method 'withDisplayName' cannot be resolved in context cacheRepository.cache(CacheLayout.ROOT.getKey()).withCrossVersionCache(CacheBuilder.LockTarget.CacheDirectory).withDisplayName("artifact cache") (line: 40) MethodCallExprContext{wrapped=cacheRepository.cache(CacheLayout.ROOT.getKey()).withCrossVersionCache(CacheBuilder.LockTarget.CacheDirectory).withDisplayName("artifact cache")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'withDisplayName' cannot be resolved in context cacheRepository.cache(CacheLayout.ROOT.getKey()).withCrossVersionCache(CacheBuilder.LockTarget.CacheDirectory).withDisplayName("artifact cache") (line: 40) MethodCallExprContext{wrapped=cacheRepository.cache(CacheLayout.ROOT.getKey()).withCrossVersionCache(CacheBuilder.LockTarget.CacheDirectory).withDisplayName("artifact cache")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve field access CacheLayout.META_DATA
Cannot solve field access CacheLayout.FILE_STORE
Cannot solve field access CacheLayout.META_DATA
Cannot solve method call CollectionUtils.collect(repositories, Transformers.cast(ResolutionAwareRepository.class)) UnsolvedSymbolException{context='Method 'cast' with parameterTypes [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.internal.artifacts.repositories.ResolutionAwareRepository, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * Utility transformers.
 */
public abstract class Transformers {

    /**
     * Creates a transformer that simply type casts the input to the given output type.
     *
     * @param outputType The type to cast the input to
     * @param <O> The type of the transformed object
     * @param <I> The type of the object to be transformed
     * @return A transformer that simply type casts the input to the given output type.
     */
    public static <O, I> Transformer<O, I> cast(Class<O> outputType) {
        return new CastingTransformer<O, I>(outputType);
    }

    // just returns the original object
    public static <T> Transformer<T, T> noOpTransformer() {
        return new Transformer<T, T>() {

            public T transform(T original) {
                return original;
            }
        };
    }

    private static class CastingTransformer<O, I> implements Transformer<O, I> {

        final Class<O> outputType;

        public CastingTransformer(Class<O> outputType) {
            this.outputType = outputType;
        }

        public O transform(I input) {
            return Cast.cast(outputType, input);
        }
    }

    public static <T> Transformer<String, T> asString() {
        return new ToStringTransformer<T>();
    }

    private static class ToStringTransformer<T> implements Transformer<String, T> {

        public String transform(T original) {
            return original == null ? null : original.toString();
        }
    }

    /**
     * Returns a transformer that names {@link Named} objects.
     *
     * Nulls are returned as null.
     *
     * @return The naming transformer.
     */
    public static Transformer<String, Named> name() {
        return name(Named.Namer.INSTANCE);
    }

    /**
     * Returns a transformer that names objects with the given {@link Namer}
     *
     * @param namer The namer to name the objects with
     * @param <T> The type of objects to be named
     * @return The naming transformer.
     */
    public static <T> Transformer<String, T> name(Namer<? super T> namer) {
        return new ToNameTransformer<T>(namer);
    }

    private static class ToNameTransformer<T> implements Transformer<String, T> {

        private final Namer<? super T> namer;

        public ToNameTransformer(Namer<? super T> namer) {
            this.namer = namer;
        }

        public String transform(T thing) {
            return thing == null ? null : namer.determineName(thing);
        }
    }

    /**
     * Transforms strings which may have spaces and which may have already been escaped with
     * quotes into safe command-line arguments.
     */
    public static Transformer<String, String> asSafeCommandLineArgument() {
        return new CommandLineArgumentTransformer();
    }

    private static class CommandLineArgumentTransformer implements Transformer<String, String> {

        private static final Pattern SINGLE_QUOTED = Pattern.compile("^'.*'$");

        private static final Pattern DOUBLE_QUOTED = Pattern.compile("^\".*\"$");

        private static final Pattern A_SINGLE_QUOTE = Pattern.compile("'");

        @Override
        public String transform(String input) {
            if (SINGLE_QUOTED.matcher(input).matches() || DOUBLE_QUOTED.matcher(input).matches() || !input.contains(" ")) {
                return input;
            } else {
                return wrapWithSingleQuotes(input);
            }
        }

        private String wrapWithSingleQuotes(String input) {
            return String.format("'%1$s'", escapeSingleQuotes(input));
        }

        private String escapeSingleQuotes(String input) {
            return A_SINGLE_QUOTE.matcher(input).replaceAll("\\\\'");
        }
    }

    /**
     * A getClass() transformer.
     *
     * @param <T> The type of the object
     * @return A getClass() transformer.
     */
    public static <T> Transformer<Class<T>, T> type() {
        return new Transformer<Class<T>, T>() {

            public Class<T> transform(T original) {
                @SuppressWarnings("unchecked") Class<T> aClass = (Class<T>) original.getClass();
                return aClass;
            }
        };
    }

    public static <R> Transformer<R, Object> toTransformer(final Factory<R> factory) {
        return new Transformer<R, Object>() {

            public R transform(Object original) {
                return factory.create();
            }
        };
    }

    public static <R, I> Transformer<R, I> toTransformer(final Action<? super I> action) {
        return new Transformer<R, I>() {

            public R transform(I original) {
                action.execute(original);
                return null;
            }
        };
    }

    /**
     * Converts a URL to a URI
     */
    public static Transformer<URL, URI> toURL() {
        return new Transformer<URL, URI>() {

            public URL transform(URI original) {
                try {
                    return original.toURL();
                } catch (MalformedURLException e) {
                    throw UncheckedException.throwAsUncheckedException(e);
                }
            }
        };
    }

    /**
     * Always returns the given argument.
     */
    public static <T, I> Transformer<T, I> constant(final T t) {
        return new Transformer<T, I>() {

            public T transform(I original) {
                return t;
            }
        };
    }
}}'} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/DefaultConfigurationResolver.java
Cannot solve method call ruleActionAdapter.createFromClosure(ComponentSelection.class, closure) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/resolutionstrategy/DefaultComponentSelectionRules.java
Cannot solve method call createAllSpecRulesAction(ruleActionAdapter.createFromClosure(ComponentSelection.class, closure)) java.lang.RuntimeException: Error calculating the type of parameter closure of method call ruleActionAdapter.createFromClosure(ComponentSelection.class, closure) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/resolutionstrategy/DefaultComponentSelectionRules.java
Cannot solve method call addRule(createAllSpecRulesAction(ruleActionAdapter.createFromClosure(ComponentSelection.class, closure))) java.lang.RuntimeException: Error calculating the type of parameter ruleActionAdapter.createFromClosure(ComponentSelection.class, closure) of method call createAllSpecRulesAction(ruleActionAdapter.createFromClosure(ComponentSelection.class, closure)) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/resolutionstrategy/DefaultComponentSelectionRules.java
Cannot solve method call createAllSpecRulesAction(ruleActionAdapter.createFromRuleSource(ComponentSelection.class, ruleSource)) java.lang.RuntimeException: Method 'createFromRuleSource' cannot be resolved in context ruleActionAdapter.createFromRuleSource(ComponentSelection.class, ruleSource) (line: 101) MethodCallExprContext{wrapped=ruleActionAdapter.createFromRuleSource(ComponentSelection.class, ruleSource)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.artifacts.ComponentSelection, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/resolutionstrategy/DefaultComponentSelectionRules.java
Cannot solve method call addRule(createAllSpecRulesAction(ruleActionAdapter.createFromRuleSource(ComponentSelection.class, ruleSource))) java.lang.RuntimeException: Error calculating the type of parameter ruleActionAdapter.createFromRuleSource(ComponentSelection.class, ruleSource) of method call createAllSpecRulesAction(ruleActionAdapter.createFromRuleSource(ComponentSelection.class, ruleSource)) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/resolutionstrategy/DefaultComponentSelectionRules.java
Cannot solve method call ruleActionAdapter.createFromClosure(ComponentSelection.class, closure) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/resolutionstrategy/DefaultComponentSelectionRules.java
Cannot solve method call createSpecRuleActionFromId(id, ruleActionAdapter.createFromClosure(ComponentSelection.class, closure)) java.lang.RuntimeException: Error calculating the type of parameter closure of method call ruleActionAdapter.createFromClosure(ComponentSelection.class, closure) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/resolutionstrategy/DefaultComponentSelectionRules.java
Cannot solve method call addRule(createSpecRuleActionFromId(id, ruleActionAdapter.createFromClosure(ComponentSelection.class, closure))) java.lang.RuntimeException: Error calculating the type of parameter ruleActionAdapter.createFromClosure(ComponentSelection.class, closure) of method call createSpecRuleActionFromId(id, ruleActionAdapter.createFromClosure(ComponentSelection.class, closure)) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/resolutionstrategy/DefaultComponentSelectionRules.java
Cannot solve method call createSpecRuleActionFromId(id, ruleActionAdapter.createFromRuleSource(ComponentSelection.class, ruleSource)) java.lang.RuntimeException: Method 'createFromRuleSource' cannot be resolved in context ruleActionAdapter.createFromRuleSource(ComponentSelection.class, ruleSource) (line: 113) MethodCallExprContext{wrapped=ruleActionAdapter.createFromRuleSource(ComponentSelection.class, ruleSource)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.artifacts.ComponentSelection, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/resolutionstrategy/DefaultComponentSelectionRules.java
Cannot solve method call addRule(createSpecRuleActionFromId(id, ruleActionAdapter.createFromRuleSource(ComponentSelection.class, ruleSource))) java.lang.RuntimeException: Error calculating the type of parameter ruleActionAdapter.createFromRuleSource(ComponentSelection.class, ruleSource) of method call createSpecRuleActionFromId(id, ruleActionAdapter.createFromRuleSource(ComponentSelection.class, ruleSource)) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/resolutionstrategy/DefaultComponentSelectionRules.java
Cannot solve method call clientModuleMetaData.setArtifacts(Sets.newHashSet(artifact)) UnsolvedSymbolException{context='Method 'newHashSet' with parameterTypes [ReferenceType{org.gradle.internal.component.external.model.ModuleComponentArtifactMetadata, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Sets}'} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/clientmodule/ClientModuleResolver.java
Empty name expression Listed
Empty name expression Failed
Empty name expression Missing
Empty name expression Resolved
Empty name expression Failed
Cannot solve method call repositoryNames.add(repository.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context repository.getName() (line: 54) MethodCallExprContext{wrapped=repository.getName()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/DynamicVersionResolver.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call LOGGER.debug("Using {} from {}", latestResolved.module.getId(), latestResolved.repository) UnsolvedSymbolException{context='unknown', name='module', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/DynamicVersionResolver.java
Empty name expression Failed
Empty name expression Missing
Empty name expression Unknown
Empty name expression Resolved
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call versionedComponentChooser.selectNewestComponent(one.module, two.module) UnsolvedSymbolException{context='unknown', name='module', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/DynamicVersionResolver.java
Cannot resolve field access null
Empty name expression Failed
Empty name expression Listed
Empty name expression Unknown
Empty name expression NoMatch
Empty name expression Match
Empty name expression Failed
Cannot solve method call process(repository.getLocalAccess()) java.lang.RuntimeException: Method 'getLocalAccess' cannot be resolved in context repository.getLocalAccess() (line: 280) MethodCallExprContext{wrapped=repository.getLocalAccess()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/DynamicVersionResolver.java
Cannot solve method call process(repository.getRemoteAccess()) java.lang.RuntimeException: Method 'getRemoteAccess' cannot be resolved in context repository.getRemoteAccess() (line: 291) MethodCallExprContext{wrapped=repository.getRemoteAccess()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/DynamicVersionResolver.java
Empty name expression Resolved
Empty name expression Missing
Empty name expression Failed
Empty name expression Unknown
Cannot solve method call process(dependency, repository.getLocalAccess()) java.lang.RuntimeException: Method 'getLocalAccess' cannot be resolved in context repository.getLocalAccess() (line: 339) MethodCallExprContext{wrapped=repository.getLocalAccess()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/DynamicVersionResolver.java
Cannot solve method call process(dependency, repository.getRemoteAccess()) java.lang.RuntimeException: Method 'getRemoteAccess' cannot be resolved in context repository.getRemoteAccess() (line: 351) MethodCallExprContext{wrapped=repository.getRemoteAccess()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/DynamicVersionResolver.java
Cannot solve method call "false".equalsIgnoreCase(System.getProperty(TOGGLE_PROPERTY)) UnsolvedSymbolException{context='Method 'getProperty' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=java.lang.System}'} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/memcache/InMemoryCachedRepositoryFactory.java
Cannot solve method call this.typedArtifacts.put(new TypedArtifactsKey(component, type), ImmutableSet.copyOf(result.getResult())) UnsolvedSymbolException{context='Method 'copyOf' with parameterTypes [ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=WildcardUsage{type=EXTENDS, boundedType=ReferenceType{org.gradle.internal.component.model.ComponentArtifactMetadata, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.ImmutableSet}'} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/memcache/InMemoryArtifactsCache.java
Cannot resolve field access null
Cannot solve field access BuildableModuleComponentMetaDataResolveResult.State.Resolved
Cannot resolve field access null
Cannot solve field access BuildableModuleComponentMetaDataResolveResult.State.Resolved
Empty name expression Unknown
Empty name expression Missing
Empty name expression Failed
Cannot resolve field access null
Cannot solve field access BuildableModuleComponentMetaDataResolveResult.State.Resolved
Cannot resolve field access null
Cannot solve field access BuildableModuleComponentMetaDataResolveResult.State.Resolved
Cannot resolve field access null
Cannot solve field access BuildableModuleComponentMetaDataResolveResult.State.Resolved
Cannot solve method call SPECIAL_MEANINGS.get(parts1[i].toLowerCase(Locale.US)) java.lang.RuntimeException: Method 'toLowerCase' cannot be resolved in context parts1[i].toLowerCase(Locale.US) (line: 57) MethodCallExprContext{wrapped=parts1[i].toLowerCase(Locale.US)}. Parameter types: [ReferenceType{java.util.Locale, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/strategy/StaticVersionComparator.java
Cannot solve method call SPECIAL_MEANINGS.get(parts2[i].toLowerCase(Locale.US)) java.lang.RuntimeException: Method 'toLowerCase' cannot be resolved in context parts2[i].toLowerCase(Locale.US) (line: 58) MethodCallExprContext{wrapped=parts2[i].toLowerCase(Locale.US)}. Parameter types: [ReferenceType{java.util.Locale, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/strategy/StaticVersionComparator.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Method 'matcher' cannot be resolved in context VersionRangeSelector.ALL_RANGE.matcher(selectorString) (line: 27) MethodCallExprContext{wrapped=VersionRangeSelector.ALL_RANGE.matcher(selectorString)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call selector.substring(0, selector.length() - 1) java.lang.RuntimeException: Method 'length' cannot be resolved in context selector.length() (line: 26) MethodCallExprContext{wrapped=selector.length()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/strategy/SubVersionSelector.java
Cannot solve method call parts.add(original.substring(startPart, pos)) java.lang.RuntimeException: Method 'substring' cannot be resolved in context original.substring(startPart, pos) (line: 59) MethodCallExprContext{wrapped=original.substring(startPart, pos)}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/strategy/VersionParser.java
Cannot solve method call parts.add(original.substring(startPart, pos)) java.lang.RuntimeException: Method 'substring' cannot be resolved in context original.substring(startPart, pos) (line: 49) MethodCallExprContext{wrapped=original.substring(startPart, pos)}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/strategy/VersionParser.java
Cannot solve method call parts.add(original.substring(startPart, pos)) java.lang.RuntimeException: Method 'substring' cannot be resolved in context original.substring(startPart, pos) (line: 36) MethodCallExprContext{wrapped=original.substring(startPart, pos)}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/strategy/VersionParser.java
Cannot solve method call parts.add(original.substring(startPart, pos)) java.lang.RuntimeException: Method 'substring' cannot be resolved in context original.substring(startPart, pos) (line: 66) MethodCallExprContext{wrapped=original.substring(startPart, pos)}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/strategy/VersionParser.java
Cannot solve method call version.substring(0, version.length() - 1) java.lang.RuntimeException: Method 'length' cannot be resolved in context version.length() (line: 58) MethodCallExprContext{wrapped=version.length()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/strategy/MavenVersionSelectorScheme.java
Method 'getLocalResource' cannot be resolved in context resource.getLocalResource() (line: 133) MethodCallExprContext{wrapped=resource.getLocalResource()}. Parameter types: []
Method 'getLocalResource' cannot be resolved in context resource.getLocalResource() (line: 133) MethodCallExprContext{wrapped=resource.getLocalResource()}. Parameter types: []
Method 'getLocalResource' cannot be resolved in context resource.getLocalResource() (line: 133) MethodCallExprContext{wrapped=resource.getLocalResource()}. Parameter types: []
Cannot solve method call PROJECT.equals(projectElement.getNodeName()) java.lang.RuntimeException: Method 'getNodeName' cannot be resolved in context projectElement.getNodeName() (line: 144) MethodCallExprContext{wrapped=projectElement.getNodeName()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/PomReader.java
Cannot solve method call MODEL.equals(projectElement.getNodeName()) java.lang.RuntimeException: Method 'getNodeName' cannot be resolved in context projectElement.getNodeName() (line: 144) MethodCallExprContext{wrapped=projectElement.getNodeName()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/PomReader.java
Cannot solve field access GavProperty.PARENT_GROUP_ID
Cannot solve field access GavProperty.PARENT_VERSION
Cannot solve field access GavProperty.PARENT_ARTIFACT_ID
Method 'getOwnerDocument' cannot be resolved in context projectElement.getOwnerDocument() (line: 227) MethodCallExprContext{wrapped=projectElement.getOwnerDocument()}. Parameter types: []
Method 'getDependencies' cannot be resolved in context pomParent.getDependencies() (line: 383) MethodCallExprContext{wrapped=pomParent.getDependencies()}. Parameter types: []
Cannot solve method call DEPENDENCY.equals(node.getNodeName()) java.lang.RuntimeException: Method 'getNodeName' cannot be resolved in context node.getNodeName() (line: 405) MethodCallExprContext{wrapped=node.getNodeName()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/PomReader.java
Cannot solve method call dependencies.putAll(pomParent.getDependencyMgt()) java.lang.RuntimeException: Method 'getDependencyMgt' cannot be resolved in context pomParent.getDependencyMgt() (line: 426) MethodCallExprContext{wrapped=pomParent.getDependencyMgt()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/PomReader.java
Cannot solve method call DEPENDENCY.equals(node.getNodeName()) java.lang.RuntimeException: Method 'getNodeName' cannot be resolved in context node.getNodeName() (line: 464) MethodCallExprContext{wrapped=node.getNodeName()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/PomReader.java
Cannot solve field access GavProperty.GROUP_ID
Cannot solve field access GavProperty.ARTIFACT_ID
Cannot solve field access GavProperty.VERSION
Cannot solve method call EXCLUSION.equals(node.getNodeName()) java.lang.RuntimeException: Method 'getNodeName' cannot be resolved in context node.getNodeName() (line: 554) MethodCallExprContext{wrapped=node.getNodeName()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/PomReader.java
Cannot solve method call PROFILE.equals(profileElement.getNodeName()) java.lang.RuntimeException: Method 'getNodeName' cannot be resolved in context profileElement.getNodeName() (line: 628) MethodCallExprContext{wrapped=profileElement.getNodeName()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/PomReader.java
Cannot solve method call pomProperties.put(prop.getNodeName(), getTextContent(prop)) java.lang.RuntimeException: Method 'getNodeName' cannot be resolved in context prop.getNodeName() (line: 694) MethodCallExprContext{wrapped=prop.getNodeName()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/PomReader.java
Cannot solve field access MavenScope.System
Cannot solve field access MavenScope.Test
Cannot solve field access MavenScope.Provided
Cannot solve field access MavenScope.Runtime
Cannot solve field access MavenScope.Compile
Cannot solve field access MavenScope.Compile
Cannot solve field access JarDependencyType.TEST_JAR
Cannot solve field access JarDependencyType.EJB_CLIENT
Cannot solve name expression Node
Cannot resolve field access null
Cannot solve name expression Node
Cannot resolve field access null
Cannot solve name expression child
Method 'getNodeType' cannot be resolved in context child.getNodeType() (line: 37) MethodCallExprContext{wrapped=child.getNodeType()}. Parameter types: []
Cannot solve name expression result
Method 'getNodeType' cannot be resolved in context child.getNodeType() (line: 37) MethodCallExprContext{wrapped=child.getNodeType()}. Parameter types: []
Cannot solve method call name.equals(node.getNodeName()) java.lang.RuntimeException: Method 'getNodeName' cannot be resolved in context node.getNodeName() (line: 66) MethodCallExprContext{wrapped=node.getNodeName()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/PomDomParser.java
Method 'getBytes' cannot be resolved in context xmlDecl.getBytes() (line: 121) MethodCallExprContext{wrapped=xmlDecl.getBytes()}. Parameter types: []
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Method 'append' cannot be resolved in context key.append(groupId) (line: 74) MethodCallExprContext{wrapped=key.append(groupId)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context key.append(groupId) (line: 74) MethodCallExprContext{wrapped=key.append(groupId)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context key.append(groupId) (line: 74) MethodCallExprContext{wrapped=key.append(groupId)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context key.append(groupId) (line: 74) MethodCallExprContext{wrapped=key.append(groupId)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context key.append(KEY_SEPARATOR) (line: 77) MethodCallExprContext{wrapped=key.append(KEY_SEPARATOR)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve field access ArtifactType.MAVEN_POM
Cannot solve method call String.format("Could not parse %s %s", typeName, resource.getDisplayName()) java.lang.RuntimeException: Method 'getDisplayName' cannot be resolved in context resource.getDisplayName() (line: 30) MethodCallExprContext{wrapped=resource.getDisplayName()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/MetaDataParseException.java
Method 'getLocalResource' cannot be resolved in context resource.getLocalResource() (line: 39) MethodCallExprContext{wrapped=resource.getLocalResource()}. Parameter types: []
Method 'getLocalResource' cannot be resolved in context resource.getLocalResource() (line: 39) MethodCallExprContext{wrapped=resource.getLocalResource()}. Parameter types: []
Method 'getLocalResource' cannot be resolved in context resource.getLocalResource() (line: 39) MethodCallExprContext{wrapped=resource.getLocalResource()}. Parameter types: []
Cannot solve method call DefaultModuleComponentIdentifier.newId(moduleRevisionId.getOrganisation(), moduleRevisionId.getName(), moduleRevisionId.getRevision()) java.lang.RuntimeException: Method 'getOrganisation' cannot be resolved in context moduleRevisionId.getOrganisation() (line: 67) MethodCallExprContext{wrapped=moduleRevisionId.getOrganisation()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyModuleDescriptorConverter.java
Cannot solve method call state.setBranch(moduleRevisionId.getBranch()) java.lang.RuntimeException: Method 'getBranch' cannot be resolved in context moduleRevisionId.getBranch() (line: 70) MethodCallExprContext{wrapped=moduleRevisionId.getBranch()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyModuleDescriptorConverter.java
Cannot solve method call state.setDescription(ivyDescriptor.getDescription()) java.lang.RuntimeException: Method 'getDescription' cannot be resolved in context ivyDescriptor.getDescription() (line: 71) MethodCallExprContext{wrapped=ivyDescriptor.getDescription()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyModuleDescriptorConverter.java
Cannot solve method call state.setPublicationDate(ivyDescriptor.getPublicationDate()) java.lang.RuntimeException: Method 'getPublicationDate' cannot be resolved in context ivyDescriptor.getPublicationDate() (line: 72) MethodCallExprContext{wrapped=ivyDescriptor.getPublicationDate()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyModuleDescriptorConverter.java
Cannot solve method call Cast.uncheckedCast(ivyDescriptor.getExtraInfo()) java.lang.RuntimeException: Method 'getExtraInfo' cannot be resolved in context ivyDescriptor.getExtraInfo() (line: 73) MethodCallExprContext{wrapped=ivyDescriptor.getExtraInfo()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyModuleDescriptorConverter.java
Method 'getDependencies' cannot be resolved in context ivyDescriptor.getDependencies() (line: 84) MethodCallExprContext{wrapped=ivyDescriptor.getDependencies()}. Parameter types: []
Cannot solve method call Lists.newArrayListWithCapacity(ivyDescriptor.getDependencies().length) java.lang.RuntimeException: Method 'getDependencies' cannot be resolved in context ivyDescriptor.getDependencies() (line: 84) MethodCallExprContext{wrapped=ivyDescriptor.getDependencies()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyModuleDescriptorConverter.java
Method 'getConfigurations' cannot be resolved in context ivyDescriptor.getConfigurations() (line: 92) MethodCallExprContext{wrapped=ivyDescriptor.getConfigurations()}. Parameter types: []
Cannot solve method call Lists.newArrayListWithCapacity(ivyDescriptor.getConfigurations().length) java.lang.RuntimeException: Method 'getConfigurations' cannot be resolved in context ivyDescriptor.getConfigurations() (line: 92) MethodCallExprContext{wrapped=ivyDescriptor.getConfigurations()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyModuleDescriptorConverter.java
Cannot resolve field access null
Cannot solve method call Lists.newArrayList(configuration.getExtends()) java.lang.RuntimeException: Method 'getExtends' cannot be resolved in context configuration.getExtends() (line: 103) MethodCallExprContext{wrapped=configuration.getExtends()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyModuleDescriptorConverter.java
Cannot solve method call DefaultModuleVersionSelector.newSelector(revisionId.getOrganisation(), revisionId.getName(), revisionId.getRevision()) java.lang.RuntimeException: Method 'getOrganisation' cannot be resolved in context revisionId.getOrganisation() (line: 113) MethodCallExprContext{wrapped=revisionId.getOrganisation()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyModuleDescriptorConverter.java
Cannot solve method call DefaultIvyArtifactName.of(ivyArtifact.getName(), ivyArtifact.getType(), ivyArtifact.getExt(), (String) ivyArtifact.getExtraAttributes().get(CLASSIFIER)) UnsolvedSymbolException{context='unknown', name='DependencyArtifactDescriptor', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyModuleDescriptorConverter.java
Cannot solve method call Sets.newHashSet(ivyArtifact.getConfigurations()) UnsolvedSymbolException{context='unknown', name='DependencyArtifactDescriptor', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyModuleDescriptorConverter.java
Method 'getDynamicConstraintDependencyRevisionId' cannot be resolved in context dependencyDescriptor.getDynamicConstraintDependencyRevisionId() (line: 133) MethodCallExprContext{wrapped=dependencyDescriptor.getDynamicConstraintDependencyRevisionId()}. Parameter types: []
Method 'getModuleId' cannot be resolved in context id.getModuleId() (line: 145) MethodCallExprContext{wrapped=id.getModuleId()}. Parameter types: []
Method 'getModuleId' cannot be resolved in context id.getModuleId() (line: 145) MethodCallExprContext{wrapped=id.getModuleId()}. Parameter types: []
Method 'getMatcher' cannot be resolved in context excludeRule.getMatcher() (line: 146) MethodCallExprContext{wrapped=excludeRule.getMatcher()}. Parameter types: []
Cannot solve method call Arrays.asList(dependencyDescriptor.getDependencyConfigurations(modConfs)) java.lang.RuntimeException: Method 'getDependencyConfigurations' cannot be resolved in context dependencyDescriptor.getDependencyConfigurations(modConfs) (line: 162) MethodCallExprContext{wrapped=dependencyDescriptor.getDependencyConfigurations(modConfs)}. Parameter types: [ResolvedArrayType{ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyModuleDescriptorConverter.java
Cannot solve method call results.put(modConf, Arrays.asList(dependencyDescriptor.getDependencyConfigurations(modConfs))) java.lang.RuntimeException: Error calculating the type of parameter dependencyDescriptor.getDependencyConfigurations(modConfs) of method call Arrays.asList(dependencyDescriptor.getDependencyConfigurations(modConfs)) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyModuleDescriptorConverter.java
Method 'getLocalResource' cannot be resolved in context resource.getLocalResource() (line: 119) MethodCallExprContext{wrapped=resource.getLocalResource()}. Parameter types: []
Method 'getLocalResource' cannot be resolved in context resource.getLocalResource() (line: 119) MethodCallExprContext{wrapped=resource.getLocalResource()}. Parameter types: []
Method 'getLocalResource' cannot be resolved in context resource.getLocalResource() (line: 119) MethodCallExprContext{wrapped=resource.getLocalResource()}. Parameter types: []
Cannot solve method call properties.put(property, System.getProperty(property)) UnsolvedSymbolException{context='Method 'getProperty' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=java.lang.System}'} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call evaluateCondition(depConfs[k].trim(), dd) java.lang.RuntimeException: Method 'trim' cannot be resolved in context depConfs[k].trim() (line: 252) MethodCallExprContext{wrapped=depConfs[k].trim()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call dd.addDependencyConfiguration(modConfs[j].trim(), mappedDependency) java.lang.RuntimeException: Method 'trim' cannot be resolved in context modConfs[j].trim() (line: 254) MethodCallExprContext{wrapped=modConfs[j].trim()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call dd.addDependencyConfiguration(modConfs[j].trim(), modConfs[j].trim()) java.lang.RuntimeException: Method 'trim' cannot be resolved in context modConfs[j].trim() (line: 241) MethodCallExprContext{wrapped=modConfs[j].trim()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call evaluateCondition(depConfs[k].trim(), dd) java.lang.RuntimeException: Method 'trim' cannot be resolved in context depConfs[k].trim() (line: 231) MethodCallExprContext{wrapped=depConfs[k].trim()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call dd.addDependencyConfiguration(modConfs[j].trim(), mappedDependency) java.lang.RuntimeException: Method 'trim' cannot be resolved in context modConfs[j].trim() (line: 234) MethodCallExprContext{wrapped=modConfs[j].trim()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call dd.addDependencyConfiguration(modConfs[j].trim(), modConfs[j].trim()) java.lang.RuntimeException: Method 'trim' cannot be resolved in context modConfs[j].trim() (line: 222) MethodCallExprContext{wrapped=modConfs[j].trim()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot resolve field access null
Cannot resolve field access null
Method 'substring' cannot be resolved in context condition.substring(0, notEqualIndex) (line: 314) MethodCallExprContext{wrapped=condition.substring(0, notEqualIndex)}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}]
Method 'substring' cannot be resolved in context condition.substring(notEqualIndex + 2) (line: 315) MethodCallExprContext{wrapped=condition.substring(notEqualIndex + 2)}. Parameter types: [PrimitiveTypeUsage{name='int'}]
Cannot solve method call addError("invalid conf " + conf + " for " + dd.getDependencyRevisionId()) java.lang.RuntimeException: Method 'getDependencyRevisionId' cannot be resolved in context dd.getDependencyRevisionId() (line: 297) MethodCallExprContext{wrapped=dd.getDependencyRevisionId()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Method 'substring' cannot be resolved in context condition.substring(0, equalIndex) (line: 301) MethodCallExprContext{wrapped=condition.substring(0, equalIndex)}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}]
Method 'substring' cannot be resolved in context condition.substring(equalIndex + 1) (line: 302) MethodCallExprContext{wrapped=condition.substring(equalIndex + 1)}. Parameter types: [PrimitiveTypeUsage{name='int'}]
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call errors.add(msg + " in " + res.getDisplayName()) java.lang.RuntimeException: Method 'getDisplayName' cannot be resolved in context res.getDisplayName() (line: 367) MethodCallExprContext{wrapped=res.getDisplayName()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call LOGGER.warn("xml parsing: {}: {}", getLocationString(ex), ex.getMessage()) java.lang.RuntimeException: Method 'getMessage' cannot be resolved in context ex.getMessage() (line: 371) MethodCallExprContext{wrapped=ex.getMessage()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call addError("xml parsing: " + getLocationString(ex) + ": " + ex.getMessage()) java.lang.RuntimeException: Method 'getMessage' cannot be resolved in context ex.getMessage() (line: 375) MethodCallExprContext{wrapped=ex.getMessage()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call addError("[Fatal Error] " + getLocationString(ex) + ": " + ex.getMessage()) java.lang.RuntimeException: Method 'getMessage' cannot be resolved in context ex.getMessage() (line: 379) MethodCallExprContext{wrapped=ex.getMessage()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call str.append(getResource().getDisplayName()) java.lang.RuntimeException: Method 'getDisplayName' cannot be resolved in context getResource().getDisplayName() (line: 394) MethodCallExprContext{wrapped=getResource().getDisplayName()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call str.append(ex.getLineNumber()) java.lang.RuntimeException: Method 'getLineNumber' cannot be resolved in context ex.getLineNumber() (line: 397) MethodCallExprContext{wrapped=ex.getLineNumber()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call str.append(ex.getColumnNumber()) java.lang.RuntimeException: Method 'getColumnNumber' cannot be resolved in context ex.getColumnNumber() (line: 399) MethodCallExprContext{wrapped=ex.getColumnNumber()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot resolve field access null
Cannot solve field access State.NONE
Method 'getModuleRevisionId' cannot be resolved in context getMd().getModuleRevisionId() (line: 553) MethodCallExprContext{wrapped=getMd().getModuleRevisionId()}. Parameter types: []
Cannot solve method call DefaultIvyArtifactName.of(getMd().getModuleRevisionId().getName(), "jar", "jar") java.lang.RuntimeException: Method 'getModuleRevisionId' cannot be resolved in context getMd().getModuleRevisionId() (line: 553) MethodCallExprContext{wrapped=getMd().getModuleRevisionId()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call Sets.newHashSet(getMd().getConfigurationsNames()) java.lang.RuntimeException: Method 'getConfigurationsNames' cannot be resolved in context getMd().getConfigurationsNames() (line: 554) MethodCallExprContext{wrapped=getMd().getConfigurationsNames()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve field access State.DESCRIPTION
Cannot solve field access State.INFO
Cannot solve field access State.INFO
Cannot solve field access State.INFO
Cannot solve field access State.INFO
Cannot solve field access State.INFO
Cannot solve field access State.INFO
Cannot solve field access State.DEP
Cannot solve field access State.DEP
Cannot solve field access State.DEPS
Cannot solve field access State.DEPS
Cannot solve field access State.CONFLICT
Cannot solve field access State.DEPS
Cannot solve field access State.CONF
Cannot solve field access State.EXTRA_INFO
Cannot solve field access State.DESCRIPTION
Cannot solve method call LOGGER.debug("Ivy.xml dependency overrides are not supported by Gradle. Ignoring override declared in {}", getResource().getDisplayName()) java.lang.RuntimeException: Method 'getDisplayName' cannot be resolved in context getResource().getDisplayName() (line: 614) MethodCallExprContext{wrapped=getResource().getDisplayName()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call LOGGER.debug("Ivy.xml conflict managers are not supported by Gradle. Ignoring conflict manager declared in {}", getResource().getDisplayName()) java.lang.RuntimeException: Method 'getDisplayName' cannot be resolved in context getResource().getDisplayName() (line: 612) MethodCallExprContext{wrapped=getResource().getDisplayName()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("name")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("name") (line: 610) MethodCallExprContext{wrapped=attributes.getValue("name")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call dd.addDependencyConfiguration(conf, substitute(attributes.getValue("name"))) java.lang.RuntimeException: Error calculating the type of parameter attributes.getValue("name") of method call substitute(attributes.getValue("name")) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve field access State.EXCLUDE
Cannot solve field access State.CONFLICT
Cannot solve field access State.EXTRA_INFO
Cannot solve method call substitute(attributes.getValue("homepage")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("homepage") (line: 580) MethodCallExprContext{wrapped=attributes.getValue("homepage")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call getMd().setHomePage(substitute(attributes.getValue("homepage"))) java.lang.RuntimeException: Error calculating the type of parameter attributes.getValue("homepage") of method call substitute(attributes.getValue("homepage")) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve field access State.DESCRIPTION
Cannot solve method call substitute(attributes.getValue("name")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("name") (line: 572) MethodCallExprContext{wrapped=attributes.getValue("name")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("url")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("url") (line: 572) MethodCallExprContext{wrapped=attributes.getValue("url")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call elvis(attributes.getValue("location"), "../ivy.xml") java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("location") (line: 635) MethodCallExprContext{wrapped=attributes.getValue("location")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call elvis(attributes.getValue("extendType"), "all") java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("extendType") (line: 637) MethodCallExprContext{wrapped=attributes.getValue("extendType")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Error calculating the type of parameter attributes.getValue("extendType") of method call elvis(attributes.getValue("extendType"), "all")
Cannot solve method call Arrays.asList(extendType.split(",")) java.lang.RuntimeException: Method 'split' cannot be resolved in context extendType.split(",") (line: 638) MethodCallExprContext{wrapped=extendType.split(",")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Method 'getModuleRevisionId' cannot be resolved in context parent.getModuleRevisionId() (line: 647) MethodCallExprContext{wrapped=parent.getModuleRevisionId()}. Parameter types: []
Cannot solve method call mergeConfigurations(parent.getModuleRevisionId(), parent.getConfigurations()) java.lang.RuntimeException: Method 'getModuleRevisionId' cannot be resolved in context parent.getModuleRevisionId() (line: 682) MethodCallExprContext{wrapped=parent.getModuleRevisionId()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call mergeDependencies(parent.getDependencies()) java.lang.RuntimeException: Method 'getDependencies' cannot be resolved in context parent.getDependencies() (line: 686) MethodCallExprContext{wrapped=parent.getDependencies()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call mergeDescription(parent.getDescription()) java.lang.RuntimeException: Method 'getDescription' cannot be resolved in context parent.getDescription() (line: 690) MethodCallExprContext{wrapped=parent.getDescription()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call mergeConfigurations(sourceMrid, parent.getConfigurations()) java.lang.RuntimeException: Method 'getConfigurations' cannot be resolved in context parent.getConfigurations() (line: 698) MethodCallExprContext{wrapped=parent.getConfigurations()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call mergeDependencies(parent.getDependencies()) java.lang.RuntimeException: Method 'getDependencies' cannot be resolved in context parent.getDependencies() (line: 699) MethodCallExprContext{wrapped=parent.getDependencies()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call mergeDescription(parent.getDescription()) java.lang.RuntimeException: Method 'getDescription' cannot be resolved in context parent.getDescription() (line: 700) MethodCallExprContext{wrapped=parent.getDescription()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call mergeValue(parentMrid.getOrganisation(), currentMrid.getOrganisation()) java.lang.RuntimeException: Method 'getOrganisation' cannot be resolved in context parentMrid.getOrganisation() (line: 710) MethodCallExprContext{wrapped=parentMrid.getOrganisation()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call mergeValue(parentMrid.getBranch(), currentMrid.getBranch()) java.lang.RuntimeException: Method 'getBranch' cannot be resolved in context parentMrid.getBranch() (line: 712) MethodCallExprContext{wrapped=parentMrid.getBranch()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call mergeValue(parentMrid.getRevision(), currentMrid.getRevision()) java.lang.RuntimeException: Method 'getRevision' cannot be resolved in context parentMrid.getRevision() (line: 713) MethodCallExprContext{wrapped=parentMrid.getRevision()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call mergeValues(parentMrid.getQualifiedExtraAttributes(), currentMrid.getQualifiedExtraAttributes()) java.lang.RuntimeException: Method 'getQualifiedExtraAttributes' cannot be resolved in context parentMrid.getQualifiedExtraAttributes() (line: 714) MethodCallExprContext{wrapped=parentMrid.getQualifiedExtraAttributes()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call createModuleRevisionId(mergeValue(parentMrid.getOrganisation(), currentMrid.getOrganisation()), currentMrid.getName(), mergeValue(parentMrid.getBranch(), currentMrid.getBranch()), mergeValue(parentMrid.getRevision(), currentMrid.getRevision()), mergeValues(parentMrid.getQualifiedExtraAttributes(), currentMrid.getQualifiedExtraAttributes())) java.lang.RuntimeException: Error calculating the type of parameter parentMrid.getOrganisation() of method call mergeValue(parentMrid.getOrganisation(), currentMrid.getOrganisation()) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call mergeValue(parent.getStatus(), descriptor.getStatus()) java.lang.RuntimeException: Method 'getStatus' cannot be resolved in context parent.getStatus() (line: 720) MethodCallExprContext{wrapped=parent.getStatus()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call descriptor.setStatus(mergeValue(parent.getStatus(), descriptor.getStatus())) java.lang.RuntimeException: Error calculating the type of parameter parent.getStatus() of method call mergeValue(parent.getStatus(), descriptor.getStatus()) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call descriptor.setNamespace(parentNamespace) UnsolvedSymbolException{context='unknown', name='Namespace', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call LOGGER.debug("Merging configuration with: {}", configuration.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context configuration.getName() (line: 741) MethodCallExprContext{wrapped=configuration.getName()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call LOGGER.debug("Merging dependency with: {}", dependencyDescriptor.getDependencyRevisionId()) java.lang.RuntimeException: Method 'getDependencyRevisionId' cannot be resolved in context dependencyDescriptor.getDependencyRevisionId() (line: 750) MethodCallExprContext{wrapped=dependencyDescriptor.getDependencyRevisionId()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Method 'trim' cannot be resolved in context current.trim() (line: 757) MethodCallExprContext{wrapped=current.trim()}. Parameter types: []
Cannot solve field access ArtifactType.IVY_DESCRIPTOR
Method 'getLocalResource' cannot be resolved in context externalResource.getLocalResource() (line: 781) MethodCallExprContext{wrapped=externalResource.getLocalResource()}. Parameter types: []
Method 'getLocalResource' cannot be resolved in context externalResource.getLocalResource() (line: 781) MethodCallExprContext{wrapped=externalResource.getLocalResource()}. Parameter types: []
Method 'getLocalResource' cannot be resolved in context externalResource.getLocalResource() (line: 781) MethodCallExprContext{wrapped=externalResource.getLocalResource()}. Parameter types: []
Cannot solve method call parseModuleDescriptor(externalResource, externalResource.getLocalResource().getFile().toURI().toURL()) java.lang.RuntimeException: Method 'getLocalResource' cannot be resolved in context externalResource.getLocalResource() (line: 781) MethodCallExprContext{wrapped=externalResource.getLocalResource()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve field access State.PUB
Cannot solve method call substitute(attributes.getValue("defaultconf")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("defaultconf") (line: 794) MethodCallExprContext{wrapped=attributes.getValue("defaultconf")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("file")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("file") (line: 806) MethodCallExprContext{wrapped=attributes.getValue("file")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("url")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("url") (line: 806) MethodCallExprContext{wrapped=attributes.getValue("url")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call relativeUrlResolver.getURL(descriptorURL, substitute(attributes.getValue("file")), substitute(attributes.getValue("url"))) java.lang.RuntimeException: Error calculating the type of parameter attributes.getValue("file") of method call substitute(attributes.getValue("file")) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call newParser(UrlExternalResource.open(url), url) UnsolvedSymbolException{context='Solving UrlExternalResource', name='UrlExternalResource', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("name")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("name") (line: 836) MethodCallExprContext{wrapped=attributes.getValue("name")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Empty name expression CONF
Cannot solve method call substitute(attributes.getValue("visibility")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("visibility") (line: 839) MethodCallExprContext{wrapped=attributes.getValue("visibility")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call elvis(substitute(attributes.getValue("visibility")), "public") java.lang.RuntimeException: Error calculating the type of parameter attributes.getValue("visibility") of method call substitute(attributes.getValue("visibility")) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot resolve field access null
Cannot solve method call substitute(attributes.getValue("description")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("description") (line: 840) MethodCallExprContext{wrapped=attributes.getValue("description")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("extends")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("extends") (line: 841) MethodCallExprContext{wrapped=attributes.getValue("extends")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("extends")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("extends") (line: 841) MethodCallExprContext{wrapped=attributes.getValue("extends")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Error calculating the type of parameter attributes.getValue("extends") of method call substitute(attributes.getValue("extends"))
Cannot solve method call Boolean.valueOf(attributes.getValue("transitive")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("transitive") (line: 843) MethodCallExprContext{wrapped=attributes.getValue("transitive")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Empty name expression PUB
Empty name expression DEP
Cannot solve method call substitute(attributes.getValue("mapped")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("mapped") (line: 862) MethodCallExprContext{wrapped=attributes.getValue("mapped")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call dd.addDependencyConfiguration(conf, depConf.trim()) java.lang.RuntimeException: Method 'trim' cannot be resolved in context depConf.trim() (line: 866) MethodCallExprContext{wrapped=depConf.trim()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Empty name expression DEP_ARTIFACT
Empty name expression ARTIFACT_INCLUDE
Empty name expression ARTIFACT_EXCLUDE
Cannot solve field access State.DEP
Cannot solve method call substitute(attributes.getValue("org")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("org") (line: 885) MethodCallExprContext{wrapped=attributes.getValue("org")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Method 'getModuleRevisionId' cannot be resolved in context getMd().getModuleRevisionId() (line: 887) MethodCallExprContext{wrapped=getMd().getModuleRevisionId()}. Parameter types: []
Cannot solve method call substitute(attributes.getValue("force")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("force") (line: 889) MethodCallExprContext{wrapped=attributes.getValue("force")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call Boolean.valueOf(substitute(attributes.getValue("force"))) java.lang.RuntimeException: Error calculating the type of parameter attributes.getValue("force") of method call substitute(attributes.getValue("force")) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("changing")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("changing") (line: 890) MethodCallExprContext{wrapped=attributes.getValue("changing")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call Boolean.valueOf(substitute(attributes.getValue("changing"))) java.lang.RuntimeException: Error calculating the type of parameter attributes.getValue("changing") of method call substitute(attributes.getValue("changing")) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("transitive")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("transitive") (line: 892) MethodCallExprContext{wrapped=attributes.getValue("transitive")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("name")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("name") (line: 895) MethodCallExprContext{wrapped=attributes.getValue("name")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("branch")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("branch") (line: 896) MethodCallExprContext{wrapped=attributes.getValue("branch")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("branchConstraint")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("branchConstraint") (line: 897) MethodCallExprContext{wrapped=attributes.getValue("branchConstraint")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("rev")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("rev") (line: 898) MethodCallExprContext{wrapped=attributes.getValue("rev")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("revConstraint")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("revConstraint") (line: 899) MethodCallExprContext{wrapped=attributes.getValue("revConstraint")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("conf")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("conf") (line: 922) MethodCallExprContext{wrapped=attributes.getValue("conf")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve field access State.PUB
Cannot solve field access State.DEP
Cannot solve method call substitute(attributes.getValue("name")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("name") (line: 932) MethodCallExprContext{wrapped=attributes.getValue("name")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Method 'getModuleRevisionId' cannot be resolved in context getMd().getModuleRevisionId() (line: 932) MethodCallExprContext{wrapped=getMd().getModuleRevisionId()}. Parameter types: []
Cannot solve method call elvis(substitute(attributes.getValue("name")), getMd().getModuleRevisionId().getName()) java.lang.RuntimeException: Error calculating the type of parameter attributes.getValue("name") of method call substitute(attributes.getValue("name")) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("type")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("type") (line: 933) MethodCallExprContext{wrapped=attributes.getValue("type")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call elvis(substitute(attributes.getValue("type")), "jar") java.lang.RuntimeException: Error calculating the type of parameter attributes.getValue("type") of method call substitute(attributes.getValue("type")) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("ext")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("ext") (line: 934) MethodCallExprContext{wrapped=attributes.getValue("ext")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call elvis(substitute(attributes.getValue("ext")), type) java.lang.RuntimeException: Error calculating the type of parameter attributes.getValue("ext") of method call substitute(attributes.getValue("ext")) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("conf")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("conf") (line: 937) MethodCallExprContext{wrapped=attributes.getValue("conf")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call artifact.addConfiguration(confName.trim()) java.lang.RuntimeException: Method 'trim' cannot be resolved in context confName.trim() (line: 948) MethodCallExprContext{wrapped=confName.trim()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve field access State.DEPS
Cannot solve method call substitute(attributes.getValue("defaultconf")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("defaultconf") (line: 961) MethodCallExprContext{wrapped=attributes.getValue("defaultconf")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("defaultconfmapping")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("defaultconfmapping") (line: 965) MethodCallExprContext{wrapped=attributes.getValue("defaultconfmapping")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("confmappingoverride")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("confmappingoverride") (line: 969) MethodCallExprContext{wrapped=attributes.getValue("confmappingoverride")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call getMd().setMappingOverride(Boolean.valueOf(confMappingOverride)) UnsolvedSymbolException{context='Method 'valueOf' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=Boolean}'} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve field access State.CONF
Cannot solve method call substitute(attributes.getValue("defaultconfmapping")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("defaultconfmapping") (line: 978) MethodCallExprContext{wrapped=attributes.getValue("defaultconfmapping")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call setDefaultConfMapping(substitute(attributes.getValue("defaultconfmapping"))) java.lang.RuntimeException: Error calculating the type of parameter attributes.getValue("defaultconfmapping") of method call substitute(attributes.getValue("defaultconfmapping")) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("defaultconf")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("defaultconf") (line: 979) MethodCallExprContext{wrapped=attributes.getValue("defaultconf")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call setDefaultConf(substitute(attributes.getValue("defaultconf"))) java.lang.RuntimeException: Error calculating the type of parameter attributes.getValue("defaultconf") of method call substitute(attributes.getValue("defaultconf")) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("confmappingoverride")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("confmappingoverride") (line: 980) MethodCallExprContext{wrapped=attributes.getValue("confmappingoverride")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call Boolean.valueOf(substitute(attributes.getValue("confmappingoverride"))) java.lang.RuntimeException: Error calculating the type of parameter attributes.getValue("confmappingoverride") of method call substitute(attributes.getValue("confmappingoverride")) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call getMd().setMappingOverride(Boolean.valueOf(substitute(attributes.getValue("confmappingoverride")))) java.lang.RuntimeException: Error calculating the type of parameter substitute(attributes.getValue("confmappingoverride")) of method call Boolean.valueOf(substitute(attributes.getValue("confmappingoverride"))) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve field access State.INFO
Cannot solve method call substitute(attributes.getValue("organisation")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("organisation") (line: 985) MethodCallExprContext{wrapped=attributes.getValue("organisation")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("module")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("module") (line: 986) MethodCallExprContext{wrapped=attributes.getValue("module")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("revision")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("revision") (line: 987) MethodCallExprContext{wrapped=attributes.getValue("revision")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("branch")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("branch") (line: 988) MethodCallExprContext{wrapped=attributes.getValue("branch")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("status")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("status") (line: 992) MethodCallExprContext{wrapped=attributes.getValue("status")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call elvis(substitute(attributes.getValue("status")), "integration") java.lang.RuntimeException: Error calculating the type of parameter attributes.getValue("status") of method call substitute(attributes.getValue("status")) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call getMd().setStatus(elvis(substitute(attributes.getValue("status")), "integration")) java.lang.RuntimeException: Error calculating the type of parameter substitute(attributes.getValue("status")) of method call elvis(substitute(attributes.getValue("status")), "integration") /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("default")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("default") (line: 993) MethodCallExprContext{wrapped=attributes.getValue("default")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call Boolean.valueOf(substitute(attributes.getValue("default"))) java.lang.RuntimeException: Error calculating the type of parameter attributes.getValue("default") of method call substitute(attributes.getValue("default")) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call getMd().setDefault(Boolean.valueOf(substitute(attributes.getValue("default")))) java.lang.RuntimeException: Error calculating the type of parameter substitute(attributes.getValue("default")) of method call Boolean.valueOf(substitute(attributes.getValue("default"))) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("publication")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("publication") (line: 994) MethodCallExprContext{wrapped=attributes.getValue("publication")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call getMd().setPublicationDate(ivyDateFormat.parse(pubDate)) java.lang.RuntimeException: Method 'parse' cannot be resolved in context ivyDateFormat.parse(pubDate) (line: 998) MethodCallExprContext{wrapped=ivyDateFormat.parse(pubDate)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot resolve field access null
Cannot solve method call LOGGER.debug("pre 1.3 ivy file: using {} as default matcher", PatternMatcher.EXACT_OR_REGEXP) UnsolvedSymbolException{context='unknown', name='EXACT_OR_REGEXP', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot resolve field access null
Cannot solve method call getMatcher(PatternMatcher.EXACT_OR_REGEXP) UnsolvedSymbolException{context='unknown', name='EXACT_OR_REGEXP', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot resolve field access null
Cannot solve method call LOGGER.debug("post 1.3 ivy file: using {} as default matcher", PatternMatcher.EXACT) UnsolvedSymbolException{context='unknown', name='EXACT', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot resolve field access null
Cannot solve method call getMatcher(PatternMatcher.EXACT) UnsolvedSymbolException{context='unknown', name='EXACT', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Method 'getQName' cannot be resolved in context attributes.getQName(i) (line: 1021) MethodCallExprContext{wrapped=attributes.getQName(i)}. Parameter types: [PrimitiveTypeUsage{name='int'}]
Method 'getQName' cannot be resolved in context attributes.getQName(i) (line: 1022) MethodCallExprContext{wrapped=attributes.getQName(i)}. Parameter types: [PrimitiveTypeUsage{name='int'}]
Cannot solve method call getMd().addExtraAttributeNamespace(attributes.getQName(i).substring("xmlns:".length()), attributes.getValue(i)) java.lang.RuntimeException: Method 'getQName' cannot be resolved in context attributes.getQName(i) (line: 1022) MethodCallExprContext{wrapped=attributes.getQName(i)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Method 'append' cannot be resolved in context buffer.append("<") (line: 1028) MethodCallExprContext{wrapped=buffer.append("<")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call buffer.append(attributes.getQName(i)) java.lang.RuntimeException: Method 'getQName' cannot be resolved in context attributes.getQName(i) (line: 1031) MethodCallExprContext{wrapped=attributes.getQName(i)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call buffer.append(attributes.getValue(i)) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue(i) (line: 1033) MethodCallExprContext{wrapped=attributes.getValue(i)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve field access State.DEP_ARTIFACT
Cannot solve field access State.ARTIFACT_INCLUDE
Cannot solve field access State.ARTIFACT_EXCLUDE
Cannot solve method call substitute(attributes.getValue("name")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("name") (line: 1058) MethodCallExprContext{wrapped=attributes.getValue("name")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("artifact")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("artifact") (line: 1060) MethodCallExprContext{wrapped=attributes.getValue("artifact")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Method 'getDependencyId' cannot be resolved in context dd.getDependencyId() (line: 1062) MethodCallExprContext{wrapped=dd.getDependencyId()}. Parameter types: []
Cannot solve method call substitute(attributes.getValue("type")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("type") (line: 1066) MethodCallExprContext{wrapped=attributes.getValue("type")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("ext")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("ext") (line: 1070) MethodCallExprContext{wrapped=attributes.getValue("ext")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve field access State.DEP_ARTIFACT
Cannot solve field access State.ARTIFACT_INCLUDE
Cannot solve method call getPatternMatcher(attributes.getValue("matcher")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("matcher") (line: 1084) MethodCallExprContext{wrapped=attributes.getValue("matcher")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("org")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("org") (line: 1085) MethodCallExprContext{wrapped=attributes.getValue("org")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call elvis(substitute(attributes.getValue("org")), PatternMatchers.ANY_EXPRESSION) java.lang.RuntimeException: Error calculating the type of parameter attributes.getValue("org") of method call substitute(attributes.getValue("org")) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("module")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("module") (line: 1086) MethodCallExprContext{wrapped=attributes.getValue("module")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call elvis(substitute(attributes.getValue("module")), PatternMatchers.ANY_EXPRESSION) java.lang.RuntimeException: Error calculating the type of parameter attributes.getValue("module") of method call substitute(attributes.getValue("module")) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call getPatternMatcher(attributes.getValue("matcher")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("matcher") (line: 1077) MethodCallExprContext{wrapped=attributes.getValue("matcher")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("org")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("org") (line: 1078) MethodCallExprContext{wrapped=attributes.getValue("org")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call elvis(substitute(attributes.getValue("org")), PatternMatchers.ANY_EXPRESSION) java.lang.RuntimeException: Error calculating the type of parameter attributes.getValue("org") of method call substitute(attributes.getValue("org")) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("module")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("module") (line: 1079) MethodCallExprContext{wrapped=attributes.getValue("module")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call elvis(substitute(attributes.getValue("module")), PatternMatchers.ANY_EXPRESSION) java.lang.RuntimeException: Error calculating the type of parameter attributes.getValue("module") of method call substitute(attributes.getValue("module")) /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("url")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("url") (line: 1073) MethodCallExprContext{wrapped=attributes.getValue("url")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue("conf")) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue("conf") (line: 1091) MethodCallExprContext{wrapped=attributes.getValue("conf")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call addConfiguration(confName.trim()) java.lang.RuntimeException: Method 'trim' cannot be resolved in context confName.trim() (line: 1102) MethodCallExprContext{wrapped=confName.trim()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve field access State.EXCLUDE
Cannot solve method call dd.addIncludeRule(c, (IncludeRule) confAware) UnsolvedSymbolException{context='unknown', name='IncludeRule', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call dd.addDependencyArtifact(c, (DependencyArtifactDescriptor) confAware) UnsolvedSymbolException{context='unknown', name='DependencyArtifactDescriptor', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve field access State.PUB
Cannot solve field access State.DEP_ARTIFACT
Cannot solve field access State.ARTIFACT_INCLUDE
Cannot solve field access State.ARTIFACT_EXCLUDE
Cannot solve field access State.EXCLUDE
Cannot solve field access State.DEP
Cannot solve field access State.DEPS
Cannot solve field access State.INFO
Cannot solve field access State.DESCRIPTION
Cannot solve field access State.EXTRA_INFO
Cannot solve field access State.DESCRIPTION
Method 'append' cannot be resolved in context buffer.append("</") (line: 1195) MethodCallExprContext{wrapped=buffer.append("</")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context buffer.append("</") (line: 1195) MethodCallExprContext{wrapped=buffer.append("</")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call buffer.deleteCharAt(buffer.length() - 1) java.lang.RuntimeException: Method 'length' cannot be resolved in context buffer.length() (line: 1192) MethodCallExprContext{wrapped=buffer.length()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Method 'getExtraInfo' cannot be resolved in context getMd().getExtraInfo() (line: 1187) MethodCallExprContext{wrapped=getMd().getExtraInfo()}. Parameter types: []
Cannot solve field access State.INFO
Cannot solve field access State.INFO
Cannot solve field access State.NONE
Cannot solve field access State.NONE
Method 'getModuleConfigurations' cannot be resolved in context dd.getModuleConfigurations() (line: 1173) MethodCallExprContext{wrapped=dd.getModuleConfigurations()}. Parameter types: []
Cannot solve field access State.DEPS
Method 'getConfigurations' cannot be resolved in context confAware.getConfigurations() (line: 1164) MethodCallExprContext{wrapped=confAware.getConfigurations()}. Parameter types: []
Cannot solve field access State.DEPS
Cannot solve field access State.DEP
Method 'getConfigurations' cannot be resolved in context confAware.getConfigurations() (line: 1156) MethodCallExprContext{wrapped=confAware.getConfigurations()}. Parameter types: []
Cannot solve method call artifact.addConfiguration(confName.trim()) java.lang.RuntimeException: Method 'trim' cannot be resolved in context confName.trim() (line: 1145) MethodCallExprContext{wrapped=confName.trim()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Method 'getConfigurations' cannot be resolved in context getMd().getConfigurations() (line: 1201) MethodCallExprContext{wrapped=getMd().getConfigurations()}. Parameter types: []
Cannot solve method call ignored.contains(attributes.getQName(i)) java.lang.RuntimeException: Method 'getQName' cannot be resolved in context attributes.getQName(i) (line: 1231) MethodCallExprContext{wrapped=attributes.getQName(i)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call substitute(attributes.getValue(i)) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attributes.getValue(i) (line: 1232) MethodCallExprContext{wrapped=attributes.getValue(i)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Cannot solve method call ret.put(attributes.getQName(i), substitute(attributes.getValue(i))) java.lang.RuntimeException: Method 'getQName' cannot be resolved in context attributes.getQName(i) (line: 1232) MethodCallExprContext{wrapped=attributes.getQName(i)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/ivyresolve/parser/IvyXmlModuleDescriptorParser.java
Empty name expression Failed
Empty name expression Missing
Empty name expression Resolved
Method 'append' cannot be resolved in context new HashCodeBuilder(17, 31).append(namespace) (line: 93) MethodCallExprContext{wrapped=new HashCodeBuilder(17, 31).append(namespace)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context new HashCodeBuilder(17, 31).append(namespace) (line: 93) MethodCallExprContext{wrapped=new HashCodeBuilder(17, 31).append(namespace)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot resolve field access null
Cannot solve field access MutationValidator.MutationType.STRATEGY
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call validate(split[0].trim(), notation) java.lang.RuntimeException: Method 'trim' cannot be resolved in context split[0].trim() (line: 43) MethodCallExprContext{wrapped=split[0].trim()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/dependencysubstitution/ModuleSelectorStringNotationConverter.java
Cannot solve method call validate(split[1].trim(), notation) java.lang.RuntimeException: Method 'trim' cannot be resolved in context split[1].trim() (line: 44) MethodCallExprContext{wrapped=split[1].trim()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/dependencysubstitution/ModuleSelectorStringNotationConverter.java
Cannot resolve field access null
Method 'candidate' cannot be resolved in context visitor.candidate("String describing the module in 'group:name' format") (line: 58) MethodCallExprContext{wrapped=visitor.candidate("String describing the module in 'group:name' format")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'candidate' cannot be resolved in context visitor.candidate("String describing the selector in 'group:name:version' format") (line: 59) MethodCallExprContext{wrapped=visitor.candidate("String describing the selector in 'group:name:version' format")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'trim' cannot be resolved in context description.trim() (line: 123) MethodCallExprContext{wrapped=description.trim()}. Parameter types: []
Cannot solve method call writer.attribute("extends", Joiner.on(',').join(exts)) UnsolvedSymbolException{context='Method 'on' with parameterTypes [PrimitiveTypeUsage{name='char'}]', name='ReflectionClassDeclaration{clazz=Joiner}'} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/publisher/IvyXmlModuleDescriptorWriter.java
Cannot solve method call writer.attribute("conf", Joiner.on(",").join(artifactMetadata.getConfigurations())) UnsolvedSymbolException{context='Method 'on' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=Joiner}'} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/publisher/IvyXmlModuleDescriptorWriter.java
Cannot solve method call writer.attribute("conf", Joiner.on(',').join(ruleConfs)) UnsolvedSymbolException{context='Method 'on' with parameterTypes [PrimitiveTypeUsage{name='char'}]', name='ReflectionClassDeclaration{clazz=Joiner}'} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/publisher/IvyXmlModuleDescriptorWriter.java
Cannot solve method call writer.attribute("conf", Joiner.on(',').join(ruleConfs)) UnsolvedSymbolException{context='Method 'on' with parameterTypes [PrimitiveTypeUsage{name='char'}]', name='ReflectionClassDeclaration{clazz=Joiner}'} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/publisher/IvyXmlModuleDescriptorWriter.java
Cannot solve method call writer.attribute(entry.getKey(), entry.getValue().toString()) java.lang.UnsupportedOperationException: unbounded wildcard /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/publisher/IvyXmlModuleDescriptorWriter.java
Method 'keySet' cannot be resolved in context confMappings.keySet() (line: 204) MethodCallExprContext{wrapped=confMappings.keySet()}. Parameter types: []
Cannot solve method call writeCount(confMappings.keySet().size()) java.lang.RuntimeException: Method 'keySet' cannot be resolved in context confMappings.keySet() (line: 204) MethodCallExprContext{wrapped=confMappings.keySet()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/modulecache/ModuleMetadataSerializer.java
Cannot solve method call writeStringSet(confMappings.get(conf)) java.lang.RuntimeException: Method 'get' cannot be resolved in context confMappings.get(conf) (line: 207) MethodCallExprContext{wrapped=confMappings.get(conf)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/modulecache/ModuleMetadataSerializer.java
Cannot solve method call writeStringArray(exclude.getConfigurations().toArray(new String[0])) java.lang.RuntimeException: String[] T[] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/modulecache/ModuleMetadataSerializer.java
Cannot resolve field access null
Cannot solve method call createEntry(metadata, resource.getSha1()) java.lang.RuntimeException: Method 'getSha1' cannot be resolved in context resource.getSha1() (line: 91) MethodCallExprContext{wrapped=resource.getSha1()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/modulecache/DefaultModuleMetaDataCache.java
Cannot solve field access ModuleState.New
Cannot solve field access ModuleState.Selected
Cannot solve field access ModuleState.Evicted
Cannot solve field access ModuleState.Selected
Cannot solve field access ModuleState.Conflict
Cannot solve field access ModuleState.New
Cannot solve field access ModuleState.Selected
Cannot resolve field access null
Method 'getName' cannot be resolved in context matcher.getName() (line: 61) MethodCallExprContext{wrapped=matcher.getName()}. Parameter types: []
Method 'getMatcher' cannot be resolved in context matcher.getMatcher(expression) (line: 92) MethodCallExprContext{wrapped=matcher.getMatcher(expression)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot resolve field access null
Cannot solve method call addMatcher(ExactPatternMatcher.INSTANCE) UnsolvedSymbolException{context='unknown', name='INSTANCE', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/resolveengine/excludes/PatternMatchers.java
Cannot solve method call addMatcher(RegexpPatternMatcher.INSTANCE) UnsolvedSymbolException{context='unknown', name='INSTANCE', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/resolveengine/excludes/PatternMatchers.java
Cannot solve method call addMatcher(ExactOrRegexpPatternMatcher.INSTANCE) UnsolvedSymbolException{context='unknown', name='INSTANCE', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/resolveengine/excludes/PatternMatchers.java
Cannot solve method call addMatcher(GlobPatternMatcher.INSTANCE) UnsolvedSymbolException{context='unknown', name='INSTANCE', typeSolver=null} /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/resolveengine/excludes/PatternMatchers.java
Cannot solve method call matchers.put(instance.getName(), instance) java.lang.RuntimeException: Method 'getName' cannot be resolved in context instance.getName() (line: 51) MethodCallExprContext{wrapped=instance.getName()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/resolveengine/excludes/PatternMatchers.java
Cannot solve method call versionParser.transform(candidate.getVersion()) java.lang.RuntimeException: Method 'getVersion' cannot be resolved in context candidate.getVersion() (line: 38) MethodCallExprContext{wrapped=candidate.getVersion()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/resolveengine/LatestModuleConflictResolver.java
Cannot solve field access Implementation.BUILD
Cannot solve field access Implementation.MODULE
Cannot solve field access Implementation.LIBRARY
Cannot solve field access Implementation.LIBRARY
Cannot solve field access Implementation.BUILD
Cannot solve field access Implementation.MODULE
Method 'inverse' cannot be resolved in context REASONS.inverse() (line: 55) MethodCallExprContext{wrapped=REASONS.inverse()}. Parameter types: []
Cannot solve field access Implementation.BUILD
Cannot solve field access Implementation.MODULE
Cannot solve field access Implementation.LIBRARY
Cannot solve field access Implementation.LIBRARY
Cannot solve field access Implementation.BUILD
Cannot solve field access Implementation.MODULE
Cannot solve method call child.addParentSpecificArtifacts(parent, newHashSet(mapping.getArtifacts(decoder.readSmallLong()))) java.lang.RuntimeException: Method 'newHashSet' cannot be resolved in context newHashSet(mapping.getArtifacts(decoder.readSmallLong())) (line: 175) MethodCallExprContext{wrapped=newHashSet(mapping.getArtifacts(decoder.readSmallLong()))}. Parameter types: [ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{org.gradle.api.artifacts.ResolvedArtifact, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/resolveengine/oldresult/TransientConfigurationResultsBuilder.java
Cannot resolve field access null
Method 'getName' cannot be resolved in context entry.getKey().getName() (line: 43) MethodCallExprContext{wrapped=entry.getKey().getName()}. Parameter types: []
Cannot resolve field access null
Cannot solve method call validate(split[0].trim(), notation) java.lang.RuntimeException: Method 'trim' cannot be resolved in context split[0].trim() (line: 46) MethodCallExprContext{wrapped=split[0].trim()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/notations/ModuleIdentifierNotationConverter.java
Cannot solve method call validate(split[1].trim(), notation) java.lang.RuntimeException: Method 'trim' cannot be resolved in context split[1].trim() (line: 47) MethodCallExprContext{wrapped=split[1].trim()}. Parameter types: [] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/notations/ModuleIdentifierNotationConverter.java
Method 'candidate' cannot be resolved in context visitor.candidate("String describing the module in 'group:name' format") (line: 65) MethodCallExprContext{wrapped=visitor.candidate("String describing the module in 'group:name' format")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'candidate' cannot be resolved in context visitor.candidate("Map with mandatory 'path' and optional 'configuration' key") (line: 57) MethodCallExprContext{wrapped=visitor.candidate("Map with mandatory 'path' and optional 'configuration' key")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'candidate' cannot be resolved in context visitor.candidate("Maps") (line: 38) MethodCallExprContext{wrapped=visitor.candidate("Maps")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'candidate' cannot be resolved in context visitor.candidate("Projects") (line: 37) MethodCallExprContext{wrapped=visitor.candidate("Projects")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'candidate' cannot be resolved in context visitor.candidate("String or CharSequence values") (line: 40) MethodCallExprContext{wrapped=visitor.candidate("String or CharSequence values")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'candidate' cannot be resolved in context visitor.candidate("ClassPathNotation") (line: 71) MethodCallExprContext{wrapped=visitor.candidate("ClassPathNotation")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getClassPath' cannot be resolved in context classPathRegistry.getClassPath(notation.name()) (line: 91) MethodCallExprContext{wrapped=classPathRegistry.getClassPath(notation.name())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getClassPath' cannot be resolved in context classPathRegistry.getClassPath(LOCAL_GROOVY.name()) (line: 109) MethodCallExprContext{wrapped=classPathRegistry.getClassPath(LOCAL_GROOVY.name())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getClassPath' cannot be resolved in context classPathRegistry.getClassPath("GRADLE_INSTALLATION_BEACON") (line: 110) MethodCallExprContext{wrapped=classPathRegistry.getClassPath("GRADLE_INSTALLATION_BEACON")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve field access RuntimeShadedJarType.API
Method 'relocatedDepsJar' cannot be resolved in context relocatedDepsJar(apiClasspath, "gradleApi()", RuntimeShadedJarType.API) (line: 115) MethodCallExprContext{wrapped=relocatedDepsJar(apiClasspath, "gradleApi()", RuntimeShadedJarType.API)}. Parameter types: [ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.api.internal.runtimeshaded.RuntimeShadedJarType, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getClassPath' cannot be resolved in context classPathRegistry.getClassPath(GRADLE_API.name()) (line: 134) MethodCallExprContext{wrapped=classPathRegistry.getClassPath(GRADLE_API.name())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve field access RuntimeShadedJarType.TEST_KIT
Method 'relocatedDepsJar' cannot be resolved in context relocatedDepsJar(testKitClasspath, "gradleTestKit()", RuntimeShadedJarType.TEST_KIT) (line: 137) MethodCallExprContext{wrapped=relocatedDepsJar(testKitClasspath, "gradleTestKit()", RuntimeShadedJarType.TEST_KIT)}. Parameter types: [ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.api.internal.runtimeshaded.RuntimeShadedJarType, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'candidate' cannot be resolved in context visitor.candidate("FileCollections") (line: 36) MethodCallExprContext{wrapped=visitor.candidate("FileCollections")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call result.converted(instantiator.newInstance(DefaultSelfResolvingDependency.class, notation)) java.lang.RuntimeException: Method 'newInstance' cannot be resolved in context instantiator.newInstance(DefaultSelfResolvingDependency.class, notation) (line: 40) MethodCallExprContext{wrapped=instantiator.newInstance(DefaultSelfResolvingDependency.class, notation)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.internal.artifacts.dependencies.DefaultSelfResolvingDependency, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{org.gradle.api.file.FileCollection, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/dependency-management/src/main/java/org/gradle/api/internal/notations/DependencyFilesNotationConverter.java
Cannot solve method call GUtil.last(GUtil.last(STRING_COMPARATOR, OTHER_GROUP), DEFAULT_GROUP) UnsolvedSymbolException{context='Method 'last' with parameterTypes [ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=public class GUtil {

    private static final Pattern WORD_SEPARATOR = Pattern.compile("\\W+");

    private static final Pattern UPPER_LOWER = Pattern.compile("(?m)([A-Z]*)([a-z0-9]*)");

    public static <T extends Collection> T flatten(Object[] elements, T addTo, boolean flattenMaps) {
        return flatten(asList(elements), addTo, flattenMaps);
    }

    public static <T extends Collection> T flatten(Object[] elements, T addTo) {
        return flatten(asList(elements), addTo);
    }

    public static <T extends Collection> T flatten(Collection elements, T addTo) {
        return flatten(elements, addTo, true);
    }

    public static <T extends Collection> T flattenElements(Object... elements) {
        Collection<T> out = new LinkedList<T>();
        flatten(elements, out, true);
        return (T) out;
    }

    public static <T extends Collection> T flatten(Collection elements, T addTo, boolean flattenMapsAndArrays) {
        return flatten(elements, addTo, flattenMapsAndArrays, flattenMapsAndArrays);
    }

    public static <T extends Collection> T flatten(Collection elements, T addTo, boolean flattenMaps, boolean flattenArrays) {
        Iterator iter = elements.iterator();
        while (iter.hasNext()) {
            Object element = iter.next();
            if (element instanceof Collection) {
                flatten((Collection) element, addTo, flattenMaps, flattenArrays);
            } else if ((element instanceof Map) && flattenMaps) {
                flatten(((Map) element).values(), addTo, flattenMaps, flattenArrays);
            } else if ((element.getClass().isArray()) && flattenArrays) {
                flatten(asList((Object[]) element), addTo, flattenMaps, flattenArrays);
            } else {
                addTo.add(element);
            }
        }
        return addTo;
    }

    /**
     * Flattens input collections (including arrays *but* not maps). If input is not a collection wraps it in a collection and returns it.
     *
     * @param input any object
     * @return collection of flattened input or single input wrapped in a collection.
     */
    public static Collection collectionize(Object input) {
        if (input == null) {
            return emptyList();
        } else if (input instanceof Collection) {
            Collection out = new LinkedList();
            flatten((Collection) input, out, false, true);
            return out;
        } else if (input.getClass().isArray()) {
            Collection out = new LinkedList();
            flatten(asList((Object[]) input), out, false, true);
            return out;
        } else {
            return asList(input);
        }
    }

    public static List flatten(Collection elements, boolean flattenMapsAndArrays) {
        return flatten(elements, new ArrayList(), flattenMapsAndArrays);
    }

    public static List flatten(Collection elements) {
        return flatten(elements, new ArrayList());
    }

    public static String asPath(Iterable<?> collection) {
        return CollectionUtils.join(File.pathSeparator, collection);
    }

    public static List<String> prefix(String prefix, Collection<String> strings) {
        List<String> prefixed = new ArrayList<String>();
        for (String string : strings) {
            prefixed.add(prefix + string);
        }
        return prefixed;
    }

    public static boolean isTrue(Object object) {
        if (object == null) {
            return false;
        }
        if (object instanceof Collection) {
            return ((Collection) object).size() > 0;
        } else if (object instanceof String) {
            return ((String) object).length() > 0;
        }
        return true;
    }

    public static <T> T elvis(T object, T defaultValue) {
        return isTrue(object) ? object : defaultValue;
    }

    public static <V, T extends Collection<? super V>> T addToCollection(T dest, boolean failOnNull, Iterable<? extends V>... srcs) {
        for (Iterable<? extends V> src : srcs) {
            for (V v : src) {
                if (failOnNull && v == null) {
                    throw new IllegalArgumentException("Illegal null value provided in this collection: " + src);
                }
                dest.add(v);
            }
        }
        return dest;
    }

    public static <V, T extends Collection<? super V>> T addToCollection(T dest, Iterable<? extends V>... srcs) {
        return addToCollection(dest, false, srcs);
    }

    public static Comparator<String> caseInsensitive() {
        return new Comparator<String>() {

            public int compare(String o1, String o2) {
                int diff = o1.compareToIgnoreCase(o2);
                if (diff != 0) {
                    return diff;
                }
                return o1.compareTo(o2);
            }
        };
    }

    public static Map addMaps(Map map1, Map map2) {
        HashMap map = new HashMap();
        map.putAll(map1);
        map.putAll(map2);
        return map;
    }

    public static void addToMap(Map<String, String> dest, Map<?, ?> src) {
        for (Map.Entry<?, ?> entry : src.entrySet()) {
            dest.put(entry.getKey().toString(), entry.getValue().toString());
        }
    }

    public static Properties loadProperties(File propertyFile) {
        try {
            FileInputStream inputStream = new FileInputStream(propertyFile);
            try {
                return loadProperties(inputStream);
            } finally {
                inputStream.close();
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static Properties loadProperties(URL url) {
        try {
            URLConnection uc = url.openConnection();
            uc.setUseCaches(false);
            return loadProperties(uc.getInputStream());
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static Properties loadProperties(InputStream inputStream) {
        Properties properties = new Properties();
        try {
            properties.load(inputStream);
            inputStream.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
        return properties;
    }

    public static void saveProperties(Properties properties, File propertyFile) {
        try {
            FileOutputStream propertiesFileOutputStream = new FileOutputStream(propertyFile);
            try {
                properties.store(propertiesFileOutputStream, null);
            } finally {
                propertiesFileOutputStream.close();
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static void saveProperties(Properties properties, OutputStream outputStream) {
        try {
            try {
                properties.store(outputStream, null);
            } finally {
                outputStream.close();
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static void savePropertiesNoDateComment(Properties properties, OutputStream outputStream) {
        saveProperties(properties, new LineBufferingOutputStream(new SkipFirstTextStream(new WriterTextStream(new OutputStreamWriter(outputStream, Charsets.ISO_8859_1)))));
    }

    public static Map map(Object... objects) {
        Map map = new HashMap();
        assert objects.length % 2 == 0;
        for (int i = 0; i < objects.length; i += 2) {
            map.put(objects[i], objects[i + 1]);
        }
        return map;
    }

    public static String toString(Iterable<?> names) {
        Formatter formatter = new Formatter();
        boolean first = true;
        for (Object name : names) {
            if (first) {
                formatter.format("'%s'", name);
                first = false;
            } else {
                formatter.format(", '%s'", name);
            }
        }
        return formatter.toString();
    }

    /**
     * Converts an arbitrary string to a camel-case string which can be used in a Java identifier. Eg, with_underscores -> withUnderscores
     */
    public static String toCamelCase(CharSequence string) {
        if (string == null) {
            return null;
        }
        StringBuilder builder = new StringBuilder();
        Matcher matcher = WORD_SEPARATOR.matcher(string);
        int pos = 0;
        while (matcher.find()) {
            builder.append(StringUtils.capitalize(string.subSequence(pos, matcher.start()).toString()));
            pos = matcher.end();
        }
        builder.append(StringUtils.capitalize(string.subSequence(pos, string.length()).toString()));
        return builder.toString();
    }

    public static String toLowerCamelCase(CharSequence string) {
        String camelCase = toCamelCase(string);
        if (camelCase == null) {
            return null;
        }
        if (camelCase.length() == 0) {
            return "";
        }
        return ((Character) camelCase.charAt(0)).toString().toLowerCase() + camelCase.subSequence(1, camelCase.length());
    }

    /**
     * Converts an arbitrary string to upper case identifier with words separated by _. Eg, camelCase -> CAMEL_CASE
     */
    public static String toConstant(CharSequence string) {
        if (string == null) {
            return null;
        }
        return toWords(string, '_').toUpperCase();
    }

    /**
     * Converts an arbitrary string to space-separated words. Eg, camelCase -> camel case, with_underscores -> with underscores
     */
    public static String toWords(CharSequence string) {
        return toWords(string, ' ');
    }

    public static String toWords(CharSequence string, char separator) {
        if (string == null) {
            return null;
        }
        StringBuilder builder = new StringBuilder();
        int pos = 0;
        Matcher matcher = UPPER_LOWER.matcher(string);
        while (pos < string.length()) {
            matcher.find(pos);
            if (matcher.end() == pos) {
                // Not looking at a match
                pos++;
                continue;
            }
            if (builder.length() > 0) {
                builder.append(separator);
            }
            String group1 = matcher.group(1).toLowerCase();
            String group2 = matcher.group(2);
            if (group2.length() == 0) {
                builder.append(group1);
            } else {
                if (group1.length() > 1) {
                    builder.append(group1.substring(0, group1.length() - 1));
                    builder.append(separator);
                    builder.append(group1.substring(group1.length() - 1));
                } else {
                    builder.append(group1);
                }
                builder.append(group2);
            }
            pos = matcher.end();
        }
        return builder.toString();
    }

    public static byte[] serialize(Object object) {
        StreamByteBuffer buffer = new StreamByteBuffer();
        serialize(object, buffer.getOutputStream());
        return buffer.readAsByteArray();
    }

    public static void serialize(Object object, OutputStream outputStream) {
        try {
            ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);
            objectOutputStream.writeObject(object);
            objectOutputStream.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static <T> Comparator<T> last(final Comparator<? super T> comparator, final T lastValue) {
        return new Comparator<T>() {

            public int compare(T o1, T o2) {
                boolean o1Last = comparator.compare(o1, lastValue) == 0;
                boolean o2Last = comparator.compare(o2, lastValue) == 0;
                if (o1Last && o2Last) {
                    return 0;
                }
                if (o1Last && !o2Last) {
                    return 1;
                }
                if (!o1Last && o2Last) {
                    return -1;
                }
                return comparator.compare(o1, o2);
            }
        };
    }

    /**
     * Calls the given callable converting any thrown exception to an unchecked exception via {@link UncheckedException#throwAsUncheckedException(Throwable)}
     *
     * @param callable The callable to call
     * @param <T> Callable's return type
     * @return The value returned by {@link Callable#call()}
     */
    public static <T> T uncheckedCall(Callable<T> callable) {
        try {
            return callable.call();
        } catch (Exception e) {
            throw UncheckedException.throwAsUncheckedException(e);
        }
    }
}}'} /repo/subprojects/diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/internal/DefaultGroupTaskReportModel.java
Cannot solve method call findOtherGroup(groups.keySet()) java.lang.RuntimeException: Method 'keySet' cannot be resolved in context groups.keySet() (line: 57) MethodCallExprContext{wrapped=groups.keySet()}. Parameter types: [] /repo/subprojects/diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/internal/DefaultGroupTaskReportModel.java
Method 'keySet' cannot be resolved in context groups.keySet() (line: 58) MethodCallExprContext{wrapped=groups.keySet()}. Parameter types: []
Cannot solve method call groups.putAll(otherGroupName, groups.removeAll(DEFAULT_GROUP)) java.lang.RuntimeException: Method 'removeAll' cannot be resolved in context groups.removeAll(DEFAULT_GROUP) (line: 59) MethodCallExprContext{wrapped=groups.removeAll(DEFAULT_GROUP)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/internal/DefaultGroupTaskReportModel.java
Method 'keySet' cannot be resolved in context groups.keySet() (line: 61) MethodCallExprContext{wrapped=groups.keySet()}. Parameter types: []
Method 'keySet' cannot be resolved in context groups.keySet() (line: 61) MethodCallExprContext{wrapped=groups.keySet()}. Parameter types: []
Cannot solve method call groups.putAll(OTHER_GROUP, groups.removeAll(DEFAULT_GROUP)) java.lang.RuntimeException: Method 'removeAll' cannot be resolved in context groups.removeAll(DEFAULT_GROUP) (line: 62) MethodCallExprContext{wrapped=groups.removeAll(DEFAULT_GROUP)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/internal/DefaultGroupTaskReportModel.java
Method 'getTextOutput' cannot be resolved in context getTextOutput() (line: 69) MethodCallExprContext{wrapped=getTextOutput()}. Parameter types: []
Cannot solve method call addSubheading(StringUtils.capitalize(taskGroup) + " tasks") UnsolvedSymbolException{context='Method 'capitalize' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=org.apache.commons.lang.StringUtils}'} /repo/subprojects/diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/internal/TaskReportRenderer.java
Method 'getTextOutput' cannot be resolved in context getTextOutput() (line: 99) MethodCallExprContext{wrapped=getTextOutput()}. Parameter types: []
Method 'getTextOutput' cannot be resolved in context getTextOutput() (line: 100) MethodCallExprContext{wrapped=getTextOutput()}. Parameter types: []
Method 'getTextOutput' cannot be resolved in context getTextOutput() (line: 100) MethodCallExprContext{wrapped=getTextOutput()}. Parameter types: []
Cannot solve method call GUtil.isTrue(task.getDescription()) java.lang.RuntimeException: Method 'getDescription' cannot be resolved in context task.getDescription() (line: 101) MethodCallExprContext{wrapped=task.getDescription()}. Parameter types: [] /repo/subprojects/diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/internal/TaskReportRenderer.java
Method 'getTextOutput' cannot be resolved in context getTextOutput() (line: 102) MethodCallExprContext{wrapped=getTextOutput()}. Parameter types: []
Method 'getTextOutput' cannot be resolved in context getTextOutput() (line: 102) MethodCallExprContext{wrapped=getTextOutput()}. Parameter types: []
Cannot solve method call sortedDependencies.add(dependency.getPath()) java.lang.RuntimeException: Method 'getPath' cannot be resolved in context dependency.getPath() (line: 107) MethodCallExprContext{wrapped=dependency.getPath()}. Parameter types: [] /repo/subprojects/diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/internal/TaskReportRenderer.java
Method 'getTextOutput' cannot be resolved in context getTextOutput() (line: 110) MethodCallExprContext{wrapped=getTextOutput()}. Parameter types: []
Method 'getTextOutput' cannot be resolved in context getTextOutput() (line: 110) MethodCallExprContext{wrapped=getTextOutput()}. Parameter types: []
Method 'getTextOutput' cannot be resolved in context getTextOutput() (line: 113) MethodCallExprContext{wrapped=getTextOutput()}. Parameter types: []
Method 'getTextOutput' cannot be resolved in context getTextOutput() (line: 118) MethodCallExprContext{wrapped=getTextOutput()}. Parameter types: []
Method 'getBuilder' cannot be resolved in context getBuilder() (line: 121) MethodCallExprContext{wrapped=getBuilder()}. Parameter types: []
Method 'getTextOutput' cannot be resolved in context getTextOutput() (line: 129) MethodCallExprContext{wrapped=getTextOutput()}. Parameter types: []
Method 'getTextOutput' cannot be resolved in context getTextOutput() (line: 129) MethodCallExprContext{wrapped=getTextOutput()}. Parameter types: []
Method 'getTextOutput' cannot be resolved in context getTextOutput() (line: 143) MethodCallExprContext{wrapped=getTextOutput()}. Parameter types: []
No matching between ReferenceType{CharSequence, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual)
No matching between ReferenceType{CharSequence, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual)
Cannot solve method call item(title, fileResolver.resolveAsRelativePath(value)) java.lang.RuntimeException: Method 'resolveAsRelativePath' cannot be resolved in context fileResolver.resolveAsRelativePath(value) (line: 57) MethodCallExprContext{wrapped=fileResolver.resolveAsRelativePath(value)}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/internal/text/DefaultTextReportBuilder.java
No matching between ReferenceType{CharSequence, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual)
Cannot solve method call item(title, Joiner.on(", ").join(values)) UnsolvedSymbolException{context='Method 'on' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=Joiner}'} /repo/subprojects/diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/internal/text/DefaultTextReportBuilder.java
Cannot solve method call item(fileResolver.resolveAsRelativePath(value)) java.lang.RuntimeException: Method 'resolveAsRelativePath' cannot be resolved in context fileResolver.resolveAsRelativePath(value) (line: 73) MethodCallExprContext{wrapped=fileResolver.resolveAsRelativePath(value)}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/internal/text/DefaultTextReportBuilder.java
No matching between ReferenceType{CharSequence, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual)
Cannot solve method call renderer.setOutput(getTextOutputFactory().create(getClass())) java.lang.RuntimeException: Method 'create' cannot be resolved in context getTextOutputFactory().create(getClass()) (line: 54) MethodCallExprContext{wrapped=getTextOutputFactory().create(getClass())}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}] /repo/subprojects/diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/internal/ReportGenerator.java
Method 'getPath' cannot be resolved in context task1.getPath() (line: 35) MethodCallExprContext{wrapped=task1.getPath()}. Parameter types: []
Cannot solve method call dependencies.add(factory.create(dep)) java.lang.RuntimeException: Method 'create' cannot be resolved in context factory.create(dep) (line: 73) MethodCallExprContext{wrapped=factory.create(dep)}. Parameter types: [ReferenceType{org.gradle.api.Task, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/internal/SingleProjectTaskReportModel.java
Method 'candidate' cannot be resolved in context visitor.candidate("Non-empty String or CharSequence value") (line: 36) MethodCallExprContext{wrapped=visitor.candidate("Non-empty String or CharSequence value")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'invalidNotationMessage' cannot be resolved in context NotationParserBuilder.toType(new TypeInfo<Spec<DependencyResult>>(Spec.class)).invalidNotationMessage("Please check the input for the DependencyInsight.dependency element.") (line: 40) MethodCallExprContext{wrapped=NotationParserBuilder.toType(new TypeInfo<Spec<DependencyResult>>(Spec.class)).invalidNotationMessage("Please check the input for the DependencyInsight.dependency element.")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'invalidNotationMessage' cannot be resolved in context NotationParserBuilder.toType(new TypeInfo<Spec<DependencyResult>>(Spec.class)).invalidNotationMessage("Please check the input for the DependencyInsight.dependency element.") (line: 40) MethodCallExprContext{wrapped=NotationParserBuilder.toType(new TypeInfo<Spec<DependencyResult>>(Spec.class)).invalidNotationMessage("Please check the input for the DependencyInsight.dependency element.")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'invalidNotationMessage' cannot be resolved in context NotationParserBuilder.toType(new TypeInfo<Spec<DependencyResult>>(Spec.class)).invalidNotationMessage("Please check the input for the DependencyInsight.dependency element.") (line: 40) MethodCallExprContext{wrapped=NotationParserBuilder.toType(new TypeInfo<Spec<DependencyResult>>(Spec.class)).invalidNotationMessage("Please check the input for the DependencyInsight.dependency element.")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call output.println("No dependencies matching given input were found in " + String.valueOf(configuration)) UnsolvedSymbolException{context='Method 'valueOf' with parameterTypes [ReferenceType{org.gradle.api.artifacts.Configuration, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/DependencyInsightReportTask.java
Cannot solve method call styledTextOutput.text(StringUtils.capitalize(project.toString())) UnsolvedSymbolException{context='Method 'capitalize' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=org.apache.commons.lang.StringUtils}'} /repo/subprojects/diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/ProjectReportTask.java
Cannot solve method call getClass().getResource(getReportResourcePath("style.css")) java.lang.RuntimeException: Method 'getReportResourcePath' cannot be resolved in context getReportResourcePath("style.css") (line: 40) MethodCallExprContext{wrapped=getReportResourcePath("style.css")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/diagnostics/src/main/java/org/gradle/api/reporting/dependencies/internal/ProjectPageRenderer.java
Cannot solve method call builder.requireResource(getClass().getResource(getReportResourcePath("style.css"))) java.lang.RuntimeException: Error calculating the type of parameter getReportResourcePath("style.css") of method call getClass().getResource(getReportResourcePath("style.css")) /repo/subprojects/diagnostics/src/main/java/org/gradle/api/reporting/dependencies/internal/ProjectPageRenderer.java
Cannot solve method call getClass().getResource(getReportResourcePath("jquery.jstree.js")) java.lang.RuntimeException: Method 'getReportResourcePath' cannot be resolved in context getReportResourcePath("jquery.jstree.js") (line: 42) MethodCallExprContext{wrapped=getReportResourcePath("jquery.jstree.js")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/diagnostics/src/main/java/org/gradle/api/reporting/dependencies/internal/ProjectPageRenderer.java
Cannot solve method call builder.requireResource(getClass().getResource(getReportResourcePath("jquery.jstree.js"))) java.lang.RuntimeException: Error calculating the type of parameter getReportResourcePath("jquery.jstree.js") of method call getClass().getResource(getReportResourcePath("jquery.jstree.js")) /repo/subprojects/diagnostics/src/main/java/org/gradle/api/reporting/dependencies/internal/ProjectPageRenderer.java
Cannot solve method call getClass().getResource(getReportResourcePath("script.js")) java.lang.RuntimeException: Method 'getReportResourcePath' cannot be resolved in context getReportResourcePath("script.js") (line: 43) MethodCallExprContext{wrapped=getReportResourcePath("script.js")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/diagnostics/src/main/java/org/gradle/api/reporting/dependencies/internal/ProjectPageRenderer.java
Cannot solve method call builder.requireResource(getClass().getResource(getReportResourcePath("script.js"))) java.lang.RuntimeException: Error calculating the type of parameter getReportResourcePath("script.js") of method call getClass().getResource(getReportResourcePath("script.js")) /repo/subprojects/diagnostics/src/main/java/org/gradle/api/reporting/dependencies/internal/ProjectPageRenderer.java
Cannot solve method call getClass().getResource(getReportResourcePath("tree.css")) java.lang.RuntimeException: Method 'getReportResourcePath' cannot be resolved in context getReportResourcePath("tree.css") (line: 44) MethodCallExprContext{wrapped=getReportResourcePath("tree.css")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/diagnostics/src/main/java/org/gradle/api/reporting/dependencies/internal/ProjectPageRenderer.java
Cannot solve method call builder.requireResource(getClass().getResource(getReportResourcePath("tree.css"))) java.lang.RuntimeException: Error calculating the type of parameter getReportResourcePath("tree.css") of method call getClass().getResource(getReportResourcePath("tree.css")) /repo/subprojects/diagnostics/src/main/java/org/gradle/api/reporting/dependencies/internal/ProjectPageRenderer.java
Cannot solve method call getClass().getResource(getReportResourcePath("d.gif")) java.lang.RuntimeException: Method 'getReportResourcePath' cannot be resolved in context getReportResourcePath("d.gif") (line: 45) MethodCallExprContext{wrapped=getReportResourcePath("d.gif")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/diagnostics/src/main/java/org/gradle/api/reporting/dependencies/internal/ProjectPageRenderer.java
Cannot solve method call builder.requireResource(getClass().getResource(getReportResourcePath("d.gif"))) java.lang.RuntimeException: Error calculating the type of parameter getReportResourcePath("d.gif") of method call getClass().getResource(getReportResourcePath("d.gif")) /repo/subprojects/diagnostics/src/main/java/org/gradle/api/reporting/dependencies/internal/ProjectPageRenderer.java
Cannot solve method call getClass().getResource(getReportResourcePath("d.png")) java.lang.RuntimeException: Method 'getReportResourcePath' cannot be resolved in context getReportResourcePath("d.png") (line: 46) MethodCallExprContext{wrapped=getReportResourcePath("d.png")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/diagnostics/src/main/java/org/gradle/api/reporting/dependencies/internal/ProjectPageRenderer.java
Cannot solve method call builder.requireResource(getClass().getResource(getReportResourcePath("d.png"))) java.lang.RuntimeException: Error calculating the type of parameter getReportResourcePath("d.png") of method call getClass().getResource(getReportResourcePath("d.png")) /repo/subprojects/diagnostics/src/main/java/org/gradle/api/reporting/dependencies/internal/ProjectPageRenderer.java
Cannot solve method call getClass().getResource(getReportResourcePath("throbber.gif")) java.lang.RuntimeException: Method 'getReportResourcePath' cannot be resolved in context getReportResourcePath("throbber.gif") (line: 47) MethodCallExprContext{wrapped=getReportResourcePath("throbber.gif")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/diagnostics/src/main/java/org/gradle/api/reporting/dependencies/internal/ProjectPageRenderer.java
Cannot solve method call builder.requireResource(getClass().getResource(getReportResourcePath("throbber.gif"))) java.lang.RuntimeException: Error calculating the type of parameter getReportResourcePath("throbber.gif") of method call getClass().getResource(getReportResourcePath("throbber.gif")) /repo/subprojects/diagnostics/src/main/java/org/gradle/api/reporting/dependencies/internal/ProjectPageRenderer.java
Method 'meta' cannot be resolved in context meta() (line: 52) MethodCallExprContext{wrapped=meta()}. Parameter types: []
Method 'meta' cannot be resolved in context meta() (line: 52) MethodCallExprContext{wrapped=meta()}. Parameter types: []
Method 'meta' cannot be resolved in context meta() (line: 53) MethodCallExprContext{wrapped=meta()}. Parameter types: []
Method 'meta' cannot be resolved in context meta() (line: 53) MethodCallExprContext{wrapped=meta()}. Parameter types: []
Method 'link' cannot be resolved in context link() (line: 54) MethodCallExprContext{wrapped=link()}. Parameter types: []
Method 'link' cannot be resolved in context link() (line: 54) MethodCallExprContext{wrapped=link()}. Parameter types: []
Method 'link' cannot be resolved in context link() (line: 54) MethodCallExprContext{wrapped=link()}. Parameter types: []
Method 'link' cannot be resolved in context link() (line: 54) MethodCallExprContext{wrapped=link()}. Parameter types: []
Method 'link' cannot be resolved in context link() (line: 55) MethodCallExprContext{wrapped=link()}. Parameter types: []
Method 'link' cannot be resolved in context link() (line: 55) MethodCallExprContext{wrapped=link()}. Parameter types: []
Method 'link' cannot be resolved in context link() (line: 55) MethodCallExprContext{wrapped=link()}. Parameter types: []
Method 'link' cannot be resolved in context link() (line: 55) MethodCallExprContext{wrapped=link()}. Parameter types: []
Method 'script' cannot be resolved in context script() (line: 56) MethodCallExprContext{wrapped=script()}. Parameter types: []
Method 'script' cannot be resolved in context script() (line: 56) MethodCallExprContext{wrapped=script()}. Parameter types: []
Method 'script' cannot be resolved in context script() (line: 56) MethodCallExprContext{wrapped=script()}. Parameter types: []
Method 'script' cannot be resolved in context script() (line: 57) MethodCallExprContext{wrapped=script()}. Parameter types: []
Method 'script' cannot be resolved in context script() (line: 57) MethodCallExprContext{wrapped=script()}. Parameter types: []
Method 'script' cannot be resolved in context script() (line: 57) MethodCallExprContext{wrapped=script()}. Parameter types: []
Method 'script' cannot be resolved in context script() (line: 58) MethodCallExprContext{wrapped=script()}. Parameter types: []
Method 'script' cannot be resolved in context script() (line: 58) MethodCallExprContext{wrapped=script()}. Parameter types: []
Method 'script' cannot be resolved in context script() (line: 58) MethodCallExprContext{wrapped=script()}. Parameter types: []
Method 'script' cannot be resolved in context script() (line: 59) MethodCallExprContext{wrapped=script()}. Parameter types: []
Method 'script' cannot be resolved in context script() (line: 59) MethodCallExprContext{wrapped=script()}. Parameter types: []
Method 'script' cannot be resolved in context script() (line: 59) MethodCallExprContext{wrapped=script()}. Parameter types: []
Method 'title' cannot be resolved in context title() (line: 60) MethodCallExprContext{wrapped=title()}. Parameter types: []
Method 'title' cannot be resolved in context title() (line: 60) MethodCallExprContext{wrapped=title()}. Parameter types: []
Method 'div' cannot be resolved in context div() (line: 63) MethodCallExprContext{wrapped=div()}. Parameter types: []
Method 'h1' cannot be resolved in context h1() (line: 64) MethodCallExprContext{wrapped=h1()}. Parameter types: []
Method 'h1' cannot be resolved in context h1() (line: 64) MethodCallExprContext{wrapped=h1()}. Parameter types: []
Method 'div' cannot be resolved in context div() (line: 65) MethodCallExprContext{wrapped=div()}. Parameter types: []
Method 'a' cannot be resolved in context a() (line: 66) MethodCallExprContext{wrapped=a()}. Parameter types: []
Method 'a' cannot be resolved in context a() (line: 66) MethodCallExprContext{wrapped=a()}. Parameter types: []
Method 'a' cannot be resolved in context a() (line: 66) MethodCallExprContext{wrapped=a()}. Parameter types: []
Method 'span' cannot be resolved in context span() (line: 68) MethodCallExprContext{wrapped=span()}. Parameter types: []
Method 'span' cannot be resolved in context span() (line: 68) MethodCallExprContext{wrapped=span()}. Parameter types: []
Method 'div' cannot be resolved in context div() (line: 70) MethodCallExprContext{wrapped=div()}. Parameter types: []
Method 'div' cannot be resolved in context div() (line: 70) MethodCallExprContext{wrapped=div()}. Parameter types: []
Method 'div' cannot be resolved in context div() (line: 71) MethodCallExprContext{wrapped=div()}. Parameter types: []
Method 'div' cannot be resolved in context div() (line: 71) MethodCallExprContext{wrapped=div()}. Parameter types: []
Method 'div' cannot be resolved in context div() (line: 72) MethodCallExprContext{wrapped=div()}. Parameter types: []
Method 'a' cannot be resolved in context a() (line: 75) MethodCallExprContext{wrapped=a()}. Parameter types: []
Method 'a' cannot be resolved in context a() (line: 75) MethodCallExprContext{wrapped=a()}. Parameter types: []
Method 'a' cannot be resolved in context a() (line: 75) MethodCallExprContext{wrapped=a()}. Parameter types: []
Method 'meta' cannot be resolved in context meta() (line: 46) MethodCallExprContext{wrapped=meta()}. Parameter types: []
Method 'meta' cannot be resolved in context meta() (line: 46) MethodCallExprContext{wrapped=meta()}. Parameter types: []
Method 'meta' cannot be resolved in context meta() (line: 47) MethodCallExprContext{wrapped=meta()}. Parameter types: []
Method 'meta' cannot be resolved in context meta() (line: 47) MethodCallExprContext{wrapped=meta()}. Parameter types: []
Method 'link' cannot be resolved in context link() (line: 48) MethodCallExprContext{wrapped=link()}. Parameter types: []
Method 'link' cannot be resolved in context link() (line: 48) MethodCallExprContext{wrapped=link()}. Parameter types: []
Method 'link' cannot be resolved in context link() (line: 48) MethodCallExprContext{wrapped=link()}. Parameter types: []
Method 'link' cannot be resolved in context link() (line: 48) MethodCallExprContext{wrapped=link()}. Parameter types: []
Method 'link' cannot be resolved in context link() (line: 49) MethodCallExprContext{wrapped=link()}. Parameter types: []
Method 'link' cannot be resolved in context link() (line: 49) MethodCallExprContext{wrapped=link()}. Parameter types: []
Method 'link' cannot be resolved in context link() (line: 49) MethodCallExprContext{wrapped=link()}. Parameter types: []
Method 'link' cannot be resolved in context link() (line: 49) MethodCallExprContext{wrapped=link()}. Parameter types: []
Method 'title' cannot be resolved in context title() (line: 50) MethodCallExprContext{wrapped=title()}. Parameter types: []
Method 'title' cannot be resolved in context title() (line: 50) MethodCallExprContext{wrapped=title()}. Parameter types: []
Method 'div' cannot be resolved in context div() (line: 53) MethodCallExprContext{wrapped=div()}. Parameter types: []
Method 'h1' cannot be resolved in context h1() (line: 54) MethodCallExprContext{wrapped=h1()}. Parameter types: []
Method 'h1' cannot be resolved in context h1() (line: 54) MethodCallExprContext{wrapped=h1()}. Parameter types: []
Method 'div' cannot be resolved in context div() (line: 55) MethodCallExprContext{wrapped=div()}. Parameter types: []
Method 'th' cannot be resolved in context th() (line: 59) MethodCallExprContext{wrapped=th()}. Parameter types: []
Method 'th' cannot be resolved in context th() (line: 59) MethodCallExprContext{wrapped=th()}. Parameter types: []
Method 'th' cannot be resolved in context th() (line: 60) MethodCallExprContext{wrapped=th()}. Parameter types: []
Method 'th' cannot be resolved in context th() (line: 60) MethodCallExprContext{wrapped=th()}. Parameter types: []
Method 'td' cannot be resolved in context td() (line: 66) MethodCallExprContext{wrapped=td()}. Parameter types: []
Method 'td' cannot be resolved in context td() (line: 66) MethodCallExprContext{wrapped=td()}. Parameter types: []
Method 'td' cannot be resolved in context td() (line: 66) MethodCallExprContext{wrapped=td()}. Parameter types: []
Method 'td' cannot be resolved in context td() (line: 66) MethodCallExprContext{wrapped=td()}. Parameter types: []
Method 'td' cannot be resolved in context td() (line: 66) MethodCallExprContext{wrapped=td()}. Parameter types: []
Method 'td' cannot be resolved in context td() (line: 67) MethodCallExprContext{wrapped=td()}. Parameter types: []
Method 'td' cannot be resolved in context td() (line: 67) MethodCallExprContext{wrapped=td()}. Parameter types: []
Method 'div' cannot be resolved in context div() (line: 73) MethodCallExprContext{wrapped=div()}. Parameter types: []
Method 'a' cannot be resolved in context a() (line: 76) MethodCallExprContext{wrapped=a()}. Parameter types: []
Method 'a' cannot be resolved in context a() (line: 76) MethodCallExprContext{wrapped=a()}. Parameter types: []
Method 'a' cannot be resolved in context a() (line: 76) MethodCallExprContext{wrapped=a()}. Parameter types: []
Cannot solve method call checkNotNull(emptyToNull(name), "name must not be null nor empty") java.lang.RuntimeException: Method 'emptyToNull' cannot be resolved in context emptyToNull(name) (line: 84) MethodCallExprContext{wrapped=emptyToNull(name)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/diagnostics/src/main/java/org/gradle/api/reporting/dependents/internal/DependentComponentsRenderableDependency.java
Cannot solve method call modelElement(registry, "testSuites", modelMap(ComponentSpec.class)) java.lang.RuntimeException: Method 'modelMap' cannot be resolved in context modelMap(ComponentSpec.class) (line: 62) MethodCallExprContext{wrapped=modelMap(ComponentSpec.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.platform.base.ComponentSpec, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/diagnostics/src/main/java/org/gradle/api/reporting/dependents/internal/DependentComponentsUtils.java
Method 'append' cannot be resolved in context error.append("s '") (line: 179) MethodCallExprContext{wrapped=error.append("s '")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Error calculating the type of parameter Joiner.on("', '").join(notFound) of method call error.append("s '").append(Joiner.on("', '").join(notFound))
Error calculating the type of parameter Joiner.on("', '").join(notFound) of method call error.append("s '").append(Joiner.on("', '").join(notFound))
Method 'append' cannot be resolved in context error.append(" '") (line: 176) MethodCallExprContext{wrapped=error.append(" '")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve field access Format.FULL
Cannot solve method call Format.valueOf(format.toUpperCase()) java.lang.RuntimeException: Method 'toUpperCase' cannot be resolved in context format.toUpperCase() (line: 69) MethodCallExprContext{wrapped=format.toUpperCase()}. Parameter types: [] /repo/subprojects/diagnostics/src/main/java/org/gradle/api/reporting/model/ModelReport.java
Cannot resolve field access null
Cannot solve field access ModelReport.Format.SHORT
Cannot solve method call styledTextoutput.withStyle(Description).format(" = %s", value.get()) java.lang.RuntimeException: Method 'get' cannot be resolved in context value.get() (line: 88) MethodCallExprContext{wrapped=value.get()}. Parameter types: [] /repo/subprojects/diagnostics/src/main/java/org/gradle/api/reporting/model/internal/ModelNodeRenderer.java
Cannot solve method call printNodeAttribute(styledTextoutput, "Type:", typeDescription.get()) java.lang.RuntimeException: Method 'get' cannot be resolved in context typeDescription.get() (line: 116) MethodCallExprContext{wrapped=typeDescription.get()}. Parameter types: [] /repo/subprojects/diagnostics/src/main/java/org/gradle/api/reporting/model/internal/ModelNodeRenderer.java
Cannot solve method call printNodeAttribute(styledTextoutput, "Value:", value.get()) java.lang.RuntimeException: Method 'get' cannot be resolved in context value.get() (line: 126) MethodCallExprContext{wrapped=value.get()}. Parameter types: [] /repo/subprojects/diagnostics/src/main/java/org/gradle/api/reporting/model/internal/ModelNodeRenderer.java
Cannot solve method call builder.heading(StringUtils.capitalize(component.getDisplayName())) UnsolvedSymbolException{context='Method 'capitalize' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=org.apache.commons.lang.StringUtils}'} /repo/subprojects/diagnostics/src/main/java/org/gradle/api/reporting/components/internal/ComponentRenderer.java
Cannot solve method call builder.collection("Source sets", CollectionUtils.sort(sourceComponentSpec.getSources().values(), SourceSetRenderer.SORT_ORDER), sourceSetRenderer, "source sets") UnsolvedSymbolException{context='Method 'sort' with parameterTypes [ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=ReferenceType{org.gradle.language.base.LanguageSourceSet, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=ReferenceType{org.gradle.language.base.LanguageSourceSet, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class CollectionUtils {

    /**
     * Returns null if the collection is empty otherwise expects a {@link #single(Iterable)} element to be found.
     */
    @Nullable
    public static <T> T findSingle(Collection<T> source) {
        return source.isEmpty() ? null : single(source);
    }

    /**
     * Returns the single element in the collection or throws.
     */
    public static <T> T single(Iterable<? extends T> source) {
        Iterator<? extends T> iterator = source.iterator();
        if (!iterator.hasNext()) {
            throw new NoSuchElementException("Expecting collection with single element, got none.");
        }
        T element = iterator.next();
        if (iterator.hasNext()) {
            throw new IllegalArgumentException("Expecting collection with single element, got multiple.");
        }
        return element;
    }

    public static <T> Collection<? extends T> checkedCast(Class<T> type, Collection<?> input) {
        for (Object o : input) {
            cast(type, o);
        }
        return Cast.uncheckedCast(input);
    }

    public static <T> T findFirst(Iterable<? extends T> source, Spec<? super T> filter) {
        for (T item : source) {
            if (filter.isSatisfiedBy(item)) {
                return item;
            }
        }
        return null;
    }

    public static <T> T findFirst(T[] source, Spec<? super T> filter) {
        for (T thing : source) {
            if (filter.isSatisfiedBy(thing)) {
                return thing;
            }
        }
        return null;
    }

    public static <T> T first(Iterable<? extends T> source) {
        return source.iterator().next();
    }

    public static <T> boolean any(Iterable<? extends T> source, Spec<? super T> filter) {
        return findFirst(source, filter) != null;
    }

    public static <T> boolean any(T[] source, Spec<? super T> filter) {
        return findFirst(source, filter) != null;
    }

    public static <T> Set<T> filter(Set<? extends T> set, Spec<? super T> filter) {
        return filter(set, new LinkedHashSet<T>(), filter);
    }

    public static <T> List<T> filter(List<? extends T> list, Spec<? super T> filter) {
        return filter(list, new LinkedList<T>(), filter);
    }

    public static <T> List<T> filter(T[] array, Spec<? super T> filter) {
        return filter(Arrays.asList(array), new LinkedList<T>(), filter);
    }

    /**
     * Returns a sorted copy of the provided collection of things. Uses the provided comparator to sort.
     */
    public static <T> List<T> sort(Iterable<? extends T> things, Comparator<? super T> comparator) {
        List<T> copy = toMutableList(things);
        Collections.sort(copy, comparator);
        return copy;
    }

    /**
     * Returns a sorted copy of the provided collection of things. Uses the natural ordering of the things.
     */
    public static <T extends Comparable> List<T> sort(Iterable<T> things) {
        List<T> copy = toMutableList(things);
        Collections.sort(copy);
        return copy;
    }

    public static <T, C extends Collection<T>> C filter(Iterable<? extends T> source, C destination, Spec<? super T> filter) {
        for (T item : source) {
            if (filter.isSatisfiedBy(item)) {
                destination.add(item);
            }
        }
        return destination;
    }

    public static <K, V> Map<K, V> filter(Map<K, V> map, Spec<Map.Entry<K, V>> filter) {
        return filter(map, new HashMap<K, V>(), filter);
    }

    public static <K, V> Map<K, V> filter(Map<K, V> map, Map<K, V> destination, Spec<Map.Entry<K, V>> filter) {
        for (Map.Entry<K, V> entry : map.entrySet()) {
            if (filter.isSatisfiedBy(entry)) {
                destination.put(entry.getKey(), entry.getValue());
            }
        }
        return destination;
    }

    public static <R, I> R[] collectArray(I[] list, Class<R> newType, Transformer<? extends R, ? super I> transformer) {
        @SuppressWarnings("unchecked") R[] destination = (R[]) Array.newInstance(newType, list.length);
        return collectArray(list, destination, transformer);
    }

    public static <R, I> R[] collectArray(I[] list, R[] destination, Transformer<? extends R, ? super I> transformer) {
        assert list.length <= destination.length;
        for (int i = 0; i < list.length; ++i) {
            destination[i] = transformer.transform(list[i]);
        }
        return destination;
    }

    public static <R, I> List<R> collect(List<? extends I> list, Transformer<? extends R, ? super I> transformer) {
        return collect(list, new ArrayList<R>(list.size()), transformer);
    }

    public static <R, I> List<R> collect(I[] list, Transformer<? extends R, ? super I> transformer) {
        return collect(Arrays.asList(list), transformer);
    }

    public static <R, I> Set<R> collect(Set<? extends I> set, Transformer<? extends R, ? super I> transformer) {
        return collect(set, new HashSet<R>(), transformer);
    }

    public static <R, I> List<R> collect(Iterable<? extends I> source, Transformer<? extends R, ? super I> transformer) {
        return collect(source, new LinkedList<R>(), transformer);
    }

    public static <R, I, C extends Collection<R>> C collect(Iterable<? extends I> source, C destination, Transformer<? extends R, ? super I> transformer) {
        for (I item : source) {
            destination.add(transformer.transform(item));
        }
        return destination;
    }

    public static List<String> toStringList(Iterable<?> iterable) {
        return collect(iterable, new LinkedList<String>(), Transformers.asString());
    }

    /**
     * Recursively unpacks all the given things into a flat list.
     *
     * Nulls are not removed, they are left intact.
     *
     * @param things The things to flatten
     * @return A flattened list of the given things
     */
    public static List<?> flattenCollections(Object... things) {
        return flattenCollections(Object.class, things);
    }

    /**
     * Recursively unpacks all the given things into a flat list, ensuring they are of a certain type.
     *
     * Nulls are not removed, they are left intact.
     *
     * If a non null object cannot be cast to the target type, a ClassCastException will be thrown.
     *
     * @param things The things to flatten
     * @param <T> The target type in the flattened list
     * @return A flattened list of the given things
     */
    public static <T> List<T> flattenCollections(Class<T> type, Object... things) {
        if (things == null) {
            return Collections.singletonList(null);
        } else if (things.length == 0) {
            return Collections.emptyList();
        } else if (things.length == 1) {
            Object thing = things[0];
            if (thing == null) {
                return Collections.singletonList(null);
            }
            if (thing.getClass().isArray()) {
                Object[] thingArray = (Object[]) thing;
                List<T> list = new ArrayList<T>(thingArray.length);
                for (Object thingThing : thingArray) {
                    list.addAll(flattenCollections(type, thingThing));
                }
                return list;
            }
            if (thing instanceof Collection) {
                Collection<?> collection = (Collection<?>) thing;
                List<T> list = new ArrayList<T>();
                for (Object element : collection) {
                    list.addAll(flattenCollections(type, element));
                }
                return list;
            }
            return Collections.singletonList(cast(type, thing));
        } else {
            List<T> list = new ArrayList<T>();
            for (Object thing : things) {
                list.addAll(flattenCollections(type, thing));
            }
            return list;
        }
    }

    public static <T> List<T> toList(Iterable<? extends T> things) {
        if (things instanceof List) {
            @SuppressWarnings("unchecked") List<T> castThings = (List<T>) things;
            return castThings;
        }
        return toMutableList(things);
    }

    public static <T> List<T> toList(Enumeration<? extends T> things) {
        AbstractList<T> list = new ArrayList<T>();
        while (things.hasMoreElements()) {
            list.add(things.nextElement());
        }
        return list;
    }

    private static <T> List<T> toMutableList(Iterable<? extends T> things) {
        if (things == null) {
            return new ArrayList<T>(0);
        }
        List<T> list = new ArrayList<T>();
        for (T thing : things) {
            list.add(thing);
        }
        return list;
    }

    public static <T> List<T> intersection(Collection<? extends Collection<T>> availableValuesByDescriptor) {
        List<T> result = new ArrayList<T>();
        Iterator<? extends Collection<T>> iterator = availableValuesByDescriptor.iterator();
        if (iterator.hasNext()) {
            Collection<T> firstSet = iterator.next();
            result.addAll(firstSet);
            while (iterator.hasNext()) {
                Collection<T> next = iterator.next();
                result.retainAll(next);
            }
        }
        return result;
    }

    public static <T> List<T> toList(T[] things) {
        if (things == null || things.length == 0) {
            return new ArrayList<T>(0);
        }
        List<T> list = new ArrayList<T>(things.length);
        Collections.addAll(list, things);
        return list;
    }

    public static <T> Set<T> toSet(Iterable<? extends T> things) {
        if (things == null) {
            return new HashSet<T>(0);
        }
        if (things instanceof Set) {
            @SuppressWarnings("unchecked") Set<T> castThings = (Set<T>) things;
            return castThings;
        }
        Set<T> set = new LinkedHashSet<T>();
        for (T thing : things) {
            set.add(thing);
        }
        return set;
    }

    public static <E> List<E> compact(List<E> list) {
        boolean foundAtLeastOneNull = false;
        List<E> compacted = null;
        int i = 0;
        for (E element : list) {
            if (element == null) {
                if (!foundAtLeastOneNull) {
                    compacted = new ArrayList<E>(list.size());
                    if (i > 0) {
                        compacted.addAll(list.subList(0, i));
                    }
                }
                foundAtLeastOneNull = true;
            } else if (foundAtLeastOneNull) {
                compacted.add(element);
            }
            ++i;
        }
        return foundAtLeastOneNull ? compacted : list;
    }

    public static <C extends Collection<String>> C stringize(Iterable<?> source, C destination) {
        return collect(source, destination, Transformers.asString());
    }

    public static List<String> stringize(Collection<?> source) {
        return stringize(source, new ArrayList<String>(source.size()));
    }

    public static <E> boolean replace(List<E> list, Spec<? super E> filter, Transformer<? extends E, ? super E> transformer) {
        boolean replaced = false;
        int i = 0;
        for (E it : list) {
            if (filter.isSatisfiedBy(it)) {
                list.set(i, transformer.transform(it));
                replaced = true;
            }
            ++i;
        }
        return replaced;
    }

    public static <K, V> void collectMap(Map<K, V> destination, Iterable<? extends V> items, Transformer<? extends K, ? super V> keyGenerator) {
        for (V item : items) {
            destination.put(keyGenerator.transform(item), item);
        }
    }

    /**
     * Given a set of values, derive a set of keys and return a map
     */
    public static <K, V> Map<K, V> collectMap(Iterable<? extends V> items, Transformer<? extends K, ? super V> keyGenerator) {
        Map<K, V> map = new LinkedHashMap<K, V>();
        collectMap(map, items, keyGenerator);
        return map;
    }

    public static <K, V> void collectMapValues(Map<K, V> destination, Iterable<? extends K> keys, Transformer<? extends V, ? super K> keyGenerator) {
        for (K item : keys) {
            destination.put(item, keyGenerator.transform(item));
        }
    }

    /**
     * Given a set of keys, derive a set of values and return a map
     */
    public static <K, V> Map<K, V> collectMapValues(Iterable<? extends K> keys, Transformer<? extends V, ? super K> keyGenerator) {
        Map<K, V> map = new LinkedHashMap<K, V>();
        collectMapValues(map, keys, keyGenerator);
        return map;
    }

    public static <T> boolean every(Iterable<? extends T> things, Spec<? super T> predicate) {
        for (T thing : things) {
            if (!predicate.isSatisfiedBy(thing)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Utility for adding an iterable to a collection.
     *
     * @param t1 The collection to add to
     * @param t2 The iterable to add each item of to the collection
     * @param <T> The element type of t1
     * @return t1
     */
    public static <T> Collection<T> addAll(Collection<T> t1, Iterable<? extends T> t2) {
        for (T t : t2) {
            t1.add(t);
        }
        return t1;
    }

    /**
     * Utility for adding an array to a collection.
     *
     * @param t1 The collection to add to
     * @param t2 The iterable to add each item of to the collection
     * @param <T> The element type of t1
     * @return t1
     */
    public static <T> Collection<T> addAll(Collection<T> t1, T... t2) {
        Collections.addAll(t1, t2);
        return t1;
    }

    /**
     * The result of diffing two sets.
     *
     * @param <T> The type of element the sets contain
     * @see CollectionUtils#diffSetsBy(java.util.Set, java.util.Set, org.gradle.api.Transformer)
     */
    public static class SetDiff<T> {

        public Set<T> leftOnly = new HashSet<T>();

        public Set<Pair<T, T>> common = new HashSet<Pair<T, T>>();

        public Set<T> rightOnly = new HashSet<T>();
    }

    /**
     * Provides a “diff report” of how the two sets are similar and how they are different, comparing the entries by some aspect.
     *
     * The transformer is used to generate the value to use to compare the entries by. That is, the entries are not compared by equals by an attribute or characteristic.
     *
     * The transformer is expected to produce a unique value for each entry in a single set. Behaviour is undefined if this condition is not met.
     *
     * @param left The set on the “left” side of the comparison.
     * @param right The set on the “right” side of the comparison.
     * @param compareBy Provides the value to compare entries from either side by
     * @param <T> The type of the entry objects
     * @return A representation of the difference
     */
    public static <T> SetDiff<T> diffSetsBy(Set<? extends T> left, Set<? extends T> right, Transformer<?, T> compareBy) {
        if (left == null) {
            throw new NullPointerException("'left' set is null");
        }
        if (right == null) {
            throw new NullPointerException("'right' set is null");
        }
        SetDiff<T> setDiff = new SetDiff<T>();
        Map<Object, T> indexedLeft = collectMap(left, compareBy);
        Map<Object, T> indexedRight = collectMap(right, compareBy);
        for (Map.Entry<Object, T> leftEntry : indexedLeft.entrySet()) {
            T rightValue = indexedRight.remove(leftEntry.getKey());
            if (rightValue == null) {
                setDiff.leftOnly.add(leftEntry.getValue());
            } else {
                Pair<T, T> pair = Pair.of(leftEntry.getValue(), rightValue);
                setDiff.common.add(pair);
            }
        }
        for (T rightValue : indexedRight.values()) {
            setDiff.rightOnly.add(rightValue);
        }
        return setDiff;
    }

    /**
     * Creates a string with {@code toString()} of each object with the given separator.
     *
     * <pre>
     * expect:
     * join(",", new Object[]{"a"}) == "a"
     * join(",", new Object[]{"a", "b", "c"}) == "a,b,c"
     * join(",", new Object[]{}) == ""
     * </pre>
     *
     * The {@code separator} must not be null and {@code objects} must not be null.
     *
     * @param separator The string by which to join each string representation
     * @param objects The objects to join the string representations of
     * @return The joined string
     */
    public static String join(String separator, Object[] objects) {
        return join(separator, objects == null ? null : Arrays.asList(objects));
    }

    /**
     * Creates a string with {@code toString()} of each object with the given separator.
     *
     * <pre>
     * expect:
     * join(",", ["a"]) == "a"
     * join(",", ["a", "b", "c"]) == "a,b,c"
     * join(",", []) == ""
     * </pre>
     *
     * The {@code separator} must not be null and {@code objects} must not be null.
     *
     * @param separator The string by which to join each string representation
     * @param objects The objects to join the string representations of
     * @return The joined string
     */
    public static String join(String separator, Iterable<?> objects) {
        if (separator == null) {
            throw new NullPointerException("The 'separator' cannot be null");
        }
        if (objects == null) {
            throw new NullPointerException("The 'objects' cannot be null");
        }
        StringBuilder string = new StringBuilder();
        Iterator<?> iterator = objects.iterator();
        if (iterator.hasNext()) {
            string.append(iterator.next().toString());
            while (iterator.hasNext()) {
                string.append(separator);
                string.append(iterator.next().toString());
            }
        }
        return string.toString();
    }

    /**
     * Partition given Collection into a Pair of Collections.
     *
     * <pre>Left</pre> Collection containing entries that satisfy the given predicate
     * <pre>Right</pre> Collection containing entries that do NOT satisfy the given predicate
     */
    public static <T> Pair<Collection<T>, Collection<T>> partition(Iterable<T> items, Spec<? super T> predicate) {
        Preconditions.checkNotNull(items, "Cannot partition null Collection");
        Preconditions.checkNotNull(predicate, "Cannot apply null Spec when partitioning");
        Collection<T> left = new LinkedList<T>();
        Collection<T> right = new LinkedList<T>();
        for (T item : items) {
            if (predicate.isSatisfiedBy(item)) {
                left.add(item);
            } else {
                right.add(item);
            }
        }
        return Pair.of(left, right);
    }

    public static class InjectionStep<T, I> {

        private final T target;

        private final I item;

        public InjectionStep(T target, I item) {
            this.target = target;
            this.item = item;
        }

        public T getTarget() {
            return target;
        }

        public I getItem() {
            return item;
        }
    }

    public static <T, I> T inject(T target, Iterable<? extends I> items, Action<InjectionStep<T, I>> action) {
        if (target == null) {
            throw new NullPointerException("The 'target' cannot be null");
        }
        if (items == null) {
            throw new NullPointerException("The 'items' cannot be null");
        }
        if (action == null) {
            throw new NullPointerException("The 'action' cannot be null");
        }
        for (I item : items) {
            action.execute(new InjectionStep<T, I>(target, item));
        }
        return target;
    }

    public static <K, V> ImmutableListMultimap<K, V> groupBy(Iterable<? extends V> iterable, Transformer<? extends K, V> grouper) {
        ImmutableListMultimap.Builder<K, V> builder = ImmutableListMultimap.builder();
        for (V element : iterable) {
            K key = grouper.transform(element);
            builder.put(key, element);
        }
        return builder.build();
    }

    public static <T> Iterable<? extends T> unpack(final Iterable<? extends Factory<? extends T>> factories) {
        return new Iterable<T>() {

            private final Iterator<? extends Factory<? extends T>> delegate = factories.iterator();

            public Iterator<T> iterator() {
                return new Iterator<T>() {

                    public boolean hasNext() {
                        return delegate.hasNext();
                    }

                    public T next() {
                        return delegate.next().create();
                    }

                    public void remove() {
                        throw new UnsupportedOperationException();
                    }
                };
            }
        };
    }

    @Nullable
    public static <T> List<T> nonEmptyOrNull(Iterable<T> iterable) {
        ImmutableList<T> list = ImmutableList.copyOf(iterable);
        return list.isEmpty() ? null : list;
    }

    public static <T> List<T> dedup(Iterable<T> source, final Equivalence<? super T> equivalence) {
        Iterable<Equivalence.Wrapper<T>> wrappers = Iterables.transform(source, new Function<T, Equivalence.Wrapper<T>>() {

            public Equivalence.Wrapper<T> apply(@Nullable T input) {
                return equivalence.wrap(input);
            }
        });
        Set<Equivalence.Wrapper<T>> deduped = ImmutableSet.copyOf(wrappers);
        return ImmutableList.copyOf(Iterables.transform(deduped, new Function<Equivalence.Wrapper<T>, T>() {

            public T apply(Equivalence.Wrapper<T> input) {
                return input.get();
            }
        }));
    }

    public static String asCommandLine(Iterable<String> arguments) {
        return Joiner.on(" ").join(collect(arguments, Transformers.asSafeCommandLineArgument()));
    }
}}'} /repo/subprojects/diagnostics/src/main/java/org/gradle/api/reporting/components/internal/ComponentRenderer.java
Cannot solve method call builder.collection("Binaries", CollectionUtils.sort(variantComponentSpec.getBinaries().values(), TypeAwareBinaryRenderer.SORT_ORDER), binaryRenderer, "binaries") UnsolvedSymbolException{context='Method 'sort' with parameterTypes [ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=ReferenceType{org.gradle.platform.base.BinarySpec, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=ReferenceType{org.gradle.platform.base.BinarySpec, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class CollectionUtils {

    /**
     * Returns null if the collection is empty otherwise expects a {@link #single(Iterable)} element to be found.
     */
    @Nullable
    public static <T> T findSingle(Collection<T> source) {
        return source.isEmpty() ? null : single(source);
    }

    /**
     * Returns the single element in the collection or throws.
     */
    public static <T> T single(Iterable<? extends T> source) {
        Iterator<? extends T> iterator = source.iterator();
        if (!iterator.hasNext()) {
            throw new NoSuchElementException("Expecting collection with single element, got none.");
        }
        T element = iterator.next();
        if (iterator.hasNext()) {
            throw new IllegalArgumentException("Expecting collection with single element, got multiple.");
        }
        return element;
    }

    public static <T> Collection<? extends T> checkedCast(Class<T> type, Collection<?> input) {
        for (Object o : input) {
            cast(type, o);
        }
        return Cast.uncheckedCast(input);
    }

    public static <T> T findFirst(Iterable<? extends T> source, Spec<? super T> filter) {
        for (T item : source) {
            if (filter.isSatisfiedBy(item)) {
                return item;
            }
        }
        return null;
    }

    public static <T> T findFirst(T[] source, Spec<? super T> filter) {
        for (T thing : source) {
            if (filter.isSatisfiedBy(thing)) {
                return thing;
            }
        }
        return null;
    }

    public static <T> T first(Iterable<? extends T> source) {
        return source.iterator().next();
    }

    public static <T> boolean any(Iterable<? extends T> source, Spec<? super T> filter) {
        return findFirst(source, filter) != null;
    }

    public static <T> boolean any(T[] source, Spec<? super T> filter) {
        return findFirst(source, filter) != null;
    }

    public static <T> Set<T> filter(Set<? extends T> set, Spec<? super T> filter) {
        return filter(set, new LinkedHashSet<T>(), filter);
    }

    public static <T> List<T> filter(List<? extends T> list, Spec<? super T> filter) {
        return filter(list, new LinkedList<T>(), filter);
    }

    public static <T> List<T> filter(T[] array, Spec<? super T> filter) {
        return filter(Arrays.asList(array), new LinkedList<T>(), filter);
    }

    /**
     * Returns a sorted copy of the provided collection of things. Uses the provided comparator to sort.
     */
    public static <T> List<T> sort(Iterable<? extends T> things, Comparator<? super T> comparator) {
        List<T> copy = toMutableList(things);
        Collections.sort(copy, comparator);
        return copy;
    }

    /**
     * Returns a sorted copy of the provided collection of things. Uses the natural ordering of the things.
     */
    public static <T extends Comparable> List<T> sort(Iterable<T> things) {
        List<T> copy = toMutableList(things);
        Collections.sort(copy);
        return copy;
    }

    public static <T, C extends Collection<T>> C filter(Iterable<? extends T> source, C destination, Spec<? super T> filter) {
        for (T item : source) {
            if (filter.isSatisfiedBy(item)) {
                destination.add(item);
            }
        }
        return destination;
    }

    public static <K, V> Map<K, V> filter(Map<K, V> map, Spec<Map.Entry<K, V>> filter) {
        return filter(map, new HashMap<K, V>(), filter);
    }

    public static <K, V> Map<K, V> filter(Map<K, V> map, Map<K, V> destination, Spec<Map.Entry<K, V>> filter) {
        for (Map.Entry<K, V> entry : map.entrySet()) {
            if (filter.isSatisfiedBy(entry)) {
                destination.put(entry.getKey(), entry.getValue());
            }
        }
        return destination;
    }

    public static <R, I> R[] collectArray(I[] list, Class<R> newType, Transformer<? extends R, ? super I> transformer) {
        @SuppressWarnings("unchecked") R[] destination = (R[]) Array.newInstance(newType, list.length);
        return collectArray(list, destination, transformer);
    }

    public static <R, I> R[] collectArray(I[] list, R[] destination, Transformer<? extends R, ? super I> transformer) {
        assert list.length <= destination.length;
        for (int i = 0; i < list.length; ++i) {
            destination[i] = transformer.transform(list[i]);
        }
        return destination;
    }

    public static <R, I> List<R> collect(List<? extends I> list, Transformer<? extends R, ? super I> transformer) {
        return collect(list, new ArrayList<R>(list.size()), transformer);
    }

    public static <R, I> List<R> collect(I[] list, Transformer<? extends R, ? super I> transformer) {
        return collect(Arrays.asList(list), transformer);
    }

    public static <R, I> Set<R> collect(Set<? extends I> set, Transformer<? extends R, ? super I> transformer) {
        return collect(set, new HashSet<R>(), transformer);
    }

    public static <R, I> List<R> collect(Iterable<? extends I> source, Transformer<? extends R, ? super I> transformer) {
        return collect(source, new LinkedList<R>(), transformer);
    }

    public static <R, I, C extends Collection<R>> C collect(Iterable<? extends I> source, C destination, Transformer<? extends R, ? super I> transformer) {
        for (I item : source) {
            destination.add(transformer.transform(item));
        }
        return destination;
    }

    public static List<String> toStringList(Iterable<?> iterable) {
        return collect(iterable, new LinkedList<String>(), Transformers.asString());
    }

    /**
     * Recursively unpacks all the given things into a flat list.
     *
     * Nulls are not removed, they are left intact.
     *
     * @param things The things to flatten
     * @return A flattened list of the given things
     */
    public static List<?> flattenCollections(Object... things) {
        return flattenCollections(Object.class, things);
    }

    /**
     * Recursively unpacks all the given things into a flat list, ensuring they are of a certain type.
     *
     * Nulls are not removed, they are left intact.
     *
     * If a non null object cannot be cast to the target type, a ClassCastException will be thrown.
     *
     * @param things The things to flatten
     * @param <T> The target type in the flattened list
     * @return A flattened list of the given things
     */
    public static <T> List<T> flattenCollections(Class<T> type, Object... things) {
        if (things == null) {
            return Collections.singletonList(null);
        } else if (things.length == 0) {
            return Collections.emptyList();
        } else if (things.length == 1) {
            Object thing = things[0];
            if (thing == null) {
                return Collections.singletonList(null);
            }
            if (thing.getClass().isArray()) {
                Object[] thingArray = (Object[]) thing;
                List<T> list = new ArrayList<T>(thingArray.length);
                for (Object thingThing : thingArray) {
                    list.addAll(flattenCollections(type, thingThing));
                }
                return list;
            }
            if (thing instanceof Collection) {
                Collection<?> collection = (Collection<?>) thing;
                List<T> list = new ArrayList<T>();
                for (Object element : collection) {
                    list.addAll(flattenCollections(type, element));
                }
                return list;
            }
            return Collections.singletonList(cast(type, thing));
        } else {
            List<T> list = new ArrayList<T>();
            for (Object thing : things) {
                list.addAll(flattenCollections(type, thing));
            }
            return list;
        }
    }

    public static <T> List<T> toList(Iterable<? extends T> things) {
        if (things instanceof List) {
            @SuppressWarnings("unchecked") List<T> castThings = (List<T>) things;
            return castThings;
        }
        return toMutableList(things);
    }

    public static <T> List<T> toList(Enumeration<? extends T> things) {
        AbstractList<T> list = new ArrayList<T>();
        while (things.hasMoreElements()) {
            list.add(things.nextElement());
        }
        return list;
    }

    private static <T> List<T> toMutableList(Iterable<? extends T> things) {
        if (things == null) {
            return new ArrayList<T>(0);
        }
        List<T> list = new ArrayList<T>();
        for (T thing : things) {
            list.add(thing);
        }
        return list;
    }

    public static <T> List<T> intersection(Collection<? extends Collection<T>> availableValuesByDescriptor) {
        List<T> result = new ArrayList<T>();
        Iterator<? extends Collection<T>> iterator = availableValuesByDescriptor.iterator();
        if (iterator.hasNext()) {
            Collection<T> firstSet = iterator.next();
            result.addAll(firstSet);
            while (iterator.hasNext()) {
                Collection<T> next = iterator.next();
                result.retainAll(next);
            }
        }
        return result;
    }

    public static <T> List<T> toList(T[] things) {
        if (things == null || things.length == 0) {
            return new ArrayList<T>(0);
        }
        List<T> list = new ArrayList<T>(things.length);
        Collections.addAll(list, things);
        return list;
    }

    public static <T> Set<T> toSet(Iterable<? extends T> things) {
        if (things == null) {
            return new HashSet<T>(0);
        }
        if (things instanceof Set) {
            @SuppressWarnings("unchecked") Set<T> castThings = (Set<T>) things;
            return castThings;
        }
        Set<T> set = new LinkedHashSet<T>();
        for (T thing : things) {
            set.add(thing);
        }
        return set;
    }

    public static <E> List<E> compact(List<E> list) {
        boolean foundAtLeastOneNull = false;
        List<E> compacted = null;
        int i = 0;
        for (E element : list) {
            if (element == null) {
                if (!foundAtLeastOneNull) {
                    compacted = new ArrayList<E>(list.size());
                    if (i > 0) {
                        compacted.addAll(list.subList(0, i));
                    }
                }
                foundAtLeastOneNull = true;
            } else if (foundAtLeastOneNull) {
                compacted.add(element);
            }
            ++i;
        }
        return foundAtLeastOneNull ? compacted : list;
    }

    public static <C extends Collection<String>> C stringize(Iterable<?> source, C destination) {
        return collect(source, destination, Transformers.asString());
    }

    public static List<String> stringize(Collection<?> source) {
        return stringize(source, new ArrayList<String>(source.size()));
    }

    public static <E> boolean replace(List<E> list, Spec<? super E> filter, Transformer<? extends E, ? super E> transformer) {
        boolean replaced = false;
        int i = 0;
        for (E it : list) {
            if (filter.isSatisfiedBy(it)) {
                list.set(i, transformer.transform(it));
                replaced = true;
            }
            ++i;
        }
        return replaced;
    }

    public static <K, V> void collectMap(Map<K, V> destination, Iterable<? extends V> items, Transformer<? extends K, ? super V> keyGenerator) {
        for (V item : items) {
            destination.put(keyGenerator.transform(item), item);
        }
    }

    /**
     * Given a set of values, derive a set of keys and return a map
     */
    public static <K, V> Map<K, V> collectMap(Iterable<? extends V> items, Transformer<? extends K, ? super V> keyGenerator) {
        Map<K, V> map = new LinkedHashMap<K, V>();
        collectMap(map, items, keyGenerator);
        return map;
    }

    public static <K, V> void collectMapValues(Map<K, V> destination, Iterable<? extends K> keys, Transformer<? extends V, ? super K> keyGenerator) {
        for (K item : keys) {
            destination.put(item, keyGenerator.transform(item));
        }
    }

    /**
     * Given a set of keys, derive a set of values and return a map
     */
    public static <K, V> Map<K, V> collectMapValues(Iterable<? extends K> keys, Transformer<? extends V, ? super K> keyGenerator) {
        Map<K, V> map = new LinkedHashMap<K, V>();
        collectMapValues(map, keys, keyGenerator);
        return map;
    }

    public static <T> boolean every(Iterable<? extends T> things, Spec<? super T> predicate) {
        for (T thing : things) {
            if (!predicate.isSatisfiedBy(thing)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Utility for adding an iterable to a collection.
     *
     * @param t1 The collection to add to
     * @param t2 The iterable to add each item of to the collection
     * @param <T> The element type of t1
     * @return t1
     */
    public static <T> Collection<T> addAll(Collection<T> t1, Iterable<? extends T> t2) {
        for (T t : t2) {
            t1.add(t);
        }
        return t1;
    }

    /**
     * Utility for adding an array to a collection.
     *
     * @param t1 The collection to add to
     * @param t2 The iterable to add each item of to the collection
     * @param <T> The element type of t1
     * @return t1
     */
    public static <T> Collection<T> addAll(Collection<T> t1, T... t2) {
        Collections.addAll(t1, t2);
        return t1;
    }

    /**
     * The result of diffing two sets.
     *
     * @param <T> The type of element the sets contain
     * @see CollectionUtils#diffSetsBy(java.util.Set, java.util.Set, org.gradle.api.Transformer)
     */
    public static class SetDiff<T> {

        public Set<T> leftOnly = new HashSet<T>();

        public Set<Pair<T, T>> common = new HashSet<Pair<T, T>>();

        public Set<T> rightOnly = new HashSet<T>();
    }

    /**
     * Provides a “diff report” of how the two sets are similar and how they are different, comparing the entries by some aspect.
     *
     * The transformer is used to generate the value to use to compare the entries by. That is, the entries are not compared by equals by an attribute or characteristic.
     *
     * The transformer is expected to produce a unique value for each entry in a single set. Behaviour is undefined if this condition is not met.
     *
     * @param left The set on the “left” side of the comparison.
     * @param right The set on the “right” side of the comparison.
     * @param compareBy Provides the value to compare entries from either side by
     * @param <T> The type of the entry objects
     * @return A representation of the difference
     */
    public static <T> SetDiff<T> diffSetsBy(Set<? extends T> left, Set<? extends T> right, Transformer<?, T> compareBy) {
        if (left == null) {
            throw new NullPointerException("'left' set is null");
        }
        if (right == null) {
            throw new NullPointerException("'right' set is null");
        }
        SetDiff<T> setDiff = new SetDiff<T>();
        Map<Object, T> indexedLeft = collectMap(left, compareBy);
        Map<Object, T> indexedRight = collectMap(right, compareBy);
        for (Map.Entry<Object, T> leftEntry : indexedLeft.entrySet()) {
            T rightValue = indexedRight.remove(leftEntry.getKey());
            if (rightValue == null) {
                setDiff.leftOnly.add(leftEntry.getValue());
            } else {
                Pair<T, T> pair = Pair.of(leftEntry.getValue(), rightValue);
                setDiff.common.add(pair);
            }
        }
        for (T rightValue : indexedRight.values()) {
            setDiff.rightOnly.add(rightValue);
        }
        return setDiff;
    }

    /**
     * Creates a string with {@code toString()} of each object with the given separator.
     *
     * <pre>
     * expect:
     * join(",", new Object[]{"a"}) == "a"
     * join(",", new Object[]{"a", "b", "c"}) == "a,b,c"
     * join(",", new Object[]{}) == ""
     * </pre>
     *
     * The {@code separator} must not be null and {@code objects} must not be null.
     *
     * @param separator The string by which to join each string representation
     * @param objects The objects to join the string representations of
     * @return The joined string
     */
    public static String join(String separator, Object[] objects) {
        return join(separator, objects == null ? null : Arrays.asList(objects));
    }

    /**
     * Creates a string with {@code toString()} of each object with the given separator.
     *
     * <pre>
     * expect:
     * join(",", ["a"]) == "a"
     * join(",", ["a", "b", "c"]) == "a,b,c"
     * join(",", []) == ""
     * </pre>
     *
     * The {@code separator} must not be null and {@code objects} must not be null.
     *
     * @param separator The string by which to join each string representation
     * @param objects The objects to join the string representations of
     * @return The joined string
     */
    public static String join(String separator, Iterable<?> objects) {
        if (separator == null) {
            throw new NullPointerException("The 'separator' cannot be null");
        }
        if (objects == null) {
            throw new NullPointerException("The 'objects' cannot be null");
        }
        StringBuilder string = new StringBuilder();
        Iterator<?> iterator = objects.iterator();
        if (iterator.hasNext()) {
            string.append(iterator.next().toString());
            while (iterator.hasNext()) {
                string.append(separator);
                string.append(iterator.next().toString());
            }
        }
        return string.toString();
    }

    /**
     * Partition given Collection into a Pair of Collections.
     *
     * <pre>Left</pre> Collection containing entries that satisfy the given predicate
     * <pre>Right</pre> Collection containing entries that do NOT satisfy the given predicate
     */
    public static <T> Pair<Collection<T>, Collection<T>> partition(Iterable<T> items, Spec<? super T> predicate) {
        Preconditions.checkNotNull(items, "Cannot partition null Collection");
        Preconditions.checkNotNull(predicate, "Cannot apply null Spec when partitioning");
        Collection<T> left = new LinkedList<T>();
        Collection<T> right = new LinkedList<T>();
        for (T item : items) {
            if (predicate.isSatisfiedBy(item)) {
                left.add(item);
            } else {
                right.add(item);
            }
        }
        return Pair.of(left, right);
    }

    public static class InjectionStep<T, I> {

        private final T target;

        private final I item;

        public InjectionStep(T target, I item) {
            this.target = target;
            this.item = item;
        }

        public T getTarget() {
            return target;
        }

        public I getItem() {
            return item;
        }
    }

    public static <T, I> T inject(T target, Iterable<? extends I> items, Action<InjectionStep<T, I>> action) {
        if (target == null) {
            throw new NullPointerException("The 'target' cannot be null");
        }
        if (items == null) {
            throw new NullPointerException("The 'items' cannot be null");
        }
        if (action == null) {
            throw new NullPointerException("The 'action' cannot be null");
        }
        for (I item : items) {
            action.execute(new InjectionStep<T, I>(target, item));
        }
        return target;
    }

    public static <K, V> ImmutableListMultimap<K, V> groupBy(Iterable<? extends V> iterable, Transformer<? extends K, V> grouper) {
        ImmutableListMultimap.Builder<K, V> builder = ImmutableListMultimap.builder();
        for (V element : iterable) {
            K key = grouper.transform(element);
            builder.put(key, element);
        }
        return builder.build();
    }

    public static <T> Iterable<? extends T> unpack(final Iterable<? extends Factory<? extends T>> factories) {
        return new Iterable<T>() {

            private final Iterator<? extends Factory<? extends T>> delegate = factories.iterator();

            public Iterator<T> iterator() {
                return new Iterator<T>() {

                    public boolean hasNext() {
                        return delegate.hasNext();
                    }

                    public T next() {
                        return delegate.next().create();
                    }

                    public void remove() {
                        throw new UnsupportedOperationException();
                    }
                };
            }
        };
    }

    @Nullable
    public static <T> List<T> nonEmptyOrNull(Iterable<T> iterable) {
        ImmutableList<T> list = ImmutableList.copyOf(iterable);
        return list.isEmpty() ? null : list;
    }

    public static <T> List<T> dedup(Iterable<T> source, final Equivalence<? super T> equivalence) {
        Iterable<Equivalence.Wrapper<T>> wrappers = Iterables.transform(source, new Function<T, Equivalence.Wrapper<T>>() {

            public Equivalence.Wrapper<T> apply(@Nullable T input) {
                return equivalence.wrap(input);
            }
        });
        Set<Equivalence.Wrapper<T>> deduped = ImmutableSet.copyOf(wrappers);
        return ImmutableList.copyOf(Iterables.transform(deduped, new Function<Equivalence.Wrapper<T>, T>() {

            public T apply(Equivalence.Wrapper<T> input) {
                return input.get();
            }
        }));
    }

    public static String asCommandLine(Iterable<String> arguments) {
        return Joiner.on(" ").join(collect(arguments, Transformers.asSafeCommandLineArgument()));
    }
}}'} /repo/subprojects/diagnostics/src/main/java/org/gradle/api/reporting/components/internal/ComponentRenderer.java
Cannot solve method call builder.heading(StringUtils.capitalize(sourceSet.getDisplayName())) UnsolvedSymbolException{context='Method 'capitalize' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=org.apache.commons.lang.StringUtils}'} /repo/subprojects/diagnostics/src/main/java/org/gradle/api/reporting/components/internal/SourceSetRenderer.java
Cannot solve method call modelElement("testSuites", modelMap(ComponentSpec.class)) java.lang.RuntimeException: Method 'modelMap' cannot be resolved in context modelMap(ComponentSpec.class) (line: 83) MethodCallExprContext{wrapped=modelMap(ComponentSpec.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.platform.base.ComponentSpec, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/diagnostics/src/main/java/org/gradle/api/reporting/components/ComponentReport.java
Cannot solve method call new DslObject(task).getConventionMapping().map("configuration", new Callable<Object>() {

    public Object call() {
        BuildableJavaComponent javaProject = services.get(ComponentRegistry.class).getMainComponent();
        return javaProject == null ? null : javaProject.getCompileDependencies();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/diagnostics/src/main/java/org/gradle/api/plugins/HelpTasksPlugin.java
Method 'getByType' cannot be resolved in context project.getExtensions().getByType(ReportingExtension.class) (line: 52) MethodCallExprContext{wrapped=project.getExtensions().getByType(ReportingExtension.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.reporting.ReportingExtension, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getPlugins' cannot be resolved in context project.getConvention().getPlugins() (line: 44) MethodCallExprContext{wrapped=project.getConvention().getPlugins()}. Parameter types: []
Cannot solve method call new DslObject(htmlDependencyReportTask.getReports().getHtml()).getConventionMapping().map("destination", new Callable<Object>() {

    public Object call() throws Exception {
        return new File(convention.getProjectReportDir(), "dependencies");
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/diagnostics/src/main/java/org/gradle/api/plugins/ProjectReportsPlugin.java
Method 'text' cannot be resolved in context output.text("Detailed task information for ") (line: 55) MethodCallExprContext{wrapped=output.text("Detailed task information for ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'text' cannot be resolved in context output.text("Detailed task information for ") (line: 55) MethodCallExprContext{wrapped=output.text("Detailed task information for ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getSimpleName' cannot be resolved in context o1.getSimpleName() (line: 62) MethodCallExprContext{wrapped=o1.getSimpleName()}. Parameter types: []
Cannot solve method call typeOutput.withStyle(UserInput).text(clazz.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context clazz.getSimpleName() (line: 77) MethodCallExprContext{wrapped=clazz.getSimpleName()}. Parameter types: [] /repo/subprojects/diagnostics/src/main/java/org/gradle/configuration/TaskDetailPrinter.java
Cannot solve method call typeOutput.println(" (" + clazz.getName() + ")") java.lang.RuntimeException: Method 'getName' cannot be resolved in context clazz.getName() (line: 78) MethodCallExprContext{wrapped=clazz.getName()}. Parameter types: [] /repo/subprojects/diagnostics/src/main/java/org/gradle/configuration/TaskDetailPrinter.java
Method 'getSimpleName' cannot be resolved in context o1.getSimpleName() (line: 98) MethodCallExprContext{wrapped=o1.getSimpleName()}. Parameter types: []
Method 'collect' cannot be resolved in context collect(tasks, new HashSet<String>(), transformer) (line: 144) MethodCallExprContext{wrapped=collect(tasks, new HashSet<String>(), transformer)}. Parameter types: [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{org.gradle.api.Task, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{java.util.HashSet, typeParametersMap=TypeParametersMap{nameToValue={java.util.HashSet.E=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{org.gradle.api.Transformer, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.api.Transformer.IN=ReferenceType{org.gradle.api.Task, typeParametersMap=TypeParametersMap{nameToValue={}}}, org.gradle.api.Transformer.OUT=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call allOptions.addAll(optionReader.getOptions(task)) java.lang.RuntimeException: Method 'getOptions' cannot be resolved in context optionReader.getOptions(task) (line: 165) MethodCallExprContext{wrapped=optionReader.getOptions(task)}. Parameter types: [ReferenceType{org.gradle.api.Task, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/diagnostics/src/main/java/org/gradle/configuration/TaskDetailPrinter.java
Method 'text' cannot be resolved in context output.text("Options") (line: 169) MethodCallExprContext{wrapped=output.text("Options")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
No matching between ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual)
No matching between ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual)
No matching between ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual)
Cannot solve method call createIndentedOutput(output, StringUtils.leftPad("", offset, ' ')) UnsolvedSymbolException{context='Method 'leftPad' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='char'}]', name='ReflectionClassDeclaration{clazz=org.apache.commons.lang.StringUtils}'} /repo/subprojects/diagnostics/src/main/java/org/gradle/configuration/TaskDetailPrinter.java
Method 'getPlugins' cannot be resolved in context project.getConvention().getPlugins() (line: 64) MethodCallExprContext{wrapped=project.getConvention().getPlugins()}. Parameter types: []
Method 'getByType' cannot be resolved in context project.getExtensions().getByType(DefaultArtifactPublicationSet.class) (line: 138) MethodCallExprContext{wrapped=project.getExtensions().getByType(DefaultArtifactPublicationSet.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.internal.plugins.DefaultArtifactPublicationSet, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getConventionMapping' cannot be resolved in context task.getConventionMapping() (line: 160) MethodCallExprContext{wrapped=task.getConventionMapping()}. Parameter types: []
Method 'getConventionMapping' cannot be resolved in context task.getConventionMapping() (line: 165) MethodCallExprContext{wrapped=task.getConventionMapping()}. Parameter types: []
Cannot resolve field access null
Cannot solve method call module.setAltDeployDescriptor(moduleNode.text()) java.lang.RuntimeException: Method 'text' cannot be resolved in context moduleNode.text() (line: 303) MethodCallExprContext{wrapped=moduleNode.text()}. Parameter types: [] /repo/subprojects/ear/src/main/java/org/gradle/plugins/ear/descriptor/internal/DefaultDeploymentDescriptor.java
Cannot solve method call Cast.<List<Node>>uncheckedCast(child.children()) java.lang.RuntimeException: Method 'children' cannot be resolved in context child.children() (line: 293) MethodCallExprContext{wrapped=child.children()}. Parameter types: [] /repo/subprojects/ear/src/main/java/org/gradle/plugins/ear/descriptor/internal/DefaultDeploymentDescriptor.java
Cannot solve method call Boolean.valueOf(child.text()) java.lang.RuntimeException: Method 'text' cannot be resolved in context child.text() (line: 276) MethodCallExprContext{wrapped=child.text()}. Parameter types: [] /repo/subprojects/ear/src/main/java/org/gradle/plugins/ear/descriptor/internal/DefaultDeploymentDescriptor.java
Cannot solve method call Cast.<List<Node>>uncheckedCast(appNode.children()) java.lang.RuntimeException: Method 'children' cannot be resolved in context appNode.children() (line: 268) MethodCallExprContext{wrapped=appNode.children()}. Parameter types: [] /repo/subprojects/ear/src/main/java/org/gradle/plugins/ear/descriptor/internal/DefaultDeploymentDescriptor.java
Cannot solve method call Cast.<List<Node>>uncheckedCast(root.children()) java.lang.RuntimeException: Method 'children' cannot be resolved in context root.children() (line: 337) MethodCallExprContext{wrapped=root.children()}. Parameter types: [] /repo/subprojects/ear/src/main/java/org/gradle/plugins/ear/descriptor/internal/DefaultDeploymentDescriptor.java
Cannot solve method call String.valueOf(node.name()) java.lang.RuntimeException: Method 'name' cannot be resolved in context node.name() (line: 346) MethodCallExprContext{wrapped=node.name()}. Parameter types: [] /repo/subprojects/ear/src/main/java/org/gradle/plugins/ear/descriptor/internal/DefaultDeploymentDescriptor.java
Method 'attributes' cannot be resolved in context root.attributes() (line: 363) MethodCallExprContext{wrapped=root.attributes()}. Parameter types: []
Method 'attributes' cannot be resolved in context root.attributes() (line: 365) MethodCallExprContext{wrapped=root.attributes()}. Parameter types: []
Method 'attributes' cannot be resolved in context root.attributes() (line: 375) MethodCallExprContext{wrapped=root.attributes()}. Parameter types: []
Method 'attributes' cannot be resolved in context root.attributes() (line: 373) MethodCallExprContext{wrapped=root.attributes()}. Parameter types: []
Method 'attributes' cannot be resolved in context root.attributes() (line: 371) MethodCallExprContext{wrapped=root.attributes()}. Parameter types: []
Method 'getRootSpec' cannot be resolved in context getRootSpec() (line: 59) MethodCallExprContext{wrapped=getRootSpec()}. Parameter types: []
Error calculating the type of parameter getMainSpec() of method call getRootSpec().addChildBeforeSpec(getMainSpec())
Method 'toLowerCase' cannot be resolved in context details.getPath().toLowerCase() (line: 77) MethodCallExprContext{wrapped=details.getPath().toLowerCase()}. Parameter types: []
Cannot solve method call details.getPath().substring(0, details.getPath().lastIndexOf(".")) java.lang.RuntimeException: Method 'lastIndexOf' cannot be resolved in context details.getPath().lastIndexOf(".") (line: 78) MethodCallExprContext{wrapped=details.getPath().lastIndexOf(".")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ear/src/main/java/org/gradle/plugins/ear/Ear.java
Cannot solve field access DuplicatesStrategy.EXCLUDE
Method 'getMainSpec' cannot be resolved in context getMainSpec() (line: 64) MethodCallExprContext{wrapped=getMainSpec()}. Parameter types: []
Method 'getMainSpec' cannot be resolved in context getMainSpec() (line: 103) MethodCallExprContext{wrapped=getMainSpec()}. Parameter types: []
Method 'getMainSpec' cannot be resolved in context getMainSpec() (line: 103) MethodCallExprContext{wrapped=getMainSpec()}. Parameter types: []
Cannot solve method call getInstantiator().newInstance(DefaultDeploymentDescriptor.class, getFileResolver(), getInstantiator()) java.lang.RuntimeException: Method 'getFileResolver' cannot be resolved in context getFileResolver() (line: 142) MethodCallExprContext{wrapped=getFileResolver()}. Parameter types: [] /repo/subprojects/ear/src/main/java/org/gradle/plugins/ear/Ear.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call UUID.nameUUIDFromBytes(vsComponentPath.getBytes()) java.lang.RuntimeException: Method 'getBytes' cannot be resolved in context vsComponentPath.getBytes() (line: 82) MethodCallExprContext{wrapped=vsComponentPath.getBytes()}. Parameter types: [] /repo/subprojects/ide-native/src/main/groovy/org/gradle/ide/visualstudio/internal/DefaultVisualStudioProject.java
Error calculating the type of parameter vsComponentPath.getBytes() of method call UUID.nameUUIDFromBytes(vsComponentPath.getBytes())
Error calculating the type of parameter vsComponentPath.getBytes() of method call UUID.nameUUIDFromBytes(vsComponentPath.getBytes())
Method 'substring' cannot be resolved in context projectPath.substring(1) (line: 50) MethodCallExprContext{wrapped=projectPath.substring(1)}. Parameter types: [PrimitiveTypeUsage{name='int'}]
Cannot solve method call builder.append(StringUtils.capitalize(component)) UnsolvedSymbolException{context='Method 'capitalize' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=org.apache.commons.lang.StringUtils}'} /repo/subprojects/ide-native/src/main/groovy/org/gradle/ide/visualstudio/internal/VisualStudioProjectMapper.java
Cannot solve method call defines.addAll(getDefines("cCompiler")) java.lang.RuntimeException: Method 'getDefines' cannot be resolved in context getDefines("cCompiler") (line: 86) MethodCallExprContext{wrapped=getDefines("cCompiler")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide-native/src/main/groovy/org/gradle/ide/visualstudio/internal/VisualStudioProjectConfiguration.java
Cannot solve method call defines.addAll(getDefines("cppCompiler")) java.lang.RuntimeException: Method 'getDefines' cannot be resolved in context getDefines("cppCompiler") (line: 87) MethodCallExprContext{wrapped=getDefines("cppCompiler")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide-native/src/main/groovy/org/gradle/ide/visualstudio/internal/VisualStudioProjectConfiguration.java
Cannot solve method call defines.addAll(getDefines("rcCompiler")) java.lang.RuntimeException: Method 'getDefines' cannot be resolved in context getDefines("rcCompiler") (line: 88) MethodCallExprContext{wrapped=getDefines("rcCompiler")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide-native/src/main/groovy/org/gradle/ide/visualstudio/internal/VisualStudioProjectConfiguration.java
Cannot solve method call getConventionMapping().map("gradleExe", new Callable<Object>() {

    @Override
    public Object call() throws Exception {
        final String rootDir = getTransformer().transform(getProject().getRootDir());
        String args = "";
        if (!rootDir.equals(".")) {
            args = " -p \"" + rootDir + "\"";
        }
        if (gradlew.isFile()) {
            return getTransformer().transform(gradlew) + args;
        }
        return "gradle" + args;
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide-native/src/main/groovy/org/gradle/ide/visualstudio/tasks/GenerateProjectFileTask.java
Method 'trim' cannot be resolved in context args.trim() (line: 124) MethodCallExprContext{wrapped=args.trim()}. Parameter types: []
Method 'getActions' cannot be resolved in context solutionFile.getActions() (line: 86) MethodCallExprContext{wrapped=solutionFile.getActions()}. Parameter types: []
Cannot solve method call conventionMapping.map("sourceDirs", new Callable<Set<File>>() {

    @Override
    public Set<File> call() throws Exception {
        // TODO: Assets should probably be a source set too
        Set<File> sourceDirs = Sets.newHashSet(playApplicationBinarySpec.getAssets().getAssetDirs());
        return CollectionUtils.inject(sourceDirs, playApplicationBinarySpec.getInputs(), new Action<CollectionUtils.InjectionStep<Set<File>, LanguageSourceSet>>() {

            @Override
            public void execute(CollectionUtils.InjectionStep<Set<File>, LanguageSourceSet> step) {
                step.getTarget().addAll(step.getItem().getSource().getSrcDirs());
            }
        });
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide-play/src/main/java/org/gradle/play/plugins/ide/internal/PlayIdeaPlugin.java
Cannot solve method call Collections.singleton(fileResolver.resolve("test")) java.lang.RuntimeException: Method 'resolve' cannot be resolved in context fileResolver.resolve("test") (line: 77) MethodCallExprContext{wrapped=fileResolver.resolve("test")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide-play/src/main/java/org/gradle/play/plugins/ide/internal/PlayIdeaPlugin.java
Cannot solve method call conventionMapping.map("testSourceDirs", new Callable<Set<File>>() {

    @Override
    public Set<File> call() throws Exception {
        // TODO: This should be modeled as a source set
        return Collections.singleton(fileResolver.resolve("test"));
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide-play/src/main/java/org/gradle/play/plugins/ide/internal/PlayIdeaPlugin.java
Cannot solve method call conventionMapping.map("singleEntryLibraries", new Callable<Map<String, Iterable<File>>>() {

    @Override
    public Map<String, Iterable<File>> call() throws Exception {
        return ImmutableMap.<String, Iterable<File>>builder().put("COMPILE", Collections.singleton(playApplicationBinarySpec.getClasses().getClassesDir())).put("RUNTIME", playApplicationBinarySpec.getClasses().getResourceDirs()).put("TEST", Collections.singleton(new File(buildDir, "playBinary/testClasses"))).build();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide-play/src/main/java/org/gradle/play/plugins/ide/internal/PlayIdeaPlugin.java
Cannot solve method call conventionMapping.map("targetBytecodeVersion", new Callable<JavaVersion>() {

    @Override
    public JavaVersion call() throws Exception {
        return getTargetJavaVersion(playApplicationBinarySpec);
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide-play/src/main/java/org/gradle/play/plugins/ide/internal/PlayIdeaPlugin.java
Cannot solve method call conventionMapping.map("languageLevel", new Callable<IdeaLanguageLevel>() {

    @Override
    public IdeaLanguageLevel call() throws Exception {
        return new IdeaLanguageLevel(getTargetJavaVersion(playApplicationBinarySpec));
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide-play/src/main/java/org/gradle/play/plugins/ide/internal/PlayIdeaPlugin.java
Cannot solve method call Cast.<List<Node>>uncheckedCast(root.get(name)) java.lang.RuntimeException: Method 'get' cannot be resolved in context root.get(name) (line: 82) MethodCallExprContext{wrapped=root.get(name)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/internal/generator/XmlPersistableConfigurationObject.java
Cannot solve method call value.equals(node.attribute(attribute)) java.lang.RuntimeException: Method 'attribute' cannot be resolved in context node.attribute(attribute) (line: 100) MethodCallExprContext{wrapped=node.attribute(attribute)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/internal/generator/XmlPersistableConfigurationObject.java
Cannot solve method call Iterables.getFirst(Iterables.filter(nodes, new Predicate<Node>() {

    @Override
    public boolean apply(Node node) {
        return value.equals(node.attribute(attribute));
    }
}), null) UnsolvedSymbolException{context='Method 'filter' with parameterTypes [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{Node, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{Predicate, typeParametersMap=TypeParametersMap{nameToValue={empty.? super ScriptBlock=ReferenceType{Node, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/internal/generator/XmlPersistableConfigurationObject.java
Cannot solve method call query.forComponents(dependencies.keySet()) java.lang.RuntimeException: Method 'keySet' cannot be resolved in context dependencies.keySet() (line: 112) MethodCallExprContext{wrapped=dependencies.keySet()}. Parameter types: [] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/internal/IdeDependenciesExtractor.java
Cannot solve method call ImmutableSet.copyOf(elementsByName.keySet()) java.lang.RuntimeException: Method 'keySet' cannot be resolved in context elementsByName.keySet() (line: 110) MethodCallExprContext{wrapped=elementsByName.keySet()}. Parameter types: [] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/internal/configurer/HierarchicalElementDeduplicator.java
Cannot solve method call deduplicatedName.substring(0, deduplicatedName.lastIndexOf(originalName)) java.lang.RuntimeException: Method 'lastIndexOf' cannot be resolved in context deduplicatedName.lastIndexOf(originalName) (line: 154) MethodCallExprContext{wrapped=deduplicatedName.lastIndexOf(originalName)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/internal/configurer/HierarchicalElementDeduplicator.java
Cannot solve method call Lists.newArrayList(splitter.split(prefix)) UnsolvedSymbolException{context='unknown', name='Splitter', typeSolver=null} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/internal/configurer/HierarchicalElementDeduplicator.java
Cannot solve method call Lists.newArrayList(splitter.split(originalName)) UnsolvedSymbolException{context='unknown', name='Splitter', typeSolver=null} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/internal/configurer/HierarchicalElementDeduplicator.java
Cannot solve method call prefixPart.equals(Iterables.getLast(words, null)) UnsolvedSymbolException{context='Method 'getLast' with parameterTypes [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, com.github.javaparser.symbolsolver.model.typesystem.NullType@26c8b296]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/internal/configurer/HierarchicalElementDeduplicator.java
Method 'asMap' cannot be resolved in context elementsByName.asMap() (line: 183) MethodCallExprContext{wrapped=elementsByName.asMap()}. Parameter types: []
Cannot solve method call String.format("clean%s", StringUtils.capitalize(taskName)) UnsolvedSymbolException{context='Method 'capitalize' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=org.apache.commons.lang.StringUtils}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/internal/IdePlugin.java
Method 'getPlugin' cannot be resolved in context root.getPlugins().getPlugin(EclipsePlugin.class) (line: 111) MethodCallExprContext{wrapped=root.getPlugins().getPlugin(EclipsePlugin.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.plugins.ide.eclipse.EclipsePlugin, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call GUtil.elvis(internalProject.getComment(), null) java.lang.RuntimeException: Method 'getComment' cannot be resolved in context internalProject.getComment() (line: 123) MethodCallExprContext{wrapped=internalProject.getComment()}. Parameter types: [] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/internal/tooling/EclipseModelBuilder.java
Cannot solve method call arguments.put(convertGString(entry.getKey()), convertGString(entry.getValue())) com.github.javaparser.symbolsolver.logic.ConfilictingGenericTypesException: No matching between ReferenceType{CharSequence, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual) /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/internal/tooling/EclipseModelBuilder.java
Cannot solve method call Maps.newTreeMap(Ordering.natural()) UnsolvedSymbolException{context='Method 'natural' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Ordering}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/internal/tooling/BuildInvocationsBuilder.java
Method 'setDisplayName' cannot be resolved in context target.setPath(task.getPath()).setName(task.getName()).setGroup(task.getGroup()).setDisplayName(task.toString()) (line: 24) MethodCallExprContext{wrapped=target.setPath(task.getPath()).setName(task.getName()).setGroup(task.getGroup()).setDisplayName(task.toString())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'setDisplayName' cannot be resolved in context target.setPath(task.getPath()).setName(task.getName()).setGroup(task.getGroup()).setDisplayName(task.toString()) (line: 24) MethodCallExprContext{wrapped=target.setPath(task.getPath()).setName(task.getName()).setGroup(task.getGroup()).setDisplayName(task.toString())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'setInheritOutputDirs' cannot be resolved in context new DefaultIdeaCompilerOutput().setInheritOutputDirs(ideaModule.getInheritOutputDirs() != null ? ideaModule.getInheritOutputDirs() : false) (line: 170) MethodCallExprContext{wrapped=new DefaultIdeaCompilerOutput().setInheritOutputDirs(ideaModule.getInheritOutputDirs() != null ? ideaModule.getInheritOutputDirs() : false)}. Parameter types: [ReferenceType{Boolean, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'setInheritOutputDirs' cannot be resolved in context new DefaultIdeaCompilerOutput().setInheritOutputDirs(ideaModule.getInheritOutputDirs() != null ? ideaModule.getInheritOutputDirs() : false) (line: 170) MethodCallExprContext{wrapped=new DefaultIdeaCompilerOutput().setInheritOutputDirs(ideaModule.getInheritOutputDirs() != null ? ideaModule.getInheritOutputDirs() : false)}. Parameter types: [ReferenceType{Boolean, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call new DefaultIdeaModule().setName(ideaModule.getName()).setParent(ideaProject).setGradleProject(rootGradleProject.findByPath(ideaModule.getProject().getPath())).setContentRoots(Collections.singletonList(contentRoot)).setCompilerOutput(new DefaultIdeaCompilerOutput().setInheritOutputDirs(ideaModule.getInheritOutputDirs() != null ? ideaModule.getInheritOutputDirs() : false).setOutputDir(ideaModule.getOutputDir()).setTestOutputDir(ideaModule.getTestOutputDir())) java.lang.RuntimeException: Method 'setInheritOutputDirs' cannot be resolved in context new DefaultIdeaCompilerOutput().setInheritOutputDirs(ideaModule.getInheritOutputDirs() != null ? ideaModule.getInheritOutputDirs() : false) (line: 170) MethodCallExprContext{wrapped=new DefaultIdeaCompilerOutput().setInheritOutputDirs(ideaModule.getInheritOutputDirs() != null ? ideaModule.getInheritOutputDirs() : false)}. Parameter types: [ReferenceType{Boolean, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/internal/tooling/IdeaModelBuilder.java
Cannot solve method call JavaVersion.valueOf(languageLevel.replaceFirst("JDK", "VERSION")) java.lang.RuntimeException: Method 'replaceFirst' cannot be resolved in context languageLevel.replaceFirst("JDK", "VERSION") (line: 209) MethodCallExprContext{wrapped=languageLevel.replaceFirst("JDK", "VERSION")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/internal/tooling/IdeaModelBuilder.java
Method 'getByType' cannot be resolved in context project.getExtensions().getByType(IdeaModel.class) (line: 159) MethodCallExprContext{wrapped=project.getExtensions().getByType(IdeaModel.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.plugins.ide.idea.model.IdeaModel, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getByType' cannot be resolved in context project.getExtensions().getByType(IdeaModel.class) (line: 159) MethodCallExprContext{wrapped=project.getExtensions().getByType(IdeaModel.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.plugins.ide.idea.model.IdeaModel, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call conventionMapping.map("jdkName", new Callable<String>() {

    @Override
    public String call() throws Exception {
        return JavaVersion.current().toString();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/IdeaPlugin.java
Method 'getPlugin' cannot be resolved in context p.getConvention().getPlugin(JavaPluginConvention.class) (line: 203) MethodCallExprContext{wrapped=p.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call conventionMapping.map("languageLevel", new Callable<IdeaLanguageLevel>() {

    @Override
    public IdeaLanguageLevel call() throws Exception {
        JavaVersion maxSourceCompatibility = getMaxJavaModuleCompatibilityVersionFor(new Function<Project, JavaVersion>() {

            @Override
            public JavaVersion apply(Project p) {
                return p.getConvention().getPlugin(JavaPluginConvention.class).getSourceCompatibility();
            }
        });
        return new IdeaLanguageLevel(maxSourceCompatibility);
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/IdeaPlugin.java
Method 'getPlugin' cannot be resolved in context p.getConvention().getPlugin(JavaPluginConvention.class) (line: 216) MethodCallExprContext{wrapped=p.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call conventionMapping.map("targetBytecodeVersion", new Callable<JavaVersion>() {

    @Override
    public JavaVersion call() throws Exception {
        return getMaxJavaModuleCompatibilityVersionFor(new Function<Project, JavaVersion>() {

            @Override
            public JavaVersion apply(Project p) {
                return p.getConvention().getPlugin(JavaPluginConvention.class).getTargetCompatibility();
            }
        });
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/IdeaPlugin.java
Cannot solve method call ideaProject.setWildcards(Sets.newHashSet("!?*.class", "!?*.scala", "!?*.groovy", "!?*.java")) UnsolvedSymbolException{context='Method 'newHashSet' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Sets}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/IdeaPlugin.java
Cannot solve method call Iterables.transform(Sets.filter(project.getRootProject().getAllprojects(), new Predicate<Project>() {

    @Override
    public boolean apply(Project p) {
        return p.getPlugins().hasPlugin(IdeaPlugin.class);
    }
}), new Function<Project, IdeaModule>() {

    @Override
    public IdeaModule apply(Project p) {
        return ideaModelFor(p).getModule();
    }
}) UnsolvedSymbolException{context='Method 'filter' with parameterTypes [ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{org.gradle.api.Project, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{Predicate, typeParametersMap=TypeParametersMap{nameToValue={empty.? super ScriptBlock=ReferenceType{org.gradle.api.Project, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Sets}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/IdeaPlugin.java
Cannot solve method call Lists.newArrayList(Iterables.transform(Sets.filter(project.getRootProject().getAllprojects(), new Predicate<Project>() {

    @Override
    public boolean apply(Project p) {
        return p.getPlugins().hasPlugin(IdeaPlugin.class);
    }
}), new Function<Project, IdeaModule>() {

    @Override
    public IdeaModule apply(Project p) {
        return ideaModelFor(p).getModule();
    }
})) java.lang.RuntimeException: Error calculating the type of parameter Sets.filter(project.getRootProject().getAllprojects(), new Predicate<Project>() {

    @Override
    public boolean apply(Project p) {
        return p.getPlugins().hasPlugin(IdeaPlugin.class);
    }
}) of method call Iterables.transform(Sets.filter(project.getRootProject().getAllprojects(), new Predicate<Project>() {

    @Override
    public boolean apply(Project p) {
        return p.getPlugins().hasPlugin(IdeaPlugin.class);
    }
}), new Function<Project, IdeaModule>() {

    @Override
    public IdeaModule apply(Project p) {
        return ideaModelFor(p).getModule();
    }
}) /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/IdeaPlugin.java
Cannot solve method call conventionMapping.map("modules", new Callable<List<IdeaModule>>() {

    @Override
    public List<IdeaModule> call() throws Exception {
        return Lists.newArrayList(Iterables.transform(Sets.filter(project.getRootProject().getAllprojects(), new Predicate<Project>() {

            @Override
            public boolean apply(Project p) {
                return p.getPlugins().hasPlugin(IdeaPlugin.class);
            }
        }), new Function<Project, IdeaModule>() {

            @Override
            public IdeaModule apply(Project p) {
                return ideaModelFor(p).getModule();
            }
        }));
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/IdeaPlugin.java
Cannot solve method call conventionMapping.map("pathFactory", new Callable<PathFactory>() {

    @Override
    public PathFactory call() throws Exception {
        return new PathFactory(pathInterner).addPathVariable("PROJECT_DIR", task.getOutputFile().getParentFile());
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/IdeaPlugin.java
Cannot solve method call Iterables.transform(Sets.filter(project.getRootProject().getAllprojects(), new Predicate<Project>() {

    @Override
    public boolean apply(Project project) {
        return project.getPlugins().hasPlugin(IdeaPlugin.class) && project.getPlugins().hasPlugin(JavaBasePlugin.class);
    }
}), toJavaVersion) UnsolvedSymbolException{context='Method 'filter' with parameterTypes [ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{org.gradle.api.Project, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{Predicate, typeParametersMap=TypeParametersMap{nameToValue={empty.? super ScriptBlock=ReferenceType{org.gradle.api.Project, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Sets}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/IdeaPlugin.java
Cannot solve method call Lists.newArrayList(Iterables.transform(Sets.filter(project.getRootProject().getAllprojects(), new Predicate<Project>() {

    @Override
    public boolean apply(Project project) {
        return project.getPlugins().hasPlugin(IdeaPlugin.class) && project.getPlugins().hasPlugin(JavaBasePlugin.class);
    }
}), toJavaVersion)) java.lang.RuntimeException: Error calculating the type of parameter Sets.filter(project.getRootProject().getAllprojects(), new Predicate<Project>() {

    @Override
    public boolean apply(Project project) {
        return project.getPlugins().hasPlugin(IdeaPlugin.class) && project.getPlugins().hasPlugin(JavaBasePlugin.class);
    }
}) of method call Iterables.transform(Sets.filter(project.getRootProject().getAllprojects(), new Predicate<Project>() {

    @Override
    public boolean apply(Project project) {
        return project.getPlugins().hasPlugin(IdeaPlugin.class) && project.getPlugins().hasPlugin(JavaBasePlugin.class);
    }
}), toJavaVersion) /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/IdeaPlugin.java
Cannot solve method call Collections.max(Sets.newHashSet(allProjectJavaVersions)) UnsolvedSymbolException{context='Method 'newHashSet' with parameterTypes [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{org.gradle.api.JavaVersion, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Sets}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/IdeaPlugin.java
Cannot solve field access JavaVersion.VERSION_1_6
Cannot solve method call conventionMapping.map("sourceDirs", new Callable<Set<File>>() {

    @Override
    public Set<File> call() throws Exception {
        return Sets.newHashSet();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/IdeaPlugin.java
Cannot solve method call conventionMapping.map("name", new Callable<String>() {

    @Override
    public String call() throws Exception {
        return project.getName();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/IdeaPlugin.java
Cannot solve method call conventionMapping.map("contentRoot", new Callable<File>() {

    @Override
    public File call() throws Exception {
        return project.getProjectDir();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/IdeaPlugin.java
Cannot solve method call conventionMapping.map("testSourceDirs", new Callable<Set<File>>() {

    @Override
    public Set<File> call() throws Exception {
        return Sets.newHashSet();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/IdeaPlugin.java
Cannot solve method call Sets.newHashSet(project.getBuildDir(), project.file(".gradle")) java.lang.RuntimeException: Method 'file' cannot be resolved in context project.file(".gradle") (line: 312) MethodCallExprContext{wrapped=project.file(".gradle")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/IdeaPlugin.java
Cannot solve method call conventionMapping.map("excludeDirs", new Callable<Set<File>>() {

    @Override
    public Set<File> call() throws Exception {
        return Sets.newHashSet(project.getBuildDir(), project.file(".gradle"));
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/IdeaPlugin.java
Cannot solve method call conventionMapping.map("pathFactory", new Callable<PathFactory>() {

    @Override
    public PathFactory call() throws Exception {
        final PathFactory factory = new PathFactory(pathInterner);
        factory.addPathVariable("MODULE_DIR", task.getOutputFile().getParentFile());
        for (Map.Entry<String, File> entry : module.getPathVariables().entrySet()) {
            factory.addPathVariable(entry.getKey(), entry.getValue());
        }
        return factory;
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/IdeaPlugin.java
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 357) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getByName' cannot be resolved in context sourceSets.getByName("main") (line: 358) MethodCallExprContext{wrapped=sourceSets.getByName("main")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getByName' cannot be resolved in context sourceSets.getByName("main") (line: 358) MethodCallExprContext{wrapped=sourceSets.getByName("main")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call convention.map("sourceDirs", new Callable<Set<File>>() {

    @Override
    public Set<File> call() throws Exception {
        SourceSetContainer sourceSets = project.getConvention().getPlugin(JavaPluginConvention.class).getSourceSets();
        return sourceSets.getByName("main").getAllSource().getSrcDirs();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/IdeaPlugin.java
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 364) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getByName' cannot be resolved in context sourceSets.getByName("test") (line: 365) MethodCallExprContext{wrapped=sourceSets.getByName("test")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getByName' cannot be resolved in context sourceSets.getByName("test") (line: 365) MethodCallExprContext{wrapped=sourceSets.getByName("test")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call convention.map("testSourceDirs", new Callable<Set<File>>() {

    @Override
    public Set<File> call() throws Exception {
        SourceSetContainer sourceSets = project.getConvention().getPlugin(JavaPluginConvention.class).getSourceSets();
        return sourceSets.getByName("test").getAllSource().getSrcDirs();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/IdeaPlugin.java
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 371) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getByName' cannot be resolved in context sourceSets.getByName("main") (line: 373) MethodCallExprContext{wrapped=sourceSets.getByName("main")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getByName' cannot be resolved in context sourceSets.getByName("main") (line: 373) MethodCallExprContext{wrapped=sourceSets.getByName("main")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call map.put("RUNTIME", sourceSets.getByName("main").getOutput().getDirs()) java.lang.RuntimeException: Method 'getByName' cannot be resolved in context sourceSets.getByName("main") (line: 373) MethodCallExprContext{wrapped=sourceSets.getByName("main")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/IdeaPlugin.java
Method 'getByName' cannot be resolved in context sourceSets.getByName("test") (line: 374) MethodCallExprContext{wrapped=sourceSets.getByName("test")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getByName' cannot be resolved in context sourceSets.getByName("test") (line: 374) MethodCallExprContext{wrapped=sourceSets.getByName("test")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call map.put("TEST", sourceSets.getByName("test").getOutput().getDirs()) java.lang.RuntimeException: Method 'getByName' cannot be resolved in context sourceSets.getByName("test") (line: 374) MethodCallExprContext{wrapped=sourceSets.getByName("test")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/IdeaPlugin.java
Cannot solve method call convention.map("singleEntryLibraries", new Callable<Map<String, FileCollection>>() {

    @Override
    public Map<String, FileCollection> call() throws Exception {
        SourceSetContainer sourceSets = project.getConvention().getPlugin(JavaPluginConvention.class).getSourceSets();
        LinkedHashMap<String, FileCollection> map = new LinkedHashMap<String, FileCollection>(2);
        map.put("RUNTIME", sourceSets.getByName("main").getOutput().getDirs());
        map.put("TEST", sourceSets.getByName("test").getOutput().getDirs());
        return map;
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/IdeaPlugin.java
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 382) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call convention.map("targetBytecodeVersion", new Callable<JavaVersion>() {

    @Override
    public JavaVersion call() throws Exception {
        JavaVersion moduleTargetBytecodeLevel = project.getConvention().getPlugin(JavaPluginConvention.class).getTargetCompatibility();
        return includeModuleBytecodeLevelOverride(project.getRootProject(), moduleTargetBytecodeLevel) ? moduleTargetBytecodeLevel : null;
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/IdeaPlugin.java
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 390) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call convention.map("languageLevel", new Callable<IdeaLanguageLevel>() {

    @Override
    public IdeaLanguageLevel call() throws Exception {
        IdeaLanguageLevel moduleLanguageLevel = new IdeaLanguageLevel(project.getConvention().getPlugin(JavaPluginConvention.class).getSourceCompatibility());
        return includeModuleLanguageLevelOverride(project.getRootProject(), moduleLanguageLevel) ? moduleLanguageLevel : null;
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/IdeaPlugin.java
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 399) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getByName' cannot be resolved in context sourceSets.getByName("test") (line: 400) MethodCallExprContext{wrapped=sourceSets.getByName("test")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getByName' cannot be resolved in context sourceSets.getByName("test") (line: 400) MethodCallExprContext{wrapped=sourceSets.getByName("test")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getByName' cannot be resolved in context sourceSets.getByName("main") (line: 400) MethodCallExprContext{wrapped=sourceSets.getByName("main")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getByName' cannot be resolved in context sourceSets.getByName("main") (line: 400) MethodCallExprContext{wrapped=sourceSets.getByName("main")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getByName' cannot be resolved in context sourceSets.getByName("main") (line: 400) MethodCallExprContext{wrapped=sourceSets.getByName("main")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call scope.put("plus", Lists.<Configuration>newArrayList()) UnsolvedSymbolException{context='Method 'newArrayList' with parameterTypes []', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Lists}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/IdeaPlugin.java
Cannot solve method call scope.put("minus", Lists.<Configuration>newArrayList()) UnsolvedSymbolException{context='Method 'newArrayList' with parameterTypes []', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Lists}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/IdeaPlugin.java
Method 'findByName' cannot be resolved in context project.getTasks().findByName("ideaModule") (line: 455) MethodCallExprContext{wrapped=project.getTasks().findByName("ideaModule")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call declareUniqueProjectLibraries(Sets.newLinkedHashSet(scalaCompilerLibraries.values())) UnsolvedSymbolException{context='Method 'newLinkedHashSet' with parameterTypes [ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=ReferenceType{org.gradle.plugins.ide.idea.model.ProjectLibrary, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Sets}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/internal/IdeaScalaConfigurer.java
Method 'getByName' cannot be resolved in context rootProject.getTasks().getByName("ideaProject") (line: 75) MethodCallExprContext{wrapped=rootProject.getTasks().getByName("ideaProject")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getByType' cannot be resolved in context project.getExtensions().getByType(IdeaModel.class) (line: 88) MethodCallExprContext{wrapped=project.getExtensions().getByType(IdeaModel.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.plugins.ide.idea.model.IdeaModel, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getByType' cannot be resolved in context project.getExtensions().getByType(IdeaModel.class) (line: 88) MethodCallExprContext{wrapped=project.getExtensions().getByType(IdeaModel.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.plugins.ide.idea.model.IdeaModel, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getByType' cannot be resolved in context project.getExtensions().getByType(IdeaModel.class) (line: 88) MethodCallExprContext{wrapped=project.getExtensions().getByType(IdeaModel.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.plugins.ide.idea.model.IdeaModel, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getByType' cannot be resolved in context scalaProject.getExtensions().getByType(IdeaModel.class) (line: 107) MethodCallExprContext{wrapped=scalaProject.getExtensions().getByType(IdeaModel.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.plugins.ide.idea.model.IdeaModel, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call Iterables.find(scalaCompilerLibraries.values(), Predicates.equalTo(library), null) UnsolvedSymbolException{context='Method 'equalTo' with parameterTypes [ReferenceType{org.gradle.plugins.ide.idea.model.ProjectLibrary, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.base.Predicates}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/internal/IdeaScalaConfigurer.java
Cannot solve method call createScalaSdkFromPlatform(ideaModule.getScalaPlatform(), scalaProject.files(files), useScalaSdk) java.lang.RuntimeException: Method 'files' cannot be resolved in context scalaProject.files(files) (line: 140) MethodCallExprContext{wrapped=scalaProject.files(files)}. Parameter types: [ReferenceType{Iterable, typeParametersMap=TypeParametersMap{nameToValue={empty.BlockDoc=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/internal/IdeaScalaConfigurer.java
Method 'getByType' cannot be resolved in context rootProject.getExtensions().getByType(IdeaModel.class) (line: 157) MethodCallExprContext{wrapped=rootProject.getExtensions().getByType(IdeaModel.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.plugins.ide.idea.model.IdeaModel, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getByType' cannot be resolved in context rootProject.getExtensions().getByType(IdeaModel.class) (line: 157) MethodCallExprContext{wrapped=rootProject.getExtensions().getByType(IdeaModel.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.plugins.ide.idea.model.IdeaModel, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'attributes' cannot be resolved in context sdkLibrary.attributes() (line: 184) MethodCallExprContext{wrapped=sdkLibrary.attributes()}. Parameter types: []
Method 'attributes' cannot be resolved in context sdkLibrary.attributes() (line: 185) MethodCallExprContext{wrapped=sdkLibrary.attributes()}. Parameter types: []
Method 'attributes' cannot be resolved in context scalaFacet.attributes() (line: 193) MethodCallExprContext{wrapped=scalaFacet.attributes()}. Parameter types: []
Method 'attributes' cannot be resolved in context libraryLevel.attributes() (line: 199) MethodCallExprContext{wrapped=libraryLevel.attributes()}. Parameter types: []
Method 'attributes' cannot be resolved in context libraryName.attributes() (line: 202) MethodCallExprContext{wrapped=libraryName.attributes()}. Parameter types: []
Method 'getByType' cannot be resolved in context rootProject.getExtensions().getByType(IdeaModel.class) (line: 216) MethodCallExprContext{wrapped=rootProject.getExtensions().getByType(IdeaModel.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.plugins.ide.idea.model.IdeaModel, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call projectLibrary.setClasses(Sets.newLinkedHashSet(jars)) UnsolvedSymbolException{context='Method 'newLinkedHashSet' with parameterTypes [ReferenceType{Iterable, typeParametersMap=TypeParametersMap{nameToValue={empty.BlockDoc=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Sets}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/internal/IdeaScalaConfigurer.java
Cannot solve method call projectLibrary.setCompilerClasspath(Sets.newLinkedHashSet(jars)) UnsolvedSymbolException{context='Method 'newLinkedHashSet' with parameterTypes [ReferenceType{Iterable, typeParametersMap=TypeParametersMap{nameToValue={empty.BlockDoc=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Sets}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/internal/IdeaScalaConfigurer.java
Method 'getByType' cannot be resolved in context parent.getExtensions().getByType(IdeaModel.class) (line: 66) MethodCallExprContext{wrapped=parent.getExtensions().getByType(IdeaModel.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.plugins.ide.idea.model.IdeaModel, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve field access GeneratedIdeaScope.PROVIDED_TEST
Cannot solve field access GeneratedIdeaScope.PROVIDED
Cannot solve method call scopeMappings.put(GeneratedIdeaScope.PROVIDED, Lists.newArrayList(new IdeaScopeMappingRule("providedCompile"), new IdeaScopeMappingRule("providedRuntime"))) UnsolvedSymbolException{context='Method 'newArrayList' with parameterTypes [ReferenceType{org.gradle.plugins.ide.idea.model.internal.IdeaScopeMappingRule, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.plugins.ide.idea.model.internal.IdeaScopeMappingRule, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Lists}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/internal/IdeaDependenciesProvider.java
Cannot solve field access GeneratedIdeaScope.COMPILE
Cannot solve field access GeneratedIdeaScope.RUNTIME_COMPILE_CLASSPATH
Cannot solve field access GeneratedIdeaScope.RUNTIME_TEST_COMPILE_CLASSPATH
Cannot solve field access GeneratedIdeaScope.RUNTIME_TEST
Cannot solve field access GeneratedIdeaScope.RUNTIME
Cannot solve field access GeneratedIdeaScope.TEST
Cannot solve method call scopeMappings.put(GeneratedIdeaScope.TEST, Lists.newArrayList(new IdeaScopeMappingRule("testCompileClasspath"), new IdeaScopeMappingRule("testCompile"), new IdeaScopeMappingRule("testRuntime"))) UnsolvedSymbolException{context='Method 'newArrayList' with parameterTypes [ReferenceType{org.gradle.plugins.ide.idea.model.internal.IdeaScopeMappingRule, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.plugins.ide.idea.model.internal.IdeaScopeMappingRule, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.plugins.ide.idea.model.internal.IdeaScopeMappingRule, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Lists}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/internal/IdeaDependenciesProvider.java
Cannot solve field access GeneratedIdeaScope.COMPILE_CLASSPATH
Cannot solve method call usedUnresolvedDependencies.addAll(dependenciesExtractor.unresolvedExternalDependencies(plusConfigurations, minusConfigurations)) java.lang.RuntimeException: Method 'unresolvedExternalDependencies' cannot be resolved in context dependenciesExtractor.unresolvedExternalDependencies(plusConfigurations, minusConfigurations) (line: 151) MethodCallExprContext{wrapped=dependenciesExtractor.unresolvedExternalDependencies(plusConfigurations, minusConfigurations)}. Parameter types: [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{org.gradle.api.artifacts.Configuration, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{org.gradle.api.artifacts.Configuration, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/internal/IdeaDependenciesProvider.java
Cannot solve method call Lists.newArrayList(Iterables.transform(minusConfigurations, new Function<Configuration, String>() {

    @Override
    public String apply(Configuration configuration) {
        return configuration.getName();
    }
})) UnsolvedSymbolException{context='Method 'transform' with parameterTypes [ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=ReferenceType{org.gradle.api.artifacts.Configuration, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{Function, typeParametersMap=TypeParametersMap{nameToValue={empty.Equivalence.Wrapper<Method>=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, empty.Method=ReferenceType{org.gradle.api.artifacts.Configuration, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/internal/IdeaDependenciesProvider.java
Cannot solve method call Lists.newArrayList(Iterables.transform(scope.scopes, scopeToDependency(dependencyKey))) UnsolvedSymbolException{context='Method 'transform' with parameterTypes [ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{Function, typeParametersMap=TypeParametersMap{nameToValue={empty.Equivalence.Wrapper<Method>=ReferenceType{org.gradle.plugins.ide.idea.model.Dependency, typeParametersMap=TypeParametersMap{nameToValue={}}}, empty.Method=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/internal/IdeaDependenciesProvider.java
Cannot solve method call dependencies.addAll(Lists.newArrayList(Iterables.transform(scope.scopes, scopeToDependency(dependencyKey)))) java.lang.RuntimeException: Error calculating the type of parameter Iterables.transform(scope.scopes, scopeToDependency(dependencyKey)) of method call Lists.newArrayList(Iterables.transform(scope.scopes, scopeToDependency(dependencyKey))) /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/internal/IdeaDependenciesProvider.java
Cannot solve method call Lists.newArrayList(Iterables.transform(scope.scopes, scopeToDependency(dependencyKey))) UnsolvedSymbolException{context='Method 'transform' with parameterTypes [ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{Function, typeParametersMap=TypeParametersMap{nameToValue={empty.Equivalence.Wrapper<Method>=ReferenceType{org.gradle.plugins.ide.idea.model.Dependency, typeParametersMap=TypeParametersMap{nameToValue={}}}, empty.Method=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/internal/IdeaDependenciesProvider.java
Cannot solve method call dependencies.addAll(Lists.newArrayList(Iterables.transform(scope.scopes, scopeToDependency(dependencyKey)))) java.lang.RuntimeException: Error calculating the type of parameter Iterables.transform(scope.scopes, scopeToDependency(dependencyKey)) of method call Lists.newArrayList(Iterables.transform(scope.scopes, scopeToDependency(dependencyKey))) /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/internal/IdeaDependenciesProvider.java
Cannot solve method call Iterables.any(configurations, Predicates.equalTo(configuration)) UnsolvedSymbolException{context='Method 'equalTo' with parameterTypes [ReferenceType{org.gradle.api.artifacts.Configuration, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.base.Predicates}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/internal/IdeaDependenciesProvider.java
Method 'get' cannot be resolved in context dependenciesToConfigs.get(dependencyKey) (line: 318) MethodCallExprContext{wrapped=dependenciesToConfigs.get(dependencyKey)}. Parameter types: [ReferenceType{org.gradle.plugins.ide.internal.resolver.model.IdeDependencyKey, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.plugins.ide.internal.resolver.model.IdeDependencyKey.T=WildcardUsage{type=null, boundedType=null}, org.gradle.plugins.ide.internal.resolver.model.IdeDependencyKey.R=ReferenceType{org.gradle.plugins.ide.idea.model.Dependency, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'get' cannot be resolved in context dependenciesToConfigs.get(dependencyKey) (line: 321) MethodCallExprContext{wrapped=dependenciesToConfigs.get(dependencyKey)}. Parameter types: [ReferenceType{org.gradle.plugins.ide.internal.resolver.model.IdeDependencyKey, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.plugins.ide.internal.resolver.model.IdeDependencyKey.T=WildcardUsage{type=null, boundedType=null}, org.gradle.plugins.ide.internal.resolver.model.IdeDependencyKey.R=ReferenceType{org.gradle.plugins.ide.idea.model.Dependency, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call Collections.unmodifiableSet(Sets.newHashSet(scopes)) UnsolvedSymbolException{context='Method 'newHashSet' with parameterTypes [ResolvedArrayType{ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Sets}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/internal/GeneratedIdeaScope.java
Method 'toLowerCase' cannot be resolved in context expandedUrl.toLowerCase() (line: 117) MethodCallExprContext{wrapped=expandedUrl.toLowerCase()}. Parameter types: []
Method 'toLowerCase' cannot be resolved in context expandedUrl.toLowerCase() (line: 119) MethodCallExprContext{wrapped=expandedUrl.toLowerCase()}. Parameter types: []
Method 'substring' cannot be resolved in context expandedUrl.substring(6) (line: 120) MethodCallExprContext{wrapped=expandedUrl.substring(6)}. Parameter types: [PrimitiveTypeUsage{name='int'}]
Cannot resolve field access null
Method 'append' cannot be resolved in context s.append(f.get(j)) (line: 191) MethodCallExprContext{wrapped=s.append(f.get(j))}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call this.modulePaths.addAll(Lists.transform(modules, new Function<IdeaModule, Path>() {

    @Override
    public Path apply(IdeaModule module) {
        return pathFactory.relativePath("PROJECT_DIR", module.getOutputFile());
    }
})) UnsolvedSymbolException{context='Method 'transform' with parameterTypes [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{org.gradle.plugins.ide.idea.model.IdeaModule, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{Function, typeParametersMap=TypeParametersMap{nameToValue={empty.Equivalence.Wrapper<Method>=ReferenceType{org.gradle.plugins.ide.idea.model.Path, typeParametersMap=TypeParametersMap{nameToValue={}}}, empty.Method=ReferenceType{org.gradle.plugins.ide.idea.model.IdeaModule, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Lists}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/Project.java
Cannot solve method call collectRootUrlAsFiles(getChildren(library, "CLASSES")) java.lang.RuntimeException: Method 'getChildren' cannot be resolved in context getChildren(library, "CLASSES") (line: 192) MethodCallExprContext{wrapped=getChildren(library, "CLASSES")}. Parameter types: [ReferenceType{Node, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/Project.java
Cannot solve method call projectLibrary.setClasses(collectRootUrlAsFiles(getChildren(library, "CLASSES"))) java.lang.RuntimeException: Error calculating the type of parameter getChildren(library, "CLASSES") of method call collectRootUrlAsFiles(getChildren(library, "CLASSES")) /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/Project.java
Cannot solve method call collectRootUrlAsFiles(getChildren(library, "JAVADOC")) java.lang.RuntimeException: Method 'getChildren' cannot be resolved in context getChildren(library, "JAVADOC") (line: 193) MethodCallExprContext{wrapped=getChildren(library, "JAVADOC")}. Parameter types: [ReferenceType{Node, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/Project.java
Cannot solve method call projectLibrary.setJavadoc(collectRootUrlAsFiles(getChildren(library, "JAVADOC"))) java.lang.RuntimeException: Error calculating the type of parameter getChildren(library, "JAVADOC") of method call collectRootUrlAsFiles(getChildren(library, "JAVADOC")) /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/Project.java
Cannot solve method call collectRootUrlAsFiles(getChildren(library, "SOURCES")) java.lang.RuntimeException: Method 'getChildren' cannot be resolved in context getChildren(library, "SOURCES") (line: 194) MethodCallExprContext{wrapped=getChildren(library, "SOURCES")}. Parameter types: [ReferenceType{Node, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/Project.java
Cannot solve method call projectLibrary.setSources(collectRootUrlAsFiles(getChildren(library, "SOURCES"))) java.lang.RuntimeException: Error calculating the type of parameter getChildren(library, "SOURCES") of method call collectRootUrlAsFiles(getChildren(library, "SOURCES")) /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/Project.java
Method 'attributes' cannot be resolved in context projectRoot.attributes() (line: 235) MethodCallExprContext{wrapped=projectRoot.attributes()}. Parameter types: []
Method 'attributes' cannot be resolved in context projectRoot.attributes() (line: 236) MethodCallExprContext{wrapped=projectRoot.attributes()}. Parameter types: []
Method 'attributes' cannot be resolved in context projectRoot.attributes() (line: 237) MethodCallExprContext{wrapped=projectRoot.attributes()}. Parameter types: []
Method 'attributes' cannot be resolved in context projectRoot.attributes() (line: 238) MethodCallExprContext{wrapped=projectRoot.attributes()}. Parameter types: []
Method 'attributes' cannot be resolved in context bytecodeLevelConfiguration.attributes() (line: 243) MethodCallExprContext{wrapped=bytecodeLevelConfiguration.attributes()}. Parameter types: []
Method 'attributes' cannot be resolved in context moduleNode.attributes() (line: 255) MethodCallExprContext{wrapped=moduleNode.attributes()}. Parameter types: []
Method 'attributes' cannot be resolved in context moduleNode.attributes() (line: 257) MethodCallExprContext{wrapped=moduleNode.attributes()}. Parameter types: []
Method 'attributes' cannot be resolved in context findVcsDirectoryMappings().attributes() (line: 264) MethodCallExprContext{wrapped=findVcsDirectoryMappings().attributes()}. Parameter types: []
Cannot solve method call findFirstWithAttributeValue(getChildren(getXml(), "component"), "name", "ProjectRootManager") java.lang.RuntimeException: Method 'getChildren' cannot be resolved in context getChildren(getXml(), "component") (line: 281) MethodCallExprContext{wrapped=getChildren(getXml(), "component")}. Parameter types: [ReferenceType{Node, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/Project.java
Cannot solve method call findFirstWithAttributeValue(getChildren(getXml(), "component"), "name", "ProjectModuleManager") java.lang.RuntimeException: Method 'getChildren' cannot be resolved in context getChildren(getXml(), "component") (line: 285) MethodCallExprContext{wrapped=getChildren(getXml(), "component")}. Parameter types: [ReferenceType{Node, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/Project.java
Cannot solve method call findFirstWithAttributeValue(getChildren(getXml(), "component"), "name", "CompilerConfiguration") java.lang.RuntimeException: Method 'getChildren' cannot be resolved in context getChildren(getXml(), "component") (line: 295) MethodCallExprContext{wrapped=getChildren(getXml(), "component")}. Parameter types: [ReferenceType{Node, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/Project.java
Cannot solve method call findFirstWithAttributeValue(getChildren(getXml(), "component"), "name", "VcsDirectoryMappings") java.lang.RuntimeException: Method 'getChildren' cannot be resolved in context getChildren(getXml(), "component") (line: 309) MethodCallExprContext{wrapped=getChildren(getXml(), "component")}. Parameter types: [ReferenceType{Node, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/Project.java
Cannot solve method call findFirstWithAttributeValue(getChildren(getXml(), "component"), "name", "libraryTable") java.lang.RuntimeException: Method 'getChildren' cannot be resolved in context getChildren(getXml(), "component") (line: 314) MethodCallExprContext{wrapped=getChildren(getXml(), "component")}. Parameter types: [ReferenceType{Node, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/Project.java
Cannot solve method call "false".equals(sourceFolder.attribute("isTestSource")) java.lang.RuntimeException: Method 'attribute' cannot be resolved in context sourceFolder.attribute("isTestSource") (line: 242) MethodCallExprContext{wrapped=sourceFolder.attribute("isTestSource")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/Module.java
Cannot solve method call "true".equals(sourceFolder.attribute("generated")) java.lang.RuntimeException: Method 'attribute' cannot be resolved in context sourceFolder.attribute("generated") (line: 247) MethodCallExprContext{wrapped=sourceFolder.attribute("generated")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/Module.java
Cannot solve method call "true".equals(getNewModuleRootManager().attribute("inherit-compiler-output")) java.lang.RuntimeException: Method 'attribute' cannot be resolved in context getNewModuleRootManager().attribute("inherit-compiler-output") (line: 258) MethodCallExprContext{wrapped=getNewModuleRootManager().attribute("inherit-compiler-output")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/Module.java
Method 'parent' cannot be resolved in context inheritedJdk.parent() (line: 314) MethodCallExprContext{wrapped=inheritedJdk.parent()}. Parameter types: []
Method 'attributes' cannot be resolved in context findOrCreateContentNode().attributes() (line: 336) MethodCallExprContext{wrapped=findOrCreateContentNode().attributes()}. Parameter types: []
Method 'attributes' cannot be resolved in context getNewModuleRootManager().attributes() (line: 378) MethodCallExprContext{wrapped=getNewModuleRootManager().attributes()}. Parameter types: []
Method 'attributes' cannot be resolved in context getNewModuleRootManager().attributes() (line: 383) MethodCallExprContext{wrapped=getNewModuleRootManager().attributes()}. Parameter types: []
Method 'attributes' cannot be resolved in context findOrCreateOutputDir().attributes() (line: 389) MethodCallExprContext{wrapped=findOrCreateOutputDir().attributes()}. Parameter types: []
Method 'attributes' cannot be resolved in context findOrCreateTestOutputDir().attributes() (line: 392) MethodCallExprContext{wrapped=findOrCreateTestOutputDir().attributes()}. Parameter types: []
Cannot solve method call Arrays.asList("module-library", "module").contains(((Node) orderEntry).attribute("type")) java.lang.RuntimeException: Method 'attribute' cannot be resolved in context ((Node) orderEntry).attribute("type") (line: 406) MethodCallExprContext{wrapped=((Node) orderEntry).attribute("type")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/Module.java
Cannot solve method call findFirstWithAttributeValue(getChildren(getXml(), "component"), "name", "NewModuleRootManager") java.lang.RuntimeException: Method 'getChildren' cannot be resolved in context getChildren(getXml(), "component") (line: 417) MethodCallExprContext{wrapped=getChildren(getXml(), "component")}. Parameter types: [ReferenceType{Node, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/Module.java
Cannot solve method call ConfigureUtil.configure(closure, getIpr()) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/IdeaProject.java
Cannot solve method call xmlProject.getModulePaths().add(pathFactory.relativePath("PROJECT_DIR", imlFile)) java.lang.RuntimeException: Method 'relativePath' cannot be resolved in context pathFactory.relativePath("PROJECT_DIR", imlFile) (line: 309) MethodCallExprContext{wrapped=pathFactory.relativePath("PROJECT_DIR", imlFile)}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/IdeaProject.java
Cannot solve method call Sets.newLinkedHashSet(Iterables.transform(files, new Function<File, Path>() {

    @Override
    public Path apply(File file) {
        return getPathFactory().path(file);
    }
})) UnsolvedSymbolException{context='Method 'transform' with parameterTypes [ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{Function, typeParametersMap=TypeParametersMap{nameToValue={empty.Equivalence.Wrapper<Method>=ReferenceType{org.gradle.plugins.ide.idea.model.Path, typeParametersMap=TypeParametersMap{nameToValue={}}}, empty.Method=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/IdeaModule.java
Cannot solve method call Maps.newHashMap(ImmutableMap.<String, Object>builder().put("type", "module-library").putAll(getAttributeMapForScopeAndExported()).build()) UnsolvedSymbolException{context='Method 'builder' with parameterTypes []', name='ReflectionClassDeclaration{clazz=ImmutableMap}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/ModuleLibrary.java
Method 'appendNode' cannot be resolved in context parentNode.appendNode("orderEntry", orderEntryAttributes) (line: 123) MethodCallExprContext{wrapped=parentNode.appendNode("orderEntry", orderEntryAttributes)}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call attributes.put("recursive", String.valueOf(jarDirectory.isRecursive())) UnsolvedSymbolException{context='Method 'valueOf' with parameterTypes [PrimitiveTypeUsage{name='boolean'}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/ModuleLibrary.java
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
Cannot solve method call Maps.newHashMap(ImmutableMap.<String, Object>builder().put("type", "module").put("module-name", name).putAll(getAttributeMapForScopeAndExported()).build()) UnsolvedSymbolException{context='Method 'builder' with parameterTypes []', name='ReflectionClassDeclaration{clazz=ImmutableMap}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/idea/model/ModuleDependency.java
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
Cannot resolve field access null
Method 'getByType' cannot be resolved in context project.getExtensions().getByType(EclipseModel.class) (line: 134) MethodCallExprContext{wrapped=project.getExtensions().getByType(EclipseModel.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.plugins.ide.eclipse.model.EclipseModel, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getByType' cannot be resolved in context project.getExtensions().getByType(EclipseModel.class) (line: 134) MethodCallExprContext{wrapped=project.getExtensions().getByType(EclipseModel.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.plugins.ide.eclipse.model.EclipseModel, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call projectComponentProvider.registerAdditionalArtifact(projectId, createArtifact("project", projectId, projectName, project)) java.lang.RuntimeException: Method 'createArtifact' cannot be resolved in context createArtifact("project", projectId, projectName, project) (line: 135) MethodCallExprContext{wrapped=createArtifact("project", projectId, projectName, project)}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.api.artifacts.component.ProjectComponentIdentifier, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.api.Project, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
Cannot solve method call projectComponentProvider.registerAdditionalArtifact(projectId, createArtifact("classpath", projectId, projectName, project)) java.lang.RuntimeException: Method 'createArtifact' cannot be resolved in context createArtifact("classpath", projectId, projectName, project) (line: 136) MethodCallExprContext{wrapped=createArtifact("classpath", projectId, projectName, project)}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.api.artifacts.component.ProjectComponentIdentifier, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.api.Project, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
Cannot solve method call task.setInputFile(project.file(".project")) java.lang.RuntimeException: Method 'file' cannot be resolved in context project.file(".project") (line: 155) MethodCallExprContext{wrapped=project.file(".project")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
Cannot solve method call task.setOutputFile(project.file(".project")) java.lang.RuntimeException: Method 'file' cannot be resolved in context project.file(".project") (line: 156) MethodCallExprContext{wrapped=project.file(".project")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
Cannot solve method call convention.map("comment", new Callable<String>() {

    @Override
    public String call() {
        return project.getDescription();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
Cannot solve method call convention.map("linkedResources", new Callable<Set<Link>>() {

    @Override
    public Set<Link> call() {
        return new LinkedResourcesCreator().links(project);
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
Cannot solve method call projectModel.getBuildCommands().set(Iterables.indexOf(projectModel.getBuildCommands(), new Predicate<BuildCommand>() {

    @Override
    public boolean apply(BuildCommand buildCommand) {
        return buildCommand.getName().equals("org.eclipse.jdt.core.javabuilder");
    }
}), new BuildCommand("org.scala-ide.sdt.core.scalabuilder")) UnsolvedSymbolException{context='Method 'indexOf' with parameterTypes [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{org.gradle.plugins.ide.eclipse.model.BuildCommand, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{Predicate, typeParametersMap=TypeParametersMap{nameToValue={empty.? super ScriptBlock=ReferenceType{org.gradle.plugins.ide.eclipse.model.BuildCommand, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
Cannot solve method call model.setClasspath(instantiator.newInstance(EclipseClasspath.class, project)) java.lang.RuntimeException: Method 'newInstance' cannot be resolved in context instantiator.newInstance(EclipseClasspath.class, project) (line: 218) MethodCallExprContext{wrapped=instantiator.newInstance(EclipseClasspath.class, project)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.plugins.ide.eclipse.model.EclipseClasspath, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{org.gradle.api.Project, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
Cannot solve method call ((IConventionAware) model.getClasspath()).getConventionMapping().map("defaultOutputDir", new Callable<File>() {

    @Override
    public File call() {
        return new File(project.getProjectDir(), "bin");
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
Cannot solve method call task.setInputFile(project.file(".classpath")) java.lang.RuntimeException: Method 'file' cannot be resolved in context project.file(".classpath") (line: 236) MethodCallExprContext{wrapped=project.file(".classpath")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
Cannot solve method call task.setOutputFile(project.file(".classpath")) java.lang.RuntimeException: Method 'file' cannot be resolved in context project.file(".classpath") (line: 237) MethodCallExprContext{wrapped=project.file(".classpath")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 242) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call task.getClasspath().setSourceSets(project.getConvention().getPlugin(JavaPluginConvention.class).getSourceSets()) java.lang.RuntimeException: Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 242) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
Cannot solve method call Lists.newArrayList(project.getConfigurations().getByName("testRuntime"), project.getConfigurations().getByName("compileClasspath"), project.getConfigurations().getByName("testCompileClasspath")) java.lang.RuntimeException: Method 'getByName' cannot be resolved in context project.getConfigurations().getByName("testRuntime") (line: 274) MethodCallExprContext{wrapped=project.getConfigurations().getByName("testRuntime")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
Cannot solve method call task.getClasspath().setPlusConfigurations(Lists.newArrayList(project.getConfigurations().getByName("testRuntime"), project.getConfigurations().getByName("compileClasspath"), project.getConfigurations().getByName("testCompileClasspath"))) java.lang.RuntimeException: Error calculating the type of parameter project.getConfigurations().getByName("testRuntime") of method call Lists.newArrayList(project.getConfigurations().getByName("testRuntime"), project.getConfigurations().getByName("compileClasspath"), project.getConfigurations().getByName("testCompileClasspath")) /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 278) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getByName' cannot be resolved in context sourceSets.getByName("main") (line: 279) MethodCallExprContext{wrapped=sourceSets.getByName("main")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getByName' cannot be resolved in context sourceSets.getByName("main") (line: 279) MethodCallExprContext{wrapped=sourceSets.getByName("main")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getByName' cannot be resolved in context sourceSets.getByName("test") (line: 279) MethodCallExprContext{wrapped=sourceSets.getByName("test")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getByName' cannot be resolved in context sourceSets.getByName("test") (line: 279) MethodCallExprContext{wrapped=sourceSets.getByName("test")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call Iterables.concat(sourceSets.getByName("main").getOutput().getDirs(), sourceSets.getByName("test").getOutput().getDirs()) java.lang.RuntimeException: Method 'getByName' cannot be resolved in context sourceSets.getByName("main") (line: 279) MethodCallExprContext{wrapped=sourceSets.getByName("main")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
Cannot solve method call Lists.newArrayList(Iterables.concat(sourceSets.getByName("main").getOutput().getDirs(), sourceSets.getByName("test").getOutput().getDirs())) java.lang.RuntimeException: Error calculating the type of parameter sourceSets.getByName("main").getOutput().getDirs() of method call Iterables.concat(sourceSets.getByName("main").getOutput().getDirs(), sourceSets.getByName("test").getOutput().getDirs()) /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
Cannot solve method call ((IConventionAware) task.getClasspath()).getConventionMapping().map("classFolders", new Callable<List<File>>() {

    @Override
    public List<File> call() {
        SourceSetContainer sourceSets = project.getConvention().getPlugin(JavaPluginConvention.class).getSourceSets();
        return Lists.newArrayList(Iterables.concat(sourceSets.getByName("main").getOutput().getDirs(), sourceSets.getByName("test").getOutput().getDirs()));
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 283) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getByName' cannot be resolved in context sourceSets.getByName("main") (line: 284) MethodCallExprContext{wrapped=sourceSets.getByName("main")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getByName' cannot be resolved in context sourceSets.getByName("main") (line: 284) MethodCallExprContext{wrapped=sourceSets.getByName("main")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call task.dependsOn(sourceSets.getByName("main").getOutput().getDirs()) java.lang.RuntimeException: Method 'getByName' cannot be resolved in context sourceSets.getByName("main") (line: 284) MethodCallExprContext{wrapped=sourceSets.getByName("main")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
Method 'getByName' cannot be resolved in context sourceSets.getByName("test") (line: 285) MethodCallExprContext{wrapped=sourceSets.getByName("test")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getByName' cannot be resolved in context sourceSets.getByName("test") (line: 285) MethodCallExprContext{wrapped=sourceSets.getByName("test")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call task.dependsOn(sourceSets.getByName("test").getOutput().getDirs()) java.lang.RuntimeException: Method 'getByName' cannot be resolved in context sourceSets.getByName("test") (line: 285) MethodCallExprContext{wrapped=sourceSets.getByName("test")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
Cannot solve method call Iterables.concat(Iterables.transform(task.getClasspath().getPlusConfigurations(), new Function<Configuration, Iterable<Dependency>>() {

    @Override
    public Iterable<Dependency> apply(Configuration config) {
        return config.getAllDependencies();
    }
})) UnsolvedSymbolException{context='Method 'transform' with parameterTypes [ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=ReferenceType{org.gradle.api.artifacts.Configuration, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{Function, typeParametersMap=TypeParametersMap{nameToValue={empty.Equivalence.Wrapper<Method>=ReferenceType{Iterable, typeParametersMap=TypeParametersMap{nameToValue={empty.BlockDoc=ReferenceType{org.gradle.api.artifacts.Dependency, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, empty.Method=ReferenceType{org.gradle.api.artifacts.Configuration, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
Cannot solve method call Iterables.filter(Iterables.concat(Iterables.transform(task.getClasspath().getPlusConfigurations(), new Function<Configuration, Iterable<Dependency>>() {

    @Override
    public Iterable<Dependency> apply(Configuration config) {
        return config.getAllDependencies();
    }
})), dependencyInProvided) java.lang.RuntimeException: Error calculating the type of parameter Iterables.transform(task.getClasspath().getPlusConfigurations(), new Function<Configuration, Iterable<Dependency>>() {

    @Override
    public Iterable<Dependency> apply(Configuration config) {
        return config.getAllDependencies();
    }
}) of method call Iterables.concat(Iterables.transform(task.getClasspath().getPlusConfigurations(), new Function<Configuration, Iterable<Dependency>>() {

    @Override
    public Iterable<Dependency> apply(Configuration config) {
        return config.getAllDependencies();
    }
})) /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
Cannot solve method call Lists.newArrayList(Iterables.filter(Iterables.concat(Iterables.transform(task.getClasspath().getPlusConfigurations(), new Function<Configuration, Iterable<Dependency>>() {

    @Override
    public Iterable<Dependency> apply(Configuration config) {
        return config.getAllDependencies();
    }
})), dependencyInProvided)) java.lang.RuntimeException: Error calculating the type of parameter Iterables.concat(Iterables.transform(task.getClasspath().getPlusConfigurations(), new Function<Configuration, Iterable<Dependency>>() {

    @Override
    public Iterable<Dependency> apply(Configuration config) {
        return config.getAllDependencies();
    }
})) of method call Iterables.filter(Iterables.concat(Iterables.transform(task.getClasspath().getPlusConfigurations(), new Function<Configuration, Iterable<Dependency>>() {

    @Override
    public Iterable<Dependency> apply(Configuration config) {
        return config.getAllDependencies();
    }
})), dependencyInProvided) /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
Cannot solve method call project.getConfigurations().detachedConfiguration(dependencies.toArray(new Dependency[0])) java.lang.RuntimeException: org.gradle.api.artifacts.Dependency[] T[] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
Cannot solve method call task.getClasspath().getMinusConfigurations().add(project.getConfigurations().detachedConfiguration(dependencies.toArray(new Dependency[0]))) java.lang.RuntimeException: Error calculating the type of parameter dependencies.toArray(new Dependency[0]) of method call project.getConfigurations().detachedConfiguration(dependencies.toArray(new Dependency[0])) /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
Cannot solve method call task.setOutputFile(project.file(".settings/org.eclipse.jdt.core.prefs")) java.lang.RuntimeException: Method 'file' cannot be resolved in context project.file(".settings/org.eclipse.jdt.core.prefs") (line: 333) MethodCallExprContext{wrapped=project.file(".settings/org.eclipse.jdt.core.prefs")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
Cannot solve method call task.setInputFile(project.file(".settings/org.eclipse.jdt.core.prefs")) java.lang.RuntimeException: Method 'file' cannot be resolved in context project.file(".settings/org.eclipse.jdt.core.prefs") (line: 334) MethodCallExprContext{wrapped=project.file(".settings/org.eclipse.jdt.core.prefs")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 342) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call conventionMapping.map("sourceCompatibility", new Callable<JavaVersion>() {

    @Override
    public JavaVersion call() {
        return project.getConvention().getPlugin(JavaPluginConvention.class).getSourceCompatibility();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 349) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call conventionMapping.map("targetCompatibility", new Callable<JavaVersion>() {

    @Override
    public JavaVersion call() {
        return project.getConvention().getPlugin(JavaPluginConvention.class).getTargetCompatibility();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 356) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call conventionMapping.map("javaRuntimeName", new Callable<String>() {

    @Override
    public String call() {
        return "JavaSE-" + project.getConvention().getPlugin(JavaPluginConvention.class).getTargetCompatibility();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 33) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call deduplicator.deduplicate(eclipseProjects.keySet()) java.lang.RuntimeException: Method 'keySet' cannot be resolved in context eclipseProjects.keySet() (line: 39) MethodCallExprContext{wrapped=eclipseProjects.keySet()}. Parameter types: [] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/internal/EclipseNameDeduper.java
Cannot solve method call PathUtil.normalizePath(emptyToNull(location)) java.lang.RuntimeException: Method 'emptyToNull' cannot be resolved in context emptyToNull(location) (line: 42) MethodCallExprContext{wrapped=emptyToNull(location)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/Link.java
Cannot solve method call addClasspathEntry(node, Maps.<String, Object>newLinkedHashMap()) UnsolvedSymbolException{context='Method 'newLinkedHashMap' with parameterTypes []', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Maps}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/AbstractClasspathEntry.java
Cannot solve method call attributes.put((String) attributeNode.attribute("name"), attributeNode.attribute("value")) java.lang.RuntimeException: Method 'attribute' cannot be resolved in context attributeNode.attribute("value") (line: 179) MethodCallExprContext{wrapped=attributeNode.attribute("value")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/AbstractClasspathEntry.java
Cannot solve method call Preconditions.checkArgument(path.startsWith("/")) java.lang.RuntimeException: Method 'startsWith' cannot be resolved in context path.startsWith("/") (line: 68) MethodCallExprContext{wrapped=path.startsWith("/")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/ProjectDependency.java
Cannot solve method call Lists.newArrayList(Lists.transform(regularSourceFolders, new Function<SourceFolder, String>() {

    @Override
    public String apply(SourceFolder sourceFolder) {
        return sourceFolder.getName();
    }
})) UnsolvedSymbolException{context='Method 'transform' with parameterTypes [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{org.gradle.plugins.ide.eclipse.model.SourceFolder, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{Function, typeParametersMap=TypeParametersMap{nameToValue={empty.Equivalence.Wrapper<Method>=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, empty.Method=ReferenceType{org.gradle.plugins.ide.eclipse.model.SourceFolder, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Lists}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/internal/SourceFoldersCreator.java
Cannot solve method call CollectionUtils.dedup(allIncludes, Equivalence.equals()) UnsolvedSymbolException{context='Method 'equals' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Equivalence}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/internal/SourceFoldersCreator.java
Cannot solve method call CollectionUtils.intersection(Lists.newArrayList(javaSrcDirs, resSrcDirs)) UnsolvedSymbolException{context='Method 'newArrayList' with parameterTypes [ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Lists}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/internal/SourceFoldersCreator.java
Cannot solve method call Cast.<Set<String>>uncheckedCast(DynamicObjectUtil.asDynamicObject(patterns).getProperty(filterOperation)) UnsolvedSymbolException{context='Method 'asDynamicObject' with parameterTypes [ReferenceType{org.gradle.api.tasks.util.PatternSet, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class DynamicObjectUtil {

    public static DynamicObject asDynamicObject(Object object) {
        if (object instanceof DynamicObject) {
            return (DynamicObject) object;
        } else if (object instanceof DynamicObjectAware) {
            return ((DynamicObjectAware) object).getAsDynamicObject();
        } else {
            return new BeanDynamicObject(object);
        }
    }
}}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/internal/SourceFoldersCreator.java
No matching between ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual)
Cannot solve method call entries.addAll(getEntriesFromConfigurations(project, configOrEmptySet(wtp.getRootConfigurations()), configOrEmptySet(wtp.getMinusConfigurations()), wtp, "/")) java.lang.RuntimeException: Method 'getEntriesFromConfigurations' cannot be resolved in context getEntriesFromConfigurations(project, configOrEmptySet(wtp.getRootConfigurations()), configOrEmptySet(wtp.getMinusConfigurations()), wtp, "/") (line: 60) MethodCallExprContext{wrapped=getEntriesFromConfigurations(project, configOrEmptySet(wtp.getRootConfigurations()), configOrEmptySet(wtp.getMinusConfigurations()), wtp, "/")}. Parameter types: [ReferenceType{org.gradle.api.Project, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{org.gradle.api.artifacts.Configuration, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{org.gradle.api.artifacts.Configuration, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/internal/WtpComponentFactory.java
Cannot solve method call dependenciesExtractor.extractRepoFileDependencies(classpath.getProject().getDependencies(), classpath.getPlusConfigurations(), classpath.getMinusConfigurations(), downloadSources, downloadJavadoc) java.lang.RuntimeException: Method 'getDependencies' cannot be resolved in context classpath.getProject().getDependencies() (line: 82) MethodCallExprContext{wrapped=classpath.getProject().getDependencies()}. Parameter types: [] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/internal/EclipseDependenciesCreator.java
Method 'replace' cannot be resolved in context jarURI.replace("jar:", "") (line: 86) MethodCallExprContext{wrapped=jarURI.replace("jar:", "")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call path.substring(prefix.length()) java.lang.RuntimeException: Method 'length' cannot be resolved in context prefix.length() (line: 104) MethodCallExprContext{wrapped=prefix.length()}. Parameter types: [] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/internal/FileReferenceFactory.java
Method 'appendNode' cannot be resolved in context node.appendNode("dependency-type") (line: 71) MethodCallExprContext{wrapped=node.appendNode("dependency-type")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call not(instanceOf(WbDependentModule.class)) java.lang.RuntimeException: Method 'instanceOf' cannot be resolved in context instanceOf(WbDependentModule.class) (line: 80) MethodCallExprContext{wrapped=instanceOf(WbDependentModule.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.plugins.ide.eclipse.model.WbDependentModule, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/WtpComponent.java
Cannot solve method call Iterables.filter(wbModuleEntries, not(instanceOf(WbDependentModule.class))) java.lang.RuntimeException: Error calculating the type of parameter instanceOf(WbDependentModule.class) of method call not(instanceOf(WbDependentModule.class)) /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/WtpComponent.java
Cannot solve method call Sets.newLinkedHashSet(Iterables.concat(toKeep, newEntries)) UnsolvedSymbolException{context='Method 'concat' with parameterTypes [ReferenceType{Iterable, typeParametersMap=TypeParametersMap{nameToValue={empty.BlockDoc=ReferenceType{org.gradle.plugins.ide.eclipse.model.WbModuleEntry, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{org.gradle.plugins.ide.eclipse.model.WbModuleEntry, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/WtpComponent.java
Cannot solve method call Lists.newArrayList(Sets.newLinkedHashSet(Iterables.concat(toKeep, newEntries))) java.lang.RuntimeException: Error calculating the type of parameter Iterables.concat(toKeep, newEntries) of method call Sets.newLinkedHashSet(Iterables.concat(toKeep, newEntries)) /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/WtpComponent.java
Cannot solve method call "property".equals(node.name()) java.lang.RuntimeException: Method 'name' cannot be resolved in context node.name() (line: 96) MethodCallExprContext{wrapped=node.name()}. Parameter types: [] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/WtpComponent.java
Cannot solve method call "wb-resource".equals(node.name()) java.lang.RuntimeException: Method 'name' cannot be resolved in context node.name() (line: 102) MethodCallExprContext{wrapped=node.name()}. Parameter types: [] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/WtpComponent.java
Cannot solve method call "dependent-module".equals(node.name()) java.lang.RuntimeException: Method 'name' cannot be resolved in context node.name() (line: 104) MethodCallExprContext{wrapped=node.name()}. Parameter types: [] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/WtpComponent.java
Cannot solve method call "context-root".equals(node.attribute("name")) java.lang.RuntimeException: Method 'attribute' cannot be resolved in context node.attribute("name") (line: 97) MethodCallExprContext{wrapped=node.attribute("name")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/WtpComponent.java
Cannot solve method call Cast.<List<Node>>uncheckedCast(wbModuleNode.children()) java.lang.RuntimeException: Method 'children' cannot be resolved in context wbModuleNode.children() (line: 95) MethodCallExprContext{wrapped=wbModuleNode.children()}. Parameter types: [] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/WtpComponent.java
Method 'attributes' cannot be resolved in context wbModuleNode.attributes() (line: 114) MethodCallExprContext{wrapped=wbModuleNode.attributes()}. Parameter types: []
Cannot solve method call Lists.newArrayList(Iterables.concat(getResources(), Collections.singleton(new WbResource(args.get("deployPath"), args.get("sourcePath"))))) UnsolvedSymbolException{context='Method 'concat' with parameterTypes [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{org.gradle.plugins.ide.eclipse.model.WbResource, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{org.gradle.plugins.ide.eclipse.model.WbResource, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/EclipseWtpComponent.java
Cannot solve method call Lists.newArrayList(Iterables.concat(getProperties(), Collections.singleton(new WbProperty(args.get("name"), args.get("value"))))) UnsolvedSymbolException{context='Method 'concat' with parameterTypes [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{org.gradle.plugins.ide.eclipse.model.WbProperty, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{org.gradle.plugins.ide.eclipse.model.WbProperty, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/EclipseWtpComponent.java
Cannot solve method call Lists.newArrayList(Sets.newLinkedHashSet(facets)) UnsolvedSymbolException{context='Method 'newLinkedHashSet' with parameterTypes [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{org.gradle.plugins.ide.eclipse.model.Facet, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Sets}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/WtpFacet.java
Cannot solve method call Lists.newArrayList(Sets.newLinkedHashSet(natures)) UnsolvedSymbolException{context='Method 'newLinkedHashSet' with parameterTypes [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Sets}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/Project.java
Cannot solve method call Lists.newArrayList(Sets.newLinkedHashSet(buildCommands)) UnsolvedSymbolException{context='Method 'newLinkedHashSet' with parameterTypes [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{org.gradle.plugins.ide.eclipse.model.BuildCommand, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Sets}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/Project.java
Cannot solve method call referencedProjects.add(projectNode.text()) java.lang.RuntimeException: Method 'text' cannot be resolved in context projectNode.text() (line: 148) MethodCallExprContext{wrapped=projectNode.text()}. Parameter types: [] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/Project.java
Cannot solve method call getChildren(findFirstChildNamed(getXml(), "projects"), "project") java.lang.RuntimeException: Method 'findFirstChildNamed' cannot be resolved in context findFirstChildNamed(getXml(), "projects") (line: 147) MethodCallExprContext{wrapped=findFirstChildNamed(getXml(), "projects")}. Parameter types: [ReferenceType{Node, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/Project.java
Cannot solve method call natures.add(natureNode.text()) java.lang.RuntimeException: Method 'text' cannot be resolved in context natureNode.text() (line: 154) MethodCallExprContext{wrapped=natureNode.text()}. Parameter types: [] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/Project.java
Cannot solve method call getChildren(findFirstChildNamed(getXml(), "natures"), "nature") java.lang.RuntimeException: Method 'findFirstChildNamed' cannot be resolved in context findFirstChildNamed(getXml(), "natures") (line: 153) MethodCallExprContext{wrapped=findFirstChildNamed(getXml(), "natures")}. Parameter types: [ReferenceType{Node, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/Project.java
Method 'findFirstChildNamed' cannot be resolved in context findFirstChildNamed(commandNode, "name") (line: 160) MethodCallExprContext{wrapped=findFirstChildNamed(commandNode, "name")}. Parameter types: [ReferenceType{Node, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'findFirstChildNamed' cannot be resolved in context findFirstChildNamed(dictionaryNode, "key") (line: 163) MethodCallExprContext{wrapped=findFirstChildNamed(dictionaryNode, "key")}. Parameter types: [ReferenceType{Node, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'findFirstChildNamed' cannot be resolved in context findFirstChildNamed(dictionaryNode, "value") (line: 164) MethodCallExprContext{wrapped=findFirstChildNamed(dictionaryNode, "value")}. Parameter types: [ReferenceType{Node, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call getChildren(findFirstChildNamed(commandNode, "arguments"), "dictionary") java.lang.RuntimeException: Method 'findFirstChildNamed' cannot be resolved in context findFirstChildNamed(commandNode, "arguments") (line: 162) MethodCallExprContext{wrapped=findFirstChildNamed(commandNode, "arguments")}. Parameter types: [ReferenceType{Node, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/Project.java
Cannot solve method call getChildren(findFirstChildNamed(getXml(), "buildSpec"), "buildCommand") java.lang.RuntimeException: Method 'findFirstChildNamed' cannot be resolved in context findFirstChildNamed(getXml(), "buildSpec") (line: 159) MethodCallExprContext{wrapped=findFirstChildNamed(getXml(), "buildSpec")}. Parameter types: [ReferenceType{Node, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/Project.java
Cannot solve method call getChildren(findFirstChildNamed(getXml(), "linkedResources"), "link") java.lang.RuntimeException: Method 'findFirstChildNamed' cannot be resolved in context findFirstChildNamed(getXml(), "linkedResources") (line: 172) MethodCallExprContext{wrapped=findFirstChildNamed(getXml(), "linkedResources")}. Parameter types: [ReferenceType{Node, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/Project.java
Cannot solve method call xml.appendNode("name", nullToEmpty(name)) java.lang.RuntimeException: Method 'nullToEmpty' cannot be resolved in context nullToEmpty(name) (line: 194) MethodCallExprContext{wrapped=nullToEmpty(name)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/Project.java
Cannot solve method call xml.appendNode("comment", nullToEmpty(comment)) java.lang.RuntimeException: Method 'nullToEmpty' cannot be resolved in context nullToEmpty(comment) (line: 195) MethodCallExprContext{wrapped=nullToEmpty(comment)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/Project.java
Cannot solve field access JavaVersion.VERSION_1_3
Cannot solve field access JavaVersion.VERSION_1_4
Cannot solve field access FacetType.installed
Cannot solve field access FacetType.installed
Cannot solve field access FacetType.installed
Cannot solve field access FacetType.installed
Cannot solve method call Arrays.asList(((String) attribute).split("\\|")) java.lang.RuntimeException: Method 'split' cannot be resolved in context ((String) attribute).split("\\|") (line: 54) MethodCallExprContext{wrapped=((String) attribute).split("\\|")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/SourceFolder.java
Cannot solve method call attributes.put("including", joiner.join(includes)) java.lang.RuntimeException: Method 'join' cannot be resolved in context joiner.join(includes) (line: 129) MethodCallExprContext{wrapped=joiner.join(includes)}. Parameter types: [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/SourceFolder.java
Cannot solve method call attributes.put("excluding", joiner.join(excludes)) java.lang.RuntimeException: Method 'join' cannot be resolved in context joiner.join(excludes) (line: 130) MethodCallExprContext{wrapped=joiner.join(excludes)}. Parameter types: [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/SourceFolder.java
Cannot solve method call Sets.difference(args.keySet(), VALID_LINKED_RESOURCE_ARGS) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/EclipseProject.java
Cannot solve method call Lists.newArrayList(Iterables.concat(getFacets(), Collections.singleton(ConfigureUtil.configureByMap(args, new Facet())))) UnsolvedSymbolException{context='Method 'concat' with parameterTypes [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{org.gradle.plugins.ide.eclipse.model.Facet, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{org.gradle.plugins.ide.eclipse.model.Facet, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/model/EclipseWtpFacet.java
Cannot solve method call model.setWtp(instantiator.newInstance(EclipseWtp.class)) java.lang.RuntimeException: Method 'newInstance' cannot be resolved in context instantiator.newInstance(EclipseWtp.class) (line: 79) MethodCallExprContext{wrapped=instantiator.newInstance(EclipseWtp.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.plugins.ide.eclipse.model.EclipseWtp, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Cannot solve method call task.setInputFile(project.file(".settings/org.eclipse.wst.common.component")) java.lang.RuntimeException: Method 'file' cannot be resolved in context project.file(".settings/org.eclipse.wst.common.component") (line: 132) MethodCallExprContext{wrapped=project.file(".settings/org.eclipse.wst.common.component")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Cannot solve method call task.setOutputFile(project.file(".settings/org.eclipse.wst.common.component")) java.lang.RuntimeException: Method 'file' cannot be resolved in context project.file(".settings/org.eclipse.wst.common.component") (line: 133) MethodCallExprContext{wrapped=project.file(".settings/org.eclipse.wst.common.component")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Cannot solve method call ((IConventionAware) task.getComponent()).getConventionMapping().map("deployName", new Callable<String>() {

    @Override
    public String call() throws Exception {
        return model.getProject().getName();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Cannot solve method call Sets.<Configuration>newHashSet(project.getConfigurations().getByName("runtime")) java.lang.RuntimeException: Method 'getByName' cannot be resolved in context project.getConfigurations().getByName("runtime") (line: 152) MethodCallExprContext{wrapped=project.getConfigurations().getByName("runtime")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Cannot solve method call task.getComponent().setLibConfigurations(Sets.<Configuration>newHashSet(project.getConfigurations().getByName("runtime"))) java.lang.RuntimeException: Error calculating the type of parameter project.getConfigurations().getByName("runtime") of method call Sets.<Configuration>newHashSet(project.getConfigurations().getByName("runtime")) /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Cannot solve method call task.getComponent().setMinusConfigurations(Sets.<Configuration>newHashSet()) UnsolvedSymbolException{context='Method 'newHashSet' with parameterTypes []', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Sets}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Cannot solve method call ((IConventionAware) task.getComponent()).getConventionMapping().map("libDeployPath", new Callable<String>() {

    @Override
    public String call() throws Exception {
        return "../";
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Cannot solve method call ((IConventionAware) task.getComponent()).getConventionMapping().map("sourceDirs", new Callable<Set<File>>() {

    @Override
    public Set<File> call() throws Exception {
        return getMainSourceDirs(project);
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Cannot solve method call Sets.<Configuration>newHashSet(project.getConfigurations().getByName("runtime")) java.lang.RuntimeException: Method 'getByName' cannot be resolved in context project.getConfigurations().getByName("runtime") (line: 173) MethodCallExprContext{wrapped=project.getConfigurations().getByName("runtime")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Cannot solve method call task.getComponent().setLibConfigurations(Sets.<Configuration>newHashSet(project.getConfigurations().getByName("runtime"))) java.lang.RuntimeException: Error calculating the type of parameter project.getConfigurations().getByName("runtime") of method call Sets.<Configuration>newHashSet(project.getConfigurations().getByName("runtime")) /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Cannot solve method call Sets.<Configuration>newHashSet(project.getConfigurations().getByName("providedRuntime")) java.lang.RuntimeException: Method 'getByName' cannot be resolved in context project.getConfigurations().getByName("providedRuntime") (line: 174) MethodCallExprContext{wrapped=project.getConfigurations().getByName("providedRuntime")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Cannot solve method call task.getComponent().setMinusConfigurations(Sets.<Configuration>newHashSet(project.getConfigurations().getByName("providedRuntime"))) java.lang.RuntimeException: Error calculating the type of parameter project.getConfigurations().getByName("providedRuntime") of method call Sets.<Configuration>newHashSet(project.getConfigurations().getByName("providedRuntime")) /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Cannot solve method call convention.map("libDeployPath", new Callable<String>() {

    @Override
    public String call() throws Exception {
        return "/WEB-INF/lib";
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Cannot solve method call convention.map("contextPath", new Callable<String>() {

    @Override
    public String call() throws Exception {
        return ((War) project.getTasks().getByName("war")).getBaseName();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(WarPluginConvention.class) (line: 192) MethodCallExprContext{wrapped=project.getConvention().getPlugin(WarPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.WarPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call convention.map("resources", new Callable<List<WbResource>>() {

    @Override
    public List<WbResource> call() throws Exception {
        return Lists.newArrayList(new WbResource("/", project.getConvention().getPlugin(WarPluginConvention.class).getWebAppDirName()));
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Cannot solve method call convention.map("sourceDirs", new Callable<Set<File>>() {

    @Override
    public Set<File> call() throws Exception {
        return getMainSourceDirs(project);
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Cannot solve method call Sets.<Configuration>newHashSet(project.getConfigurations().getByName("deploy")) java.lang.RuntimeException: Method 'getByName' cannot be resolved in context project.getConfigurations().getByName("deploy") (line: 207) MethodCallExprContext{wrapped=project.getConfigurations().getByName("deploy")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Cannot solve method call task.getComponent().setRootConfigurations(Sets.<Configuration>newHashSet(project.getConfigurations().getByName("deploy"))) java.lang.RuntimeException: Error calculating the type of parameter project.getConfigurations().getByName("deploy") of method call Sets.<Configuration>newHashSet(project.getConfigurations().getByName("deploy")) /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Cannot solve method call Sets.<Configuration>newHashSet(project.getConfigurations().getByName("earlib")) java.lang.RuntimeException: Method 'getByName' cannot be resolved in context project.getConfigurations().getByName("earlib") (line: 208) MethodCallExprContext{wrapped=project.getConfigurations().getByName("earlib")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Cannot solve method call task.getComponent().setLibConfigurations(Sets.<Configuration>newHashSet(project.getConfigurations().getByName("earlib"))) java.lang.RuntimeException: Error calculating the type of parameter project.getConfigurations().getByName("earlib") of method call Sets.<Configuration>newHashSet(project.getConfigurations().getByName("earlib")) /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Cannot solve method call task.getComponent().setMinusConfigurations(Sets.<Configuration>newHashSet()) UnsolvedSymbolException{context='Method 'newHashSet' with parameterTypes []', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Sets}'} /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Cannot solve method call convention.map("libDeployPath", new Callable<String>() {

    @Override
    public String call() throws Exception {
        String deployPath = ((Ear) project.getTasks().findByName(EarPlugin.EAR_TASK_NAME)).getLibDirName();
        if (!deployPath.startsWith("/")) {
            deployPath = "/" + deployPath;
        }
        return deployPath;
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(EarPluginConvention.class) (line: 226) MethodCallExprContext{wrapped=project.getConvention().getPlugin(EarPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.plugins.ear.EarPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call project.files(project.getConvention().getPlugin(EarPluginConvention.class).getAppDirName()) java.lang.RuntimeException: Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(EarPluginConvention.class) (line: 226) MethodCallExprContext{wrapped=project.getConvention().getPlugin(EarPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.plugins.ear.EarPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Error calculating the type of parameter project.getConvention().getPlugin(EarPluginConvention.class).getAppDirName() of method call project.files(project.getConvention().getPlugin(EarPluginConvention.class).getAppDirName())
Cannot solve method call convention.map("sourceDirs", new Callable<Set<File>>() {

    @Override
    public Set<File> call() throws Exception {
        return project.files(project.getConvention().getPlugin(EarPluginConvention.class).getAppDirName()).getFiles();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Cannot solve method call convention.map("sourceDirs", new Callable<Set<File>>() {

    @Override
    public Set<File> call() throws Exception {
        return getMainSourceDirs(project);
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Cannot solve method call task.setInputFile(project.file(".settings/org.eclipse.wst.common.project.facet.core.xml")) java.lang.RuntimeException: Method 'file' cannot be resolved in context project.file(".settings/org.eclipse.wst.common.project.facet.core.xml") (line: 255) MethodCallExprContext{wrapped=project.file(".settings/org.eclipse.wst.common.project.facet.core.xml")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Cannot solve method call task.setOutputFile(project.file(".settings/org.eclipse.wst.common.project.facet.core.xml")) java.lang.RuntimeException: Method 'file' cannot be resolved in context project.file(".settings/org.eclipse.wst.common.project.facet.core.xml") (line: 256) MethodCallExprContext{wrapped=project.file(".settings/org.eclipse.wst.common.project.facet.core.xml")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Cannot resolve field access null
Cannot solve field access Facet.FacetType.fixed
Cannot resolve field access null
Cannot solve field access Facet.FacetType.installed
Cannot resolve field access null
Cannot solve field access Facet.FacetType.installed
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 274) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call toJavaFacetVersion(project.getConvention().getPlugin(JavaPluginConvention.class).getSourceCompatibility()) java.lang.RuntimeException: Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 274) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Cannot solve method call ((IConventionAware) task.getFacet()).getConventionMapping().map("facets", new Callable<List<Facet>>() {

    @Override
    public List<Facet> call() throws Exception {
        return Lists.newArrayList(new Facet(Facet.FacetType.fixed, "jst.java", null), new Facet(Facet.FacetType.installed, "jst.utility", "1.0"), new Facet(Facet.FacetType.installed, "jst.java", toJavaFacetVersion(project.getConvention().getPlugin(JavaPluginConvention.class).getSourceCompatibility())));
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Cannot resolve field access null
Cannot solve field access Facet.FacetType.fixed
Cannot resolve field access null
Cannot solve field access Facet.FacetType.fixed
Cannot resolve field access null
Cannot solve field access Facet.FacetType.installed
Cannot resolve field access null
Cannot solve field access Facet.FacetType.installed
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 291) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call toJavaFacetVersion(project.getConvention().getPlugin(JavaPluginConvention.class).getSourceCompatibility()) java.lang.RuntimeException: Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 291) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Cannot solve method call ((IConventionAware) task.getFacet()).getConventionMapping().map("facets", new Callable<List<Facet>>() {

    @Override
    public List<Facet> call() throws Exception {
        return Lists.newArrayList(new Facet(Facet.FacetType.fixed, "jst.java", null), new Facet(Facet.FacetType.fixed, "jst.web", null), new Facet(Facet.FacetType.installed, "jst.web", "2.4"), new Facet(Facet.FacetType.installed, "jst.java", toJavaFacetVersion(project.getConvention().getPlugin(JavaPluginConvention.class).getSourceCompatibility())));
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Cannot resolve field access null
Cannot solve field access Facet.FacetType.fixed
Cannot resolve field access null
Cannot solve field access Facet.FacetType.installed
Cannot solve method call ((IConventionAware) task.getFacet()).getConventionMapping().map("facets", new Callable<List<Facet>>() {

    @Override
    public List<Facet> call() throws Exception {
        return Lists.newArrayList(new Facet(Facet.FacetType.fixed, "jst.ear", null), new Facet(Facet.FacetType.installed, "jst.ear", "5.0"));
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ide/src/main/java/org/gradle/plugins/ide/eclipse/EclipseWtpPlugin.java
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 356) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 356) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 356) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 356) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve field access JavaVersion.VERSION_1_5
Cannot solve field access JavaVersion.VERSION_1_6
Cannot solve method call new DslObject(ivyArtifact).getConventionMapping().map("name", new Callable<String>() {

    public String call() throws Exception {
        return publicationIdentity.getModule();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ivy/src/main/java/org/gradle/api/publish/ivy/internal/artifact/IvyArtifactNotationParserFactory.java
Method 'candidate' cannot be resolved in context visitor.candidate("Maps containing a 'source' entry") (line: 146) MethodCallExprContext{wrapped=visitor.candidate("Maps containing a 'source' entry")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve field access ArtifactType.IVY_DESCRIPTOR
Method 'maybeRegisterComponentType' cannot be resolved in context componentTypeRegistry.maybeRegisterComponentType(IvyModule.class) (line: 60) MethodCallExprContext{wrapped=componentTypeRegistry.maybeRegisterComponentType(IvyModule.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.ivy.IvyModule, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'startElement' cannot be resolved in context xmlWriter.startElement("ivy-module") (line: 110) MethodCallExprContext{wrapped=xmlWriter.startElement("ivy-module")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context xmlWriter.startElement("info") (line: 115) MethodCallExprContext{wrapped=xmlWriter.startElement("info")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context xmlWriter.startElement("info") (line: 115) MethodCallExprContext{wrapped=xmlWriter.startElement("info")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context xmlWriter.startElement("info") (line: 115) MethodCallExprContext{wrapped=xmlWriter.startElement("info")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context xmlWriter.startElement("info") (line: 115) MethodCallExprContext{wrapped=xmlWriter.startElement("info")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context xmlWriter.startElement("info") (line: 115) MethodCallExprContext{wrapped=xmlWriter.startElement("info")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context xmlWriter.startElement("info") (line: 115) MethodCallExprContext{wrapped=xmlWriter.startElement("info")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context xmlWriter.startElement("ns:" + entry.getKey().getLocalPart()) (line: 126) MethodCallExprContext{wrapped=xmlWriter.startElement("ns:" + entry.getKey().getLocalPart())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context xmlWriter.startElement("ns:" + entry.getKey().getLocalPart()) (line: 126) MethodCallExprContext{wrapped=xmlWriter.startElement("ns:" + entry.getKey().getLocalPart())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context xmlWriter.startElement("ns:" + entry.getKey().getLocalPart()) (line: 126) MethodCallExprContext{wrapped=xmlWriter.startElement("ns:" + entry.getKey().getLocalPart())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context xmlWriter.startElement("conf") (line: 161) MethodCallExprContext{wrapped=xmlWriter.startElement("conf")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context xmlWriter.startElement("conf") (line: 161) MethodCallExprContext{wrapped=xmlWriter.startElement("conf")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call xmlWriter.attribute("extends", CollectionUtils.join(",", configuration.getExtends())) UnsolvedSymbolException{context='Method 'join' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class CollectionUtils {

    /**
     * Returns null if the collection is empty otherwise expects a {@link #single(Iterable)} element to be found.
     */
    @Nullable
    public static <T> T findSingle(Collection<T> source) {
        return source.isEmpty() ? null : single(source);
    }

    /**
     * Returns the single element in the collection or throws.
     */
    public static <T> T single(Iterable<? extends T> source) {
        Iterator<? extends T> iterator = source.iterator();
        if (!iterator.hasNext()) {
            throw new NoSuchElementException("Expecting collection with single element, got none.");
        }
        T element = iterator.next();
        if (iterator.hasNext()) {
            throw new IllegalArgumentException("Expecting collection with single element, got multiple.");
        }
        return element;
    }

    public static <T> Collection<? extends T> checkedCast(Class<T> type, Collection<?> input) {
        for (Object o : input) {
            cast(type, o);
        }
        return Cast.uncheckedCast(input);
    }

    public static <T> T findFirst(Iterable<? extends T> source, Spec<? super T> filter) {
        for (T item : source) {
            if (filter.isSatisfiedBy(item)) {
                return item;
            }
        }
        return null;
    }

    public static <T> T findFirst(T[] source, Spec<? super T> filter) {
        for (T thing : source) {
            if (filter.isSatisfiedBy(thing)) {
                return thing;
            }
        }
        return null;
    }

    public static <T> T first(Iterable<? extends T> source) {
        return source.iterator().next();
    }

    public static <T> boolean any(Iterable<? extends T> source, Spec<? super T> filter) {
        return findFirst(source, filter) != null;
    }

    public static <T> boolean any(T[] source, Spec<? super T> filter) {
        return findFirst(source, filter) != null;
    }

    public static <T> Set<T> filter(Set<? extends T> set, Spec<? super T> filter) {
        return filter(set, new LinkedHashSet<T>(), filter);
    }

    public static <T> List<T> filter(List<? extends T> list, Spec<? super T> filter) {
        return filter(list, new LinkedList<T>(), filter);
    }

    public static <T> List<T> filter(T[] array, Spec<? super T> filter) {
        return filter(Arrays.asList(array), new LinkedList<T>(), filter);
    }

    /**
     * Returns a sorted copy of the provided collection of things. Uses the provided comparator to sort.
     */
    public static <T> List<T> sort(Iterable<? extends T> things, Comparator<? super T> comparator) {
        List<T> copy = toMutableList(things);
        Collections.sort(copy, comparator);
        return copy;
    }

    /**
     * Returns a sorted copy of the provided collection of things. Uses the natural ordering of the things.
     */
    public static <T extends Comparable> List<T> sort(Iterable<T> things) {
        List<T> copy = toMutableList(things);
        Collections.sort(copy);
        return copy;
    }

    public static <T, C extends Collection<T>> C filter(Iterable<? extends T> source, C destination, Spec<? super T> filter) {
        for (T item : source) {
            if (filter.isSatisfiedBy(item)) {
                destination.add(item);
            }
        }
        return destination;
    }

    public static <K, V> Map<K, V> filter(Map<K, V> map, Spec<Map.Entry<K, V>> filter) {
        return filter(map, new HashMap<K, V>(), filter);
    }

    public static <K, V> Map<K, V> filter(Map<K, V> map, Map<K, V> destination, Spec<Map.Entry<K, V>> filter) {
        for (Map.Entry<K, V> entry : map.entrySet()) {
            if (filter.isSatisfiedBy(entry)) {
                destination.put(entry.getKey(), entry.getValue());
            }
        }
        return destination;
    }

    public static <R, I> R[] collectArray(I[] list, Class<R> newType, Transformer<? extends R, ? super I> transformer) {
        @SuppressWarnings("unchecked") R[] destination = (R[]) Array.newInstance(newType, list.length);
        return collectArray(list, destination, transformer);
    }

    public static <R, I> R[] collectArray(I[] list, R[] destination, Transformer<? extends R, ? super I> transformer) {
        assert list.length <= destination.length;
        for (int i = 0; i < list.length; ++i) {
            destination[i] = transformer.transform(list[i]);
        }
        return destination;
    }

    public static <R, I> List<R> collect(List<? extends I> list, Transformer<? extends R, ? super I> transformer) {
        return collect(list, new ArrayList<R>(list.size()), transformer);
    }

    public static <R, I> List<R> collect(I[] list, Transformer<? extends R, ? super I> transformer) {
        return collect(Arrays.asList(list), transformer);
    }

    public static <R, I> Set<R> collect(Set<? extends I> set, Transformer<? extends R, ? super I> transformer) {
        return collect(set, new HashSet<R>(), transformer);
    }

    public static <R, I> List<R> collect(Iterable<? extends I> source, Transformer<? extends R, ? super I> transformer) {
        return collect(source, new LinkedList<R>(), transformer);
    }

    public static <R, I, C extends Collection<R>> C collect(Iterable<? extends I> source, C destination, Transformer<? extends R, ? super I> transformer) {
        for (I item : source) {
            destination.add(transformer.transform(item));
        }
        return destination;
    }

    public static List<String> toStringList(Iterable<?> iterable) {
        return collect(iterable, new LinkedList<String>(), Transformers.asString());
    }

    /**
     * Recursively unpacks all the given things into a flat list.
     *
     * Nulls are not removed, they are left intact.
     *
     * @param things The things to flatten
     * @return A flattened list of the given things
     */
    public static List<?> flattenCollections(Object... things) {
        return flattenCollections(Object.class, things);
    }

    /**
     * Recursively unpacks all the given things into a flat list, ensuring they are of a certain type.
     *
     * Nulls are not removed, they are left intact.
     *
     * If a non null object cannot be cast to the target type, a ClassCastException will be thrown.
     *
     * @param things The things to flatten
     * @param <T> The target type in the flattened list
     * @return A flattened list of the given things
     */
    public static <T> List<T> flattenCollections(Class<T> type, Object... things) {
        if (things == null) {
            return Collections.singletonList(null);
        } else if (things.length == 0) {
            return Collections.emptyList();
        } else if (things.length == 1) {
            Object thing = things[0];
            if (thing == null) {
                return Collections.singletonList(null);
            }
            if (thing.getClass().isArray()) {
                Object[] thingArray = (Object[]) thing;
                List<T> list = new ArrayList<T>(thingArray.length);
                for (Object thingThing : thingArray) {
                    list.addAll(flattenCollections(type, thingThing));
                }
                return list;
            }
            if (thing instanceof Collection) {
                Collection<?> collection = (Collection<?>) thing;
                List<T> list = new ArrayList<T>();
                for (Object element : collection) {
                    list.addAll(flattenCollections(type, element));
                }
                return list;
            }
            return Collections.singletonList(cast(type, thing));
        } else {
            List<T> list = new ArrayList<T>();
            for (Object thing : things) {
                list.addAll(flattenCollections(type, thing));
            }
            return list;
        }
    }

    public static <T> List<T> toList(Iterable<? extends T> things) {
        if (things instanceof List) {
            @SuppressWarnings("unchecked") List<T> castThings = (List<T>) things;
            return castThings;
        }
        return toMutableList(things);
    }

    public static <T> List<T> toList(Enumeration<? extends T> things) {
        AbstractList<T> list = new ArrayList<T>();
        while (things.hasMoreElements()) {
            list.add(things.nextElement());
        }
        return list;
    }

    private static <T> List<T> toMutableList(Iterable<? extends T> things) {
        if (things == null) {
            return new ArrayList<T>(0);
        }
        List<T> list = new ArrayList<T>();
        for (T thing : things) {
            list.add(thing);
        }
        return list;
    }

    public static <T> List<T> intersection(Collection<? extends Collection<T>> availableValuesByDescriptor) {
        List<T> result = new ArrayList<T>();
        Iterator<? extends Collection<T>> iterator = availableValuesByDescriptor.iterator();
        if (iterator.hasNext()) {
            Collection<T> firstSet = iterator.next();
            result.addAll(firstSet);
            while (iterator.hasNext()) {
                Collection<T> next = iterator.next();
                result.retainAll(next);
            }
        }
        return result;
    }

    public static <T> List<T> toList(T[] things) {
        if (things == null || things.length == 0) {
            return new ArrayList<T>(0);
        }
        List<T> list = new ArrayList<T>(things.length);
        Collections.addAll(list, things);
        return list;
    }

    public static <T> Set<T> toSet(Iterable<? extends T> things) {
        if (things == null) {
            return new HashSet<T>(0);
        }
        if (things instanceof Set) {
            @SuppressWarnings("unchecked") Set<T> castThings = (Set<T>) things;
            return castThings;
        }
        Set<T> set = new LinkedHashSet<T>();
        for (T thing : things) {
            set.add(thing);
        }
        return set;
    }

    public static <E> List<E> compact(List<E> list) {
        boolean foundAtLeastOneNull = false;
        List<E> compacted = null;
        int i = 0;
        for (E element : list) {
            if (element == null) {
                if (!foundAtLeastOneNull) {
                    compacted = new ArrayList<E>(list.size());
                    if (i > 0) {
                        compacted.addAll(list.subList(0, i));
                    }
                }
                foundAtLeastOneNull = true;
            } else if (foundAtLeastOneNull) {
                compacted.add(element);
            }
            ++i;
        }
        return foundAtLeastOneNull ? compacted : list;
    }

    public static <C extends Collection<String>> C stringize(Iterable<?> source, C destination) {
        return collect(source, destination, Transformers.asString());
    }

    public static List<String> stringize(Collection<?> source) {
        return stringize(source, new ArrayList<String>(source.size()));
    }

    public static <E> boolean replace(List<E> list, Spec<? super E> filter, Transformer<? extends E, ? super E> transformer) {
        boolean replaced = false;
        int i = 0;
        for (E it : list) {
            if (filter.isSatisfiedBy(it)) {
                list.set(i, transformer.transform(it));
                replaced = true;
            }
            ++i;
        }
        return replaced;
    }

    public static <K, V> void collectMap(Map<K, V> destination, Iterable<? extends V> items, Transformer<? extends K, ? super V> keyGenerator) {
        for (V item : items) {
            destination.put(keyGenerator.transform(item), item);
        }
    }

    /**
     * Given a set of values, derive a set of keys and return a map
     */
    public static <K, V> Map<K, V> collectMap(Iterable<? extends V> items, Transformer<? extends K, ? super V> keyGenerator) {
        Map<K, V> map = new LinkedHashMap<K, V>();
        collectMap(map, items, keyGenerator);
        return map;
    }

    public static <K, V> void collectMapValues(Map<K, V> destination, Iterable<? extends K> keys, Transformer<? extends V, ? super K> keyGenerator) {
        for (K item : keys) {
            destination.put(item, keyGenerator.transform(item));
        }
    }

    /**
     * Given a set of keys, derive a set of values and return a map
     */
    public static <K, V> Map<K, V> collectMapValues(Iterable<? extends K> keys, Transformer<? extends V, ? super K> keyGenerator) {
        Map<K, V> map = new LinkedHashMap<K, V>();
        collectMapValues(map, keys, keyGenerator);
        return map;
    }

    public static <T> boolean every(Iterable<? extends T> things, Spec<? super T> predicate) {
        for (T thing : things) {
            if (!predicate.isSatisfiedBy(thing)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Utility for adding an iterable to a collection.
     *
     * @param t1 The collection to add to
     * @param t2 The iterable to add each item of to the collection
     * @param <T> The element type of t1
     * @return t1
     */
    public static <T> Collection<T> addAll(Collection<T> t1, Iterable<? extends T> t2) {
        for (T t : t2) {
            t1.add(t);
        }
        return t1;
    }

    /**
     * Utility for adding an array to a collection.
     *
     * @param t1 The collection to add to
     * @param t2 The iterable to add each item of to the collection
     * @param <T> The element type of t1
     * @return t1
     */
    public static <T> Collection<T> addAll(Collection<T> t1, T... t2) {
        Collections.addAll(t1, t2);
        return t1;
    }

    /**
     * The result of diffing two sets.
     *
     * @param <T> The type of element the sets contain
     * @see CollectionUtils#diffSetsBy(java.util.Set, java.util.Set, org.gradle.api.Transformer)
     */
    public static class SetDiff<T> {

        public Set<T> leftOnly = new HashSet<T>();

        public Set<Pair<T, T>> common = new HashSet<Pair<T, T>>();

        public Set<T> rightOnly = new HashSet<T>();
    }

    /**
     * Provides a “diff report” of how the two sets are similar and how they are different, comparing the entries by some aspect.
     *
     * The transformer is used to generate the value to use to compare the entries by. That is, the entries are not compared by equals by an attribute or characteristic.
     *
     * The transformer is expected to produce a unique value for each entry in a single set. Behaviour is undefined if this condition is not met.
     *
     * @param left The set on the “left” side of the comparison.
     * @param right The set on the “right” side of the comparison.
     * @param compareBy Provides the value to compare entries from either side by
     * @param <T> The type of the entry objects
     * @return A representation of the difference
     */
    public static <T> SetDiff<T> diffSetsBy(Set<? extends T> left, Set<? extends T> right, Transformer<?, T> compareBy) {
        if (left == null) {
            throw new NullPointerException("'left' set is null");
        }
        if (right == null) {
            throw new NullPointerException("'right' set is null");
        }
        SetDiff<T> setDiff = new SetDiff<T>();
        Map<Object, T> indexedLeft = collectMap(left, compareBy);
        Map<Object, T> indexedRight = collectMap(right, compareBy);
        for (Map.Entry<Object, T> leftEntry : indexedLeft.entrySet()) {
            T rightValue = indexedRight.remove(leftEntry.getKey());
            if (rightValue == null) {
                setDiff.leftOnly.add(leftEntry.getValue());
            } else {
                Pair<T, T> pair = Pair.of(leftEntry.getValue(), rightValue);
                setDiff.common.add(pair);
            }
        }
        for (T rightValue : indexedRight.values()) {
            setDiff.rightOnly.add(rightValue);
        }
        return setDiff;
    }

    /**
     * Creates a string with {@code toString()} of each object with the given separator.
     *
     * <pre>
     * expect:
     * join(",", new Object[]{"a"}) == "a"
     * join(",", new Object[]{"a", "b", "c"}) == "a,b,c"
     * join(",", new Object[]{}) == ""
     * </pre>
     *
     * The {@code separator} must not be null and {@code objects} must not be null.
     *
     * @param separator The string by which to join each string representation
     * @param objects The objects to join the string representations of
     * @return The joined string
     */
    public static String join(String separator, Object[] objects) {
        return join(separator, objects == null ? null : Arrays.asList(objects));
    }

    /**
     * Creates a string with {@code toString()} of each object with the given separator.
     *
     * <pre>
     * expect:
     * join(",", ["a"]) == "a"
     * join(",", ["a", "b", "c"]) == "a,b,c"
     * join(",", []) == ""
     * </pre>
     *
     * The {@code separator} must not be null and {@code objects} must not be null.
     *
     * @param separator The string by which to join each string representation
     * @param objects The objects to join the string representations of
     * @return The joined string
     */
    public static String join(String separator, Iterable<?> objects) {
        if (separator == null) {
            throw new NullPointerException("The 'separator' cannot be null");
        }
        if (objects == null) {
            throw new NullPointerException("The 'objects' cannot be null");
        }
        StringBuilder string = new StringBuilder();
        Iterator<?> iterator = objects.iterator();
        if (iterator.hasNext()) {
            string.append(iterator.next().toString());
            while (iterator.hasNext()) {
                string.append(separator);
                string.append(iterator.next().toString());
            }
        }
        return string.toString();
    }

    /**
     * Partition given Collection into a Pair of Collections.
     *
     * <pre>Left</pre> Collection containing entries that satisfy the given predicate
     * <pre>Right</pre> Collection containing entries that do NOT satisfy the given predicate
     */
    public static <T> Pair<Collection<T>, Collection<T>> partition(Iterable<T> items, Spec<? super T> predicate) {
        Preconditions.checkNotNull(items, "Cannot partition null Collection");
        Preconditions.checkNotNull(predicate, "Cannot apply null Spec when partitioning");
        Collection<T> left = new LinkedList<T>();
        Collection<T> right = new LinkedList<T>();
        for (T item : items) {
            if (predicate.isSatisfiedBy(item)) {
                left.add(item);
            } else {
                right.add(item);
            }
        }
        return Pair.of(left, right);
    }

    public static class InjectionStep<T, I> {

        private final T target;

        private final I item;

        public InjectionStep(T target, I item) {
            this.target = target;
            this.item = item;
        }

        public T getTarget() {
            return target;
        }

        public I getItem() {
            return item;
        }
    }

    public static <T, I> T inject(T target, Iterable<? extends I> items, Action<InjectionStep<T, I>> action) {
        if (target == null) {
            throw new NullPointerException("The 'target' cannot be null");
        }
        if (items == null) {
            throw new NullPointerException("The 'items' cannot be null");
        }
        if (action == null) {
            throw new NullPointerException("The 'action' cannot be null");
        }
        for (I item : items) {
            action.execute(new InjectionStep<T, I>(target, item));
        }
        return target;
    }

    public static <K, V> ImmutableListMultimap<K, V> groupBy(Iterable<? extends V> iterable, Transformer<? extends K, V> grouper) {
        ImmutableListMultimap.Builder<K, V> builder = ImmutableListMultimap.builder();
        for (V element : iterable) {
            K key = grouper.transform(element);
            builder.put(key, element);
        }
        return builder.build();
    }

    public static <T> Iterable<? extends T> unpack(final Iterable<? extends Factory<? extends T>> factories) {
        return new Iterable<T>() {

            private final Iterator<? extends Factory<? extends T>> delegate = factories.iterator();

            public Iterator<T> iterator() {
                return new Iterator<T>() {

                    public boolean hasNext() {
                        return delegate.hasNext();
                    }

                    public T next() {
                        return delegate.next().create();
                    }

                    public void remove() {
                        throw new UnsupportedOperationException();
                    }
                };
            }
        };
    }

    @Nullable
    public static <T> List<T> nonEmptyOrNull(Iterable<T> iterable) {
        ImmutableList<T> list = ImmutableList.copyOf(iterable);
        return list.isEmpty() ? null : list;
    }

    public static <T> List<T> dedup(Iterable<T> source, final Equivalence<? super T> equivalence) {
        Iterable<Equivalence.Wrapper<T>> wrappers = Iterables.transform(source, new Function<T, Equivalence.Wrapper<T>>() {

            public Equivalence.Wrapper<T> apply(@Nullable T input) {
                return equivalence.wrap(input);
            }
        });
        Set<Equivalence.Wrapper<T>> deduped = ImmutableSet.copyOf(wrappers);
        return ImmutableList.copyOf(Iterables.transform(deduped, new Function<Equivalence.Wrapper<T>, T>() {

            public T apply(Equivalence.Wrapper<T> input) {
                return input.get();
            }
        }));
    }

    public static String asCommandLine(Iterable<String> arguments) {
        return Joiner.on(" ").join(collect(arguments, Transformers.asSafeCommandLineArgument()));
    }
}}'} /repo/subprojects/ivy/src/main/java/org/gradle/api/publish/ivy/internal/publisher/IvyDescriptorFileGenerator.java
Method 'startElement' cannot be resolved in context xmlWriter.startElement("artifact") (line: 175) MethodCallExprContext{wrapped=xmlWriter.startElement("artifact")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context xmlWriter.startElement("artifact") (line: 175) MethodCallExprContext{wrapped=xmlWriter.startElement("artifact")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context xmlWriter.startElement("artifact") (line: 175) MethodCallExprContext{wrapped=xmlWriter.startElement("artifact")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context xmlWriter.startElement("artifact") (line: 175) MethodCallExprContext{wrapped=xmlWriter.startElement("artifact")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context xmlWriter.startElement("artifact") (line: 175) MethodCallExprContext{wrapped=xmlWriter.startElement("artifact")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context xmlWriter.startElement("artifact") (line: 175) MethodCallExprContext{wrapped=xmlWriter.startElement("artifact")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context xmlWriter.startElement("dependency") (line: 189) MethodCallExprContext{wrapped=xmlWriter.startElement("dependency")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context xmlWriter.startElement("dependency") (line: 189) MethodCallExprContext{wrapped=xmlWriter.startElement("dependency")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context xmlWriter.startElement("dependency") (line: 189) MethodCallExprContext{wrapped=xmlWriter.startElement("dependency")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context xmlWriter.startElement("dependency") (line: 189) MethodCallExprContext{wrapped=xmlWriter.startElement("dependency")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context xmlWriter.startElement("exclude") (line: 211) MethodCallExprContext{wrapped=xmlWriter.startElement("exclude")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context xmlWriter.startElement("exclude") (line: 211) MethodCallExprContext{wrapped=xmlWriter.startElement("exclude")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context xmlWriter.startElement("exclude") (line: 211) MethodCallExprContext{wrapped=xmlWriter.startElement("exclude")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context xmlWriter.startElement("artifact") (line: 219) MethodCallExprContext{wrapped=xmlWriter.startElement("artifact")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context xmlWriter.startElement("artifact") (line: 219) MethodCallExprContext{wrapped=xmlWriter.startElement("artifact")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context xmlWriter.startElement("artifact") (line: 219) MethodCallExprContext{wrapped=xmlWriter.startElement("artifact")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context xmlWriter.startElement("artifact") (line: 219) MethodCallExprContext{wrapped=xmlWriter.startElement("artifact")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'startElement' cannot be resolved in context xmlWriter.startElement("artifact") (line: 219) MethodCallExprContext{wrapped=xmlWriter.startElement("artifact")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'field' cannot be resolved in context field(publication, "organisation", identity.getOrganisation()) (line: 55) MethodCallExprContext{wrapped=field(publication, "organisation", identity.getOrganisation())}. Parameter types: [ReferenceType{org.gradle.api.publish.ivy.internal.publisher.IvyNormalizedPublication, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'field' cannot be resolved in context field(publication, "organisation", identity.getOrganisation()) (line: 55) MethodCallExprContext{wrapped=field(publication, "organisation", identity.getOrganisation())}. Parameter types: [ReferenceType{org.gradle.api.publish.ivy.internal.publisher.IvyNormalizedPublication, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'field' cannot be resolved in context field(publication, "module name", identity.getModule()) (line: 58) MethodCallExprContext{wrapped=field(publication, "module name", identity.getModule())}. Parameter types: [ReferenceType{org.gradle.api.publish.ivy.internal.publisher.IvyNormalizedPublication, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'field' cannot be resolved in context field(publication, "module name", identity.getModule()) (line: 58) MethodCallExprContext{wrapped=field(publication, "module name", identity.getModule())}. Parameter types: [ReferenceType{org.gradle.api.publish.ivy.internal.publisher.IvyNormalizedPublication, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'field' cannot be resolved in context field(publication, "revision", identity.getRevision()) (line: 61) MethodCallExprContext{wrapped=field(publication, "revision", identity.getRevision())}. Parameter types: [ReferenceType{org.gradle.api.publish.ivy.internal.publisher.IvyNormalizedPublication, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'field' cannot be resolved in context field(publication, "revision", identity.getRevision()) (line: 61) MethodCallExprContext{wrapped=field(publication, "revision", identity.getRevision())}. Parameter types: [ReferenceType{org.gradle.api.publish.ivy.internal.publisher.IvyNormalizedPublication, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'field' cannot be resolved in context field(publication, "branch", metadata.getDescriptor().getBranch()) (line: 71) MethodCallExprContext{wrapped=field(publication, "branch", metadata.getDescriptor().getBranch())}. Parameter types: [ReferenceType{org.gradle.api.publish.ivy.internal.publisher.IvyNormalizedPublication, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'field' cannot be resolved in context field(publication, "branch", metadata.getDescriptor().getBranch()) (line: 71) MethodCallExprContext{wrapped=field(publication, "branch", metadata.getDescriptor().getBranch())}. Parameter types: [ReferenceType{org.gradle.api.publish.ivy.internal.publisher.IvyNormalizedPublication, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'field' cannot be resolved in context field(publication, "status", metadata.getStatus()) (line: 75) MethodCallExprContext{wrapped=field(publication, "status", metadata.getStatus())}. Parameter types: [ReferenceType{org.gradle.api.publish.ivy.internal.publisher.IvyNormalizedPublication, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'field' cannot be resolved in context field(publication, "status", metadata.getStatus()) (line: 75) MethodCallExprContext{wrapped=field(publication, "status", metadata.getStatus())}. Parameter types: [ReferenceType{org.gradle.api.publish.ivy.internal.publisher.IvyNormalizedPublication, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'field' cannot be resolved in context field(publication, "artifact name", artifact.getName()) (line: 90) MethodCallExprContext{wrapped=field(publication, "artifact name", artifact.getName())}. Parameter types: [ReferenceType{org.gradle.api.publish.ivy.internal.publisher.IvyNormalizedPublication, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'field' cannot be resolved in context field(publication, "artifact name", artifact.getName()) (line: 90) MethodCallExprContext{wrapped=field(publication, "artifact name", artifact.getName())}. Parameter types: [ReferenceType{org.gradle.api.publish.ivy.internal.publisher.IvyNormalizedPublication, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'field' cannot be resolved in context field(publication, "artifact type", artifact.getType()) (line: 92) MethodCallExprContext{wrapped=field(publication, "artifact type", artifact.getType())}. Parameter types: [ReferenceType{org.gradle.api.publish.ivy.internal.publisher.IvyNormalizedPublication, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'field' cannot be resolved in context field(publication, "artifact type", artifact.getType()) (line: 92) MethodCallExprContext{wrapped=field(publication, "artifact type", artifact.getType())}. Parameter types: [ReferenceType{org.gradle.api.publish.ivy.internal.publisher.IvyNormalizedPublication, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'field' cannot be resolved in context field(publication, "artifact extension", artifact.getExtension()) (line: 94) MethodCallExprContext{wrapped=field(publication, "artifact extension", artifact.getExtension())}. Parameter types: [ReferenceType{org.gradle.api.publish.ivy.internal.publisher.IvyNormalizedPublication, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'field' cannot be resolved in context field(publication, "artifact extension", artifact.getExtension()) (line: 94) MethodCallExprContext{wrapped=field(publication, "artifact extension", artifact.getExtension())}. Parameter types: [ReferenceType{org.gradle.api.publish.ivy.internal.publisher.IvyNormalizedPublication, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'field' cannot be resolved in context field(publication, "artifact classifier", artifact.getClassifier()) (line: 96) MethodCallExprContext{wrapped=field(publication, "artifact classifier", artifact.getClassifier())}. Parameter types: [ReferenceType{org.gradle.api.publish.ivy.internal.publisher.IvyNormalizedPublication, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'field' cannot be resolved in context field(publication, "artifact classifier", artifact.getClassifier()) (line: 96) MethodCallExprContext{wrapped=field(publication, "artifact classifier", artifact.getClassifier())}. Parameter types: [ReferenceType{org.gradle.api.publish.ivy.internal.publisher.IvyNormalizedPublication, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getByName' cannot be resolved in context configurations.getByName("default") (line: 103) MethodCallExprContext{wrapped=configurations.getByName("default")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'artifact' cannot be resolved in context artifact(publishArtifact) (line: 106) MethodCallExprContext{wrapped=artifact(publishArtifact)}. Parameter types: [ReferenceType{org.gradle.api.artifacts.PublishArtifact, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'file' cannot be resolved in context getInputs().file(new Callable<FileCollection>() {

    public FileCollection call() throws Exception {
        IvyPublicationInternal publicationInternal = getPublicationInternal();
        return publicationInternal == null ? null : publicationInternal.getPublishableFiles();
    }
}) (line: 51) MethodCallExprContext{wrapped=getInputs().file(new Callable<FileCollection>() {

    public FileCollection call() throws Exception {
        IvyPublicationInternal publicationInternal = getPublicationInternal();
        return publicationInternal == null ? null : publicationInternal.getPublishableFiles();
    }
})}. Parameter types: [ReferenceType{java.util.concurrent.Callable, typeParametersMap=TypeParametersMap{nameToValue={java.util.concurrent.Callable.V=ReferenceType{org.gradle.api.file.FileCollection, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call publisher.publish(normalizedPublication, Cast.cast(PublicationAwareRepository.class, repository)) UnsolvedSymbolException{context='Method 'cast' with parameterTypes [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.internal.artifacts.repositories.PublicationAwareRepository, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{org.gradle.api.artifacts.repositories.IvyArtifactRepository, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class Cast {

    /**
     * Casts the given object to the given type, providing a better error message than the default.
     *
     * The standard {@link Class#cast(Object)} method produces unsatisfactory error messages on some platforms
     * when it fails. All this method does is provide a better, consistent, error message.
     *
     * This should be used whenever there is a chance the cast could fail. If in doubt, use this.
     *
     * @param outputType The type to cast the input to
     * @param object The object to be cast
     * @param <O> The type to be cast to
     * @param <I> The type of the object to be vast
     * @return The input object, cast to the output type
     */
    public static <O, I> O cast(Class<O> outputType, I object) {
        try {
            return outputType.cast(object);
        } catch (ClassCastException e) {
            throw new ClassCastException(String.format("Failed to cast object %s of type %s to target type %s", object, object.getClass().getName(), outputType.getName()));
        }
    }

    @SuppressWarnings("unchecked")
    public static <T> T uncheckedCast(Object object) {
        return (T) object;
    }
}}'} /repo/subprojects/ivy/src/main/java/org/gradle/api/publish/ivy/tasks/PublishToIvyRepository.java
Cannot solve method call extension.getPublications().registerFactory(IvyPublication.class, new IvyPublicationFactory(dependencyMetaDataProvider, instantiator, fileResolver)) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ivy/src/main/java/org/gradle/api/publish/ivy/plugins/IvyPublishPlugin.java
No matching between ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual)
No matching between ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual)
No matching between ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual)
Cannot solve field access PathSensitivity.RELATIVE
Cannot solve field access PathSensitivity.RELATIVE
Cannot solve field access PathSensitivity.RELATIVE
Cannot solve field access PathSensitivity.RELATIVE
Cannot solve field access PathSensitivity.RELATIVE
Cannot solve method call executionData.plus(getProject().files(files)) java.lang.RuntimeException: Object[] Object /repo/subprojects/jacoco/src/main/java/org/gradle/testing/jacoco/tasks/JacocoReport.java
Cannot solve method call getSourceDirectories().plus(getProject().files(sourceSet.getAllJava().getSrcDirs())) java.lang.RuntimeException: Method 'files' cannot be resolved in context getProject().files(sourceSet.getAllJava().getSrcDirs()) (line: 291) MethodCallExprContext{wrapped=getProject().files(sourceSet.getAllJava().getSrcDirs())}. Parameter types: [ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/jacoco/src/main/java/org/gradle/testing/jacoco/tasks/JacocoReport.java
Cannot solve method call setSourceDirectories(getSourceDirectories().plus(getProject().files(sourceSet.getAllJava().getSrcDirs()))) java.lang.RuntimeException: Error calculating the type of parameter getProject().files(sourceSet.getAllJava().getSrcDirs()) of method call getSourceDirectories().plus(getProject().files(sourceSet.getAllJava().getSrcDirs())) /repo/subprojects/jacoco/src/main/java/org/gradle/testing/jacoco/tasks/JacocoReport.java
Cannot solve method call setSourceDirectories(getProject().files(sourceSet.getAllJava().getSrcDirs())) java.lang.RuntimeException: Method 'files' cannot be resolved in context getProject().files(sourceSet.getAllJava().getSrcDirs()) (line: 289) MethodCallExprContext{wrapped=getProject().files(sourceSet.getAllJava().getSrcDirs())}. Parameter types: [ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/jacoco/src/main/java/org/gradle/testing/jacoco/tasks/JacocoReport.java
Cannot solve method call additionalClassDirs(getProject().files(Arrays.asList(dirs))) java.lang.RuntimeException: Method 'files' cannot be resolved in context getProject().files(Arrays.asList(dirs)) (line: 309) MethodCallExprContext{wrapped=getProject().files(Arrays.asList(dirs))}. Parameter types: [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/jacoco/src/main/java/org/gradle/testing/jacoco/tasks/JacocoReport.java
Cannot solve method call additionalSourceDirs(getProject().files(Arrays.asList(dirs))) java.lang.RuntimeException: Method 'files' cannot be resolved in context getProject().files(Arrays.asList(dirs)) (line: 331) MethodCallExprContext{wrapped=getProject().files(Arrays.asList(dirs))}. Parameter types: [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/jacoco/src/main/java/org/gradle/testing/jacoco/tasks/JacocoReport.java
Cannot solve method call executionData.plus(getProject().files(files)) java.lang.RuntimeException: Object[] Object /repo/subprojects/jacoco/src/main/java/org/gradle/testing/jacoco/tasks/JacocoMerge.java
Cannot solve method call ((IConventionAware) extension).getConventionMapping().map("reportsDir", new Callable<File>() {

    @Override
    public File call() {
        return reportingExtension.file("jacoco");
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/jacoco/src/main/java/org/gradle/testing/jacoco/plugins/JacocoPlugin.java
Cannot solve method call ((IConventionAware) jacocoAgentJar).getConventionMapping().map("agentConf", Callables.returning(config)) UnsolvedSymbolException{context='Method 'returning' with parameterTypes [ReferenceType{org.gradle.api.artifacts.Configuration, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.util.concurrent.Callables}'} /repo/subprojects/jacoco/src/main/java/org/gradle/testing/jacoco/plugins/JacocoPlugin.java
Cannot solve method call dependencies.add(project.getDependencies().create("org.jacoco:org.jacoco.agent:" + extension.getToolVersion())) java.lang.RuntimeException: Method 'create' cannot be resolved in context project.getDependencies().create("org.jacoco:org.jacoco.agent:" + extension.getToolVersion()) (line: 110) MethodCallExprContext{wrapped=project.getDependencies().create("org.jacoco:org.jacoco.agent:" + extension.getToolVersion())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/jacoco/src/main/java/org/gradle/testing/jacoco/plugins/JacocoPlugin.java
Cannot solve method call ((IConventionAware) task).getConventionMapping().map("jacocoClasspath", Callables.returning(config)) UnsolvedSymbolException{context='Method 'returning' with parameterTypes [ReferenceType{org.gradle.api.artifacts.Configuration, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.util.concurrent.Callables}'} /repo/subprojects/jacoco/src/main/java/org/gradle/testing/jacoco/plugins/JacocoPlugin.java
Cannot solve method call dependencies.add(project.getDependencies().create("org.jacoco:org.jacoco.ant:" + extension.getToolVersion())) java.lang.RuntimeException: Method 'create' cannot be resolved in context project.getDependencies().create("org.jacoco:org.jacoco.ant:" + extension.getToolVersion()) (line: 132) MethodCallExprContext{wrapped=project.getDependencies().create("org.jacoco:org.jacoco.ant:" + extension.getToolVersion())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/jacoco/src/main/java/org/gradle/testing/jacoco/plugins/JacocoPlugin.java
Cannot solve method call mapping.map("destinationFile", new Callable<File>() {

    @Override
    public File call() {
        return new File(project.getBuildDir(), "/jacoco/" + task.getName() + ".exec");
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/jacoco/src/main/java/org/gradle/testing/jacoco/plugins/JacocoPlugin.java
Cannot solve method call mapping.map("enabled", Callables.returning(report.getName().equals("html"))) UnsolvedSymbolException{context='Method 'returning' with parameterTypes [PrimitiveTypeUsage{name='boolean'}]', name='ReflectionClassDeclaration{clazz=com.google.common.util.concurrent.Callables}'} /repo/subprojects/jacoco/src/main/java/org/gradle/testing/jacoco/plugins/JacocoPlugin.java
Cannot resolve field access null
Cannot solve field access Report.OutputType.DIRECTORY
Cannot solve method call mapping.map("destination", new Callable<File>() {

    @Override
    public File call() {
        return new File(extension.getReportsDir(), reportTask.getName() + "/" + reportTask.getName() + "." + report.getName());
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/jacoco/src/main/java/org/gradle/testing/jacoco/plugins/JacocoPlugin.java
Cannot solve method call mapping.map("destination", new Callable<File>() {

    @Override
    public File call() {
        return new File(extension.getReportsDir(), reportTask.getName() + "/" + report.getName());
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/jacoco/src/main/java/org/gradle/testing/jacoco/plugins/JacocoPlugin.java
Method 'getName' cannot be resolved in context task.getName() (line: 213) MethodCallExprContext{wrapped=task.getName()}. Parameter types: []
Cannot solve method call project.getTasks().create("jacoco" + StringUtils.capitalise(task.getName()) + "Report", JacocoReport.class) java.lang.RuntimeException: Error calculating the type of parameter task.getName() of method call StringUtils.capitalise(task.getName()) /repo/subprojects/jacoco/src/main/java/org/gradle/testing/jacoco/plugins/JacocoPlugin.java
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 225) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 225) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call reportTask.sourceSets(project.getConvention().getPlugin(JavaPluginConvention.class).getSourceSets().getByName("main")) java.lang.RuntimeException: Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 225) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/jacoco/src/main/java/org/gradle/testing/jacoco/plugins/JacocoPlugin.java
Cannot resolve field access null
Cannot solve field access Report.OutputType.DIRECTORY
Cannot solve method call reportMapping.map("destination", new Callable<File>() {

    @Override
    public File call() {
        return new File(extension.getReportsDir(), task.getName() + "/" + reportTask.getName() + "." + report.getName());
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/jacoco/src/main/java/org/gradle/testing/jacoco/plugins/JacocoPlugin.java
Cannot solve method call reportMapping.map("destination", new Callable<File>() {

    @Override
    public File call() {
        return new File(extension.getReportsDir(), task.getName() + "/" + report.getName());
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/jacoco/src/main/java/org/gradle/testing/jacoco/plugins/JacocoPlugin.java
Method 'getConventionValue' cannot be resolved in context taskMapping.getConventionValue(reportTask.getReports(), "reports", false) (line: 227) MethodCallExprContext{wrapped=taskMapping.getConventionValue(reportTask.getReports(), "reports", false)}. Parameter types: [ReferenceType{org.gradle.testing.jacoco.tasks.JacocoReportsContainer, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, PrimitiveTypeUsage{name='boolean'}]
Cannot solve method call project.file(String.valueOf(project.getBuildDir()) + "/jacoco/" + taskName + ".exec") UnsolvedSymbolException{context='Method 'valueOf' with parameterTypes [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/jacoco/src/main/java/org/gradle/testing/jacoco/plugins/JacocoPluginExtension.java
Cannot solve method call ((IConventionAware) extension).getConventionMapping().map("destinationFile", new Callable<File>() {

    @Override
    public File call() {
        return project.file(String.valueOf(project.getBuildDir()) + "/jacoco/" + taskName + ".exec");
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/jacoco/src/main/java/org/gradle/testing/jacoco/plugins/JacocoPluginExtension.java
Cannot solve method call applyTo(Cast.<T>uncheckedCast(task)) UnsolvedSymbolException{context='Method 'uncheckedCast' with parameterTypes [ReferenceType{org.gradle.process.JavaForkOptions, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class Cast {

    /**
     * Casts the given object to the given type, providing a better error message than the default.
     *
     * The standard {@link Class#cast(Object)} method produces unsatisfactory error messages on some platforms
     * when it fails. All this method does is provide a better, consistent, error message.
     *
     * This should be used whenever there is a chance the cast could fail. If in doubt, use this.
     *
     * @param outputType The type to cast the input to
     * @param object The object to be cast
     * @param <O> The type to be cast to
     * @param <I> The type of the object to be vast
     * @return The input object, cast to the output type
     */
    public static <O, I> O cast(Class<O> outputType, I object) {
        try {
            return outputType.cast(object);
        } catch (ClassCastException e) {
            throw new ClassCastException(String.format("Failed to cast object %s of type %s to target type %s", object, object.getClass().getName(), outputType.getName()));
        }
    }

    @SuppressWarnings("unchecked")
    public static <T> T uncheckedCast(Object object) {
        return (T) object;
    }
}}'} /repo/subprojects/jacoco/src/main/java/org/gradle/testing/jacoco/plugins/JacocoPluginExtension.java
Cannot solve field access Output.FILE
Method 'append' cannot be resolved in context builder.append(name) (line: 311) MethodCallExprContext{wrapped=builder.append(name)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call builder.append(Joiner.on(':').join((Collection) value)) UnsolvedSymbolException{context='Method 'on' with parameterTypes [PrimitiveTypeUsage{name='char'}]', name='ReflectionClassDeclaration{clazz=Joiner}'} /repo/subprojects/jacoco/src/main/java/org/gradle/testing/jacoco/plugins/JacocoTaskExtension.java
Cannot solve method call antBuilder.invokeMethod("taskdef", ImmutableMap.of("name", "jacocoMerge", "classname", "org.jacoco.ant.MergeTask")) UnsolvedSymbolException{context='Method 'of' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=ImmutableMap}'} /repo/subprojects/jacoco/src/main/java/org/gradle/internal/jacoco/AntJacocoMerge.java
Cannot solve method call ant.withClasspath(classpath).execute(new Closure<Object>(this, this) {

    @SuppressWarnings("UnusedDeclaration")
    public Object doCall(Object it) {
        final GroovyObjectSupport antBuilder = (GroovyObjectSupport) it;
        antBuilder.invokeMethod("taskdef", ImmutableMap.of("name", "jacocoMerge", "classname", "org.jacoco.ant.MergeTask"));
        Map<String, File> arguments = ImmutableMap.of("destfile", destinationFile);
        antBuilder.invokeMethod("jacocoMerge", new Object[] { arguments, new Closure<Object>(this, this) {

            public Object doCall(Object ignore) {
                executionData.addToAntBuilder(antBuilder, "resources");
                return null;
            }
        } });
        return null;
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/jacoco/src/main/java/org/gradle/internal/jacoco/AntJacocoMerge.java
Cannot solve method call antBuilder.invokeMethod("taskdef", ImmutableMap.of("name", "jacocoReport", "classname", "org.jacoco.ant.ReportTask")) UnsolvedSymbolException{context='Method 'of' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=ImmutableMap}'} /repo/subprojects/jacoco/src/main/java/org/gradle/internal/jacoco/AntJacocoReport.java
Cannot solve method call ant.withClasspath(classpath).execute(new Closure<Object>(this, this) {

    @SuppressWarnings("UnusedDeclaration")
    public Object doCall(Object it) {
        final GroovyObjectSupport antBuilder = (GroovyObjectSupport) it;
        antBuilder.invokeMethod("taskdef", ImmutableMap.of("name", "jacocoReport", "classname", "org.jacoco.ant.ReportTask"));
        final Map<String, Object> emptyArgs = Collections.<String, Object>emptyMap();
        antBuilder.invokeMethod("jacocoReport", new Object[] { emptyArgs, new Closure<Object>(this, this) {

            public Object doCall(Object ignore) {
                antBuilder.invokeMethod("executiondata", new Object[] { emptyArgs, new Closure<Object>(this, this) {

                    public Object doCall(Object ignore) {
                        executionData.addToAntBuilder(antBuilder, "resources");
                        return null;
                    }
                } });
                Map<String, Object> structureArgs = ImmutableMap.<String, Object>of("name", projectName);
                antBuilder.invokeMethod("structure", new Object[] { structureArgs, new Closure<Object>(this, this) {

                    public Object doCall(Object ignore) {
                        antBuilder.invokeMethod("classfiles", new Object[] { emptyArgs, new Closure<Object>(this, this) {

                            public Object doCall(Object ignore) {
                                allClassesDirs.addToAntBuilder(antBuilder, "resources");
                                return null;
                            }
                        } });
                        antBuilder.invokeMethod("sourcefiles", new Object[] { emptyArgs, new Closure<Object>(this, this) {

                            public Object doCall(Object ignore) {
                                allSourcesDirs.addToAntBuilder(antBuilder, "resources");
                                return null;
                            }
                        } });
                        return null;
                    }
                } });
                if (reports.getHtml().isEnabled()) {
                    antBuilder.invokeMethod("html", new Object[] { ImmutableMap.<String, Object>of("destdir", reports.getHtml().getDestination()) });
                }
                if (reports.getXml().isEnabled()) {
                    antBuilder.invokeMethod("xml", new Object[] { ImmutableMap.<String, Object>of("destfile", reports.getXml().getDestination()) });
                }
                if (reports.getCsv().isEnabled()) {
                    antBuilder.invokeMethod("csv", new Object[] { ImmutableMap.<String, Object>of("destfile", reports.getCsv().getDestination()) });
                }
                return null;
            }
        } });
        return null;
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/jacoco/src/main/java/org/gradle/internal/jacoco/AntJacocoReport.java
Method 'zipTree' cannot be resolved in context project.zipTree(getAgentConfConventionValue().getSingleFile()) (line: 67) MethodCallExprContext{wrapped=project.zipTree(getAgentConfConventionValue().getSingleFile())}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'zipTree' cannot be resolved in context project.zipTree(getAgentConfConventionValue().getSingleFile()) (line: 67) MethodCallExprContext{wrapped=project.zipTree(getAgentConfConventionValue().getSingleFile())}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call V_0_6_2_0.compareTo(extractVersion(file.getName())) java.lang.RuntimeException: Method 'extractVersion' cannot be resolved in context extractVersion(file.getName()) (line: 81) MethodCallExprContext{wrapped=extractVersion(file.getName())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/jacoco/src/main/java/org/gradle/internal/jacoco/JacocoAgentJar.java
Cannot solve method call V_0_7_6_0.compareTo(extractVersion(file.getName())) java.lang.RuntimeException: Method 'extractVersion' cannot be resolved in context extractVersion(file.getName()) (line: 91) MethodCallExprContext{wrapped=extractVersion(file.getName())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/jacoco/src/main/java/org/gradle/internal/jacoco/JacocoAgentJar.java
Cannot solve method call VersionNumber.parse(jarName.substring(versionStart, versionEnd)) java.lang.RuntimeException: Method 'substring' cannot be resolved in context jarName.substring(versionStart, versionEnd) (line: 109) MethodCallExprContext{wrapped=jarName.substring(versionStart, versionEnd)}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}] /repo/subprojects/jacoco/src/main/java/org/gradle/internal/jacoco/JacocoAgentJar.java
Cannot resolve field access null
Cannot solve method call getProject().files(BrowserEvaluate.this.content) UnsolvedSymbolException{context='unknown', name='content', typeSolver=null} /repo/subprojects/javascript/src/main/java/org/gradle/plugins/javascript/envjs/browser/BrowserEvaluate.java
Error calculating the type of parameter BrowserEvaluate.this.content of method call getProject().files(BrowserEvaluate.this.content)
Cannot solve method call conventionMapping.map("js", new Callable<Configuration>() {

    public Configuration call() {
        return configuration;
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/javascript/src/main/java/org/gradle/plugins/javascript/envjs/EnvJsPlugin.java
Cannot solve method call conventionMapping.map("version", new Callable<String>() {

    public String call() {
        return EnvJsExtension.DEFAULT_DEPENDENCY_VERSION;
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/javascript/src/main/java/org/gradle/plugins/javascript/envjs/EnvJsPlugin.java
Cannot solve method call ((IConventionAware) task).getConventionMapping().map("evaluator", new Callable<EnvJsBrowserEvaluator>() {

    public EnvJsBrowserEvaluator call() {
        RhinoWorkerHandleFactory handleFactory = new DefaultRhinoWorkerHandleFactory(workerProcessBuilderFactory);
        File workDir = project.getProjectDir();
        Factory<File> envJsFactory = new Factory<File>() {

            public File create() {
                return envJsExtension.getJs().getSingleFile();
            }
        };
        return new EnvJsBrowserEvaluator(handleFactory, rhinoExtension.getClasspath(), envJsFactory, project.getGradle().getStartParameter().getLogLevel(), workDir);
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/javascript/src/main/java/org/gradle/plugins/javascript/envjs/EnvJsPlugin.java
Cannot solve method call context.getIndex(req.getTarget()) java.lang.RuntimeException: Method 'getTarget' cannot be resolved in context req.getTarget() (line: 45) MethodCallExprContext{wrapped=req.getTarget()}. Parameter types: [] /repo/subprojects/javascript/src/main/java/org/gradle/plugins/javascript/envjs/http/simple/internal/SimpleFileServerContainer.java
Method 'getPrintStream' cannot be resolved in context resp.getPrintStream() (line: 52) MethodCallExprContext{wrapped=resp.getPrintStream()}. Parameter types: []
Cannot solve method call RhinoWorkerUtils.parse(spec.getJsHint(), "UTF-8") java.lang.RuntimeException: Method 'getJsHint' cannot be resolved in context spec.getJsHint() (line: 37) MethodCallExprContext{wrapped=spec.getJsHint()}. Parameter types: [] /repo/subprojects/javascript/src/main/java/org/gradle/plugins/javascript/jshint/internal/JsHintWorker.java
Cannot solve method call conventionMapping.map("js", new Callable<Configuration>() {

    public Configuration call() {
        return configuration;
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/javascript/src/main/java/org/gradle/plugins/javascript/jshint/JsHintPlugin.java
Cannot solve method call conventionMapping.map("version", new Callable<String>() {

    public String call() {
        return JsHintExtension.DEFAULT_DEPENDENCY_VERSION;
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/javascript/src/main/java/org/gradle/plugins/javascript/jshint/JsHintPlugin.java
Cannot solve method call task.getConventionMapping().map("rhinoClasspath", new Callable<FileCollection>() {

    public FileCollection call() {
        return rhinoExtension.getClasspath();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/javascript/src/main/java/org/gradle/plugins/javascript/jshint/JsHintPlugin.java
Cannot solve method call task.getConventionMapping().map("jsHint", new Callable<FileCollection>() {

    public FileCollection call() {
        return jsHintExtension.getJs();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/javascript/src/main/java/org/gradle/plugins/javascript/jshint/JsHintPlugin.java
Cannot solve method call task.getConventionMapping().map("jsonReport", new Callable<File>() {

    public File call() {
        return reportingExtension.file(task.getName() + "/report.json");
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/javascript/src/main/java/org/gradle/plugins/javascript/jshint/JsHintPlugin.java
Method 'setPrettyPrinting' cannot be resolved in context new GsonBuilder().setPrettyPrinting() (line: 147) MethodCallExprContext{wrapped=new GsonBuilder().setPrettyPrinting()}. Parameter types: []
Method 'setPrettyPrinting' cannot be resolved in context new GsonBuilder().setPrettyPrinting() (line: 147) MethodCallExprContext{wrapped=new GsonBuilder().setPrettyPrinting()}. Parameter types: []
Cannot solve method call conventionMapping.map("classpath", new Callable<Configuration>() {

    public Configuration call() {
        return configuration;
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/javascript/src/main/java/org/gradle/plugins/javascript/rhino/RhinoPlugin.java
Cannot solve method call conventionMapping.map("version", new Callable<String>() {

    public String call() {
        return RhinoExtension.DEFAULT_RHINO_DEPENDENCY_VERSION;
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/javascript/src/main/java/org/gradle/plugins/javascript/rhino/RhinoPlugin.java
Cannot solve method call task.getConventionMapping().map("classpath", new Callable<FileCollection>() {

    public FileCollection call() {
        return rhinoExtension.getClasspath();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/javascript/src/main/java/org/gradle/plugins/javascript/rhino/RhinoPlugin.java
Cannot solve method call task.getConventionMapping().map("main", new Callable<String>() {

    public String call() {
        return RhinoExtension.RHINO_SHELL_MAIN;
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/javascript/src/main/java/org/gradle/plugins/javascript/rhino/RhinoPlugin.java
Cannot solve method call context.evaluateString(scope, readFile(rhinoScript, "UTF-8"), rhinoScript.getName(), 1, null) java.lang.RuntimeException: Method 'readFile' cannot be resolved in context readFile(rhinoScript, "UTF-8") (line: 67) MethodCallExprContext{wrapped=readFile(rhinoScript, "UTF-8")}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/javascript/src/main/java/org/gradle/plugins/javascript/rhino/worker/RhinoWorkerUtils.java
Cannot solve method call object.equals(Context.getUndefinedValue()) UnsolvedSymbolException{context='Method 'getUndefinedValue' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Context}'} /repo/subprojects/javascript/src/main/java/org/gradle/plugins/javascript/rhino/worker/RhinoWorkerUtils.java
Cannot solve method call conventionMapping.map("js", new Callable<Configuration>() {

    @Override
    public Configuration call() {
        return jsConfiguration;
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/javascript/src/main/java/org/gradle/plugins/javascript/coffeescript/CoffeeScriptBasePlugin.java
Cannot solve method call conventionMapping.map("version", new Callable<String>() {

    @Override
    public String call() {
        return CoffeeScriptExtension.DEFAULT_JS_DEPENDENCY_VERSION;
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/javascript/src/main/java/org/gradle/plugins/javascript/coffeescript/CoffeeScriptBasePlugin.java
Cannot solve method call task.getConventionMapping().map("rhinoClasspath", new Callable<FileCollection>() {

    public FileCollection call() {
        return rhinoExtension.getClasspath();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/javascript/src/main/java/org/gradle/plugins/javascript/coffeescript/CoffeeScriptBasePlugin.java
Cannot solve method call task.getConventionMapping().map("coffeeScriptJs", new Callable<FileCollection>() {

    public FileCollection call() {
        return csExtension.getJs();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/javascript/src/main/java/org/gradle/plugins/javascript/coffeescript/CoffeeScriptBasePlugin.java
Cannot solve method call sourceFileName.substring(0, sourceFileName.length() - 7) java.lang.RuntimeException: Method 'length' cannot be resolved in context sourceFileName.length() (line: 37) MethodCallExprContext{wrapped=sourceFileName.length()}. Parameter types: [] /repo/subprojects/javascript/src/main/java/org/gradle/plugins/javascript/coffeescript/compile/internal/CoffeeScriptCompileDestinationCalculator.java
Cannot solve method call getProject().configure(getOptions(), closure) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/javascript/src/main/java/org/gradle/plugins/javascript/coffeescript/CoffeeScriptCompile.java
Method 'newOperation' cannot be resolved in context getServices().get(ProgressLoggerFactory.class).newOperation(JettyStop.class) (line: 55) MethodCallExprContext{wrapped=getServices().get(ProgressLoggerFactory.class).newOperation(JettyStop.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.jetty.JettyStop, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call out.write((getStopKey() + "\r\nstop\r\n").getBytes()) java.lang.RuntimeException: Method 'getBytes' cannot be resolved in context (getStopKey() + "\r\nstop\r\n").getBytes() (line: 62) MethodCallExprContext{wrapped=(getStopKey() + "\r\nstop\r\n").getBytes()}. Parameter types: [] /repo/subprojects/jetty/src/main/java/org/gradle/api/plugins/jetty/JettyStop.java
Method 'newOperation' cannot be resolved in context progressLoggerFactory.newOperation(AbstractJettyRunTask.class) (line: 208) MethodCallExprContext{wrapped=progressLoggerFactory.newOperation(AbstractJettyRunTask.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.jetty.AbstractJettyRunTask, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot resolve field access null
Cannot resolve field access null
Method 'newOperation' cannot be resolved in context progressLoggerFactory.newOperation(AbstractJettyRunTask.class) (line: 274) MethodCallExprContext{wrapped=progressLoggerFactory.newOperation(AbstractJettyRunTask.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.jetty.AbstractJettyRunTask, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call Arrays.asList(webAppConfig.getSystemClasses()) java.lang.RuntimeException: Method 'getSystemClasses' cannot be resolved in context webAppConfig.getSystemClasses() (line: 310) MethodCallExprContext{wrapped=webAppConfig.getSystemClasses()}. Parameter types: [] /repo/subprojects/jetty/src/main/java/org/gradle/api/plugins/jetty/AbstractJettyRunTask.java
Cannot solve method call webAppConfig.setSystemClasses(systemClasses.toArray(new String[0])) java.lang.RuntimeException: String[] T[] /repo/subprojects/jetty/src/main/java/org/gradle/api/plugins/jetty/AbstractJettyRunTask.java
Cannot solve method call LOGGER.info("Context path = " + webAppConfig.getContextPath()) java.lang.RuntimeException: Method 'getContextPath' cannot be resolved in context webAppConfig.getContextPath() (line: 317) MethodCallExprContext{wrapped=webAppConfig.getContextPath()}. Parameter types: [] /repo/subprojects/jetty/src/main/java/org/gradle/api/plugins/jetty/AbstractJettyRunTask.java
Cannot resolve field access null
Cannot solve method call LOGGER.debug("Setting Connector: {} on port {}", connector.getClass().getName(), connector.getPort()) UnsolvedSymbolException{context='unknown', name='Connector', typeSolver=null} /repo/subprojects/jetty/src/main/java/org/gradle/api/plugins/jetty/internal/Jetty6PluginServer.java
Cannot solve method call this.server.addConnector(connector) UnsolvedSymbolException{context='unknown', name='Connector', typeSolver=null} /repo/subprojects/jetty/src/main/java/org/gradle/api/plugins/jetty/internal/Jetty6PluginServer.java
Cannot resolve field access null
Cannot solve method call this.server.addUserRealm((UserRealm) realms[i]) UnsolvedSymbolException{context='unknown', name='UserRealm', typeSolver=null} /repo/subprojects/jetty/src/main/java/org/gradle/api/plugins/jetty/internal/Jetty6PluginServer.java
Cannot resolve field access null
Method 'getThreadPool' cannot be resolved in context this.server.getThreadPool() (line: 167) MethodCallExprContext{wrapped=this.server.getThreadPool()}. Parameter types: []
Method 'getWebAppContext' cannot be resolved in context getWebAppContext() (line: 65) MethodCallExprContext{wrapped=getWebAppContext()}. Parameter types: []
Method 'getWebAppContext' cannot be resolved in context getWebAppContext() (line: 71) MethodCallExprContext{wrapped=getWebAppContext()}. Parameter types: []
Cannot solve method call annotationParserClass.getMethod("parseAnnotations", WebAppContext.class, Class.class, RunAsCollection.class, InjectionCollection.class, LifeCycleCallbackCollection.class) UnsolvedSymbolException{context='unknown', name='RunAsCollection', typeSolver=null} /repo/subprojects/jetty/src/main/java/org/gradle/api/plugins/jetty/internal/JettyConfiguration.java
Method 'getWebAppContext' cannot be resolved in context getWebAppContext() (line: 114) MethodCallExprContext{wrapped=getWebAppContext()}. Parameter types: []
Cannot solve method call parseAnnotationsMethod.invoke(null, getWebAppContext(), servlet, _runAsCollection, _injections, _callbacks) java.lang.RuntimeException: Method 'getWebAppContext' cannot be resolved in context getWebAppContext() (line: 115) MethodCallExprContext{wrapped=getWebAppContext()}. Parameter types: [] /repo/subprojects/jetty/src/main/java/org/gradle/api/plugins/jetty/internal/JettyConfiguration.java
Method 'getWebAppContext' cannot be resolved in context getWebAppContext() (line: 123) MethodCallExprContext{wrapped=getWebAppContext()}. Parameter types: []
Cannot solve method call parseAnnotationsMethod.invoke(null, getWebAppContext(), filter, null, _injections, _callbacks) java.lang.RuntimeException: Method 'getWebAppContext' cannot be resolved in context getWebAppContext() (line: 124) MethodCallExprContext{wrapped=getWebAppContext()}. Parameter types: [] /repo/subprojects/jetty/src/main/java/org/gradle/api/plugins/jetty/internal/JettyConfiguration.java
Cannot solve method call parseAnnotationsMethod.invoke(null, getWebAppContext(), listener.getClass(), null, _injections, _callbacks) java.lang.RuntimeException: Method 'getWebAppContext' cannot be resolved in context getWebAppContext() (line: 131) MethodCallExprContext{wrapped=getWebAppContext()}. Parameter types: [] /repo/subprojects/jetty/src/main/java/org/gradle/api/plugins/jetty/internal/JettyConfiguration.java
Cannot solve method call jettyRunWar.getConventionMapping().map("webApp", new Callable<Object>() {

    public Object call() throws Exception {
        return ((War) project.getTasks().getByName(WarPlugin.WAR_TASK_NAME)).getArchivePath();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/jetty/src/main/java/org/gradle/api/plugins/jetty/JettyPlugin.java
Cannot solve method call jettyStop.getConventionMapping().map("stopPort", new Callable<Object>() {

    public Object call() throws Exception {
        return jettyConvention.getStopPort();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/jetty/src/main/java/org/gradle/api/plugins/jetty/JettyPlugin.java
Cannot solve method call jettyStop.getConventionMapping().map("stopKey", new Callable<Object>() {

    public Object call() throws Exception {
        return jettyConvention.getStopKey();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/jetty/src/main/java/org/gradle/api/plugins/jetty/JettyPlugin.java
Cannot solve method call jettyRun.getConventionMapping().map("webXml", new Callable<Object>() {

    public Object call() throws Exception {
        return getWebXml(project);
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/jetty/src/main/java/org/gradle/api/plugins/jetty/JettyPlugin.java
Cannot solve method call jettyRun.getConventionMapping().map("classpath", new Callable<Object>() {

    public Object call() throws Exception {
        return getJavaConvention(project).getSourceSets().getByName(SourceSet.MAIN_SOURCE_SET_NAME).getRuntimeClasspath();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/jetty/src/main/java/org/gradle/api/plugins/jetty/JettyPlugin.java
Cannot solve method call jettyRun.getConventionMapping().map("webAppSourceDirectory", new Callable<Object>() {

    public Object call() throws Exception {
        return getWarConvention(project).getWebAppDir();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/jetty/src/main/java/org/gradle/api/plugins/jetty/JettyPlugin.java
Cannot solve method call jettyTask.getConventionMapping().map("contextPath", new Callable<Object>() {

    public Object call() throws Exception {
        return ((War) project.getTasks().getByName(WarPlugin.WAR_TASK_NAME)).getBaseName();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/jetty/src/main/java/org/gradle/api/plugins/jetty/JettyPlugin.java
Cannot solve method call jettyTask.getConventionMapping().map("httpPort", new Callable<Object>() {

    public Object call() throws Exception {
        return jettyConvention.getHttpPort();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/jetty/src/main/java/org/gradle/api/plugins/jetty/JettyPlugin.java
Cannot solve method call jettyTask.getConventionMapping().map("stopPort", new Callable<Object>() {

    public Object call() throws Exception {
        return jettyConvention.getStopPort();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/jetty/src/main/java/org/gradle/api/plugins/jetty/JettyPlugin.java
Cannot solve method call jettyTask.getConventionMapping().map("stopKey", new Callable<Object>() {

    public Object call() throws Exception {
        return jettyConvention.getStopKey();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/jetty/src/main/java/org/gradle/api/plugins/jetty/JettyPlugin.java
Cannot solve method call String.valueOf(resource.getFile()) java.lang.RuntimeException: Method 'getFile' cannot be resolved in context resource.getFile() (line: 301) MethodCallExprContext{wrapped=resource.getFile()}. Parameter types: [] /repo/subprojects/jetty/src/main/java/org/gradle/api/plugins/jetty/JettyRun.java
Error calculating the type of parameter resource.getFile() of method call String.valueOf(resource.getFile())
Method 'getURL' cannot be resolved in context resource.getURL() (line: 303) MethodCallExprContext{wrapped=resource.getURL()}. Parameter types: []
Cannot solve method call Resource.newResource("jar:" + resource.getURL().toString() + "!/") java.lang.RuntimeException: Method 'getURL' cannot be resolved in context resource.getURL() (line: 303) MethodCallExprContext{wrapped=resource.getURL()}. Parameter types: [] /repo/subprojects/jetty/src/main/java/org/gradle/api/plugins/jetty/JettyRun.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call version.compareTo(VersionNumber.parse("2.0")) UnsolvedSymbolException{context='Method 'parse' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * Represents, parses, and compares version numbers. Supports a couple of different schemes: <ul> <li>MAJOR.MINOR.MICRO-QUALIFIER (the default).</li> <li>MAJOR.MINOR.MICRO.PATCH-QUALIFIER.</li> </ul>
 *
 * <p>The {@link #parse} method handles missing parts and allows "." to be used instead of "-", and "_" to be used instead of "." for the patch number.
 *
 * <p>This class considers missing parts to be 0, so that "1.0" == "1.0.0" == "1.0.0_0".</p>
 *
 * <p>Note that this class considers "1.2.3-something" less than "1.2.3". Qualifiers are compared lexicographically ("1.2.3-alpha" < "1.2.3-beta") and case-insensitive ("1.2.3-alpha" <
 * "1.2.3.RELEASE").
 *
 * <p>To check if a version number is at least "1.2.3", disregarding a potential qualifier like "beta", use {@code version.getBaseVersion().compareTo(VersionNumber.parse("1.2.3")) >= 0}.
 */
public class VersionNumber implements Comparable<VersionNumber> {

    private static final DefaultScheme DEFAULT_SCHEME = new DefaultScheme();

    private static final SchemeWithPatchVersion PATCH_SCHEME = new SchemeWithPatchVersion();

    public static final VersionNumber UNKNOWN = version(0);

    private final int major;

    private final int minor;

    private final int micro;

    private final int patch;

    private final String qualifier;

    private final AbstractScheme scheme;

    public VersionNumber(int major, int minor, int micro, @Nullable String qualifier) {
        this(major, minor, micro, 0, qualifier, DEFAULT_SCHEME);
    }

    public VersionNumber(int major, int minor, int micro, int patch, @Nullable String qualifier) {
        this(major, minor, micro, patch, qualifier, PATCH_SCHEME);
    }

    private VersionNumber(int major, int minor, int micro, int patch, @Nullable String qualifier, AbstractScheme scheme) {
        this.major = major;
        this.minor = minor;
        this.micro = micro;
        this.patch = patch;
        this.qualifier = qualifier;
        this.scheme = scheme;
    }

    public int getMajor() {
        return major;
    }

    public int getMinor() {
        return minor;
    }

    public int getMicro() {
        return micro;
    }

    public int getPatch() {
        return patch;
    }

    public String getQualifier() {
        return qualifier;
    }

    public VersionNumber getBaseVersion() {
        return new VersionNumber(major, minor, micro, patch, null, scheme);
    }

    public int compareTo(VersionNumber other) {
        if (major != other.major) {
            return major - other.major;
        }
        if (minor != other.minor) {
            return minor - other.minor;
        }
        if (micro != other.micro) {
            return micro - other.micro;
        }
        if (patch != other.patch) {
            return patch - other.patch;
        }
        return Ordering.natural().nullsLast().compare(toLowerCase(qualifier), toLowerCase(other.qualifier));
    }

    public boolean equals(Object other) {
        return other instanceof VersionNumber && compareTo((VersionNumber) other) == 0;
    }

    public int hashCode() {
        int result = major;
        result = 31 * result + minor;
        result = 31 * result + micro;
        result = 31 * result + patch;
        result = 31 * result + Objects.hashCode(qualifier);
        return result;
    }

    public String toString() {
        return scheme.format(this);
    }

    public static VersionNumber version(int major) {
        return new VersionNumber(major, 0, 0, 0, null, DEFAULT_SCHEME);
    }

    /**
     * Returns the default MAJOR.MINOR.MICRO-QUALIFIER scheme.
     */
    public static Scheme scheme() {
        return DEFAULT_SCHEME;
    }

    /**
     * Returns the MAJOR.MINOR.MICRO.PATCH-QUALIFIER scheme.
     */
    public static Scheme withPatchNumber() {
        return PATCH_SCHEME;
    }

    public static VersionNumber parse(String versionString) {
        return DEFAULT_SCHEME.parse(versionString);
    }

    private String toLowerCase(@Nullable String string) {
        return string == null ? null : string.toLowerCase();
    }

    public interface Scheme {

        public VersionNumber parse(String value);

        public String format(VersionNumber versionNumber);
    }

    private abstract static class AbstractScheme implements Scheme {

        final int depth;

        protected AbstractScheme(int depth) {
            this.depth = depth;
        }

        public VersionNumber parse(String versionString) {
            if (versionString == null || versionString.length() == 0) {
                return UNKNOWN;
            }
            Scanner scanner = new Scanner(versionString);
            int major = 0;
            int minor = 0;
            int micro = 0;
            int patch = 0;
            if (!scanner.hasDigit()) {
                return UNKNOWN;
            }
            major = scanner.scanDigit();
            if (scanner.isSeparatorAndDigit('.')) {
                scanner.skipSeparator();
                minor = scanner.scanDigit();
                if (scanner.isSeparatorAndDigit('.')) {
                    scanner.skipSeparator();
                    micro = scanner.scanDigit();
                    if (depth > 3 && scanner.isSeparatorAndDigit('.', '_')) {
                        scanner.skipSeparator();
                        patch = scanner.scanDigit();
                    }
                }
            }
            if (scanner.isEnd()) {
                return new VersionNumber(major, minor, micro, patch, null, this);
            }
            if (scanner.isQualifier()) {
                scanner.skipSeparator();
                return new VersionNumber(major, minor, micro, patch, scanner.remainder(), this);
            }
            return UNKNOWN;
        }

        private static class Scanner {

            int pos;

            final String str;

            private Scanner(String string) {
                this.str = string;
            }

            boolean hasDigit() {
                return pos < str.length() && Character.isDigit(str.charAt(pos));
            }

            boolean isSeparatorAndDigit(char... separators) {
                return pos < str.length() - 1 && oneOf(separators) && Character.isDigit(str.charAt(pos + 1));
            }

            private boolean oneOf(char... separators) {
                char current = str.charAt(pos);
                for (int i = 0; i < separators.length; i++) {
                    char separator = separators[i];
                    if (current == separator) {
                        return true;
                    }
                }
                return false;
            }

            boolean isQualifier() {
                return pos < str.length() - 1 && oneOf('.', '-');
            }

            int scanDigit() {
                int start = pos;
                while (hasDigit()) {
                    pos++;
                }
                return Integer.parseInt(str.substring(start, pos));
            }

            public boolean isEnd() {
                return pos == str.length();
            }

            private boolean skip(char ch) {
                if (pos < str.length() && str.charAt(pos) == ch) {
                    pos++;
                    return true;
                }
                return false;
            }

            public void skipSeparator() {
                pos++;
            }

            public String remainder() {
                return pos == str.length() ? null : str.substring(pos);
            }
        }
    }

    private static class DefaultScheme extends AbstractScheme {

        private static final String VERSION_TEMPLATE = "%d.%d.%d%s";

        public DefaultScheme() {
            super(3);
        }

        public String format(VersionNumber versionNumber) {
            return String.format(VERSION_TEMPLATE, versionNumber.major, versionNumber.minor, versionNumber.micro, versionNumber.qualifier == null ? "" : "-" + versionNumber.qualifier);
        }
    }

    private static class SchemeWithPatchVersion extends AbstractScheme {

        private static final String VERSION_TEMPLATE = "%d.%d.%d.%d%s";

        private SchemeWithPatchVersion() {
            super(4);
        }

        public String format(VersionNumber versionNumber) {
            return String.format(VERSION_TEMPLATE, versionNumber.major, versionNumber.minor, versionNumber.micro, versionNumber.patch, versionNumber.qualifier == null ? "" : "-" + versionNumber.qualifier);
        }
    }
}}'} /repo/subprojects/language-groovy/src/main/java/org/gradle/api/internal/tasks/compile/ApiGroovyCompiler.java
Cannot solve method call unit.addSources(Iterables.toArray(spec.getSource(), File.class)) UnsolvedSymbolException{context='Method 'toArray' with parameterTypes [ReferenceType{org.gradle.api.file.FileCollection, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/language-groovy/src/main/java/org/gradle/api/internal/tasks/compile/ApiGroovyCompiler.java
Method 'getErrorCollector' cannot be resolved in context cu.getErrorCollector() (line: 166) MethodCallExprContext{wrapped=cu.getErrorCollector()}. Parameter types: []
Cannot solve method call System.err.println(e.getMessage()) java.lang.RuntimeException: Method 'getMessage' cannot be resolved in context e.getMessage() (line: 176) MethodCallExprContext{wrapped=e.getMessage()}. Parameter types: [] /repo/subprojects/language-groovy/src/main/java/org/gradle/api/internal/tasks/compile/ApiGroovyCompiler.java
Cannot solve method call version.compareTo(VersionNumber.parse("2.1")) UnsolvedSymbolException{context='Method 'parse' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * Represents, parses, and compares version numbers. Supports a couple of different schemes: <ul> <li>MAJOR.MINOR.MICRO-QUALIFIER (the default).</li> <li>MAJOR.MINOR.MICRO.PATCH-QUALIFIER.</li> </ul>
 *
 * <p>The {@link #parse} method handles missing parts and allows "." to be used instead of "-", and "_" to be used instead of "." for the patch number.
 *
 * <p>This class considers missing parts to be 0, so that "1.0" == "1.0.0" == "1.0.0_0".</p>
 *
 * <p>Note that this class considers "1.2.3-something" less than "1.2.3". Qualifiers are compared lexicographically ("1.2.3-alpha" < "1.2.3-beta") and case-insensitive ("1.2.3-alpha" <
 * "1.2.3.RELEASE").
 *
 * <p>To check if a version number is at least "1.2.3", disregarding a potential qualifier like "beta", use {@code version.getBaseVersion().compareTo(VersionNumber.parse("1.2.3")) >= 0}.
 */
public class VersionNumber implements Comparable<VersionNumber> {

    private static final DefaultScheme DEFAULT_SCHEME = new DefaultScheme();

    private static final SchemeWithPatchVersion PATCH_SCHEME = new SchemeWithPatchVersion();

    public static final VersionNumber UNKNOWN = version(0);

    private final int major;

    private final int minor;

    private final int micro;

    private final int patch;

    private final String qualifier;

    private final AbstractScheme scheme;

    public VersionNumber(int major, int minor, int micro, @Nullable String qualifier) {
        this(major, minor, micro, 0, qualifier, DEFAULT_SCHEME);
    }

    public VersionNumber(int major, int minor, int micro, int patch, @Nullable String qualifier) {
        this(major, minor, micro, patch, qualifier, PATCH_SCHEME);
    }

    private VersionNumber(int major, int minor, int micro, int patch, @Nullable String qualifier, AbstractScheme scheme) {
        this.major = major;
        this.minor = minor;
        this.micro = micro;
        this.patch = patch;
        this.qualifier = qualifier;
        this.scheme = scheme;
    }

    public int getMajor() {
        return major;
    }

    public int getMinor() {
        return minor;
    }

    public int getMicro() {
        return micro;
    }

    public int getPatch() {
        return patch;
    }

    public String getQualifier() {
        return qualifier;
    }

    public VersionNumber getBaseVersion() {
        return new VersionNumber(major, minor, micro, patch, null, scheme);
    }

    public int compareTo(VersionNumber other) {
        if (major != other.major) {
            return major - other.major;
        }
        if (minor != other.minor) {
            return minor - other.minor;
        }
        if (micro != other.micro) {
            return micro - other.micro;
        }
        if (patch != other.patch) {
            return patch - other.patch;
        }
        return Ordering.natural().nullsLast().compare(toLowerCase(qualifier), toLowerCase(other.qualifier));
    }

    public boolean equals(Object other) {
        return other instanceof VersionNumber && compareTo((VersionNumber) other) == 0;
    }

    public int hashCode() {
        int result = major;
        result = 31 * result + minor;
        result = 31 * result + micro;
        result = 31 * result + patch;
        result = 31 * result + Objects.hashCode(qualifier);
        return result;
    }

    public String toString() {
        return scheme.format(this);
    }

    public static VersionNumber version(int major) {
        return new VersionNumber(major, 0, 0, 0, null, DEFAULT_SCHEME);
    }

    /**
     * Returns the default MAJOR.MINOR.MICRO-QUALIFIER scheme.
     */
    public static Scheme scheme() {
        return DEFAULT_SCHEME;
    }

    /**
     * Returns the MAJOR.MINOR.MICRO.PATCH-QUALIFIER scheme.
     */
    public static Scheme withPatchNumber() {
        return PATCH_SCHEME;
    }

    public static VersionNumber parse(String versionString) {
        return DEFAULT_SCHEME.parse(versionString);
    }

    private String toLowerCase(@Nullable String string) {
        return string == null ? null : string.toLowerCase();
    }

    public interface Scheme {

        public VersionNumber parse(String value);

        public String format(VersionNumber versionNumber);
    }

    private abstract static class AbstractScheme implements Scheme {

        final int depth;

        protected AbstractScheme(int depth) {
            this.depth = depth;
        }

        public VersionNumber parse(String versionString) {
            if (versionString == null || versionString.length() == 0) {
                return UNKNOWN;
            }
            Scanner scanner = new Scanner(versionString);
            int major = 0;
            int minor = 0;
            int micro = 0;
            int patch = 0;
            if (!scanner.hasDigit()) {
                return UNKNOWN;
            }
            major = scanner.scanDigit();
            if (scanner.isSeparatorAndDigit('.')) {
                scanner.skipSeparator();
                minor = scanner.scanDigit();
                if (scanner.isSeparatorAndDigit('.')) {
                    scanner.skipSeparator();
                    micro = scanner.scanDigit();
                    if (depth > 3 && scanner.isSeparatorAndDigit('.', '_')) {
                        scanner.skipSeparator();
                        patch = scanner.scanDigit();
                    }
                }
            }
            if (scanner.isEnd()) {
                return new VersionNumber(major, minor, micro, patch, null, this);
            }
            if (scanner.isQualifier()) {
                scanner.skipSeparator();
                return new VersionNumber(major, minor, micro, patch, scanner.remainder(), this);
            }
            return UNKNOWN;
        }

        private static class Scanner {

            int pos;

            final String str;

            private Scanner(String string) {
                this.str = string;
            }

            boolean hasDigit() {
                return pos < str.length() && Character.isDigit(str.charAt(pos));
            }

            boolean isSeparatorAndDigit(char... separators) {
                return pos < str.length() - 1 && oneOf(separators) && Character.isDigit(str.charAt(pos + 1));
            }

            private boolean oneOf(char... separators) {
                char current = str.charAt(pos);
                for (int i = 0; i < separators.length; i++) {
                    char separator = separators[i];
                    if (current == separator) {
                        return true;
                    }
                }
                return false;
            }

            boolean isQualifier() {
                return pos < str.length() - 1 && oneOf('.', '-');
            }

            int scanDigit() {
                int start = pos;
                while (hasDigit()) {
                    pos++;
                }
                return Integer.parseInt(str.substring(start, pos));
            }

            public boolean isEnd() {
                return pos == str.length();
            }

            private boolean skip(char ch) {
                if (pos < str.length() && str.charAt(pos) == ch) {
                    pos++;
                    return true;
                }
                return false;
            }

            public void skipSeparator() {
                pos++;
            }

            public String remainder() {
                return pos == str.length() ? null : str.substring(pos);
            }
        }
    }

    private static class DefaultScheme extends AbstractScheme {

        private static final String VERSION_TEMPLATE = "%d.%d.%d%s";

        public DefaultScheme() {
            super(3);
        }

        public String format(VersionNumber versionNumber) {
            return String.format(VERSION_TEMPLATE, versionNumber.major, versionNumber.minor, versionNumber.micro, versionNumber.qualifier == null ? "" : "-" + versionNumber.qualifier);
        }
    }

    private static class SchemeWithPatchVersion extends AbstractScheme {

        private static final String VERSION_TEMPLATE = "%d.%d.%d.%d%s";

        private SchemeWithPatchVersion() {
            super(4);
        }

        public String format(VersionNumber versionNumber) {
            return String.format(VERSION_TEMPLATE, versionNumber.major, versionNumber.minor, versionNumber.micro, versionNumber.patch, versionNumber.qualifier == null ? "" : "-" + versionNumber.qualifier);
        }
    }
}}'} /repo/subprojects/language-groovy/src/main/java/org/gradle/api/internal/tasks/compile/ApiGroovyCompiler.java
Cannot solve method call spec.setGroovyClasspath(Lists.newArrayList(spec.getGroovyClasspath())) UnsolvedSymbolException{context='Method 'newArrayList' with parameterTypes [ReferenceType{Iterable, typeParametersMap=TypeParametersMap{nameToValue={empty.BlockDoc=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Lists}'} /repo/subprojects/language-groovy/src/main/java/org/gradle/api/internal/tasks/compile/NormalizingGroovyCompiler.java
Cannot solve method call spec.getCompileOptions().setCompilerArgs(CollectionUtils.toStringList(spec.getCompileOptions().getCompilerArgs())) UnsolvedSymbolException{context='Method 'toStringList' with parameterTypes [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class CollectionUtils {

    /**
     * Returns null if the collection is empty otherwise expects a {@link #single(Iterable)} element to be found.
     */
    @Nullable
    public static <T> T findSingle(Collection<T> source) {
        return source.isEmpty() ? null : single(source);
    }

    /**
     * Returns the single element in the collection or throws.
     */
    public static <T> T single(Iterable<? extends T> source) {
        Iterator<? extends T> iterator = source.iterator();
        if (!iterator.hasNext()) {
            throw new NoSuchElementException("Expecting collection with single element, got none.");
        }
        T element = iterator.next();
        if (iterator.hasNext()) {
            throw new IllegalArgumentException("Expecting collection with single element, got multiple.");
        }
        return element;
    }

    public static <T> Collection<? extends T> checkedCast(Class<T> type, Collection<?> input) {
        for (Object o : input) {
            cast(type, o);
        }
        return Cast.uncheckedCast(input);
    }

    public static <T> T findFirst(Iterable<? extends T> source, Spec<? super T> filter) {
        for (T item : source) {
            if (filter.isSatisfiedBy(item)) {
                return item;
            }
        }
        return null;
    }

    public static <T> T findFirst(T[] source, Spec<? super T> filter) {
        for (T thing : source) {
            if (filter.isSatisfiedBy(thing)) {
                return thing;
            }
        }
        return null;
    }

    public static <T> T first(Iterable<? extends T> source) {
        return source.iterator().next();
    }

    public static <T> boolean any(Iterable<? extends T> source, Spec<? super T> filter) {
        return findFirst(source, filter) != null;
    }

    public static <T> boolean any(T[] source, Spec<? super T> filter) {
        return findFirst(source, filter) != null;
    }

    public static <T> Set<T> filter(Set<? extends T> set, Spec<? super T> filter) {
        return filter(set, new LinkedHashSet<T>(), filter);
    }

    public static <T> List<T> filter(List<? extends T> list, Spec<? super T> filter) {
        return filter(list, new LinkedList<T>(), filter);
    }

    public static <T> List<T> filter(T[] array, Spec<? super T> filter) {
        return filter(Arrays.asList(array), new LinkedList<T>(), filter);
    }

    /**
     * Returns a sorted copy of the provided collection of things. Uses the provided comparator to sort.
     */
    public static <T> List<T> sort(Iterable<? extends T> things, Comparator<? super T> comparator) {
        List<T> copy = toMutableList(things);
        Collections.sort(copy, comparator);
        return copy;
    }

    /**
     * Returns a sorted copy of the provided collection of things. Uses the natural ordering of the things.
     */
    public static <T extends Comparable> List<T> sort(Iterable<T> things) {
        List<T> copy = toMutableList(things);
        Collections.sort(copy);
        return copy;
    }

    public static <T, C extends Collection<T>> C filter(Iterable<? extends T> source, C destination, Spec<? super T> filter) {
        for (T item : source) {
            if (filter.isSatisfiedBy(item)) {
                destination.add(item);
            }
        }
        return destination;
    }

    public static <K, V> Map<K, V> filter(Map<K, V> map, Spec<Map.Entry<K, V>> filter) {
        return filter(map, new HashMap<K, V>(), filter);
    }

    public static <K, V> Map<K, V> filter(Map<K, V> map, Map<K, V> destination, Spec<Map.Entry<K, V>> filter) {
        for (Map.Entry<K, V> entry : map.entrySet()) {
            if (filter.isSatisfiedBy(entry)) {
                destination.put(entry.getKey(), entry.getValue());
            }
        }
        return destination;
    }

    public static <R, I> R[] collectArray(I[] list, Class<R> newType, Transformer<? extends R, ? super I> transformer) {
        @SuppressWarnings("unchecked") R[] destination = (R[]) Array.newInstance(newType, list.length);
        return collectArray(list, destination, transformer);
    }

    public static <R, I> R[] collectArray(I[] list, R[] destination, Transformer<? extends R, ? super I> transformer) {
        assert list.length <= destination.length;
        for (int i = 0; i < list.length; ++i) {
            destination[i] = transformer.transform(list[i]);
        }
        return destination;
    }

    public static <R, I> List<R> collect(List<? extends I> list, Transformer<? extends R, ? super I> transformer) {
        return collect(list, new ArrayList<R>(list.size()), transformer);
    }

    public static <R, I> List<R> collect(I[] list, Transformer<? extends R, ? super I> transformer) {
        return collect(Arrays.asList(list), transformer);
    }

    public static <R, I> Set<R> collect(Set<? extends I> set, Transformer<? extends R, ? super I> transformer) {
        return collect(set, new HashSet<R>(), transformer);
    }

    public static <R, I> List<R> collect(Iterable<? extends I> source, Transformer<? extends R, ? super I> transformer) {
        return collect(source, new LinkedList<R>(), transformer);
    }

    public static <R, I, C extends Collection<R>> C collect(Iterable<? extends I> source, C destination, Transformer<? extends R, ? super I> transformer) {
        for (I item : source) {
            destination.add(transformer.transform(item));
        }
        return destination;
    }

    public static List<String> toStringList(Iterable<?> iterable) {
        return collect(iterable, new LinkedList<String>(), Transformers.asString());
    }

    /**
     * Recursively unpacks all the given things into a flat list.
     *
     * Nulls are not removed, they are left intact.
     *
     * @param things The things to flatten
     * @return A flattened list of the given things
     */
    public static List<?> flattenCollections(Object... things) {
        return flattenCollections(Object.class, things);
    }

    /**
     * Recursively unpacks all the given things into a flat list, ensuring they are of a certain type.
     *
     * Nulls are not removed, they are left intact.
     *
     * If a non null object cannot be cast to the target type, a ClassCastException will be thrown.
     *
     * @param things The things to flatten
     * @param <T> The target type in the flattened list
     * @return A flattened list of the given things
     */
    public static <T> List<T> flattenCollections(Class<T> type, Object... things) {
        if (things == null) {
            return Collections.singletonList(null);
        } else if (things.length == 0) {
            return Collections.emptyList();
        } else if (things.length == 1) {
            Object thing = things[0];
            if (thing == null) {
                return Collections.singletonList(null);
            }
            if (thing.getClass().isArray()) {
                Object[] thingArray = (Object[]) thing;
                List<T> list = new ArrayList<T>(thingArray.length);
                for (Object thingThing : thingArray) {
                    list.addAll(flattenCollections(type, thingThing));
                }
                return list;
            }
            if (thing instanceof Collection) {
                Collection<?> collection = (Collection<?>) thing;
                List<T> list = new ArrayList<T>();
                for (Object element : collection) {
                    list.addAll(flattenCollections(type, element));
                }
                return list;
            }
            return Collections.singletonList(cast(type, thing));
        } else {
            List<T> list = new ArrayList<T>();
            for (Object thing : things) {
                list.addAll(flattenCollections(type, thing));
            }
            return list;
        }
    }

    public static <T> List<T> toList(Iterable<? extends T> things) {
        if (things instanceof List) {
            @SuppressWarnings("unchecked") List<T> castThings = (List<T>) things;
            return castThings;
        }
        return toMutableList(things);
    }

    public static <T> List<T> toList(Enumeration<? extends T> things) {
        AbstractList<T> list = new ArrayList<T>();
        while (things.hasMoreElements()) {
            list.add(things.nextElement());
        }
        return list;
    }

    private static <T> List<T> toMutableList(Iterable<? extends T> things) {
        if (things == null) {
            return new ArrayList<T>(0);
        }
        List<T> list = new ArrayList<T>();
        for (T thing : things) {
            list.add(thing);
        }
        return list;
    }

    public static <T> List<T> intersection(Collection<? extends Collection<T>> availableValuesByDescriptor) {
        List<T> result = new ArrayList<T>();
        Iterator<? extends Collection<T>> iterator = availableValuesByDescriptor.iterator();
        if (iterator.hasNext()) {
            Collection<T> firstSet = iterator.next();
            result.addAll(firstSet);
            while (iterator.hasNext()) {
                Collection<T> next = iterator.next();
                result.retainAll(next);
            }
        }
        return result;
    }

    public static <T> List<T> toList(T[] things) {
        if (things == null || things.length == 0) {
            return new ArrayList<T>(0);
        }
        List<T> list = new ArrayList<T>(things.length);
        Collections.addAll(list, things);
        return list;
    }

    public static <T> Set<T> toSet(Iterable<? extends T> things) {
        if (things == null) {
            return new HashSet<T>(0);
        }
        if (things instanceof Set) {
            @SuppressWarnings("unchecked") Set<T> castThings = (Set<T>) things;
            return castThings;
        }
        Set<T> set = new LinkedHashSet<T>();
        for (T thing : things) {
            set.add(thing);
        }
        return set;
    }

    public static <E> List<E> compact(List<E> list) {
        boolean foundAtLeastOneNull = false;
        List<E> compacted = null;
        int i = 0;
        for (E element : list) {
            if (element == null) {
                if (!foundAtLeastOneNull) {
                    compacted = new ArrayList<E>(list.size());
                    if (i > 0) {
                        compacted.addAll(list.subList(0, i));
                    }
                }
                foundAtLeastOneNull = true;
            } else if (foundAtLeastOneNull) {
                compacted.add(element);
            }
            ++i;
        }
        return foundAtLeastOneNull ? compacted : list;
    }

    public static <C extends Collection<String>> C stringize(Iterable<?> source, C destination) {
        return collect(source, destination, Transformers.asString());
    }

    public static List<String> stringize(Collection<?> source) {
        return stringize(source, new ArrayList<String>(source.size()));
    }

    public static <E> boolean replace(List<E> list, Spec<? super E> filter, Transformer<? extends E, ? super E> transformer) {
        boolean replaced = false;
        int i = 0;
        for (E it : list) {
            if (filter.isSatisfiedBy(it)) {
                list.set(i, transformer.transform(it));
                replaced = true;
            }
            ++i;
        }
        return replaced;
    }

    public static <K, V> void collectMap(Map<K, V> destination, Iterable<? extends V> items, Transformer<? extends K, ? super V> keyGenerator) {
        for (V item : items) {
            destination.put(keyGenerator.transform(item), item);
        }
    }

    /**
     * Given a set of values, derive a set of keys and return a map
     */
    public static <K, V> Map<K, V> collectMap(Iterable<? extends V> items, Transformer<? extends K, ? super V> keyGenerator) {
        Map<K, V> map = new LinkedHashMap<K, V>();
        collectMap(map, items, keyGenerator);
        return map;
    }

    public static <K, V> void collectMapValues(Map<K, V> destination, Iterable<? extends K> keys, Transformer<? extends V, ? super K> keyGenerator) {
        for (K item : keys) {
            destination.put(item, keyGenerator.transform(item));
        }
    }

    /**
     * Given a set of keys, derive a set of values and return a map
     */
    public static <K, V> Map<K, V> collectMapValues(Iterable<? extends K> keys, Transformer<? extends V, ? super K> keyGenerator) {
        Map<K, V> map = new LinkedHashMap<K, V>();
        collectMapValues(map, keys, keyGenerator);
        return map;
    }

    public static <T> boolean every(Iterable<? extends T> things, Spec<? super T> predicate) {
        for (T thing : things) {
            if (!predicate.isSatisfiedBy(thing)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Utility for adding an iterable to a collection.
     *
     * @param t1 The collection to add to
     * @param t2 The iterable to add each item of to the collection
     * @param <T> The element type of t1
     * @return t1
     */
    public static <T> Collection<T> addAll(Collection<T> t1, Iterable<? extends T> t2) {
        for (T t : t2) {
            t1.add(t);
        }
        return t1;
    }

    /**
     * Utility for adding an array to a collection.
     *
     * @param t1 The collection to add to
     * @param t2 The iterable to add each item of to the collection
     * @param <T> The element type of t1
     * @return t1
     */
    public static <T> Collection<T> addAll(Collection<T> t1, T... t2) {
        Collections.addAll(t1, t2);
        return t1;
    }

    /**
     * The result of diffing two sets.
     *
     * @param <T> The type of element the sets contain
     * @see CollectionUtils#diffSetsBy(java.util.Set, java.util.Set, org.gradle.api.Transformer)
     */
    public static class SetDiff<T> {

        public Set<T> leftOnly = new HashSet<T>();

        public Set<Pair<T, T>> common = new HashSet<Pair<T, T>>();

        public Set<T> rightOnly = new HashSet<T>();
    }

    /**
     * Provides a “diff report” of how the two sets are similar and how they are different, comparing the entries by some aspect.
     *
     * The transformer is used to generate the value to use to compare the entries by. That is, the entries are not compared by equals by an attribute or characteristic.
     *
     * The transformer is expected to produce a unique value for each entry in a single set. Behaviour is undefined if this condition is not met.
     *
     * @param left The set on the “left” side of the comparison.
     * @param right The set on the “right” side of the comparison.
     * @param compareBy Provides the value to compare entries from either side by
     * @param <T> The type of the entry objects
     * @return A representation of the difference
     */
    public static <T> SetDiff<T> diffSetsBy(Set<? extends T> left, Set<? extends T> right, Transformer<?, T> compareBy) {
        if (left == null) {
            throw new NullPointerException("'left' set is null");
        }
        if (right == null) {
            throw new NullPointerException("'right' set is null");
        }
        SetDiff<T> setDiff = new SetDiff<T>();
        Map<Object, T> indexedLeft = collectMap(left, compareBy);
        Map<Object, T> indexedRight = collectMap(right, compareBy);
        for (Map.Entry<Object, T> leftEntry : indexedLeft.entrySet()) {
            T rightValue = indexedRight.remove(leftEntry.getKey());
            if (rightValue == null) {
                setDiff.leftOnly.add(leftEntry.getValue());
            } else {
                Pair<T, T> pair = Pair.of(leftEntry.getValue(), rightValue);
                setDiff.common.add(pair);
            }
        }
        for (T rightValue : indexedRight.values()) {
            setDiff.rightOnly.add(rightValue);
        }
        return setDiff;
    }

    /**
     * Creates a string with {@code toString()} of each object with the given separator.
     *
     * <pre>
     * expect:
     * join(",", new Object[]{"a"}) == "a"
     * join(",", new Object[]{"a", "b", "c"}) == "a,b,c"
     * join(",", new Object[]{}) == ""
     * </pre>
     *
     * The {@code separator} must not be null and {@code objects} must not be null.
     *
     * @param separator The string by which to join each string representation
     * @param objects The objects to join the string representations of
     * @return The joined string
     */
    public static String join(String separator, Object[] objects) {
        return join(separator, objects == null ? null : Arrays.asList(objects));
    }

    /**
     * Creates a string with {@code toString()} of each object with the given separator.
     *
     * <pre>
     * expect:
     * join(",", ["a"]) == "a"
     * join(",", ["a", "b", "c"]) == "a,b,c"
     * join(",", []) == ""
     * </pre>
     *
     * The {@code separator} must not be null and {@code objects} must not be null.
     *
     * @param separator The string by which to join each string representation
     * @param objects The objects to join the string representations of
     * @return The joined string
     */
    public static String join(String separator, Iterable<?> objects) {
        if (separator == null) {
            throw new NullPointerException("The 'separator' cannot be null");
        }
        if (objects == null) {
            throw new NullPointerException("The 'objects' cannot be null");
        }
        StringBuilder string = new StringBuilder();
        Iterator<?> iterator = objects.iterator();
        if (iterator.hasNext()) {
            string.append(iterator.next().toString());
            while (iterator.hasNext()) {
                string.append(separator);
                string.append(iterator.next().toString());
            }
        }
        return string.toString();
    }

    /**
     * Partition given Collection into a Pair of Collections.
     *
     * <pre>Left</pre> Collection containing entries that satisfy the given predicate
     * <pre>Right</pre> Collection containing entries that do NOT satisfy the given predicate
     */
    public static <T> Pair<Collection<T>, Collection<T>> partition(Iterable<T> items, Spec<? super T> predicate) {
        Preconditions.checkNotNull(items, "Cannot partition null Collection");
        Preconditions.checkNotNull(predicate, "Cannot apply null Spec when partitioning");
        Collection<T> left = new LinkedList<T>();
        Collection<T> right = new LinkedList<T>();
        for (T item : items) {
            if (predicate.isSatisfiedBy(item)) {
                left.add(item);
            } else {
                right.add(item);
            }
        }
        return Pair.of(left, right);
    }

    public static class InjectionStep<T, I> {

        private final T target;

        private final I item;

        public InjectionStep(T target, I item) {
            this.target = target;
            this.item = item;
        }

        public T getTarget() {
            return target;
        }

        public I getItem() {
            return item;
        }
    }

    public static <T, I> T inject(T target, Iterable<? extends I> items, Action<InjectionStep<T, I>> action) {
        if (target == null) {
            throw new NullPointerException("The 'target' cannot be null");
        }
        if (items == null) {
            throw new NullPointerException("The 'items' cannot be null");
        }
        if (action == null) {
            throw new NullPointerException("The 'action' cannot be null");
        }
        for (I item : items) {
            action.execute(new InjectionStep<T, I>(target, item));
        }
        return target;
    }

    public static <K, V> ImmutableListMultimap<K, V> groupBy(Iterable<? extends V> iterable, Transformer<? extends K, V> grouper) {
        ImmutableListMultimap.Builder<K, V> builder = ImmutableListMultimap.builder();
        for (V element : iterable) {
            K key = grouper.transform(element);
            builder.put(key, element);
        }
        return builder.build();
    }

    public static <T> Iterable<? extends T> unpack(final Iterable<? extends Factory<? extends T>> factories) {
        return new Iterable<T>() {

            private final Iterator<? extends Factory<? extends T>> delegate = factories.iterator();

            public Iterator<T> iterator() {
                return new Iterator<T>() {

                    public boolean hasNext() {
                        return delegate.hasNext();
                    }

                    public T next() {
                        return delegate.next().create();
                    }

                    public void remove() {
                        throw new UnsupportedOperationException();
                    }
                };
            }
        };
    }

    @Nullable
    public static <T> List<T> nonEmptyOrNull(Iterable<T> iterable) {
        ImmutableList<T> list = ImmutableList.copyOf(iterable);
        return list.isEmpty() ? null : list;
    }

    public static <T> List<T> dedup(Iterable<T> source, final Equivalence<? super T> equivalence) {
        Iterable<Equivalence.Wrapper<T>> wrappers = Iterables.transform(source, new Function<T, Equivalence.Wrapper<T>>() {

            public Equivalence.Wrapper<T> apply(@Nullable T input) {
                return equivalence.wrap(input);
            }
        });
        Set<Equivalence.Wrapper<T>> deduped = ImmutableSet.copyOf(wrappers);
        return ImmutableList.copyOf(Iterables.transform(deduped, new Function<Equivalence.Wrapper<T>, T>() {

            public T apply(Equivalence.Wrapper<T> input) {
                return input.get();
            }
        }));
    }

    public static String asCommandLine(Iterable<String> arguments) {
        return Joiner.on(" ").join(collect(arguments, Transformers.asSafeCommandLineArgument()));
    }
}}'} /repo/subprojects/language-groovy/src/main/java/org/gradle/api/internal/tasks/compile/NormalizingGroovyCompiler.java
Method 'getClassPath' cannot be resolved in context classPathRegistry.getClassPath("ANT") (line: 54) MethodCallExprContext{wrapped=classPathRegistry.getClassPath("ANT")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call Type.getType(GroovyASTTransformationClass.class) UnsolvedSymbolException{context='unknown', name='GroovyASTTransformationClass', typeSolver=null} /repo/subprojects/language-groovy/src/main/java/org/gradle/api/internal/tasks/compile/GroovyCompileTransformingClassLoader.java
Error calculating the type of parameter GroovyASTTransformationClass.class of method call Type.getType(GroovyASTTransformationClass.class)
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call classReader.accept(detector, ClassReader.SKIP_DEBUG | ClassReader.SKIP_CODE) UnsolvedSymbolException{context='unknown', name='SKIP_DEBUG', typeSolver=null} /repo/subprojects/language-groovy/src/main/java/org/gradle/api/internal/tasks/compile/GroovyCompileTransformingClassLoader.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call names.add(type.getClassName()) java.lang.RuntimeException: Method 'getClassName' cannot be resolved in context type.getClassName() (line: 98) MethodCallExprContext{wrapped=type.getClassName()}. Parameter types: [] /repo/subprojects/language-groovy/src/main/java/org/gradle/api/internal/tasks/compile/GroovyCompileTransformingClassLoader.java
Cannot resolve field access null
Method 'from' cannot be resolved in context copySpec.from(source) (line: 65) MethodCallExprContext{wrapped=copySpec.from(source)}. Parameter types: [ReferenceType{org.gradle.api.file.FileCollection, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call antBuilder.invokeMethod("taskdef", ImmutableMap.of("name", "groovy", "classname", "org.codehaus.groovy.ant.Groovy")) UnsolvedSymbolException{context='Method 'of' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=ImmutableMap}'} /repo/subprojects/language-groovy/src/main/java/org/gradle/api/internal/tasks/AntGroovydoc.java
Method 'withClasspath' cannot be resolved in context ant.withClasspath(combinedClasspath) (line: 113) MethodCallExprContext{wrapped=ant.withClasspath(combinedClasspath)}. Parameter types: [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call antBuilder.invokeMethod("taskdef", ImmutableMap.of("name", "groovydoc", "classname", "org.codehaus.groovy.ant.Groovydoc")) UnsolvedSymbolException{context='Method 'of' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=ImmutableMap}'} /repo/subprojects/language-groovy/src/main/java/org/gradle/api/internal/tasks/AntGroovydoc.java
Cannot solve method call ImmutableMap.of("packages", Joiner.on(",").join(link.getPackages()), "href", link.getUrl()) UnsolvedSymbolException{context='Method 'on' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=Joiner}'} /repo/subprojects/language-groovy/src/main/java/org/gradle/api/internal/tasks/AntGroovydoc.java
Method 'withClasspath' cannot be resolved in context ant.withClasspath(combinedClasspath) (line: 136) MethodCallExprContext{wrapped=ant.withClasspath(combinedClasspath)}. Parameter types: [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve field access PathSensitivity.NAME_ONLY
Cannot solve field access LogLevel.INFO
Cannot solve field access PathSensitivity.RELATIVE
Cannot resolve field access null
type usage: com.github.javaparser.symbolsolver.model.typesystem.LazyType
Cannot solve method call writerContext.writeOption(value.toString().toLowerCase(Locale.ENGLISH)) java.lang.UnsupportedOperationException: type usage: com.github.javaparser.symbolsolver.model.typesystem.LazyType /repo/subprojects/language-java/src/main/java/org/gradle/external/javadoc/internal/EnumJavadocOptionFileOption.java
Method 'replaceAll' cannot be resolved in context value.replaceAll("\\\\", "\\\\\\\\") (line: 68) MethodCallExprContext{wrapped=value.replaceAll("\\\\", "\\\\\\\\")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call write(value.replaceAll("\\\\", "\\\\\\\\").replaceAll(SystemProperties.getInstance().getLineSeparator(), "\\\\" + SystemProperties.getInstance().getLineSeparator())) java.lang.RuntimeException: Method 'replaceAll' cannot be resolved in context value.replaceAll("\\\\", "\\\\\\\\") (line: 68) MethodCallExprContext{wrapped=value.replaceAll("\\\\", "\\\\\\\\")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/language-java/src/main/java/org/gradle/external/javadoc/internal/JavadocOptionFileWriterContext.java
Method 'write' cannot be resolved in context writerContext.writeOptionHeader(option).write("\"" + group + "\"") (line: 41) MethodCallExprContext{wrapped=writerContext.writeOptionHeader(option).write("\"" + group + "\"")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'write' cannot be resolved in context writerContext.writeOptionHeader(option).write("\"" + group + "\"") (line: 41) MethodCallExprContext{wrapped=writerContext.writeOptionHeader(option).write("\"" + group + "\"")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Error calculating the type of parameter "\"" + CollectionUtils.join(":", groupPackages) + "\"" of method call writerContext.writeOptionHeader(option).write("\"" + group + "\"").write(" ").write("\"" + CollectionUtils.join(":", groupPackages) + "\"")
Cannot solve field access JavadocOutputLevel.QUIET
Cannot solve field access JavadocMemberLevel.PUBLIC
Cannot solve field access JavadocMemberLevel.PROTECTED
Cannot solve field access JavadocMemberLevel.PACKAGE
Cannot solve method call // add additional option files
GUtil.prefix("@", GFileUtils.toPaths(optionFiles)) UnsolvedSymbolException{context='Method 'toPaths' with parameterTypes [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public class GFileUtils {

    public static FileInputStream openInputStream(File file) {
        try {
            return FileUtils.openInputStream(file);
        } catch (IOException e) {
            throw new RuntimeException("Problems opening file input stream for file: " + file, e);
        }
    }

    public static void touch(File file) {
        try {
            FileUtils.touch(file);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static void moveFile(File source, File destination) {
        try {
            FileUtils.moveFile(source, destination);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static void copyFile(File source, File destination) {
        try {
            FileUtils.copyFile(source, destination);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static void copyDirectory(File source, File destination) {
        try {
            FileUtils.copyDirectory(source, destination);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static void moveDirectory(File source, File destination) {
        try {
            FileUtils.moveDirectory(source, destination);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static String readFile(File file) {
        return readFile(file, Charset.defaultCharset().name());
    }

    public static String readFile(File file, String encoding) {
        try {
            return FileUtils.readFileToString(file, encoding);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    /**
     * Reads and returns file contents. If some exception is triggered the method returns information about this exception.
     * Useful for including file contents in debug trace / exception messages.
     *
     * @param file to read
     * @return content of the file or the problem description in case file cannot be read.
     */
    public static String readFileQuietly(File file) {
        try {
            return readFile(file);
        } catch (Exception e) {
            return "Unable to read file '" + file + "' due to: " + e.toString();
        }
    }

    public static void writeFile(String content, File destination) {
        writeFile(content, destination, Charset.defaultCharset().name());
    }

    public static void writeFile(String content, File destination, String encoding) {
        try {
            FileUtils.writeStringToFile(destination, content, encoding);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static Collection listFiles(File directory, IOFileFilter fileFilter, IOFileFilter dirFilter) {
        return FileUtils.listFiles(directory, fileFilter, dirFilter);
    }

    public static Collection listFiles(File directory, String[] extensions, boolean recursive) {
        return FileUtils.listFiles(directory, extensions, recursive);
    }

    public static List<String> toPaths(Collection<File> files) {
        List<String> paths = new ArrayList<String>();
        for (File file : files) {
            paths.add(file.getAbsolutePath());
        }
        return paths;
    }

    public static void copyURLToFile(URL source, File destination) {
        try {
            FileUtils.copyURLToFile(source, destination);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static void deleteDirectory(File directory) {
        try {
            FileUtils.deleteDirectory(directory);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static void cleanDirectory(File directory) {
        try {
            FileUtils.cleanDirectory(directory);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static boolean deleteQuietly(File file) {
        return FileUtils.deleteQuietly(file);
    }

    public static void closeInputStream(InputStream input) {
        stoppable(input).stop();
    }

    public static class TailReadingException extends RuntimeException {

        public TailReadingException(Throwable throwable) {
            super(throwable);
        }
    }

    /**
     * @param file to read from tail
     * @param maxLines max lines to read
     * @return tail content
     * @throws org.gradle.util.GFileUtils.TailReadingException when reading failed
     */
    public static String tail(File file, int maxLines) throws TailReadingException {
        BufferedReader reader = null;
        FileReader fileReader = null;
        try {
            fileReader = new FileReader(file);
            reader = new BufferedReader(fileReader);
            LimitedDescription description = new LimitedDescription(maxLines);
            String line = reader.readLine();
            while (line != null) {
                description.append(line);
                line = reader.readLine();
            }
            return description.toString();
        } catch (Exception e) {
            throw new TailReadingException(e);
        } finally {
            IOUtils.closeQuietly(fileReader);
            IOUtils.closeQuietly(reader);
        }
    }

    public static void writeStringToFile(File file, String data) {
        try {
            FileUtils.writeStringToFile(file, data);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static void forceDelete(File file) {
        try {
            FileUtils.forceDelete(file);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static Checksum checksum(File file, Checksum checksum) {
        try {
            return FileUtils.checksum(file, checksum);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    /**
     * Returns a relative path from 'from' to 'to'
     *
     * @param from where to calculate from
     * @param to where to calculate to
     * @return The relative path
     */
    public static String relativePath(File from, File to) {
        try {
            return org.apache.tools.ant.util.FileUtils.getRelativePath(from, to);
        } catch (Exception e) {
            throw UncheckedException.throwAsUncheckedException(e);
        }
    }

    /**
     * Makes the parent directory of the file, and any non existent parents.
     *
     * @param child The file to create the parent dir for
     * @return The parent dir file
     * @see #mkdirs(java.io.File)
     */
    public static File parentMkdirs(File child) {
        File parent = child.getParentFile();
        mkdirs(parent);
        return parent;
    }

    /**
     * Like {@link java.io.File#mkdirs()}, except throws an informative error if a dir cannot be created.
     *
     * @param dir The dir to create, including any non existent parent dirs.
     */
    public static void mkdirs(File dir) {
        dir = dir.getAbsoluteFile();
        if (dir.isDirectory()) {
            return;
        }
        if (dir.exists() && !dir.isDirectory()) {
            throw new UncheckedIOException(String.format("Cannot create directory '%s' as it already exists, but is not a directory", dir));
        }
        List<File> toCreate = new LinkedList<File>();
        File parent = dir.getParentFile();
        while (!parent.exists()) {
            toCreate.add(parent);
            parent = parent.getParentFile();
        }
        Collections.reverse(toCreate);
        for (File parentDirToCreate : toCreate) {
            if (parentDirToCreate.isDirectory()) {
                continue;
            }
            File parentDirToCreateParent = parentDirToCreate.getParentFile();
            if (!parentDirToCreateParent.isDirectory()) {
                throw new UncheckedIOException(String.format("Cannot create parent directory '%s' when creating directory '%s' as '%s' is not a directory", parentDirToCreate, dir, parentDirToCreateParent));
            }
            if (!parentDirToCreate.mkdir() && !parentDirToCreate.isDirectory()) {
                throw new UncheckedIOException(String.format("Failed to create parent directory '%s' when creating directory '%s'", parentDirToCreate, dir));
            }
        }
        if (!dir.mkdir() && !dir.isDirectory()) {
            throw new UncheckedIOException(String.format("Failed to create directory '%s'", dir));
        }
    }
}}'} /repo/subprojects/language-java/src/main/java/org/gradle/external/javadoc/CoreJavadocOptions.java
Cannot solve method call execHandleBuilder.args(// J flags can not be set in the option file
GUtil.prefix("-J", jFlags)) UnsolvedSymbolException{context='Method 'prefix' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public class GUtil {

    private static final Pattern WORD_SEPARATOR = Pattern.compile("\\W+");

    private static final Pattern UPPER_LOWER = Pattern.compile("(?m)([A-Z]*)([a-z0-9]*)");

    public static <T extends Collection> T flatten(Object[] elements, T addTo, boolean flattenMaps) {
        return flatten(asList(elements), addTo, flattenMaps);
    }

    public static <T extends Collection> T flatten(Object[] elements, T addTo) {
        return flatten(asList(elements), addTo);
    }

    public static <T extends Collection> T flatten(Collection elements, T addTo) {
        return flatten(elements, addTo, true);
    }

    public static <T extends Collection> T flattenElements(Object... elements) {
        Collection<T> out = new LinkedList<T>();
        flatten(elements, out, true);
        return (T) out;
    }

    public static <T extends Collection> T flatten(Collection elements, T addTo, boolean flattenMapsAndArrays) {
        return flatten(elements, addTo, flattenMapsAndArrays, flattenMapsAndArrays);
    }

    public static <T extends Collection> T flatten(Collection elements, T addTo, boolean flattenMaps, boolean flattenArrays) {
        Iterator iter = elements.iterator();
        while (iter.hasNext()) {
            Object element = iter.next();
            if (element instanceof Collection) {
                flatten((Collection) element, addTo, flattenMaps, flattenArrays);
            } else if ((element instanceof Map) && flattenMaps) {
                flatten(((Map) element).values(), addTo, flattenMaps, flattenArrays);
            } else if ((element.getClass().isArray()) && flattenArrays) {
                flatten(asList((Object[]) element), addTo, flattenMaps, flattenArrays);
            } else {
                addTo.add(element);
            }
        }
        return addTo;
    }

    /**
     * Flattens input collections (including arrays *but* not maps). If input is not a collection wraps it in a collection and returns it.
     *
     * @param input any object
     * @return collection of flattened input or single input wrapped in a collection.
     */
    public static Collection collectionize(Object input) {
        if (input == null) {
            return emptyList();
        } else if (input instanceof Collection) {
            Collection out = new LinkedList();
            flatten((Collection) input, out, false, true);
            return out;
        } else if (input.getClass().isArray()) {
            Collection out = new LinkedList();
            flatten(asList((Object[]) input), out, false, true);
            return out;
        } else {
            return asList(input);
        }
    }

    public static List flatten(Collection elements, boolean flattenMapsAndArrays) {
        return flatten(elements, new ArrayList(), flattenMapsAndArrays);
    }

    public static List flatten(Collection elements) {
        return flatten(elements, new ArrayList());
    }

    public static String asPath(Iterable<?> collection) {
        return CollectionUtils.join(File.pathSeparator, collection);
    }

    public static List<String> prefix(String prefix, Collection<String> strings) {
        List<String> prefixed = new ArrayList<String>();
        for (String string : strings) {
            prefixed.add(prefix + string);
        }
        return prefixed;
    }

    public static boolean isTrue(Object object) {
        if (object == null) {
            return false;
        }
        if (object instanceof Collection) {
            return ((Collection) object).size() > 0;
        } else if (object instanceof String) {
            return ((String) object).length() > 0;
        }
        return true;
    }

    public static <T> T elvis(T object, T defaultValue) {
        return isTrue(object) ? object : defaultValue;
    }

    public static <V, T extends Collection<? super V>> T addToCollection(T dest, boolean failOnNull, Iterable<? extends V>... srcs) {
        for (Iterable<? extends V> src : srcs) {
            for (V v : src) {
                if (failOnNull && v == null) {
                    throw new IllegalArgumentException("Illegal null value provided in this collection: " + src);
                }
                dest.add(v);
            }
        }
        return dest;
    }

    public static <V, T extends Collection<? super V>> T addToCollection(T dest, Iterable<? extends V>... srcs) {
        return addToCollection(dest, false, srcs);
    }

    public static Comparator<String> caseInsensitive() {
        return new Comparator<String>() {

            public int compare(String o1, String o2) {
                int diff = o1.compareToIgnoreCase(o2);
                if (diff != 0) {
                    return diff;
                }
                return o1.compareTo(o2);
            }
        };
    }

    public static Map addMaps(Map map1, Map map2) {
        HashMap map = new HashMap();
        map.putAll(map1);
        map.putAll(map2);
        return map;
    }

    public static void addToMap(Map<String, String> dest, Map<?, ?> src) {
        for (Map.Entry<?, ?> entry : src.entrySet()) {
            dest.put(entry.getKey().toString(), entry.getValue().toString());
        }
    }

    public static Properties loadProperties(File propertyFile) {
        try {
            FileInputStream inputStream = new FileInputStream(propertyFile);
            try {
                return loadProperties(inputStream);
            } finally {
                inputStream.close();
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static Properties loadProperties(URL url) {
        try {
            URLConnection uc = url.openConnection();
            uc.setUseCaches(false);
            return loadProperties(uc.getInputStream());
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static Properties loadProperties(InputStream inputStream) {
        Properties properties = new Properties();
        try {
            properties.load(inputStream);
            inputStream.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
        return properties;
    }

    public static void saveProperties(Properties properties, File propertyFile) {
        try {
            FileOutputStream propertiesFileOutputStream = new FileOutputStream(propertyFile);
            try {
                properties.store(propertiesFileOutputStream, null);
            } finally {
                propertiesFileOutputStream.close();
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static void saveProperties(Properties properties, OutputStream outputStream) {
        try {
            try {
                properties.store(outputStream, null);
            } finally {
                outputStream.close();
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static void savePropertiesNoDateComment(Properties properties, OutputStream outputStream) {
        saveProperties(properties, new LineBufferingOutputStream(new SkipFirstTextStream(new WriterTextStream(new OutputStreamWriter(outputStream, Charsets.ISO_8859_1)))));
    }

    public static Map map(Object... objects) {
        Map map = new HashMap();
        assert objects.length % 2 == 0;
        for (int i = 0; i < objects.length; i += 2) {
            map.put(objects[i], objects[i + 1]);
        }
        return map;
    }

    public static String toString(Iterable<?> names) {
        Formatter formatter = new Formatter();
        boolean first = true;
        for (Object name : names) {
            if (first) {
                formatter.format("'%s'", name);
                first = false;
            } else {
                formatter.format(", '%s'", name);
            }
        }
        return formatter.toString();
    }

    /**
     * Converts an arbitrary string to a camel-case string which can be used in a Java identifier. Eg, with_underscores -> withUnderscores
     */
    public static String toCamelCase(CharSequence string) {
        if (string == null) {
            return null;
        }
        StringBuilder builder = new StringBuilder();
        Matcher matcher = WORD_SEPARATOR.matcher(string);
        int pos = 0;
        while (matcher.find()) {
            builder.append(StringUtils.capitalize(string.subSequence(pos, matcher.start()).toString()));
            pos = matcher.end();
        }
        builder.append(StringUtils.capitalize(string.subSequence(pos, string.length()).toString()));
        return builder.toString();
    }

    public static String toLowerCamelCase(CharSequence string) {
        String camelCase = toCamelCase(string);
        if (camelCase == null) {
            return null;
        }
        if (camelCase.length() == 0) {
            return "";
        }
        return ((Character) camelCase.charAt(0)).toString().toLowerCase() + camelCase.subSequence(1, camelCase.length());
    }

    /**
     * Converts an arbitrary string to upper case identifier with words separated by _. Eg, camelCase -> CAMEL_CASE
     */
    public static String toConstant(CharSequence string) {
        if (string == null) {
            return null;
        }
        return toWords(string, '_').toUpperCase();
    }

    /**
     * Converts an arbitrary string to space-separated words. Eg, camelCase -> camel case, with_underscores -> with underscores
     */
    public static String toWords(CharSequence string) {
        return toWords(string, ' ');
    }

    public static String toWords(CharSequence string, char separator) {
        if (string == null) {
            return null;
        }
        StringBuilder builder = new StringBuilder();
        int pos = 0;
        Matcher matcher = UPPER_LOWER.matcher(string);
        while (pos < string.length()) {
            matcher.find(pos);
            if (matcher.end() == pos) {
                // Not looking at a match
                pos++;
                continue;
            }
            if (builder.length() > 0) {
                builder.append(separator);
            }
            String group1 = matcher.group(1).toLowerCase();
            String group2 = matcher.group(2);
            if (group2.length() == 0) {
                builder.append(group1);
            } else {
                if (group1.length() > 1) {
                    builder.append(group1.substring(0, group1.length() - 1));
                    builder.append(separator);
                    builder.append(group1.substring(group1.length() - 1));
                } else {
                    builder.append(group1);
                }
                builder.append(group2);
            }
            pos = matcher.end();
        }
        return builder.toString();
    }

    public static byte[] serialize(Object object) {
        StreamByteBuffer buffer = new StreamByteBuffer();
        serialize(object, buffer.getOutputStream());
        return buffer.readAsByteArray();
    }

    public static void serialize(Object object, OutputStream outputStream) {
        try {
            ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);
            objectOutputStream.writeObject(object);
            objectOutputStream.close();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    public static <T> Comparator<T> last(final Comparator<? super T> comparator, final T lastValue) {
        return new Comparator<T>() {

            public int compare(T o1, T o2) {
                boolean o1Last = comparator.compare(o1, lastValue) == 0;
                boolean o2Last = comparator.compare(o2, lastValue) == 0;
                if (o1Last && o2Last) {
                    return 0;
                }
                if (o1Last && !o2Last) {
                    return 1;
                }
                if (!o1Last && o2Last) {
                    return -1;
                }
                return comparator.compare(o1, o2);
            }
        };
    }

    /**
     * Calls the given callable converting any thrown exception to an unchecked exception via {@link UncheckedException#throwAsUncheckedException(Throwable)}
     *
     * @param callable The callable to call
     * @param <T> Callable's return type
     * @return The value returned by {@link Callable#call()}
     */
    public static <T> T uncheckedCall(Callable<T> callable) {
        try {
            return callable.call();
        } catch (Exception e) {
            throw UncheckedException.throwAsUncheckedException(e);
        }
    }
}}'} /repo/subprojects/language-java/src/main/java/org/gradle/external/javadoc/CoreJavadocOptions.java
Error calculating the type of parameter // J flags can not be set in the option file
GUtil.prefix("-J", jFlags) of method call execHandleBuilder.args(// J flags can not be set in the option file
GUtil.prefix("-J", jFlags))
Cannot solve field access JavadocMemberLevel.PRIVATE
Cannot solve field access JavadocOutputLevel.VERBOSE
Cannot solve field access JavadocOutputLevel.VERBOSE
Cannot solve field access JavadocOutputLevel.QUIET
Cannot solve field access ArtifactType.JAVADOC
Method 'maybeRegisterComponentType' cannot be resolved in context componentTypeRegistry.maybeRegisterComponentType(JvmLibrary.class) (line: 50) MethodCallExprContext{wrapped=componentTypeRegistry.maybeRegisterComponentType(JvmLibrary.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.jvm.JvmLibrary, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call compile.setToolChain(assembly.getToolChain()) java.lang.RuntimeException: Method 'getToolChain' cannot be resolved in context assembly.getToolChain() (line: 162) MethodCallExprContext{wrapped=assembly.getToolChain()}. Parameter types: [] /repo/subprojects/language-java/src/main/java/org/gradle/language/java/plugins/JavaLanguagePlugin.java
Cannot solve method call first(assembly.getClassDirectories()) java.lang.RuntimeException: Method 'getClassDirectories' cannot be resolved in context assembly.getClassDirectories() (line: 171) MethodCallExprContext{wrapped=assembly.getClassDirectories()}. Parameter types: [] /repo/subprojects/language-java/src/main/java/org/gradle/language/java/plugins/JavaLanguagePlugin.java
Cannot solve method call collect(repositories, Transformers.cast(ResolutionAwareRepository.class)) UnsolvedSymbolException{context='Method 'cast' with parameterTypes [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.internal.artifacts.repositories.ResolutionAwareRepository, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * Utility transformers.
 */
public abstract class Transformers {

    /**
     * Creates a transformer that simply type casts the input to the given output type.
     *
     * @param outputType The type to cast the input to
     * @param <O> The type of the transformed object
     * @param <I> The type of the object to be transformed
     * @return A transformer that simply type casts the input to the given output type.
     */
    public static <O, I> Transformer<O, I> cast(Class<O> outputType) {
        return new CastingTransformer<O, I>(outputType);
    }

    // just returns the original object
    public static <T> Transformer<T, T> noOpTransformer() {
        return new Transformer<T, T>() {

            public T transform(T original) {
                return original;
            }
        };
    }

    private static class CastingTransformer<O, I> implements Transformer<O, I> {

        final Class<O> outputType;

        public CastingTransformer(Class<O> outputType) {
            this.outputType = outputType;
        }

        public O transform(I input) {
            return Cast.cast(outputType, input);
        }
    }

    public static <T> Transformer<String, T> asString() {
        return new ToStringTransformer<T>();
    }

    private static class ToStringTransformer<T> implements Transformer<String, T> {

        public String transform(T original) {
            return original == null ? null : original.toString();
        }
    }

    /**
     * Returns a transformer that names {@link Named} objects.
     *
     * Nulls are returned as null.
     *
     * @return The naming transformer.
     */
    public static Transformer<String, Named> name() {
        return name(Named.Namer.INSTANCE);
    }

    /**
     * Returns a transformer that names objects with the given {@link Namer}
     *
     * @param namer The namer to name the objects with
     * @param <T> The type of objects to be named
     * @return The naming transformer.
     */
    public static <T> Transformer<String, T> name(Namer<? super T> namer) {
        return new ToNameTransformer<T>(namer);
    }

    private static class ToNameTransformer<T> implements Transformer<String, T> {

        private final Namer<? super T> namer;

        public ToNameTransformer(Namer<? super T> namer) {
            this.namer = namer;
        }

        public String transform(T thing) {
            return thing == null ? null : namer.determineName(thing);
        }
    }

    /**
     * Transforms strings which may have spaces and which may have already been escaped with
     * quotes into safe command-line arguments.
     */
    public static Transformer<String, String> asSafeCommandLineArgument() {
        return new CommandLineArgumentTransformer();
    }

    private static class CommandLineArgumentTransformer implements Transformer<String, String> {

        private static final Pattern SINGLE_QUOTED = Pattern.compile("^'.*'$");

        private static final Pattern DOUBLE_QUOTED = Pattern.compile("^\".*\"$");

        private static final Pattern A_SINGLE_QUOTE = Pattern.compile("'");

        @Override
        public String transform(String input) {
            if (SINGLE_QUOTED.matcher(input).matches() || DOUBLE_QUOTED.matcher(input).matches() || !input.contains(" ")) {
                return input;
            } else {
                return wrapWithSingleQuotes(input);
            }
        }

        private String wrapWithSingleQuotes(String input) {
            return String.format("'%1$s'", escapeSingleQuotes(input));
        }

        private String escapeSingleQuotes(String input) {
            return A_SINGLE_QUOTE.matcher(input).replaceAll("\\\\'");
        }
    }

    /**
     * A getClass() transformer.
     *
     * @param <T> The type of the object
     * @return A getClass() transformer.
     */
    public static <T> Transformer<Class<T>, T> type() {
        return new Transformer<Class<T>, T>() {

            public Class<T> transform(T original) {
                @SuppressWarnings("unchecked") Class<T> aClass = (Class<T>) original.getClass();
                return aClass;
            }
        };
    }

    public static <R> Transformer<R, Object> toTransformer(final Factory<R> factory) {
        return new Transformer<R, Object>() {

            public R transform(Object original) {
                return factory.create();
            }
        };
    }

    public static <R, I> Transformer<R, I> toTransformer(final Action<? super I> action) {
        return new Transformer<R, I>() {

            public R transform(I original) {
                action.execute(original);
                return null;
            }
        };
    }

    /**
     * Converts a URL to a URI
     */
    public static Transformer<URL, URI> toURL() {
        return new Transformer<URL, URI>() {

            public URL transform(URI original) {
                try {
                    return original.toURL();
                } catch (MalformedURLException e) {
                    throw UncheckedException.throwAsUncheckedException(e);
                }
            }
        };
    }

    /**
     * Always returns the given argument.
     */
    public static <T, I> Transformer<T, I> constant(final T t) {
        return new Transformer<T, I>() {

            public T transform(I original) {
                return t;
            }
        };
    }
}}'} /repo/subprojects/language-java/src/main/java/org/gradle/language/java/plugins/JavaLanguagePlugin.java
Cannot solve method call String.format("Cannot create a compiler for a spec with type %s", type.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context type.getSimpleName() (line: 50) MethodCallExprContext{wrapped=type.getSimpleName()}. Parameter types: [] /repo/subprojects/language-java/src/main/java/org/gradle/api/internal/tasks/compile/DefaultJavaCompilerFactory.java
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
Method 'getProject' cannot be resolved in context ant.getProject() (line: 54) MethodCallExprContext{wrapped=ant.getProject()}. Parameter types: []
expected either zero type arguments or has many as defined in the declaration (0). Found 2
Cannot resolve field access null
Cannot solve field access FileCollection.AntType.MatchingTask
Method 'getSource' cannot be resolved in context getSource() (line: 58) MethodCallExprContext{wrapped=getSource()}. Parameter types: []
Cannot solve method call compiler.getStandardFileManager(null, null, compileOptions.getEncoding() != null ? Charset.forName(compileOptions.getEncoding()) : null) UnsolvedSymbolException{context='Method 'forName' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=java.nio.charset.Charset}'} /repo/subprojects/language-java/src/main/java/org/gradle/api/internal/tasks/compile/JdkJavaCompiler.java
Cannot solve method call spec.getCompileOptions().setCompilerArgs(CollectionUtils.toStringList(spec.getCompileOptions().getCompilerArgs())) UnsolvedSymbolException{context='Method 'toStringList' with parameterTypes [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class CollectionUtils {

    /**
     * Returns null if the collection is empty otherwise expects a {@link #single(Iterable)} element to be found.
     */
    @Nullable
    public static <T> T findSingle(Collection<T> source) {
        return source.isEmpty() ? null : single(source);
    }

    /**
     * Returns the single element in the collection or throws.
     */
    public static <T> T single(Iterable<? extends T> source) {
        Iterator<? extends T> iterator = source.iterator();
        if (!iterator.hasNext()) {
            throw new NoSuchElementException("Expecting collection with single element, got none.");
        }
        T element = iterator.next();
        if (iterator.hasNext()) {
            throw new IllegalArgumentException("Expecting collection with single element, got multiple.");
        }
        return element;
    }

    public static <T> Collection<? extends T> checkedCast(Class<T> type, Collection<?> input) {
        for (Object o : input) {
            cast(type, o);
        }
        return Cast.uncheckedCast(input);
    }

    public static <T> T findFirst(Iterable<? extends T> source, Spec<? super T> filter) {
        for (T item : source) {
            if (filter.isSatisfiedBy(item)) {
                return item;
            }
        }
        return null;
    }

    public static <T> T findFirst(T[] source, Spec<? super T> filter) {
        for (T thing : source) {
            if (filter.isSatisfiedBy(thing)) {
                return thing;
            }
        }
        return null;
    }

    public static <T> T first(Iterable<? extends T> source) {
        return source.iterator().next();
    }

    public static <T> boolean any(Iterable<? extends T> source, Spec<? super T> filter) {
        return findFirst(source, filter) != null;
    }

    public static <T> boolean any(T[] source, Spec<? super T> filter) {
        return findFirst(source, filter) != null;
    }

    public static <T> Set<T> filter(Set<? extends T> set, Spec<? super T> filter) {
        return filter(set, new LinkedHashSet<T>(), filter);
    }

    public static <T> List<T> filter(List<? extends T> list, Spec<? super T> filter) {
        return filter(list, new LinkedList<T>(), filter);
    }

    public static <T> List<T> filter(T[] array, Spec<? super T> filter) {
        return filter(Arrays.asList(array), new LinkedList<T>(), filter);
    }

    /**
     * Returns a sorted copy of the provided collection of things. Uses the provided comparator to sort.
     */
    public static <T> List<T> sort(Iterable<? extends T> things, Comparator<? super T> comparator) {
        List<T> copy = toMutableList(things);
        Collections.sort(copy, comparator);
        return copy;
    }

    /**
     * Returns a sorted copy of the provided collection of things. Uses the natural ordering of the things.
     */
    public static <T extends Comparable> List<T> sort(Iterable<T> things) {
        List<T> copy = toMutableList(things);
        Collections.sort(copy);
        return copy;
    }

    public static <T, C extends Collection<T>> C filter(Iterable<? extends T> source, C destination, Spec<? super T> filter) {
        for (T item : source) {
            if (filter.isSatisfiedBy(item)) {
                destination.add(item);
            }
        }
        return destination;
    }

    public static <K, V> Map<K, V> filter(Map<K, V> map, Spec<Map.Entry<K, V>> filter) {
        return filter(map, new HashMap<K, V>(), filter);
    }

    public static <K, V> Map<K, V> filter(Map<K, V> map, Map<K, V> destination, Spec<Map.Entry<K, V>> filter) {
        for (Map.Entry<K, V> entry : map.entrySet()) {
            if (filter.isSatisfiedBy(entry)) {
                destination.put(entry.getKey(), entry.getValue());
            }
        }
        return destination;
    }

    public static <R, I> R[] collectArray(I[] list, Class<R> newType, Transformer<? extends R, ? super I> transformer) {
        @SuppressWarnings("unchecked") R[] destination = (R[]) Array.newInstance(newType, list.length);
        return collectArray(list, destination, transformer);
    }

    public static <R, I> R[] collectArray(I[] list, R[] destination, Transformer<? extends R, ? super I> transformer) {
        assert list.length <= destination.length;
        for (int i = 0; i < list.length; ++i) {
            destination[i] = transformer.transform(list[i]);
        }
        return destination;
    }

    public static <R, I> List<R> collect(List<? extends I> list, Transformer<? extends R, ? super I> transformer) {
        return collect(list, new ArrayList<R>(list.size()), transformer);
    }

    public static <R, I> List<R> collect(I[] list, Transformer<? extends R, ? super I> transformer) {
        return collect(Arrays.asList(list), transformer);
    }

    public static <R, I> Set<R> collect(Set<? extends I> set, Transformer<? extends R, ? super I> transformer) {
        return collect(set, new HashSet<R>(), transformer);
    }

    public static <R, I> List<R> collect(Iterable<? extends I> source, Transformer<? extends R, ? super I> transformer) {
        return collect(source, new LinkedList<R>(), transformer);
    }

    public static <R, I, C extends Collection<R>> C collect(Iterable<? extends I> source, C destination, Transformer<? extends R, ? super I> transformer) {
        for (I item : source) {
            destination.add(transformer.transform(item));
        }
        return destination;
    }

    public static List<String> toStringList(Iterable<?> iterable) {
        return collect(iterable, new LinkedList<String>(), Transformers.asString());
    }

    /**
     * Recursively unpacks all the given things into a flat list.
     *
     * Nulls are not removed, they are left intact.
     *
     * @param things The things to flatten
     * @return A flattened list of the given things
     */
    public static List<?> flattenCollections(Object... things) {
        return flattenCollections(Object.class, things);
    }

    /**
     * Recursively unpacks all the given things into a flat list, ensuring they are of a certain type.
     *
     * Nulls are not removed, they are left intact.
     *
     * If a non null object cannot be cast to the target type, a ClassCastException will be thrown.
     *
     * @param things The things to flatten
     * @param <T> The target type in the flattened list
     * @return A flattened list of the given things
     */
    public static <T> List<T> flattenCollections(Class<T> type, Object... things) {
        if (things == null) {
            return Collections.singletonList(null);
        } else if (things.length == 0) {
            return Collections.emptyList();
        } else if (things.length == 1) {
            Object thing = things[0];
            if (thing == null) {
                return Collections.singletonList(null);
            }
            if (thing.getClass().isArray()) {
                Object[] thingArray = (Object[]) thing;
                List<T> list = new ArrayList<T>(thingArray.length);
                for (Object thingThing : thingArray) {
                    list.addAll(flattenCollections(type, thingThing));
                }
                return list;
            }
            if (thing instanceof Collection) {
                Collection<?> collection = (Collection<?>) thing;
                List<T> list = new ArrayList<T>();
                for (Object element : collection) {
                    list.addAll(flattenCollections(type, element));
                }
                return list;
            }
            return Collections.singletonList(cast(type, thing));
        } else {
            List<T> list = new ArrayList<T>();
            for (Object thing : things) {
                list.addAll(flattenCollections(type, thing));
            }
            return list;
        }
    }

    public static <T> List<T> toList(Iterable<? extends T> things) {
        if (things instanceof List) {
            @SuppressWarnings("unchecked") List<T> castThings = (List<T>) things;
            return castThings;
        }
        return toMutableList(things);
    }

    public static <T> List<T> toList(Enumeration<? extends T> things) {
        AbstractList<T> list = new ArrayList<T>();
        while (things.hasMoreElements()) {
            list.add(things.nextElement());
        }
        return list;
    }

    private static <T> List<T> toMutableList(Iterable<? extends T> things) {
        if (things == null) {
            return new ArrayList<T>(0);
        }
        List<T> list = new ArrayList<T>();
        for (T thing : things) {
            list.add(thing);
        }
        return list;
    }

    public static <T> List<T> intersection(Collection<? extends Collection<T>> availableValuesByDescriptor) {
        List<T> result = new ArrayList<T>();
        Iterator<? extends Collection<T>> iterator = availableValuesByDescriptor.iterator();
        if (iterator.hasNext()) {
            Collection<T> firstSet = iterator.next();
            result.addAll(firstSet);
            while (iterator.hasNext()) {
                Collection<T> next = iterator.next();
                result.retainAll(next);
            }
        }
        return result;
    }

    public static <T> List<T> toList(T[] things) {
        if (things == null || things.length == 0) {
            return new ArrayList<T>(0);
        }
        List<T> list = new ArrayList<T>(things.length);
        Collections.addAll(list, things);
        return list;
    }

    public static <T> Set<T> toSet(Iterable<? extends T> things) {
        if (things == null) {
            return new HashSet<T>(0);
        }
        if (things instanceof Set) {
            @SuppressWarnings("unchecked") Set<T> castThings = (Set<T>) things;
            return castThings;
        }
        Set<T> set = new LinkedHashSet<T>();
        for (T thing : things) {
            set.add(thing);
        }
        return set;
    }

    public static <E> List<E> compact(List<E> list) {
        boolean foundAtLeastOneNull = false;
        List<E> compacted = null;
        int i = 0;
        for (E element : list) {
            if (element == null) {
                if (!foundAtLeastOneNull) {
                    compacted = new ArrayList<E>(list.size());
                    if (i > 0) {
                        compacted.addAll(list.subList(0, i));
                    }
                }
                foundAtLeastOneNull = true;
            } else if (foundAtLeastOneNull) {
                compacted.add(element);
            }
            ++i;
        }
        return foundAtLeastOneNull ? compacted : list;
    }

    public static <C extends Collection<String>> C stringize(Iterable<?> source, C destination) {
        return collect(source, destination, Transformers.asString());
    }

    public static List<String> stringize(Collection<?> source) {
        return stringize(source, new ArrayList<String>(source.size()));
    }

    public static <E> boolean replace(List<E> list, Spec<? super E> filter, Transformer<? extends E, ? super E> transformer) {
        boolean replaced = false;
        int i = 0;
        for (E it : list) {
            if (filter.isSatisfiedBy(it)) {
                list.set(i, transformer.transform(it));
                replaced = true;
            }
            ++i;
        }
        return replaced;
    }

    public static <K, V> void collectMap(Map<K, V> destination, Iterable<? extends V> items, Transformer<? extends K, ? super V> keyGenerator) {
        for (V item : items) {
            destination.put(keyGenerator.transform(item), item);
        }
    }

    /**
     * Given a set of values, derive a set of keys and return a map
     */
    public static <K, V> Map<K, V> collectMap(Iterable<? extends V> items, Transformer<? extends K, ? super V> keyGenerator) {
        Map<K, V> map = new LinkedHashMap<K, V>();
        collectMap(map, items, keyGenerator);
        return map;
    }

    public static <K, V> void collectMapValues(Map<K, V> destination, Iterable<? extends K> keys, Transformer<? extends V, ? super K> keyGenerator) {
        for (K item : keys) {
            destination.put(item, keyGenerator.transform(item));
        }
    }

    /**
     * Given a set of keys, derive a set of values and return a map
     */
    public static <K, V> Map<K, V> collectMapValues(Iterable<? extends K> keys, Transformer<? extends V, ? super K> keyGenerator) {
        Map<K, V> map = new LinkedHashMap<K, V>();
        collectMapValues(map, keys, keyGenerator);
        return map;
    }

    public static <T> boolean every(Iterable<? extends T> things, Spec<? super T> predicate) {
        for (T thing : things) {
            if (!predicate.isSatisfiedBy(thing)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Utility for adding an iterable to a collection.
     *
     * @param t1 The collection to add to
     * @param t2 The iterable to add each item of to the collection
     * @param <T> The element type of t1
     * @return t1
     */
    public static <T> Collection<T> addAll(Collection<T> t1, Iterable<? extends T> t2) {
        for (T t : t2) {
            t1.add(t);
        }
        return t1;
    }

    /**
     * Utility for adding an array to a collection.
     *
     * @param t1 The collection to add to
     * @param t2 The iterable to add each item of to the collection
     * @param <T> The element type of t1
     * @return t1
     */
    public static <T> Collection<T> addAll(Collection<T> t1, T... t2) {
        Collections.addAll(t1, t2);
        return t1;
    }

    /**
     * The result of diffing two sets.
     *
     * @param <T> The type of element the sets contain
     * @see CollectionUtils#diffSetsBy(java.util.Set, java.util.Set, org.gradle.api.Transformer)
     */
    public static class SetDiff<T> {

        public Set<T> leftOnly = new HashSet<T>();

        public Set<Pair<T, T>> common = new HashSet<Pair<T, T>>();

        public Set<T> rightOnly = new HashSet<T>();
    }

    /**
     * Provides a “diff report” of how the two sets are similar and how they are different, comparing the entries by some aspect.
     *
     * The transformer is used to generate the value to use to compare the entries by. That is, the entries are not compared by equals by an attribute or characteristic.
     *
     * The transformer is expected to produce a unique value for each entry in a single set. Behaviour is undefined if this condition is not met.
     *
     * @param left The set on the “left” side of the comparison.
     * @param right The set on the “right” side of the comparison.
     * @param compareBy Provides the value to compare entries from either side by
     * @param <T> The type of the entry objects
     * @return A representation of the difference
     */
    public static <T> SetDiff<T> diffSetsBy(Set<? extends T> left, Set<? extends T> right, Transformer<?, T> compareBy) {
        if (left == null) {
            throw new NullPointerException("'left' set is null");
        }
        if (right == null) {
            throw new NullPointerException("'right' set is null");
        }
        SetDiff<T> setDiff = new SetDiff<T>();
        Map<Object, T> indexedLeft = collectMap(left, compareBy);
        Map<Object, T> indexedRight = collectMap(right, compareBy);
        for (Map.Entry<Object, T> leftEntry : indexedLeft.entrySet()) {
            T rightValue = indexedRight.remove(leftEntry.getKey());
            if (rightValue == null) {
                setDiff.leftOnly.add(leftEntry.getValue());
            } else {
                Pair<T, T> pair = Pair.of(leftEntry.getValue(), rightValue);
                setDiff.common.add(pair);
            }
        }
        for (T rightValue : indexedRight.values()) {
            setDiff.rightOnly.add(rightValue);
        }
        return setDiff;
    }

    /**
     * Creates a string with {@code toString()} of each object with the given separator.
     *
     * <pre>
     * expect:
     * join(",", new Object[]{"a"}) == "a"
     * join(",", new Object[]{"a", "b", "c"}) == "a,b,c"
     * join(",", new Object[]{}) == ""
     * </pre>
     *
     * The {@code separator} must not be null and {@code objects} must not be null.
     *
     * @param separator The string by which to join each string representation
     * @param objects The objects to join the string representations of
     * @return The joined string
     */
    public static String join(String separator, Object[] objects) {
        return join(separator, objects == null ? null : Arrays.asList(objects));
    }

    /**
     * Creates a string with {@code toString()} of each object with the given separator.
     *
     * <pre>
     * expect:
     * join(",", ["a"]) == "a"
     * join(",", ["a", "b", "c"]) == "a,b,c"
     * join(",", []) == ""
     * </pre>
     *
     * The {@code separator} must not be null and {@code objects} must not be null.
     *
     * @param separator The string by which to join each string representation
     * @param objects The objects to join the string representations of
     * @return The joined string
     */
    public static String join(String separator, Iterable<?> objects) {
        if (separator == null) {
            throw new NullPointerException("The 'separator' cannot be null");
        }
        if (objects == null) {
            throw new NullPointerException("The 'objects' cannot be null");
        }
        StringBuilder string = new StringBuilder();
        Iterator<?> iterator = objects.iterator();
        if (iterator.hasNext()) {
            string.append(iterator.next().toString());
            while (iterator.hasNext()) {
                string.append(separator);
                string.append(iterator.next().toString());
            }
        }
        return string.toString();
    }

    /**
     * Partition given Collection into a Pair of Collections.
     *
     * <pre>Left</pre> Collection containing entries that satisfy the given predicate
     * <pre>Right</pre> Collection containing entries that do NOT satisfy the given predicate
     */
    public static <T> Pair<Collection<T>, Collection<T>> partition(Iterable<T> items, Spec<? super T> predicate) {
        Preconditions.checkNotNull(items, "Cannot partition null Collection");
        Preconditions.checkNotNull(predicate, "Cannot apply null Spec when partitioning");
        Collection<T> left = new LinkedList<T>();
        Collection<T> right = new LinkedList<T>();
        for (T item : items) {
            if (predicate.isSatisfiedBy(item)) {
                left.add(item);
            } else {
                right.add(item);
            }
        }
        return Pair.of(left, right);
    }

    public static class InjectionStep<T, I> {

        private final T target;

        private final I item;

        public InjectionStep(T target, I item) {
            this.target = target;
            this.item = item;
        }

        public T getTarget() {
            return target;
        }

        public I getItem() {
            return item;
        }
    }

    public static <T, I> T inject(T target, Iterable<? extends I> items, Action<InjectionStep<T, I>> action) {
        if (target == null) {
            throw new NullPointerException("The 'target' cannot be null");
        }
        if (items == null) {
            throw new NullPointerException("The 'items' cannot be null");
        }
        if (action == null) {
            throw new NullPointerException("The 'action' cannot be null");
        }
        for (I item : items) {
            action.execute(new InjectionStep<T, I>(target, item));
        }
        return target;
    }

    public static <K, V> ImmutableListMultimap<K, V> groupBy(Iterable<? extends V> iterable, Transformer<? extends K, V> grouper) {
        ImmutableListMultimap.Builder<K, V> builder = ImmutableListMultimap.builder();
        for (V element : iterable) {
            K key = grouper.transform(element);
            builder.put(key, element);
        }
        return builder.build();
    }

    public static <T> Iterable<? extends T> unpack(final Iterable<? extends Factory<? extends T>> factories) {
        return new Iterable<T>() {

            private final Iterator<? extends Factory<? extends T>> delegate = factories.iterator();

            public Iterator<T> iterator() {
                return new Iterator<T>() {

                    public boolean hasNext() {
                        return delegate.hasNext();
                    }

                    public T next() {
                        return delegate.next().create();
                    }

                    public void remove() {
                        throw new UnsupportedOperationException();
                    }
                };
            }
        };
    }

    @Nullable
    public static <T> List<T> nonEmptyOrNull(Iterable<T> iterable) {
        ImmutableList<T> list = ImmutableList.copyOf(iterable);
        return list.isEmpty() ? null : list;
    }

    public static <T> List<T> dedup(Iterable<T> source, final Equivalence<? super T> equivalence) {
        Iterable<Equivalence.Wrapper<T>> wrappers = Iterables.transform(source, new Function<T, Equivalence.Wrapper<T>>() {

            public Equivalence.Wrapper<T> apply(@Nullable T input) {
                return equivalence.wrap(input);
            }
        });
        Set<Equivalence.Wrapper<T>> deduped = ImmutableSet.copyOf(wrappers);
        return ImmutableList.copyOf(Iterables.transform(deduped, new Function<Equivalence.Wrapper<T>, T>() {

            public T apply(Equivalence.Wrapper<T> input) {
                return input.get();
            }
        }));
    }

    public static String asCommandLine(Iterable<String> arguments) {
        return Joiner.on(" ").join(collect(arguments, Transformers.asSafeCommandLineArgument()));
    }
}}'} /repo/subprojects/language-java/src/main/java/org/gradle/api/internal/tasks/compile/NormalizingJavaCompiler.java
Cannot solve method call args.add("-J-Xms" + forkOptions.getMemoryInitialSize().trim()) java.lang.RuntimeException: Method 'trim' cannot be resolved in context forkOptions.getMemoryInitialSize().trim() (line: 104) MethodCallExprContext{wrapped=forkOptions.getMemoryInitialSize().trim()}. Parameter types: [] /repo/subprojects/language-java/src/main/java/org/gradle/api/internal/tasks/compile/JavaCompilerArgumentsBuilder.java
Cannot solve method call args.add("-J-Xmx" + forkOptions.getMemoryMaximumSize().trim()) java.lang.RuntimeException: Method 'trim' cannot be resolved in context forkOptions.getMemoryMaximumSize().trim() (line: 107) MethodCallExprContext{wrapped=forkOptions.getMemoryMaximumSize().trim()}. Parameter types: [] /repo/subprojects/language-java/src/main/java/org/gradle/api/internal/tasks/compile/JavaCompilerArgumentsBuilder.java
Cannot solve method call args.add("-g:" + compileOptions.getDebugOptions().getDebugLevel().trim()) java.lang.RuntimeException: Method 'trim' cannot be resolved in context compileOptions.getDebugOptions().getDebugLevel().trim() (line: 149) MethodCallExprContext{wrapped=compileOptions.getDebugOptions().getDebugLevel().trim()}. Parameter types: [] /repo/subprojects/language-java/src/main/java/org/gradle/api/internal/tasks/compile/JavaCompilerArgumentsBuilder.java
Method 'iterator' cannot be resolved in context classpath.iterator() (line: 170) MethodCallExprContext{wrapped=classpath.iterator()}. Parameter types: []
Method 'iterator' cannot be resolved in context classpath.iterator() (line: 195) MethodCallExprContext{wrapped=classpath.iterator()}. Parameter types: []
Cannot solve method call args.add(Joiner.on(File.pathSeparatorChar).join(classpath)) UnsolvedSymbolException{context='Method 'on' with parameterTypes [PrimitiveTypeUsage{name='char'}]', name='ReflectionClassDeclaration{clazz=Joiner}'} /repo/subprojects/language-java/src/main/java/org/gradle/api/internal/tasks/compile/JavaCompilerArgumentsBuilder.java
Cannot solve method call spec.setClasspath(Iterables.concat(spec.getClasspath(), asList(spec.getDestinationDir()))) UnsolvedSymbolException{context='Method 'concat' with parameterTypes [ReferenceType{Iterable, typeParametersMap=TypeParametersMap{nameToValue={empty.BlockDoc=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {java.util.Arrays.asList(T...).T}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/language-java/src/main/java/org/gradle/api/internal/tasks/compile/incremental/IncrementalCompilationInitializer.java
Method 'fileTree' cannot be resolved in context fileOperations.fileTree(spec.getDestinationDir()) (line: 55) MethodCallExprContext{wrapped=fileOperations.fileTree(spec.getDestinationDir())}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call classesToDelete.include(path.concat(".class")) java.lang.RuntimeException: Method 'concat' cannot be resolved in context path.concat(".class") (line: 63) MethodCallExprContext{wrapped=path.concat(".class")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/language-java/src/main/java/org/gradle/api/internal/tasks/compile/incremental/IncrementalCompilationInitializer.java
Cannot solve method call classesToDelete.include(path.concat("$*.class")) java.lang.RuntimeException: Method 'concat' cannot be resolved in context path.concat("$*.class") (line: 64) MethodCallExprContext{wrapped=path.concat("$*.class")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/language-java/src/main/java/org/gradle/api/internal/tasks/compile/incremental/IncrementalCompilationInitializer.java
Cannot solve method call sourceToCompile.include(path.concat(".java")) java.lang.RuntimeException: Method 'concat' cannot be resolved in context path.concat(".java") (line: 68) MethodCallExprContext{wrapped=path.concat(".java")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/language-java/src/main/java/org/gradle/api/internal/tasks/compile/incremental/IncrementalCompilationInitializer.java
Method 'getClassName' cannot be resolved in context classReader.getClassName() (line: 49) MethodCallExprContext{wrapped=classReader.getClassName()}. Parameter types: []
Method 'replaceAll' cannot be resolved in context fileDetails.getPath().replaceAll("/", ".") (line: 51) MethodCallExprContext{wrapped=fileDetails.getPath().replaceAll("/", ".")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call contents.matching(patternSetFactory.create().include("**/*.class")) java.lang.RuntimeException: Method 'include' cannot be resolved in context patternSetFactory.create().include("**/*.class") (line: 30) MethodCallExprContext{wrapped=patternSetFactory.create().include("**/*.class")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/language-java/src/main/java/org/gradle/api/internal/tasks/compile/incremental/jar/JarArchive.java
Method 'replaceAll' cannot be resolved in context path.replaceAll("/", ".") (line: 36) MethodCallExprContext{wrapped=path.replaceAll("/", ".")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call reader.accept(visitor, ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES) UnsolvedSymbolException{context='unknown', name='SKIP_DEBUG', typeSolver=null} /repo/subprojects/language-java/src/main/java/org/gradle/api/internal/tasks/compile/incremental/analyzer/DefaultClassDependenciesAnalyzer.java
Cannot resolve field access null
Cannot resolve field access null
Method 'replaceAll' cannot be resolved in context fileDetails.getPath().replaceAll("/", ".") (line: 53) MethodCallExprContext{wrapped=fileDetails.getPath().replaceAll("/", ".")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Method 'replaceAll' cannot be resolved in context relativePath.replaceAll("/", ".") (line: 40) MethodCallExprContext{wrapped=relativePath.replaceAll("/", ".")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getDeclaredMethod' cannot be resolved in context clazz.getDeclaredMethod("getSystemJavaCompiler") (line: 92) MethodCallExprContext{wrapped=clazz.getDeclaredMethod("getSystemJavaCompiler")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call DirectInstantiator.instantiate(clazz.asSubclass(JavaCompiler.class)) java.lang.RuntimeException: Method 'asSubclass' cannot be resolved in context clazz.asSubclass(JavaCompiler.class) (line: 106) MethodCallExprContext{wrapped=clazz.asSubclass(JavaCompiler.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{javax.tools.JavaCompiler, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/language-java/src/main/java/org/gradle/api/internal/tasks/compile/JdkTools.java
Cannot solve method call String.format("Don't know how to provide tool of type %s.", toolType.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context toolType.getSimpleName() (line: 83) MethodCallExprContext{wrapped=toolType.getSimpleName()}. Parameter types: [] /repo/subprojects/language-java/src/main/java/org/gradle/api/internal/tasks/DefaultJavaToolChain.java
Cannot solve method call String.format("Could not target platform: '%s' using tool chain: '%s'.", targetPlatform.getDisplayName(), DefaultJavaToolChain.this.getDisplayName()) java.lang.RuntimeException: Method 'getDisplayName' cannot be resolved in context DefaultJavaToolChain.this.getDisplayName() (line: 124) MethodCallExprContext{wrapped=DefaultJavaToolChain.this.getDisplayName()}. Parameter types: [] /repo/subprojects/language-java/src/main/java/org/gradle/api/internal/tasks/DefaultJavaToolChain.java
Cannot solve field access PathSensitivity.NAME_ONLY
Cannot solve method call CompilerUtil.castCompiler(((JavaToolChainInternal) getToolChain()).select(getPlatform()).newCompiler(spec.getClass())) java.lang.RuntimeException: Method 'newCompiler' cannot be resolved in context ((JavaToolChainInternal) getToolChain()).select(getPlatform()).newCompiler(spec.getClass()) (line: 178) MethodCallExprContext{wrapped=((JavaToolChainInternal) getToolChain()).select(getPlatform()).newCompiler(spec.getClass())}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}] /repo/subprojects/language-java/src/main/java/org/gradle/api/tasks/compile/JavaCompile.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve field access PathSensitivity.RELATIVE
Cannot solve method call getProject().configure(getOptions(), block) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/language-java/src/main/java/org/gradle/api/tasks/javadoc/Javadoc.java
Cannot solve field access ArtifactType.SOURCES
Method 'maybeRegisterComponentType' cannot be resolved in context componentTypeRegistry.maybeRegisterComponentType(JvmLibrary.class) (line: 54) MethodCallExprContext{wrapped=componentTypeRegistry.maybeRegisterComponentType(JvmLibrary.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.jvm.JvmLibrary, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call resourcesTask.setDestinationDir(first(assembly.getResourceDirectories())) java.lang.RuntimeException: Method 'first' cannot be resolved in context first(assembly.getResourceDirectories()) (line: 107) MethodCallExprContext{wrapped=first(assembly.getResourceDirectories())}. Parameter types: [ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/language-jvm/src/main/java/org/gradle/language/jvm/plugins/JvmResourcesPlugin.java
Method 'trim' cannot be resolved in context heapSize.trim() (line: 94) MethodCallExprContext{wrapped=heapSize.trim()}. Parameter types: []
Cannot solve method call normalized.substring(0, normalized.length() - 1) java.lang.RuntimeException: Method 'length' cannot be resolved in context normalized.length() (line: 97) MethodCallExprContext{wrapped=normalized.length()}. Parameter types: [] /repo/subprojects/language-jvm/src/main/java/org/gradle/api/internal/tasks/compile/daemon/DaemonForkOptions.java
Cannot solve method call Integer.parseInt(normalized.substring(0, normalized.length() - 1)) java.lang.RuntimeException: Error calculating the type of parameter normalized.length() - 1 of method call normalized.substring(0, normalized.length() - 1) /repo/subprojects/language-jvm/src/main/java/org/gradle/api/internal/tasks/compile/daemon/DaemonForkOptions.java
Cannot solve method call normalized.substring(0, normalized.length() - 1) java.lang.RuntimeException: Method 'length' cannot be resolved in context normalized.length() (line: 100) MethodCallExprContext{wrapped=normalized.length()}. Parameter types: [] /repo/subprojects/language-jvm/src/main/java/org/gradle/api/internal/tasks/compile/daemon/DaemonForkOptions.java
Cannot solve method call Integer.parseInt(normalized.substring(0, normalized.length() - 1)) java.lang.RuntimeException: Error calculating the type of parameter normalized.length() - 1 of method call normalized.substring(0, normalized.length() - 1) /repo/subprojects/language-jvm/src/main/java/org/gradle/api/internal/tasks/compile/daemon/DaemonForkOptions.java
Cannot solve method call normalized.add(jvmArg.trim()) java.lang.RuntimeException: Method 'trim' cannot be resolved in context jvmArg.trim() (line: 116) MethodCallExprContext{wrapped=jvmArg.trim()}. Parameter types: [] /repo/subprojects/language-jvm/src/main/java/org/gradle/api/internal/tasks/compile/daemon/DaemonForkOptions.java
Cannot solve method call map.put(getAntPropertyName(field.getName()), getAntPropertyValue(field.getName(), value)) java.lang.RuntimeException: Method 'getAntPropertyName' cannot be resolved in context getAntPropertyName(field.getName()) (line: 79) MethodCallExprContext{wrapped=getAntPropertyName(field.getName())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/language-jvm/src/main/java/org/gradle/api/tasks/compile/AbstractOptions.java
Method 'withType' cannot be resolved in context project.getTasks().withType(PrefixHeaderFileGenerateTask.class) (line: 55) MethodCallExprContext{wrapped=project.getTasks().withType(PrefixHeaderFileGenerateTask.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.nativeplatform.tasks.PrefixHeaderFileGenerateTask, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call task.dependsOn(project.getTasks().withType(PrefixHeaderFileGenerateTask.class).matching(new Spec<PrefixHeaderFileGenerateTask>() {

    @Override
    public boolean isSatisfiedBy(PrefixHeaderFileGenerateTask prefixHeaderFileGenerateTask) {
        return prefixHeaderFileGenerateTask.getPrefixHeaderFile().equals(sourceSet.getPrefixHeaderFile());
    }
})) java.lang.RuntimeException: Method 'withType' cannot be resolved in context project.getTasks().withType(PrefixHeaderFileGenerateTask.class) (line: 55) MethodCallExprContext{wrapped=project.getTasks().withType(PrefixHeaderFileGenerateTask.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.nativeplatform.tasks.PrefixHeaderFileGenerateTask, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/language-native/src/main/java/org/gradle/language/nativeplatform/internal/PCHCompileTaskConfig.java
Cannot solve method call task.getOutputs().getFiles().getAsFileTree().matching(new PatternSet().include("**/*.obj", "**/*.o")) java.lang.RuntimeException: Method 'include' cannot be resolved in context new PatternSet().include("**/*.obj", "**/*.o") (line: 63) MethodCallExprContext{wrapped=new PatternSet().include("**/*.obj", "**/*.o")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/language-native/src/main/java/org/gradle/language/nativeplatform/internal/PCHCompileTaskConfig.java
Cannot solve method call binary.binaryInputs(task.getOutputs().getFiles().getAsFileTree().matching(new PatternSet().include("**/*.obj", "**/*.o"))) java.lang.RuntimeException: Error calculating the type of parameter new PatternSet().include("**/*.obj", "**/*.o") of method call task.getOutputs().getFiles().getAsFileTree().matching(new PatternSet().include("**/*.obj", "**/*.o")) /repo/subprojects/language-native/src/main/java/org/gradle/language/nativeplatform/internal/PCHCompileTaskConfig.java
Cannot solve method call task.getOutputs().getFiles().getAsFileTree().matching(new PatternSet().include("**/*.pch", "**/*.gch")) java.lang.RuntimeException: Method 'include' cannot be resolved in context new PatternSet().include("**/*.pch", "**/*.gch") (line: 66) MethodCallExprContext{wrapped=new PatternSet().include("**/*.pch", "**/*.gch")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/language-native/src/main/java/org/gradle/language/nativeplatform/internal/PCHCompileTaskConfig.java
Cannot solve method call pch.setPchObjects(task.getOutputs().getFiles().getAsFileTree().matching(new PatternSet().include("**/*.pch", "**/*.gch"))) java.lang.RuntimeException: Error calculating the type of parameter new PatternSet().include("**/*.pch", "**/*.gch") of method call task.getOutputs().getFiles().getAsFileTree().matching(new PatternSet().include("**/*.pch", "**/*.gch")) /repo/subprojects/language-native/src/main/java/org/gradle/language/nativeplatform/internal/PCHCompileTaskConfig.java
Cannot solve method call Character.isJavaIdentifierStart(token.charAt(0)) java.lang.RuntimeException: Method 'charAt' cannot be resolved in context token.charAt(0) (line: 40) MethodCallExprContext{wrapped=token.charAt(0)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/language-native/src/main/java/org/gradle/language/nativeplatform/internal/incremental/ResolvedInclude.java
Method 'substring' cannot be resolved in context token.substring(1) (line: 44) MethodCallExprContext{wrapped=token.substring(1)}. Parameter types: [PrimitiveTypeUsage{name='int'}]
Cannot solve method call fileSetSerializer.write(encoder, value.getSourceInputs()) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/language-native/src/main/java/org/gradle/language/nativeplatform/internal/incremental/CompilationStateSerializer.java
Cannot solve method call resolveIncludesSerializer.write(encoder, value.getResolvedIncludes()) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/language-native/src/main/java/org/gradle/language/nativeplatform/internal/incremental/CompilationStateSerializer.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve field access IncludeType.MACRO
Cannot solve field access IncludeType.QUOTED
Cannot solve field access IncludeType.SYSTEM
Cannot solve method call include.substring(1, include.length() - 1) java.lang.RuntimeException: Method 'length' cannot be resolved in context include.length() (line: 65) MethodCallExprContext{wrapped=include.length()}. Parameter types: [] /repo/subprojects/language-native/src/main/java/org/gradle/language/nativeplatform/internal/incremental/sourceparser/DefaultInclude.java
Method 'concat' cannot be resolved in context value.concat(":") (line: 70) MethodCallExprContext{wrapped=value.concat(":")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'concat' cannot be resolved in context value.concat(":") (line: 70) MethodCallExprContext{wrapped=value.concat(":")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'concat' cannot be resolved in context value.concat(":") (line: 70) MethodCallExprContext{wrapped=value.concat(":")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve field access IncludeType.QUOTED
Cannot solve field access IncludeType.SYSTEM
Cannot solve field access IncludeType.MACRO
Cannot solve method call includePattern.matcher(line.trim()) java.lang.RuntimeException: Method 'trim' cannot be resolved in context line.trim() (line: 54) MethodCallExprContext{wrapped=line.trim()}. Parameter types: [] /repo/subprojects/language-native/src/main/java/org/gradle/language/nativeplatform/internal/incremental/sourceparser/RegexBackedCSourceParser.java
Cannot solve method call CollectionUtils.any(compilationState.getState(file).getResolvedIncludes(), new Spec<ResolvedInclude>() {

    @Override
    public boolean isSatisfiedBy(ResolvedInclude element) {
        // Using macro
        return element.isMaybeMacro();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/language-native/src/main/java/org/gradle/language/nativeplatform/internal/incremental/IncrementalNativeCompiler.java
Cannot solve method call task.getOutputs().getFiles().getAsFileTree().matching(new PatternSet().include("**/*.obj", "**/*.o")) java.lang.RuntimeException: Method 'include' cannot be resolved in context new PatternSet().include("**/*.obj", "**/*.o") (line: 58) MethodCallExprContext{wrapped=new PatternSet().include("**/*.obj", "**/*.o")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/language-native/src/main/java/org/gradle/language/nativeplatform/internal/SourceCompileTaskConfig.java
Cannot solve method call binary.binaryInputs(task.getOutputs().getFiles().getAsFileTree().matching(new PatternSet().include("**/*.obj", "**/*.o"))) java.lang.RuntimeException: Error calculating the type of parameter new PatternSet().include("**/*.obj", "**/*.o") of method call task.getOutputs().getFiles().getAsFileTree().matching(new PatternSet().include("**/*.obj", "**/*.o")) /repo/subprojects/language-native/src/main/java/org/gradle/language/nativeplatform/internal/SourceCompileTaskConfig.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call task.getOutputs().getFiles().getAsFileTree().matching(new PatternSet().include("**/*.obj", "**/*.o")) java.lang.RuntimeException: Method 'include' cannot be resolved in context new PatternSet().include("**/*.obj", "**/*.o") (line: 63) MethodCallExprContext{wrapped=new PatternSet().include("**/*.obj", "**/*.o")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/language-native/src/main/java/org/gradle/language/assembler/plugins/internal/AssembleTaskConfig.java
Cannot solve method call binary.binaryInputs(task.getOutputs().getFiles().getAsFileTree().matching(new PatternSet().include("**/*.obj", "**/*.o"))) java.lang.RuntimeException: Error calculating the type of parameter new PatternSet().include("**/*.obj", "**/*.o") of method call task.getOutputs().getFiles().getAsFileTree().matching(new PatternSet().include("**/*.obj", "**/*.o")) /repo/subprojects/language-native/src/main/java/org/gradle/language/assembler/plugins/internal/AssembleTaskConfig.java
Cannot resolve field access null
Cannot solve method call task.getOutputs().getFiles().getAsFileTree().matching(new PatternSet().include("**/*.res")) java.lang.RuntimeException: Method 'include' cannot be resolved in context new PatternSet().include("**/*.res") (line: 68) MethodCallExprContext{wrapped=new PatternSet().include("**/*.res")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/language-native/src/main/java/org/gradle/language/rc/plugins/internal/WindowsResourcesCompileTaskConfig.java
Method 'withType' cannot be resolved in context project.getTasks().withType(PrefixHeaderFileGenerateTask.class) (line: 55) MethodCallExprContext{wrapped=project.getTasks().withType(PrefixHeaderFileGenerateTask.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.nativeplatform.tasks.PrefixHeaderFileGenerateTask, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call task.dependsOn(project.getTasks().withType(PrefixHeaderFileGenerateTask.class).matching(new Spec<PrefixHeaderFileGenerateTask>() {

    @Override
    public boolean isSatisfiedBy(PrefixHeaderFileGenerateTask prefixHeaderFileGenerateTask) {
        return prefixHeaderFileGenerateTask.getPrefixHeaderFile().equals(sourceSet.getPrefixHeaderFile());
    }
})) java.lang.RuntimeException: Method 'withType' cannot be resolved in context project.getTasks().withType(PrefixHeaderFileGenerateTask.class) (line: 55) MethodCallExprContext{wrapped=project.getTasks().withType(PrefixHeaderFileGenerateTask.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.nativeplatform.tasks.PrefixHeaderFileGenerateTask, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/language-native/src/main/java/org/gradle/language/nativeplatform/internal/PCHCompileTaskConfig.java
Cannot solve method call task.getOutputs().getFiles().getAsFileTree().matching(new PatternSet().include("**/*.obj", "**/*.o")) java.lang.RuntimeException: Method 'include' cannot be resolved in context new PatternSet().include("**/*.obj", "**/*.o") (line: 63) MethodCallExprContext{wrapped=new PatternSet().include("**/*.obj", "**/*.o")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/language-native/src/main/java/org/gradle/language/nativeplatform/internal/PCHCompileTaskConfig.java
Cannot solve method call binary.binaryInputs(task.getOutputs().getFiles().getAsFileTree().matching(new PatternSet().include("**/*.obj", "**/*.o"))) java.lang.RuntimeException: Error calculating the type of parameter new PatternSet().include("**/*.obj", "**/*.o") of method call task.getOutputs().getFiles().getAsFileTree().matching(new PatternSet().include("**/*.obj", "**/*.o")) /repo/subprojects/language-native/src/main/java/org/gradle/language/nativeplatform/internal/PCHCompileTaskConfig.java
Cannot solve method call task.getOutputs().getFiles().getAsFileTree().matching(new PatternSet().include("**/*.pch", "**/*.gch")) java.lang.RuntimeException: Method 'include' cannot be resolved in context new PatternSet().include("**/*.pch", "**/*.gch") (line: 66) MethodCallExprContext{wrapped=new PatternSet().include("**/*.pch", "**/*.gch")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/language-native/src/main/java/org/gradle/language/nativeplatform/internal/PCHCompileTaskConfig.java
Cannot solve method call pch.setPchObjects(task.getOutputs().getFiles().getAsFileTree().matching(new PatternSet().include("**/*.pch", "**/*.gch"))) java.lang.RuntimeException: Error calculating the type of parameter new PatternSet().include("**/*.pch", "**/*.gch") of method call task.getOutputs().getFiles().getAsFileTree().matching(new PatternSet().include("**/*.pch", "**/*.gch")) /repo/subprojects/language-native/src/main/java/org/gradle/language/nativeplatform/internal/PCHCompileTaskConfig.java
Cannot solve method call Character.isJavaIdentifierStart(token.charAt(0)) java.lang.RuntimeException: Method 'charAt' cannot be resolved in context token.charAt(0) (line: 40) MethodCallExprContext{wrapped=token.charAt(0)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/language-native/src/main/java/org/gradle/language/nativeplatform/internal/incremental/ResolvedInclude.java
Method 'substring' cannot be resolved in context token.substring(1) (line: 44) MethodCallExprContext{wrapped=token.substring(1)}. Parameter types: [PrimitiveTypeUsage{name='int'}]
Cannot solve method call fileSetSerializer.write(encoder, value.getSourceInputs()) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/language-native/src/main/java/org/gradle/language/nativeplatform/internal/incremental/CompilationStateSerializer.java
Cannot solve method call resolveIncludesSerializer.write(encoder, value.getResolvedIncludes()) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/language-native/src/main/java/org/gradle/language/nativeplatform/internal/incremental/CompilationStateSerializer.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve field access IncludeType.MACRO
Cannot solve field access IncludeType.QUOTED
Cannot solve field access IncludeType.SYSTEM
Cannot solve method call include.substring(1, include.length() - 1) java.lang.RuntimeException: Method 'length' cannot be resolved in context include.length() (line: 65) MethodCallExprContext{wrapped=include.length()}. Parameter types: [] /repo/subprojects/language-native/src/main/java/org/gradle/language/nativeplatform/internal/incremental/sourceparser/DefaultInclude.java
Method 'concat' cannot be resolved in context value.concat(":") (line: 70) MethodCallExprContext{wrapped=value.concat(":")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'concat' cannot be resolved in context value.concat(":") (line: 70) MethodCallExprContext{wrapped=value.concat(":")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'concat' cannot be resolved in context value.concat(":") (line: 70) MethodCallExprContext{wrapped=value.concat(":")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve field access IncludeType.QUOTED
Cannot solve field access IncludeType.SYSTEM
Cannot solve field access IncludeType.MACRO
Cannot solve method call includePattern.matcher(line.trim()) java.lang.RuntimeException: Method 'trim' cannot be resolved in context line.trim() (line: 54) MethodCallExprContext{wrapped=line.trim()}. Parameter types: [] /repo/subprojects/language-native/src/main/java/org/gradle/language/nativeplatform/internal/incremental/sourceparser/RegexBackedCSourceParser.java
Cannot solve method call CollectionUtils.any(compilationState.getState(file).getResolvedIncludes(), new Spec<ResolvedInclude>() {

    @Override
    public boolean isSatisfiedBy(ResolvedInclude element) {
        // Using macro
        return element.isMaybeMacro();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/language-native/src/main/java/org/gradle/language/nativeplatform/internal/incremental/IncrementalNativeCompiler.java
Cannot solve method call task.getOutputs().getFiles().getAsFileTree().matching(new PatternSet().include("**/*.obj", "**/*.o")) java.lang.RuntimeException: Method 'include' cannot be resolved in context new PatternSet().include("**/*.obj", "**/*.o") (line: 58) MethodCallExprContext{wrapped=new PatternSet().include("**/*.obj", "**/*.o")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/language-native/src/main/java/org/gradle/language/nativeplatform/internal/SourceCompileTaskConfig.java
Cannot solve method call binary.binaryInputs(task.getOutputs().getFiles().getAsFileTree().matching(new PatternSet().include("**/*.obj", "**/*.o"))) java.lang.RuntimeException: Error calculating the type of parameter new PatternSet().include("**/*.obj", "**/*.o") of method call task.getOutputs().getFiles().getAsFileTree().matching(new PatternSet().include("**/*.obj", "**/*.o")) /repo/subprojects/language-native/src/main/java/org/gradle/language/nativeplatform/internal/SourceCompileTaskConfig.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call task.getOutputs().getFiles().getAsFileTree().matching(new PatternSet().include("**/*.obj", "**/*.o")) java.lang.RuntimeException: Method 'include' cannot be resolved in context new PatternSet().include("**/*.obj", "**/*.o") (line: 63) MethodCallExprContext{wrapped=new PatternSet().include("**/*.obj", "**/*.o")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/language-native/src/main/java/org/gradle/language/assembler/plugins/internal/AssembleTaskConfig.java
Cannot solve method call binary.binaryInputs(task.getOutputs().getFiles().getAsFileTree().matching(new PatternSet().include("**/*.obj", "**/*.o"))) java.lang.RuntimeException: Error calculating the type of parameter new PatternSet().include("**/*.obj", "**/*.o") of method call task.getOutputs().getFiles().getAsFileTree().matching(new PatternSet().include("**/*.obj", "**/*.o")) /repo/subprojects/language-native/src/main/java/org/gradle/language/assembler/plugins/internal/AssembleTaskConfig.java
Cannot resolve field access null
Cannot solve method call task.getOutputs().getFiles().getAsFileTree().matching(new PatternSet().include("**/*.res")) java.lang.RuntimeException: Method 'include' cannot be resolved in context new PatternSet().include("**/*.res") (line: 68) MethodCallExprContext{wrapped=new PatternSet().include("**/*.res")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/language-native/src/main/java/org/gradle/language/rc/plugins/internal/WindowsResourcesCompileTaskConfig.java
Cannot solve method call String.format("Cannot create Compiler for unsupported CompileSpec type '%s'", spec.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context spec.getSimpleName() (line: 56) MethodCallExprContext{wrapped=spec.getSimpleName()}. Parameter types: [] /repo/subprojects/language-scala/src/main/java/org/gradle/language/scala/internal/toolchain/DefaultScalaToolProvider.java
Cannot solve method call String.format("Don't know how to provide tool of type %s.", toolType.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context toolType.getSimpleName() (line: 61) MethodCallExprContext{wrapped=toolType.getSimpleName()}. Parameter types: [] /repo/subprojects/language-scala/src/main/java/org/gradle/language/scala/internal/toolchain/DefaultScalaToolProvider.java
Method 'getCause' cannot be resolved in context exception.getCause() (line: 57) MethodCallExprContext{wrapped=exception.getCause()}. Parameter types: []
Cannot solve method call visitor.node(exception.getCause().getMessage()) java.lang.RuntimeException: Method 'getCause' cannot be resolved in context exception.getCause() (line: 57) MethodCallExprContext{wrapped=exception.getCause()}. Parameter types: [] /repo/subprojects/language-scala/src/main/java/org/gradle/language/scala/internal/toolchain/NotFoundScalaToolProvider.java
Cannot solve method call Maps.newHashMap(Maps.filterEntries(analysisMap, new Predicate<Map.Entry<File, File>>() {

    public boolean apply(Map.Entry<File, File> entry) {
        return classpathLookup.contains(entry.getKey());
    }
})) UnsolvedSymbolException{context='Method 'filterEntries' with parameterTypes [ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{Predicate, typeParametersMap=TypeParametersMap{nameToValue={empty.? super ScriptBlock=ReferenceType{java.util.Map.Entry, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.Entry.K=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.Entry.V=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Maps}'} /repo/subprojects/language-scala/src/main/java/org/gradle/language/scala/tasks/AbstractScalaCompile.java
Cannot solve method call CompilerUtil.castCompiler(getToolChain().select(getPlatform()).newCompiler(spec.getClass())) java.lang.RuntimeException: Method 'newCompiler' cannot be resolved in context getToolChain().select(getPlatform()).newCompiler(spec.getClass()) (line: 60) MethodCallExprContext{wrapped=getToolChain().select(getPlatform()).newCompiler(spec.getClass())}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}] /repo/subprojects/language-scala/src/main/java/org/gradle/language/scala/tasks/PlatformScalaCompile.java
Cannot solve method call compile.setDestinationDir(single(assembly.getClassDirectories())) java.lang.RuntimeException: Method 'single' cannot be resolved in context single(assembly.getClassDirectories()) (line: 140) MethodCallExprContext{wrapped=single(assembly.getClassDirectories())}. Parameter types: [ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/language-scala/src/main/java/org/gradle/language/scala/plugins/ScalaLanguagePlugin.java
Cannot solve name expression Logging
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression ZINC_DIR_SYSTEM_PROPERTY
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve name expression scalaClasspath
Cannot solve name expression zincClasspath
Cannot solve name expression gradleUserHome
Cannot solve name expression Compiler
Cannot solve method call Compiler.execute(scalaClasspath, zincClasspath, gradleUserHome, spec) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/language-scala/src/main/java/org/gradle/api/internal/tasks/scala/ZincScalaCompiler.java
Cannot solve name expression LOGGER
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call createParallelSafeCompiler(scalaClasspath, zincClasspath, logger, gradleUserHome) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/language-scala/src/main/java/org/gradle/api/internal/tasks/scala/ZincScalaCompiler.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression ImmutableList
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression ImmutableList
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression Inputs
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression LOGGER
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression Inputs
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression GFileUtils
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression Option
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression Option
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression Lists
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression ScalaLocation
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression Lists
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression SbtJars
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression Jvm
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression Setup
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression LOGGER
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression Setup
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression com
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression ZINC_CACHE_HOME_DIR_SYSTEM_PROPERTY
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression System
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression ZincCompilerServices
Cannot solve method call ZincCompilerServices.getInstance(zincCacheHomeDir) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/language-scala/src/main/java/org/gradle/api/internal/tasks/scala/ZincScalaCompiler.java
Error calculating the type of parameter zincCacheHomeDir of method call ZincCompilerServices.getInstance(zincCacheHomeDir)
Cannot solve name expression FileLockManager
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call mode(FileLockManager.LockMode.Exclusive) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/language-scala/src/main/java/org/gradle/api/internal/tasks/scala/ZincScalaCompiler.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Error calculating the type of parameter mode(FileLockManager.LockMode.Exclusive) of method call cacheRepository.cache("zinc").withDisplayName("Zinc compiler cache").withLockOptions(mode(FileLockManager.LockMode.Exclusive))
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression System
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression ZINC_DIR_IGNORED_MESSAGE
Cannot solve name expression LOGGER
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression ZINC_DIR_SYSTEM_PROPERTY
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression scalaClasspath
Cannot solve name expression zincClasspath
Cannot solve name expression logger
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression zincCache
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression SystemProperties
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression LOGGER
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression LOGGER
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression LOGGER
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression LOGGER
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression LOGGER
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression NativeServices
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call addProvider(new GlobalScopeServices(true)) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/language-scala/src/main/java/org/gradle/api/internal/tasks/scala/ZincScalaCompiler.java
Cannot solve method call addProvider(new CacheRepositoryServices(gradleUserHome, null)) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/language-scala/src/main/java/org/gradle/api/internal/tasks/scala/ZincScalaCompiler.java
Cannot solve name expression instance
Cannot solve name expression NativeServices
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression instance
Cannot solve name expression instance
Cannot solve method call spec.getCompileOptions().setCompilerArgs(CollectionUtils.toStringList(spec.getCompileOptions().getCompilerArgs())) UnsolvedSymbolException{context='Method 'toStringList' with parameterTypes [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class CollectionUtils {

    /**
     * Returns null if the collection is empty otherwise expects a {@link #single(Iterable)} element to be found.
     */
    @Nullable
    public static <T> T findSingle(Collection<T> source) {
        return source.isEmpty() ? null : single(source);
    }

    /**
     * Returns the single element in the collection or throws.
     */
    public static <T> T single(Iterable<? extends T> source) {
        Iterator<? extends T> iterator = source.iterator();
        if (!iterator.hasNext()) {
            throw new NoSuchElementException("Expecting collection with single element, got none.");
        }
        T element = iterator.next();
        if (iterator.hasNext()) {
            throw new IllegalArgumentException("Expecting collection with single element, got multiple.");
        }
        return element;
    }

    public static <T> Collection<? extends T> checkedCast(Class<T> type, Collection<?> input) {
        for (Object o : input) {
            cast(type, o);
        }
        return Cast.uncheckedCast(input);
    }

    public static <T> T findFirst(Iterable<? extends T> source, Spec<? super T> filter) {
        for (T item : source) {
            if (filter.isSatisfiedBy(item)) {
                return item;
            }
        }
        return null;
    }

    public static <T> T findFirst(T[] source, Spec<? super T> filter) {
        for (T thing : source) {
            if (filter.isSatisfiedBy(thing)) {
                return thing;
            }
        }
        return null;
    }

    public static <T> T first(Iterable<? extends T> source) {
        return source.iterator().next();
    }

    public static <T> boolean any(Iterable<? extends T> source, Spec<? super T> filter) {
        return findFirst(source, filter) != null;
    }

    public static <T> boolean any(T[] source, Spec<? super T> filter) {
        return findFirst(source, filter) != null;
    }

    public static <T> Set<T> filter(Set<? extends T> set, Spec<? super T> filter) {
        return filter(set, new LinkedHashSet<T>(), filter);
    }

    public static <T> List<T> filter(List<? extends T> list, Spec<? super T> filter) {
        return filter(list, new LinkedList<T>(), filter);
    }

    public static <T> List<T> filter(T[] array, Spec<? super T> filter) {
        return filter(Arrays.asList(array), new LinkedList<T>(), filter);
    }

    /**
     * Returns a sorted copy of the provided collection of things. Uses the provided comparator to sort.
     */
    public static <T> List<T> sort(Iterable<? extends T> things, Comparator<? super T> comparator) {
        List<T> copy = toMutableList(things);
        Collections.sort(copy, comparator);
        return copy;
    }

    /**
     * Returns a sorted copy of the provided collection of things. Uses the natural ordering of the things.
     */
    public static <T extends Comparable> List<T> sort(Iterable<T> things) {
        List<T> copy = toMutableList(things);
        Collections.sort(copy);
        return copy;
    }

    public static <T, C extends Collection<T>> C filter(Iterable<? extends T> source, C destination, Spec<? super T> filter) {
        for (T item : source) {
            if (filter.isSatisfiedBy(item)) {
                destination.add(item);
            }
        }
        return destination;
    }

    public static <K, V> Map<K, V> filter(Map<K, V> map, Spec<Map.Entry<K, V>> filter) {
        return filter(map, new HashMap<K, V>(), filter);
    }

    public static <K, V> Map<K, V> filter(Map<K, V> map, Map<K, V> destination, Spec<Map.Entry<K, V>> filter) {
        for (Map.Entry<K, V> entry : map.entrySet()) {
            if (filter.isSatisfiedBy(entry)) {
                destination.put(entry.getKey(), entry.getValue());
            }
        }
        return destination;
    }

    public static <R, I> R[] collectArray(I[] list, Class<R> newType, Transformer<? extends R, ? super I> transformer) {
        @SuppressWarnings("unchecked") R[] destination = (R[]) Array.newInstance(newType, list.length);
        return collectArray(list, destination, transformer);
    }

    public static <R, I> R[] collectArray(I[] list, R[] destination, Transformer<? extends R, ? super I> transformer) {
        assert list.length <= destination.length;
        for (int i = 0; i < list.length; ++i) {
            destination[i] = transformer.transform(list[i]);
        }
        return destination;
    }

    public static <R, I> List<R> collect(List<? extends I> list, Transformer<? extends R, ? super I> transformer) {
        return collect(list, new ArrayList<R>(list.size()), transformer);
    }

    public static <R, I> List<R> collect(I[] list, Transformer<? extends R, ? super I> transformer) {
        return collect(Arrays.asList(list), transformer);
    }

    public static <R, I> Set<R> collect(Set<? extends I> set, Transformer<? extends R, ? super I> transformer) {
        return collect(set, new HashSet<R>(), transformer);
    }

    public static <R, I> List<R> collect(Iterable<? extends I> source, Transformer<? extends R, ? super I> transformer) {
        return collect(source, new LinkedList<R>(), transformer);
    }

    public static <R, I, C extends Collection<R>> C collect(Iterable<? extends I> source, C destination, Transformer<? extends R, ? super I> transformer) {
        for (I item : source) {
            destination.add(transformer.transform(item));
        }
        return destination;
    }

    public static List<String> toStringList(Iterable<?> iterable) {
        return collect(iterable, new LinkedList<String>(), Transformers.asString());
    }

    /**
     * Recursively unpacks all the given things into a flat list.
     *
     * Nulls are not removed, they are left intact.
     *
     * @param things The things to flatten
     * @return A flattened list of the given things
     */
    public static List<?> flattenCollections(Object... things) {
        return flattenCollections(Object.class, things);
    }

    /**
     * Recursively unpacks all the given things into a flat list, ensuring they are of a certain type.
     *
     * Nulls are not removed, they are left intact.
     *
     * If a non null object cannot be cast to the target type, a ClassCastException will be thrown.
     *
     * @param things The things to flatten
     * @param <T> The target type in the flattened list
     * @return A flattened list of the given things
     */
    public static <T> List<T> flattenCollections(Class<T> type, Object... things) {
        if (things == null) {
            return Collections.singletonList(null);
        } else if (things.length == 0) {
            return Collections.emptyList();
        } else if (things.length == 1) {
            Object thing = things[0];
            if (thing == null) {
                return Collections.singletonList(null);
            }
            if (thing.getClass().isArray()) {
                Object[] thingArray = (Object[]) thing;
                List<T> list = new ArrayList<T>(thingArray.length);
                for (Object thingThing : thingArray) {
                    list.addAll(flattenCollections(type, thingThing));
                }
                return list;
            }
            if (thing instanceof Collection) {
                Collection<?> collection = (Collection<?>) thing;
                List<T> list = new ArrayList<T>();
                for (Object element : collection) {
                    list.addAll(flattenCollections(type, element));
                }
                return list;
            }
            return Collections.singletonList(cast(type, thing));
        } else {
            List<T> list = new ArrayList<T>();
            for (Object thing : things) {
                list.addAll(flattenCollections(type, thing));
            }
            return list;
        }
    }

    public static <T> List<T> toList(Iterable<? extends T> things) {
        if (things instanceof List) {
            @SuppressWarnings("unchecked") List<T> castThings = (List<T>) things;
            return castThings;
        }
        return toMutableList(things);
    }

    public static <T> List<T> toList(Enumeration<? extends T> things) {
        AbstractList<T> list = new ArrayList<T>();
        while (things.hasMoreElements()) {
            list.add(things.nextElement());
        }
        return list;
    }

    private static <T> List<T> toMutableList(Iterable<? extends T> things) {
        if (things == null) {
            return new ArrayList<T>(0);
        }
        List<T> list = new ArrayList<T>();
        for (T thing : things) {
            list.add(thing);
        }
        return list;
    }

    public static <T> List<T> intersection(Collection<? extends Collection<T>> availableValuesByDescriptor) {
        List<T> result = new ArrayList<T>();
        Iterator<? extends Collection<T>> iterator = availableValuesByDescriptor.iterator();
        if (iterator.hasNext()) {
            Collection<T> firstSet = iterator.next();
            result.addAll(firstSet);
            while (iterator.hasNext()) {
                Collection<T> next = iterator.next();
                result.retainAll(next);
            }
        }
        return result;
    }

    public static <T> List<T> toList(T[] things) {
        if (things == null || things.length == 0) {
            return new ArrayList<T>(0);
        }
        List<T> list = new ArrayList<T>(things.length);
        Collections.addAll(list, things);
        return list;
    }

    public static <T> Set<T> toSet(Iterable<? extends T> things) {
        if (things == null) {
            return new HashSet<T>(0);
        }
        if (things instanceof Set) {
            @SuppressWarnings("unchecked") Set<T> castThings = (Set<T>) things;
            return castThings;
        }
        Set<T> set = new LinkedHashSet<T>();
        for (T thing : things) {
            set.add(thing);
        }
        return set;
    }

    public static <E> List<E> compact(List<E> list) {
        boolean foundAtLeastOneNull = false;
        List<E> compacted = null;
        int i = 0;
        for (E element : list) {
            if (element == null) {
                if (!foundAtLeastOneNull) {
                    compacted = new ArrayList<E>(list.size());
                    if (i > 0) {
                        compacted.addAll(list.subList(0, i));
                    }
                }
                foundAtLeastOneNull = true;
            } else if (foundAtLeastOneNull) {
                compacted.add(element);
            }
            ++i;
        }
        return foundAtLeastOneNull ? compacted : list;
    }

    public static <C extends Collection<String>> C stringize(Iterable<?> source, C destination) {
        return collect(source, destination, Transformers.asString());
    }

    public static List<String> stringize(Collection<?> source) {
        return stringize(source, new ArrayList<String>(source.size()));
    }

    public static <E> boolean replace(List<E> list, Spec<? super E> filter, Transformer<? extends E, ? super E> transformer) {
        boolean replaced = false;
        int i = 0;
        for (E it : list) {
            if (filter.isSatisfiedBy(it)) {
                list.set(i, transformer.transform(it));
                replaced = true;
            }
            ++i;
        }
        return replaced;
    }

    public static <K, V> void collectMap(Map<K, V> destination, Iterable<? extends V> items, Transformer<? extends K, ? super V> keyGenerator) {
        for (V item : items) {
            destination.put(keyGenerator.transform(item), item);
        }
    }

    /**
     * Given a set of values, derive a set of keys and return a map
     */
    public static <K, V> Map<K, V> collectMap(Iterable<? extends V> items, Transformer<? extends K, ? super V> keyGenerator) {
        Map<K, V> map = new LinkedHashMap<K, V>();
        collectMap(map, items, keyGenerator);
        return map;
    }

    public static <K, V> void collectMapValues(Map<K, V> destination, Iterable<? extends K> keys, Transformer<? extends V, ? super K> keyGenerator) {
        for (K item : keys) {
            destination.put(item, keyGenerator.transform(item));
        }
    }

    /**
     * Given a set of keys, derive a set of values and return a map
     */
    public static <K, V> Map<K, V> collectMapValues(Iterable<? extends K> keys, Transformer<? extends V, ? super K> keyGenerator) {
        Map<K, V> map = new LinkedHashMap<K, V>();
        collectMapValues(map, keys, keyGenerator);
        return map;
    }

    public static <T> boolean every(Iterable<? extends T> things, Spec<? super T> predicate) {
        for (T thing : things) {
            if (!predicate.isSatisfiedBy(thing)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Utility for adding an iterable to a collection.
     *
     * @param t1 The collection to add to
     * @param t2 The iterable to add each item of to the collection
     * @param <T> The element type of t1
     * @return t1
     */
    public static <T> Collection<T> addAll(Collection<T> t1, Iterable<? extends T> t2) {
        for (T t : t2) {
            t1.add(t);
        }
        return t1;
    }

    /**
     * Utility for adding an array to a collection.
     *
     * @param t1 The collection to add to
     * @param t2 The iterable to add each item of to the collection
     * @param <T> The element type of t1
     * @return t1
     */
    public static <T> Collection<T> addAll(Collection<T> t1, T... t2) {
        Collections.addAll(t1, t2);
        return t1;
    }

    /**
     * The result of diffing two sets.
     *
     * @param <T> The type of element the sets contain
     * @see CollectionUtils#diffSetsBy(java.util.Set, java.util.Set, org.gradle.api.Transformer)
     */
    public static class SetDiff<T> {

        public Set<T> leftOnly = new HashSet<T>();

        public Set<Pair<T, T>> common = new HashSet<Pair<T, T>>();

        public Set<T> rightOnly = new HashSet<T>();
    }

    /**
     * Provides a “diff report” of how the two sets are similar and how they are different, comparing the entries by some aspect.
     *
     * The transformer is used to generate the value to use to compare the entries by. That is, the entries are not compared by equals by an attribute or characteristic.
     *
     * The transformer is expected to produce a unique value for each entry in a single set. Behaviour is undefined if this condition is not met.
     *
     * @param left The set on the “left” side of the comparison.
     * @param right The set on the “right” side of the comparison.
     * @param compareBy Provides the value to compare entries from either side by
     * @param <T> The type of the entry objects
     * @return A representation of the difference
     */
    public static <T> SetDiff<T> diffSetsBy(Set<? extends T> left, Set<? extends T> right, Transformer<?, T> compareBy) {
        if (left == null) {
            throw new NullPointerException("'left' set is null");
        }
        if (right == null) {
            throw new NullPointerException("'right' set is null");
        }
        SetDiff<T> setDiff = new SetDiff<T>();
        Map<Object, T> indexedLeft = collectMap(left, compareBy);
        Map<Object, T> indexedRight = collectMap(right, compareBy);
        for (Map.Entry<Object, T> leftEntry : indexedLeft.entrySet()) {
            T rightValue = indexedRight.remove(leftEntry.getKey());
            if (rightValue == null) {
                setDiff.leftOnly.add(leftEntry.getValue());
            } else {
                Pair<T, T> pair = Pair.of(leftEntry.getValue(), rightValue);
                setDiff.common.add(pair);
            }
        }
        for (T rightValue : indexedRight.values()) {
            setDiff.rightOnly.add(rightValue);
        }
        return setDiff;
    }

    /**
     * Creates a string with {@code toString()} of each object with the given separator.
     *
     * <pre>
     * expect:
     * join(",", new Object[]{"a"}) == "a"
     * join(",", new Object[]{"a", "b", "c"}) == "a,b,c"
     * join(",", new Object[]{}) == ""
     * </pre>
     *
     * The {@code separator} must not be null and {@code objects} must not be null.
     *
     * @param separator The string by which to join each string representation
     * @param objects The objects to join the string representations of
     * @return The joined string
     */
    public static String join(String separator, Object[] objects) {
        return join(separator, objects == null ? null : Arrays.asList(objects));
    }

    /**
     * Creates a string with {@code toString()} of each object with the given separator.
     *
     * <pre>
     * expect:
     * join(",", ["a"]) == "a"
     * join(",", ["a", "b", "c"]) == "a,b,c"
     * join(",", []) == ""
     * </pre>
     *
     * The {@code separator} must not be null and {@code objects} must not be null.
     *
     * @param separator The string by which to join each string representation
     * @param objects The objects to join the string representations of
     * @return The joined string
     */
    public static String join(String separator, Iterable<?> objects) {
        if (separator == null) {
            throw new NullPointerException("The 'separator' cannot be null");
        }
        if (objects == null) {
            throw new NullPointerException("The 'objects' cannot be null");
        }
        StringBuilder string = new StringBuilder();
        Iterator<?> iterator = objects.iterator();
        if (iterator.hasNext()) {
            string.append(iterator.next().toString());
            while (iterator.hasNext()) {
                string.append(separator);
                string.append(iterator.next().toString());
            }
        }
        return string.toString();
    }

    /**
     * Partition given Collection into a Pair of Collections.
     *
     * <pre>Left</pre> Collection containing entries that satisfy the given predicate
     * <pre>Right</pre> Collection containing entries that do NOT satisfy the given predicate
     */
    public static <T> Pair<Collection<T>, Collection<T>> partition(Iterable<T> items, Spec<? super T> predicate) {
        Preconditions.checkNotNull(items, "Cannot partition null Collection");
        Preconditions.checkNotNull(predicate, "Cannot apply null Spec when partitioning");
        Collection<T> left = new LinkedList<T>();
        Collection<T> right = new LinkedList<T>();
        for (T item : items) {
            if (predicate.isSatisfiedBy(item)) {
                left.add(item);
            } else {
                right.add(item);
            }
        }
        return Pair.of(left, right);
    }

    public static class InjectionStep<T, I> {

        private final T target;

        private final I item;

        public InjectionStep(T target, I item) {
            this.target = target;
            this.item = item;
        }

        public T getTarget() {
            return target;
        }

        public I getItem() {
            return item;
        }
    }

    public static <T, I> T inject(T target, Iterable<? extends I> items, Action<InjectionStep<T, I>> action) {
        if (target == null) {
            throw new NullPointerException("The 'target' cannot be null");
        }
        if (items == null) {
            throw new NullPointerException("The 'items' cannot be null");
        }
        if (action == null) {
            throw new NullPointerException("The 'action' cannot be null");
        }
        for (I item : items) {
            action.execute(new InjectionStep<T, I>(target, item));
        }
        return target;
    }

    public static <K, V> ImmutableListMultimap<K, V> groupBy(Iterable<? extends V> iterable, Transformer<? extends K, V> grouper) {
        ImmutableListMultimap.Builder<K, V> builder = ImmutableListMultimap.builder();
        for (V element : iterable) {
            K key = grouper.transform(element);
            builder.put(key, element);
        }
        return builder.build();
    }

    public static <T> Iterable<? extends T> unpack(final Iterable<? extends Factory<? extends T>> factories) {
        return new Iterable<T>() {

            private final Iterator<? extends Factory<? extends T>> delegate = factories.iterator();

            public Iterator<T> iterator() {
                return new Iterator<T>() {

                    public boolean hasNext() {
                        return delegate.hasNext();
                    }

                    public T next() {
                        return delegate.next().create();
                    }

                    public void remove() {
                        throw new UnsupportedOperationException();
                    }
                };
            }
        };
    }

    @Nullable
    public static <T> List<T> nonEmptyOrNull(Iterable<T> iterable) {
        ImmutableList<T> list = ImmutableList.copyOf(iterable);
        return list.isEmpty() ? null : list;
    }

    public static <T> List<T> dedup(Iterable<T> source, final Equivalence<? super T> equivalence) {
        Iterable<Equivalence.Wrapper<T>> wrappers = Iterables.transform(source, new Function<T, Equivalence.Wrapper<T>>() {

            public Equivalence.Wrapper<T> apply(@Nullable T input) {
                return equivalence.wrap(input);
            }
        });
        Set<Equivalence.Wrapper<T>> deduped = ImmutableSet.copyOf(wrappers);
        return ImmutableList.copyOf(Iterables.transform(deduped, new Function<Equivalence.Wrapper<T>, T>() {

            public T apply(Equivalence.Wrapper<T> input) {
                return input.get();
            }
        }));
    }

    public static String asCommandLine(Iterable<String> arguments) {
        return Joiner.on(" ").join(collect(arguments, Transformers.asSafeCommandLineArgument()));
    }
}}'} /repo/subprojects/language-scala/src/main/java/org/gradle/api/internal/tasks/scala/NormalizingScalaCompiler.java
Cannot solve field access State.Created
Cannot solve field access State.Completed
Cannot solve field access State.Completed
Cannot solve field access State.Completed
Cannot solve method call String.format("DefaultDaemonContext[uid=%s,javaHome=%s,daemonRegistryDir=%s,pid=%s,idleTimeout=%s,daemonOpts=%s]", uid, javaHome, daemonRegistryDir, pid, idleTimeout, Joiner.on(',').join(daemonOpts)) UnsolvedSymbolException{context='Method 'on' with parameterTypes [PrimitiveTypeUsage{name='char'}]', name='ReflectionClassDeclaration{clazz=Joiner}'} /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/context/DefaultDaemonContext.java
Cannot resolve field access null
Cannot solve method call sb.append(documentationRegistry.getDocumentationFor("gradle_daemon")) java.lang.RuntimeException: Method 'getDocumentationFor' cannot be resolved in context documentationRegistry.getDocumentationFor("gradle_daemon") (line: 48) MethodCallExprContext{wrapped=documentationRegistry.getDocumentationFor("gradle_daemon")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/bootstrap/DaemonGreeter.java
Cannot solve method call message.substring(daemonGreeting().length()) java.lang.RuntimeException: Method 'length' cannot be resolved in context daemonGreeting().length() (line: 72) MethodCallExprContext{wrapped=daemonGreeting().length()}. Parameter types: [] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/bootstrap/DaemonStartupCommunication.java
Error calculating the type of parameter daemonGreeting().length() of method call message.substring(daemonGreeting().length())
Cannot resolve field access null
Cannot solve field access LogLevel.DEBUG
Cannot solve method call throwableSerializer.write(encoder, failure.getValue()) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context failure.getValue() (line: 65) MethodCallExprContext{wrapped=failure.getValue()}. Parameter types: [] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/protocol/DaemonMessageSerializer.java
Cannot solve method call payloadSerializer.write(encoder, buildEvent.getPayload()) java.lang.RuntimeException: Method 'getPayload' cannot be resolved in context buildEvent.getPayload() (line: 79) MethodCallExprContext{wrapped=buildEvent.getPayload()}. Parameter types: [] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/protocol/DaemonMessageSerializer.java
Cannot solve method call encoder.writeBinary(message.getBytes()) java.lang.RuntimeException: Method 'getBytes' cannot be resolved in context message.getBytes() (line: 257) MethodCallExprContext{wrapped=message.getBytes()}. Parameter types: [] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/protocol/DaemonMessageSerializer.java
Cannot solve method call eventSerializer.write(encoder, message.getEvent()) java.lang.RuntimeException: Method 'getEvent' cannot be resolved in context message.getEvent() (line: 286) MethodCallExprContext{wrapped=message.getEvent()}. Parameter types: [] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/protocol/DaemonMessageSerializer.java
Cannot solve method call LOGGER.info("Daemon will not handle the command {} because is unavailable: {}", build, e.getMessage()) java.lang.RuntimeException: Method 'getMessage' cannot be resolved in context e.getMessage() (line: 56) MethodCallExprContext{wrapped=e.getMessage()}. Parameter types: [] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/server/exec/StartBuildOrRespondWithBusy.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call addLowMemoryDaemonExpirationStrategyWhenSupported(daemon, strategies) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/server/MasterExpirationStrategy.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve field access State.Idle
Empty name expression Idle
Empty name expression Busy
Empty name expression Canceled
Empty name expression Broken
Empty name expression StopRequested
Empty name expression Stopped
Cannot solve field access State.StopRequested
Cannot solve field access State.Stopped
Cannot solve field access State.Busy
Cannot solve field access State.Busy
Empty name expression Idle
Empty name expression Busy
Empty name expression Canceled
Empty name expression Broken
Empty name expression StopRequested
Cannot solve field access State.Busy
Cannot solve field access State.Stopped
Empty name expression Stopped
Empty name expression Idle
Empty name expression Busy
Empty name expression Canceled
Empty name expression Broken
Cannot solve field access State.StopRequested
Empty name expression StopRequested
Empty name expression Stopped
Cannot solve field access State.Busy
Cannot solve field access State.StopRequested
Cannot solve field access State.Canceled
Empty name expression Idle
Empty name expression Stopped
Empty name expression Busy
Empty name expression Canceled
Empty name expression StopRequested
Empty name expression Broken
Empty name expression Idle
Empty name expression Busy
Empty name expression Canceled
Empty name expression StopRequested
Empty name expression Broken
Empty name expression Stopped
Cannot solve field access State.Busy
Cannot solve field access State.Canceled
Cannot solve field access State.StopRequested
Empty name expression Stopped
Empty name expression Broken
Empty name expression Broken
Empty name expression StopRequested
Empty name expression Stopped
Empty name expression Busy
Empty name expression Canceled
Cannot solve field access State.Broken
Cannot solve field access State.Busy
Empty name expression Idle
Empty name expression Busy
Empty name expression Canceled
Cannot solve field access State.Broken
Cannot solve field access State.Idle
Empty name expression StopRequested
Empty name expression Stopped
Cannot solve field access State.Idle
Cannot solve field access State.Idle
Cannot solve field access State.Busy
Cannot solve method call LOGGER.warn(String.format("Unable to receive command from client %s. Discarding connection.", connection), e) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.internal.remote.internal.RemoteConnection, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.internal.remote.internal.RemoteConnection.T=ReferenceType{org.gradle.launcher.daemon.protocol.Message, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/server/DefaultIncomingConnectionHandler.java
Cannot solve method call LOGGER.warn(String.format("Unable to execute command %s from %s. Dispatching the failure to the daemon client", command, connection), e) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.launcher.daemon.protocol.Command, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.internal.remote.internal.RemoteConnection, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.internal.remote.internal.RemoteConnection.T=ReferenceType{org.gradle.launcher.daemon.protocol.Message, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/server/DefaultIncomingConnectionHandler.java
Cannot resolve field access null
Cannot solve method call reasons.add(expirationResult.getReason()) java.lang.RuntimeException: Method 'getReason' cannot be resolved in context expirationResult.getReason() (line: 50) MethodCallExprContext{wrapped=expirationResult.getReason()}. Parameter types: [] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/server/expiry/AllDaemonExpirationStrategy.java
Cannot solve method call highestPriorityOf(expirationResult.getStatus(), expirationStatus) java.lang.RuntimeException: Method 'getStatus' cannot be resolved in context expirationResult.getStatus() (line: 51) MethodCallExprContext{wrapped=expirationResult.getStatus()}. Parameter types: [] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/server/expiry/AllDaemonExpirationStrategy.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve field access DaemonExpirationStatus.DO_NOT_EXPIRE
Cannot solve method call reasons.add(expirationResult.getReason()) java.lang.RuntimeException: Method 'getReason' cannot be resolved in context expirationResult.getReason() (line: 45) MethodCallExprContext{wrapped=expirationResult.getReason()}. Parameter types: [] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/server/expiry/AnyDaemonExpirationStrategy.java
Cannot solve method call highestPriorityOf(expirationResult.getStatus(), expirationStatus) java.lang.RuntimeException: Method 'getStatus' cannot be resolved in context expirationResult.getStatus() (line: 46) MethodCallExprContext{wrapped=expirationResult.getStatus()}. Parameter types: [] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/server/expiry/AnyDaemonExpirationStrategy.java
Cannot resolve field access null
Cannot solve field access DaemonExpirationStatus.GRACEFUL_EXPIRE
Cannot solve method call completion.create(Serializers.stateful(DaemonMessageSerializer.create())) UnsolvedSymbolException{context='Method 'stateful' with parameterTypes [ReferenceType{Serializer, typeParametersMap=TypeParametersMap{nameToValue={empty.T=ReferenceType{Message, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public class Serializers {

    public static <T> StatefulSerializer<T> stateful(final Serializer<T> serializer) {
        return new StatefulSerializerAdapter<T>(serializer);
    }

    private static class StatefulSerializerAdapter<T> implements StatefulSerializer<T> {

        private final Serializer<T> serializer;

        public StatefulSerializerAdapter(Serializer<T> serializer) {
            this.serializer = serializer;
        }

        @Override
        public ObjectReader<T> newReader(final Decoder decoder) {
            return new ObjectReader<T>() {

                @Override
                public T read() throws Exception {
                    return serializer.read(decoder);
                }
            };
        }

        @Override
        public ObjectWriter<T> newWriter(final Encoder encoder) {
            return new ObjectWriter<T>() {

                @Override
                public void write(T value) throws Exception {
                    serializer.write(encoder, value);
                }
            };
        }
    }
}}'} /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/server/DaemonTcpServerConnector.java
Cannot solve field access DaemonExpirationStatus.GRACEFUL_EXPIRE
Cannot solve field access DaemonExpirationStatus.IMMEDIATE_EXPIRE
Cannot solve field access DaemonExpirationStatus.GRACEFUL_EXPIRE
Cannot resolve field access null
Cannot solve field access DaemonExpirationStatus.GRACEFUL_EXPIRE
Cannot solve method call String.format("thread %s: Could not receive message from client.", Thread.currentThread().getId()) UnsolvedSymbolException{context='Method 'currentThread' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Thread}'} /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/server/DefaultDaemonConnection.java
Cannot solve method call LOGGER.debug(String.format("thread %s: Could not receive message from client.", Thread.currentThread().getId()), e) java.lang.RuntimeException: Error calculating the type of parameter Thread.currentThread().getId() of method call String.format("thread %s: Could not receive message from client.", Thread.currentThread().getId()) /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/server/DefaultDaemonConnection.java
Cannot solve method call LOGGER.debug("thread {}: Received end-of-input from client.", Thread.currentThread().getId()) UnsolvedSymbolException{context='Method 'currentThread' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Thread}'} /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/server/DefaultDaemonConnection.java
Cannot solve method call LOGGER.debug("thread {}: Received non-IO message from client: {}", Thread.currentThread().getId(), message) UnsolvedSymbolException{context='Method 'currentThread' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Thread}'} /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/server/DefaultDaemonConnection.java
Cannot solve method call LOGGER.debug("thread {}: Received cancel message from client: {}", Thread.currentThread().getId(), message) UnsolvedSymbolException{context='Method 'currentThread' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Thread}'} /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/server/DefaultDaemonConnection.java
Cannot solve method call LOGGER.debug("thread {}: Received IO message from client: {}", Thread.currentThread().getId(), message) UnsolvedSymbolException{context='Method 'currentThread' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Thread}'} /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/server/DefaultDaemonConnection.java
Cannot solve method call LOGGER.debug("thread {}: dispatching {}", Thread.currentThread().getId(), message.getClass()) UnsolvedSymbolException{context='Method 'currentThread' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Thread}'} /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/server/SynchronizedDispatchConnection.java
Cannot solve method call LOGGER.debug("thread {}: received {}", Thread.currentThread().getId(), result == null ? "null" : result.getClass()) UnsolvedSymbolException{context='Method 'currentThread' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Thread}'} /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/server/SynchronizedDispatchConnection.java
Cannot solve method call LOGGER.debug("thread {}: stopping connection", Thread.currentThread().getId()) UnsolvedSymbolException{context='Method 'currentThread' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Thread}'} /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/server/SynchronizedDispatchConnection.java
Cannot solve field access GarbageCollectorMonitoringStrategy.UNKNOWN
Cannot resolve field access null
Cannot solve method call ImmutableMap.<String, SlidingWindow<GarbageCollectionEvent>>of(gcStrategy.getTenuredPoolName(), new DefaultSlidingWindow<GarbageCollectionEvent>(EVENT_WINDOW), gcStrategy.getPermGenPoolName(), new DefaultSlidingWindow<GarbageCollectionEvent>(EVENT_WINDOW)) java.lang.RuntimeException: Method 'getTenuredPoolName' cannot be resolved in context gcStrategy.getTenuredPoolName() (line: 50) MethodCallExprContext{wrapped=gcStrategy.getTenuredPoolName()}. Parameter types: [] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/server/health/gc/GarbageCollectionMonitor.java
Cannot solve method call pollForValues(gcStrategy.getGarbageCollectorName(), ImmutableList.copyOf(events.keySet())) java.lang.RuntimeException: Method 'getGarbageCollectorName' cannot be resolved in context gcStrategy.getGarbageCollectorName() (line: 53) MethodCallExprContext{wrapped=gcStrategy.getGarbageCollectorName()}. Parameter types: [] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/server/health/gc/GarbageCollectionMonitor.java
Cannot solve method call garbageCollectors.contains(strategy.getGarbageCollectorName()) java.lang.RuntimeException: Method 'getGarbageCollectorName' cannot be resolved in context strategy.getGarbageCollectorName() (line: 71) MethodCallExprContext{wrapped=strategy.getGarbageCollectorName()}. Parameter types: [] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/server/health/gc/GarbageCollectionMonitor.java
Cannot resolve field access null
Cannot solve method call getGarbageCollectionStatsWithEmptyDefault(gcStrategy.getTenuredPoolName()) java.lang.RuntimeException: Method 'getTenuredPoolName' cannot be resolved in context gcStrategy.getTenuredPoolName() (line: 88) MethodCallExprContext{wrapped=gcStrategy.getTenuredPoolName()}. Parameter types: [] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/server/health/gc/GarbageCollectionMonitor.java
Cannot solve method call getGarbageCollectionStatsWithEmptyDefault(gcStrategy.getPermGenPoolName()) java.lang.RuntimeException: Method 'getPermGenPoolName' cannot be resolved in context gcStrategy.getPermGenPoolName() (line: 92) MethodCallExprContext{wrapped=gcStrategy.getPermGenPoolName()}. Parameter types: [] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/server/health/gc/GarbageCollectionMonitor.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve field access GarbageCollectorMonitoringStrategy.UNKNOWN
Cannot solve method call LOGGER.debug(String.format("GC rate: %.2f/s %s usage: %s%%", gcStats.getRate(), pool, gcStats.getUsage())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, PrimitiveTypeUsage{name='double'}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, PrimitiveTypeUsage{name='int'}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/server/health/DaemonMemoryStatus.java
Cannot solve method call Cast.cast(type, ManagementFactory.getPlatformMBeanServer().getAttribute(objectName, attribute)) com.github.javaparser.symbolsolver.logic.ConfilictingGenericTypesException: No matching between ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual) /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/server/health/memory/MBeanAttributeProvider.java
Cannot solve method call out.add(DaemonStopEvent.SERIALIZER.read(decoder)) java.lang.RuntimeException: Method 'read' cannot be resolved in context DaemonStopEvent.SERIALIZER.read(decoder) (line: 129) MethodCallExprContext{wrapped=DaemonStopEvent.SERIALIZER.read(decoder)}. Parameter types: [ReferenceType{org.gradle.internal.serialize.Decoder, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/registry/DaemonRegistryContent.java
Cannot solve method call out.add(SocketInetAddress.SERIALIZER.read(decoder)) java.lang.RuntimeException: Method 'read' cannot be resolved in context SocketInetAddress.SERIALIZER.read(decoder) (line: 205) MethodCallExprContext{wrapped=SocketInetAddress.SERIALIZER.read(decoder)}. Parameter types: [ReferenceType{org.gradle.internal.serialize.Decoder, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/registry/DaemonRegistryContent.java
Cannot solve method call builder.setDaemonRegistryDir(get(DaemonDir.class).getBaseDir()) java.lang.RuntimeException: Method 'getBaseDir' cannot be resolved in context get(DaemonDir.class).getBaseDir() (line: 44) MethodCallExprContext{wrapped=get(DaemonDir.class).getBaseDir()}. Parameter types: [] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/client/DaemonClientServices.java
Cannot solve method call LOG.debug("thread {}: dispatching {}", Thread.currentThread().getId(), message.getClass()) UnsolvedSymbolException{context='Method 'currentThread' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Thread}'} /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/client/DaemonClientConnection.java
Cannot solve method call LOG.debug("thread {}: connection stop", Thread.currentThread().getId()) UnsolvedSymbolException{context='Method 'currentThread' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Thread}'} /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/client/DaemonClientConnection.java
Cannot solve method call LOGGER.lifecycle("{} Please consider using the daemon: {}.", MESSAGE, documentationRegistry.getDocumentationFor("gradle_daemon")) java.lang.RuntimeException: Method 'getDocumentationFor' cannot be resolved in context documentationRegistry.getDocumentationFor("gradle_daemon") (line: 51) MethodCallExprContext{wrapped=documentationRegistry.getDocumentationFor("gradle_daemon")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/client/SingleUseDaemonClient.java
Cannot solve method call LOGGER.debug("Forwarding input to daemon: '{}'", input.replace("\n", "\\n")) java.lang.RuntimeException: Method 'replace' cannot be resolved in context input.replace("\n", "\\n") (line: 70) MethodCallExprContext{wrapped=input.replace("\n", "\\n")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/client/DaemonClientInputForwarder.java
Method 'getModule' cannot be resolved in context registry.getModule("gradle-launcher") (line: 85) MethodCallExprContext{wrapped=registry.getModule("gradle-launcher")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getModule' cannot be resolved in context registry.getModule("gradle-launcher") (line: 79) MethodCallExprContext{wrapped=registry.getModule("gradle-launcher")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call daemonArgs.add(CollectionUtils.join(File.pathSeparator, classpath.getAsFiles())) UnsolvedSymbolException{context='Method 'join' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class CollectionUtils {

    /**
     * Returns null if the collection is empty otherwise expects a {@link #single(Iterable)} element to be found.
     */
    @Nullable
    public static <T> T findSingle(Collection<T> source) {
        return source.isEmpty() ? null : single(source);
    }

    /**
     * Returns the single element in the collection or throws.
     */
    public static <T> T single(Iterable<? extends T> source) {
        Iterator<? extends T> iterator = source.iterator();
        if (!iterator.hasNext()) {
            throw new NoSuchElementException("Expecting collection with single element, got none.");
        }
        T element = iterator.next();
        if (iterator.hasNext()) {
            throw new IllegalArgumentException("Expecting collection with single element, got multiple.");
        }
        return element;
    }

    public static <T> Collection<? extends T> checkedCast(Class<T> type, Collection<?> input) {
        for (Object o : input) {
            cast(type, o);
        }
        return Cast.uncheckedCast(input);
    }

    public static <T> T findFirst(Iterable<? extends T> source, Spec<? super T> filter) {
        for (T item : source) {
            if (filter.isSatisfiedBy(item)) {
                return item;
            }
        }
        return null;
    }

    public static <T> T findFirst(T[] source, Spec<? super T> filter) {
        for (T thing : source) {
            if (filter.isSatisfiedBy(thing)) {
                return thing;
            }
        }
        return null;
    }

    public static <T> T first(Iterable<? extends T> source) {
        return source.iterator().next();
    }

    public static <T> boolean any(Iterable<? extends T> source, Spec<? super T> filter) {
        return findFirst(source, filter) != null;
    }

    public static <T> boolean any(T[] source, Spec<? super T> filter) {
        return findFirst(source, filter) != null;
    }

    public static <T> Set<T> filter(Set<? extends T> set, Spec<? super T> filter) {
        return filter(set, new LinkedHashSet<T>(), filter);
    }

    public static <T> List<T> filter(List<? extends T> list, Spec<? super T> filter) {
        return filter(list, new LinkedList<T>(), filter);
    }

    public static <T> List<T> filter(T[] array, Spec<? super T> filter) {
        return filter(Arrays.asList(array), new LinkedList<T>(), filter);
    }

    /**
     * Returns a sorted copy of the provided collection of things. Uses the provided comparator to sort.
     */
    public static <T> List<T> sort(Iterable<? extends T> things, Comparator<? super T> comparator) {
        List<T> copy = toMutableList(things);
        Collections.sort(copy, comparator);
        return copy;
    }

    /**
     * Returns a sorted copy of the provided collection of things. Uses the natural ordering of the things.
     */
    public static <T extends Comparable> List<T> sort(Iterable<T> things) {
        List<T> copy = toMutableList(things);
        Collections.sort(copy);
        return copy;
    }

    public static <T, C extends Collection<T>> C filter(Iterable<? extends T> source, C destination, Spec<? super T> filter) {
        for (T item : source) {
            if (filter.isSatisfiedBy(item)) {
                destination.add(item);
            }
        }
        return destination;
    }

    public static <K, V> Map<K, V> filter(Map<K, V> map, Spec<Map.Entry<K, V>> filter) {
        return filter(map, new HashMap<K, V>(), filter);
    }

    public static <K, V> Map<K, V> filter(Map<K, V> map, Map<K, V> destination, Spec<Map.Entry<K, V>> filter) {
        for (Map.Entry<K, V> entry : map.entrySet()) {
            if (filter.isSatisfiedBy(entry)) {
                destination.put(entry.getKey(), entry.getValue());
            }
        }
        return destination;
    }

    public static <R, I> R[] collectArray(I[] list, Class<R> newType, Transformer<? extends R, ? super I> transformer) {
        @SuppressWarnings("unchecked") R[] destination = (R[]) Array.newInstance(newType, list.length);
        return collectArray(list, destination, transformer);
    }

    public static <R, I> R[] collectArray(I[] list, R[] destination, Transformer<? extends R, ? super I> transformer) {
        assert list.length <= destination.length;
        for (int i = 0; i < list.length; ++i) {
            destination[i] = transformer.transform(list[i]);
        }
        return destination;
    }

    public static <R, I> List<R> collect(List<? extends I> list, Transformer<? extends R, ? super I> transformer) {
        return collect(list, new ArrayList<R>(list.size()), transformer);
    }

    public static <R, I> List<R> collect(I[] list, Transformer<? extends R, ? super I> transformer) {
        return collect(Arrays.asList(list), transformer);
    }

    public static <R, I> Set<R> collect(Set<? extends I> set, Transformer<? extends R, ? super I> transformer) {
        return collect(set, new HashSet<R>(), transformer);
    }

    public static <R, I> List<R> collect(Iterable<? extends I> source, Transformer<? extends R, ? super I> transformer) {
        return collect(source, new LinkedList<R>(), transformer);
    }

    public static <R, I, C extends Collection<R>> C collect(Iterable<? extends I> source, C destination, Transformer<? extends R, ? super I> transformer) {
        for (I item : source) {
            destination.add(transformer.transform(item));
        }
        return destination;
    }

    public static List<String> toStringList(Iterable<?> iterable) {
        return collect(iterable, new LinkedList<String>(), Transformers.asString());
    }

    /**
     * Recursively unpacks all the given things into a flat list.
     *
     * Nulls are not removed, they are left intact.
     *
     * @param things The things to flatten
     * @return A flattened list of the given things
     */
    public static List<?> flattenCollections(Object... things) {
        return flattenCollections(Object.class, things);
    }

    /**
     * Recursively unpacks all the given things into a flat list, ensuring they are of a certain type.
     *
     * Nulls are not removed, they are left intact.
     *
     * If a non null object cannot be cast to the target type, a ClassCastException will be thrown.
     *
     * @param things The things to flatten
     * @param <T> The target type in the flattened list
     * @return A flattened list of the given things
     */
    public static <T> List<T> flattenCollections(Class<T> type, Object... things) {
        if (things == null) {
            return Collections.singletonList(null);
        } else if (things.length == 0) {
            return Collections.emptyList();
        } else if (things.length == 1) {
            Object thing = things[0];
            if (thing == null) {
                return Collections.singletonList(null);
            }
            if (thing.getClass().isArray()) {
                Object[] thingArray = (Object[]) thing;
                List<T> list = new ArrayList<T>(thingArray.length);
                for (Object thingThing : thingArray) {
                    list.addAll(flattenCollections(type, thingThing));
                }
                return list;
            }
            if (thing instanceof Collection) {
                Collection<?> collection = (Collection<?>) thing;
                List<T> list = new ArrayList<T>();
                for (Object element : collection) {
                    list.addAll(flattenCollections(type, element));
                }
                return list;
            }
            return Collections.singletonList(cast(type, thing));
        } else {
            List<T> list = new ArrayList<T>();
            for (Object thing : things) {
                list.addAll(flattenCollections(type, thing));
            }
            return list;
        }
    }

    public static <T> List<T> toList(Iterable<? extends T> things) {
        if (things instanceof List) {
            @SuppressWarnings("unchecked") List<T> castThings = (List<T>) things;
            return castThings;
        }
        return toMutableList(things);
    }

    public static <T> List<T> toList(Enumeration<? extends T> things) {
        AbstractList<T> list = new ArrayList<T>();
        while (things.hasMoreElements()) {
            list.add(things.nextElement());
        }
        return list;
    }

    private static <T> List<T> toMutableList(Iterable<? extends T> things) {
        if (things == null) {
            return new ArrayList<T>(0);
        }
        List<T> list = new ArrayList<T>();
        for (T thing : things) {
            list.add(thing);
        }
        return list;
    }

    public static <T> List<T> intersection(Collection<? extends Collection<T>> availableValuesByDescriptor) {
        List<T> result = new ArrayList<T>();
        Iterator<? extends Collection<T>> iterator = availableValuesByDescriptor.iterator();
        if (iterator.hasNext()) {
            Collection<T> firstSet = iterator.next();
            result.addAll(firstSet);
            while (iterator.hasNext()) {
                Collection<T> next = iterator.next();
                result.retainAll(next);
            }
        }
        return result;
    }

    public static <T> List<T> toList(T[] things) {
        if (things == null || things.length == 0) {
            return new ArrayList<T>(0);
        }
        List<T> list = new ArrayList<T>(things.length);
        Collections.addAll(list, things);
        return list;
    }

    public static <T> Set<T> toSet(Iterable<? extends T> things) {
        if (things == null) {
            return new HashSet<T>(0);
        }
        if (things instanceof Set) {
            @SuppressWarnings("unchecked") Set<T> castThings = (Set<T>) things;
            return castThings;
        }
        Set<T> set = new LinkedHashSet<T>();
        for (T thing : things) {
            set.add(thing);
        }
        return set;
    }

    public static <E> List<E> compact(List<E> list) {
        boolean foundAtLeastOneNull = false;
        List<E> compacted = null;
        int i = 0;
        for (E element : list) {
            if (element == null) {
                if (!foundAtLeastOneNull) {
                    compacted = new ArrayList<E>(list.size());
                    if (i > 0) {
                        compacted.addAll(list.subList(0, i));
                    }
                }
                foundAtLeastOneNull = true;
            } else if (foundAtLeastOneNull) {
                compacted.add(element);
            }
            ++i;
        }
        return foundAtLeastOneNull ? compacted : list;
    }

    public static <C extends Collection<String>> C stringize(Iterable<?> source, C destination) {
        return collect(source, destination, Transformers.asString());
    }

    public static List<String> stringize(Collection<?> source) {
        return stringize(source, new ArrayList<String>(source.size()));
    }

    public static <E> boolean replace(List<E> list, Spec<? super E> filter, Transformer<? extends E, ? super E> transformer) {
        boolean replaced = false;
        int i = 0;
        for (E it : list) {
            if (filter.isSatisfiedBy(it)) {
                list.set(i, transformer.transform(it));
                replaced = true;
            }
            ++i;
        }
        return replaced;
    }

    public static <K, V> void collectMap(Map<K, V> destination, Iterable<? extends V> items, Transformer<? extends K, ? super V> keyGenerator) {
        for (V item : items) {
            destination.put(keyGenerator.transform(item), item);
        }
    }

    /**
     * Given a set of values, derive a set of keys and return a map
     */
    public static <K, V> Map<K, V> collectMap(Iterable<? extends V> items, Transformer<? extends K, ? super V> keyGenerator) {
        Map<K, V> map = new LinkedHashMap<K, V>();
        collectMap(map, items, keyGenerator);
        return map;
    }

    public static <K, V> void collectMapValues(Map<K, V> destination, Iterable<? extends K> keys, Transformer<? extends V, ? super K> keyGenerator) {
        for (K item : keys) {
            destination.put(item, keyGenerator.transform(item));
        }
    }

    /**
     * Given a set of keys, derive a set of values and return a map
     */
    public static <K, V> Map<K, V> collectMapValues(Iterable<? extends K> keys, Transformer<? extends V, ? super K> keyGenerator) {
        Map<K, V> map = new LinkedHashMap<K, V>();
        collectMapValues(map, keys, keyGenerator);
        return map;
    }

    public static <T> boolean every(Iterable<? extends T> things, Spec<? super T> predicate) {
        for (T thing : things) {
            if (!predicate.isSatisfiedBy(thing)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Utility for adding an iterable to a collection.
     *
     * @param t1 The collection to add to
     * @param t2 The iterable to add each item of to the collection
     * @param <T> The element type of t1
     * @return t1
     */
    public static <T> Collection<T> addAll(Collection<T> t1, Iterable<? extends T> t2) {
        for (T t : t2) {
            t1.add(t);
        }
        return t1;
    }

    /**
     * Utility for adding an array to a collection.
     *
     * @param t1 The collection to add to
     * @param t2 The iterable to add each item of to the collection
     * @param <T> The element type of t1
     * @return t1
     */
    public static <T> Collection<T> addAll(Collection<T> t1, T... t2) {
        Collections.addAll(t1, t2);
        return t1;
    }

    /**
     * The result of diffing two sets.
     *
     * @param <T> The type of element the sets contain
     * @see CollectionUtils#diffSetsBy(java.util.Set, java.util.Set, org.gradle.api.Transformer)
     */
    public static class SetDiff<T> {

        public Set<T> leftOnly = new HashSet<T>();

        public Set<Pair<T, T>> common = new HashSet<Pair<T, T>>();

        public Set<T> rightOnly = new HashSet<T>();
    }

    /**
     * Provides a “diff report” of how the two sets are similar and how they are different, comparing the entries by some aspect.
     *
     * The transformer is used to generate the value to use to compare the entries by. That is, the entries are not compared by equals by an attribute or characteristic.
     *
     * The transformer is expected to produce a unique value for each entry in a single set. Behaviour is undefined if this condition is not met.
     *
     * @param left The set on the “left” side of the comparison.
     * @param right The set on the “right” side of the comparison.
     * @param compareBy Provides the value to compare entries from either side by
     * @param <T> The type of the entry objects
     * @return A representation of the difference
     */
    public static <T> SetDiff<T> diffSetsBy(Set<? extends T> left, Set<? extends T> right, Transformer<?, T> compareBy) {
        if (left == null) {
            throw new NullPointerException("'left' set is null");
        }
        if (right == null) {
            throw new NullPointerException("'right' set is null");
        }
        SetDiff<T> setDiff = new SetDiff<T>();
        Map<Object, T> indexedLeft = collectMap(left, compareBy);
        Map<Object, T> indexedRight = collectMap(right, compareBy);
        for (Map.Entry<Object, T> leftEntry : indexedLeft.entrySet()) {
            T rightValue = indexedRight.remove(leftEntry.getKey());
            if (rightValue == null) {
                setDiff.leftOnly.add(leftEntry.getValue());
            } else {
                Pair<T, T> pair = Pair.of(leftEntry.getValue(), rightValue);
                setDiff.common.add(pair);
            }
        }
        for (T rightValue : indexedRight.values()) {
            setDiff.rightOnly.add(rightValue);
        }
        return setDiff;
    }

    /**
     * Creates a string with {@code toString()} of each object with the given separator.
     *
     * <pre>
     * expect:
     * join(",", new Object[]{"a"}) == "a"
     * join(",", new Object[]{"a", "b", "c"}) == "a,b,c"
     * join(",", new Object[]{}) == ""
     * </pre>
     *
     * The {@code separator} must not be null and {@code objects} must not be null.
     *
     * @param separator The string by which to join each string representation
     * @param objects The objects to join the string representations of
     * @return The joined string
     */
    public static String join(String separator, Object[] objects) {
        return join(separator, objects == null ? null : Arrays.asList(objects));
    }

    /**
     * Creates a string with {@code toString()} of each object with the given separator.
     *
     * <pre>
     * expect:
     * join(",", ["a"]) == "a"
     * join(",", ["a", "b", "c"]) == "a,b,c"
     * join(",", []) == ""
     * </pre>
     *
     * The {@code separator} must not be null and {@code objects} must not be null.
     *
     * @param separator The string by which to join each string representation
     * @param objects The objects to join the string representations of
     * @return The joined string
     */
    public static String join(String separator, Iterable<?> objects) {
        if (separator == null) {
            throw new NullPointerException("The 'separator' cannot be null");
        }
        if (objects == null) {
            throw new NullPointerException("The 'objects' cannot be null");
        }
        StringBuilder string = new StringBuilder();
        Iterator<?> iterator = objects.iterator();
        if (iterator.hasNext()) {
            string.append(iterator.next().toString());
            while (iterator.hasNext()) {
                string.append(separator);
                string.append(iterator.next().toString());
            }
        }
        return string.toString();
    }

    /**
     * Partition given Collection into a Pair of Collections.
     *
     * <pre>Left</pre> Collection containing entries that satisfy the given predicate
     * <pre>Right</pre> Collection containing entries that do NOT satisfy the given predicate
     */
    public static <T> Pair<Collection<T>, Collection<T>> partition(Iterable<T> items, Spec<? super T> predicate) {
        Preconditions.checkNotNull(items, "Cannot partition null Collection");
        Preconditions.checkNotNull(predicate, "Cannot apply null Spec when partitioning");
        Collection<T> left = new LinkedList<T>();
        Collection<T> right = new LinkedList<T>();
        for (T item : items) {
            if (predicate.isSatisfiedBy(item)) {
                left.add(item);
            } else {
                right.add(item);
            }
        }
        return Pair.of(left, right);
    }

    public static class InjectionStep<T, I> {

        private final T target;

        private final I item;

        public InjectionStep(T target, I item) {
            this.target = target;
            this.item = item;
        }

        public T getTarget() {
            return target;
        }

        public I getItem() {
            return item;
        }
    }

    public static <T, I> T inject(T target, Iterable<? extends I> items, Action<InjectionStep<T, I>> action) {
        if (target == null) {
            throw new NullPointerException("The 'target' cannot be null");
        }
        if (items == null) {
            throw new NullPointerException("The 'items' cannot be null");
        }
        if (action == null) {
            throw new NullPointerException("The 'action' cannot be null");
        }
        for (I item : items) {
            action.execute(new InjectionStep<T, I>(target, item));
        }
        return target;
    }

    public static <K, V> ImmutableListMultimap<K, V> groupBy(Iterable<? extends V> iterable, Transformer<? extends K, V> grouper) {
        ImmutableListMultimap.Builder<K, V> builder = ImmutableListMultimap.builder();
        for (V element : iterable) {
            K key = grouper.transform(element);
            builder.put(key, element);
        }
        return builder.build();
    }

    public static <T> Iterable<? extends T> unpack(final Iterable<? extends Factory<? extends T>> factories) {
        return new Iterable<T>() {

            private final Iterator<? extends Factory<? extends T>> delegate = factories.iterator();

            public Iterator<T> iterator() {
                return new Iterator<T>() {

                    public boolean hasNext() {
                        return delegate.hasNext();
                    }

                    public T next() {
                        return delegate.next().create();
                    }

                    public void remove() {
                        throw new UnsupportedOperationException();
                    }
                };
            }
        };
    }

    @Nullable
    public static <T> List<T> nonEmptyOrNull(Iterable<T> iterable) {
        ImmutableList<T> list = ImmutableList.copyOf(iterable);
        return list.isEmpty() ? null : list;
    }

    public static <T> List<T> dedup(Iterable<T> source, final Equivalence<? super T> equivalence) {
        Iterable<Equivalence.Wrapper<T>> wrappers = Iterables.transform(source, new Function<T, Equivalence.Wrapper<T>>() {

            public Equivalence.Wrapper<T> apply(@Nullable T input) {
                return equivalence.wrap(input);
            }
        });
        Set<Equivalence.Wrapper<T>> deduped = ImmutableSet.copyOf(wrappers);
        return ImmutableList.copyOf(Iterables.transform(deduped, new Function<Equivalence.Wrapper<T>, T>() {

            public T apply(Equivalence.Wrapper<T> input) {
                return input.get();
            }
        }));
    }

    public static String asCommandLine(Iterable<String> arguments) {
        return Joiner.on(" ").join(collect(arguments, Transformers.asSafeCommandLineArgument()));
    }
}}'} /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/client/DefaultDaemonStarter.java
Cannot solve method call LOGGER.quiet(String.format(STATUS_FORMAT, "PID", "STATUS", "INFO")) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/client/ReportDaemonStatusClient.java
Cannot solve method call LOGGER.quiet(STATUS_FOOTER + " See " + documentationRegistry.getDocumentationFor("gradle_daemon", "sec:status")) java.lang.RuntimeException: Method 'getDocumentationFor' cannot be resolved in context documentationRegistry.getDocumentationFor("gradle_daemon", "sec:status") (line: 95) MethodCallExprContext{wrapped=documentationRegistry.getDocumentationFor("gradle_daemon", "sec:status")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/client/ReportDaemonStatusClient.java
Cannot solve method call LOGGER.quiet(String.format(STATUS_FORMAT, pid == null ? "PID unknown" : pid, status.getStatus(), status.getVersion())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/client/ReportDaemonStatusClient.java
Cannot solve method call LOGGER.quiet(String.format(STATUS_FORMAT, pid == null ? "PID unknown" : pid, "STOPPED", "(" + event.getReason() + ")")) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/client/ReportDaemonStatusClient.java
Cannot solve method call LOGGER.debug(String.format("Unable to get status of %s.", connection), failure) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.internal.remote.internal.Connection, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.internal.remote.internal.Connection.T=ReferenceType{org.gradle.launcher.daemon.protocol.Message, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/client/ReportStatusDispatcher.java
Cannot solve field access JavaVersion.VERSION_1_7
Cannot solve method call LOGGER.debug(String.format("Unable to complete stop daemon using %s.", connection), failure) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.internal.remote.internal.Connection, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.internal.remote.internal.Connection.T=ReferenceType{org.gradle.launcher.daemon.protocol.Message, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/client/StopDispatcher.java
Cannot solve method call findConnection(getCompatibleDaemons(daemonRegistry.getAll(), constraint)) java.lang.RuntimeException: Method 'getCompatibleDaemons' cannot be resolved in context getCompatibleDaemons(daemonRegistry.getAll(), constraint) (line: 94) MethodCallExprContext{wrapped=getCompatibleDaemons(daemonRegistry.getAll(), constraint)}. Parameter types: [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{DaemonInfo, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{org.gradle.api.internal.specs.ExplainingSpec, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.api.internal.specs.ExplainingSpec.T=ReferenceType{org.gradle.launcher.daemon.context.DaemonContext, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/client/DefaultDaemonConnector.java
Method 'newOperation' cannot be resolved in context progressLoggerFactory.newOperation(DefaultDaemonConnector.class) (line: 201) MethodCallExprContext{wrapped=progressLoggerFactory.newOperation(DefaultDaemonConnector.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.launcher.daemon.client.DefaultDaemonConnector, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'newOperation' cannot be resolved in context progressLoggerFactory.newOperation(DefaultDaemonConnector.class) (line: 246) MethodCallExprContext{wrapped=progressLoggerFactory.newOperation(DefaultDaemonConnector.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.launcher.daemon.client.DefaultDaemonConnector, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call connector.connect(daemon.getAddress()).create(Serializers.stateful(DaemonMessageSerializer.create())) UnsolvedSymbolException{context='Method 'stateful' with parameterTypes [ReferenceType{Serializer, typeParametersMap=TypeParametersMap{nameToValue={empty.T=ReferenceType{Message, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public class Serializers {

    public static <T> StatefulSerializer<T> stateful(final Serializer<T> serializer) {
        return new StatefulSerializerAdapter<T>(serializer);
    }

    private static class StatefulSerializerAdapter<T> implements StatefulSerializer<T> {

        private final Serializer<T> serializer;

        public StatefulSerializerAdapter(Serializer<T> serializer) {
            this.serializer = serializer;
        }

        @Override
        public ObjectReader<T> newReader(final Decoder decoder) {
            return new ObjectReader<T>() {

                @Override
                public T read() throws Exception {
                    return serializer.read(decoder);
                }
            };
        }

        @Override
        public ObjectWriter<T> newWriter(final Encoder encoder) {
            return new ObjectWriter<T>() {

                @Override
                public void write(T value) throws Exception {
                    serializer.write(encoder, value);
                }
            };
        }
    }
}}'} /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/client/DefaultDaemonConnector.java
Cannot solve method call LOGGER.debug("{}, Trying a different daemon...", e.getMessage()) java.lang.RuntimeException: Method 'getMessage' cannot be resolved in context e.getMessage() (line: 133) MethodCallExprContext{wrapped=e.getMessage()}. Parameter types: [] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/client/DaemonClient.java
Method 'getDaemon' cannot be resolved in context connection.getDaemon() (line: 129) MethodCallExprContext{wrapped=connection.getDaemon()}. Parameter types: []
Cannot solve method call LOGGER.info("Connected to daemon {}. Dispatching request {}.", connection.getDaemon(), build) java.lang.RuntimeException: Method 'getDaemon' cannot be resolved in context connection.getDaemon() (line: 148) MethodCallExprContext{wrapped=connection.getDaemon()}. Parameter types: [] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/client/DaemonClient.java
Cannot solve method call LOGGER.info("Received result {} from daemon {} (build should be starting).", result, connection.getDaemon()) java.lang.RuntimeException: Method 'getDaemon' cannot be resolved in context connection.getDaemon() (line: 162) MethodCallExprContext{wrapped=connection.getDaemon()}. Parameter types: [] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/client/DaemonClient.java
Cannot solve method call LOGGER.info("Received result {} from daemon {} (build should be done).", result, connection.getDaemon()) java.lang.RuntimeException: Method 'getDaemon' cannot be resolved in context connection.getDaemon() (line: 170) MethodCallExprContext{wrapped=connection.getDaemon()}. Parameter types: [] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/daemon/client/DaemonClient.java
Cannot solve field access JavaVersion.VERSION_1_9
Cannot solve method call System.err.println(e.getMessage()) java.lang.RuntimeException: Method 'getMessage' cannot be resolved in context e.getMessage() (line: 131) MethodCallExprContext{wrapped=e.getMessage()}. Parameter types: [] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/cli/CommandLineActionFactory.java
Cannot solve method call sb.append(GroovySystem.getVersion()) UnsolvedSymbolException{context='Solving GroovySystem', name='GroovySystem', typeSolver=null} /repo/subprojects/launcher/src/main/java/org/gradle/launcher/cli/CommandLineActionFactory.java
Cannot solve method call sb.append(Main.getAntVersion()) UnsolvedSymbolException{context='Method 'getAntVersion' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Main}'} /repo/subprojects/launcher/src/main/java/org/gradle/launcher/cli/CommandLineActionFactory.java
Method 'getFactory' cannot be resolved in context loggingServices.getFactory(LoggingManagerInternal.class) (line: 204) MethodCallExprContext{wrapped=loggingServices.getFactory(LoggingManagerInternal.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.internal.logging.LoggingManagerInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'hasDescription' cannot be resolved in context parser.option(FOREGROUND).hasDescription("Starts the Gradle Daemon in the foreground.") (line: 53) MethodCallExprContext{wrapped=parser.option(FOREGROUND).hasDescription("Starts the Gradle Daemon in the foreground.")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call startParameter.setConfigureOnDemand(isTrue(properties.get(GradleProperties.CONFIGURE_ON_DEMAND_PROPERTY))) com.github.javaparser.symbolsolver.logic.ConfilictingGenericTypesException: No matching between ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual) /repo/subprojects/launcher/src/main/java/org/gradle/launcher/cli/converter/PropertiesToStartParameterConverter.java
Cannot solve method call target.setEnabled(isTrue(daemonEnabledPropertyValue)) com.github.javaparser.symbolsolver.logic.ConfilictingGenericTypesException: No matching between ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual) /repo/subprojects/launcher/src/main/java/org/gradle/launcher/cli/converter/PropertiesToDaemonParametersConverter.java
Cannot solve method call target.setDebug(isTrue(debugEnabledPropertyValue)) com.github.javaparser.symbolsolver.logic.ConfilictingGenericTypesException: No matching between ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual) /repo/subprojects/launcher/src/main/java/org/gradle/launcher/cli/converter/PropertiesToDaemonParametersConverter.java
Cannot solve method call layoutConverter.convert(args, target.getLayout()) java.lang.RuntimeException: Method 'getLayout' cannot be resolved in context target.getLayout() (line: 72) MethodCallExprContext{wrapped=target.getLayout()}. Parameter types: [] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/cli/ParametersConverter.java
Cannot solve method call layoutToPropertiesConverter.convert(target.getLayout(), properties) java.lang.RuntimeException: Method 'getLayout' cannot be resolved in context target.getLayout() (line: 75) MethodCallExprContext{wrapped=target.getLayout()}. Parameter types: [] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/cli/ParametersConverter.java
Cannot solve method call propertiesToStartParameterConverter.convert(properties, target.getStartParameter()) java.lang.RuntimeException: Method 'getStartParameter' cannot be resolved in context target.getStartParameter() (line: 78) MethodCallExprContext{wrapped=target.getStartParameter()}. Parameter types: [] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/cli/ParametersConverter.java
Cannot solve method call commandLineConverter.convert(args, target.getStartParameter()) java.lang.RuntimeException: Method 'getStartParameter' cannot be resolved in context target.getStartParameter() (line: 79) MethodCallExprContext{wrapped=target.getStartParameter()}. Parameter types: [] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/cli/ParametersConverter.java
Method 'getStartParameter' cannot be resolved in context target.getStartParameter() (line: 81) MethodCallExprContext{wrapped=target.getStartParameter()}. Parameter types: []
Method 'displayName' cannot be resolved in context ServiceRegistryBuilder.builder().displayName("Global services") (line: 120) MethodCallExprContext{wrapped=ServiceRegistryBuilder.builder().displayName("Global services")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'displayName' cannot be resolved in context ServiceRegistryBuilder.builder().displayName("Global services") (line: 120) MethodCallExprContext{wrapped=ServiceRegistryBuilder.builder().displayName("Global services")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'displayName' cannot be resolved in context ServiceRegistryBuilder.builder().displayName("Global services") (line: 120) MethodCallExprContext{wrapped=ServiceRegistryBuilder.builder().displayName("Global services")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'displayName' cannot be resolved in context ServiceRegistryBuilder.builder().displayName("Global services") (line: 120) MethodCallExprContext{wrapped=ServiceRegistryBuilder.builder().displayName("Global services")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'displayName' cannot be resolved in context ServiceRegistryBuilder.builder().displayName("Daemon client global services") (line: 148) MethodCallExprContext{wrapped=ServiceRegistryBuilder.builder().displayName("Daemon client global services")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'displayName' cannot be resolved in context ServiceRegistryBuilder.builder().displayName("Daemon client global services") (line: 148) MethodCallExprContext{wrapped=ServiceRegistryBuilder.builder().displayName("Daemon client global services")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'displayName' cannot be resolved in context ServiceRegistryBuilder.builder().displayName("Daemon client global services") (line: 148) MethodCallExprContext{wrapped=ServiceRegistryBuilder.builder().displayName("Daemon client global services")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'displayName' cannot be resolved in context ServiceRegistryBuilder.builder().displayName("Daemon client global services") (line: 148) MethodCallExprContext{wrapped=ServiceRegistryBuilder.builder().displayName("Daemon client global services")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Object[] Object
Cannot solve field access JavaVersion.VERSION_1_7
Cannot solve method call executionListener.onFailure(e.getCause()) java.lang.RuntimeException: Method 'getCause' cannot be resolved in context e.getCause() (line: 35) MethodCallExprContext{wrapped=e.getCause()}. Parameter types: [] /repo/subprojects/launcher/src/main/java/org/gradle/launcher/cli/ExceptionReportingAction.java
Cannot solve field access LogLevel.LIFECYCLE
Method 'println' cannot be resolved in context logger.println("Change detected, executing build...") (line: 106) MethodCallExprContext{wrapped=logger.println("Change detected, executing build...")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot resolve field access null
Cannot solve field access StyledTextOutput.Style.Failure
Cannot resolve field access null
Cannot solve field access LogLevel.INFO
Cannot solve field access LogLevel.DEBUG
Cannot resolve field access null
Method 'getFactory' cannot be resolved in context loggingServices.getFactory(LoggingManagerInternal.class) (line: 158) MethodCallExprContext{wrapped=loggingServices.getFactory(LoggingManagerInternal.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.internal.logging.LoggingManagerInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getFactory' cannot be resolved in context loggingServices.getFactory(LoggingManagerInternal.class) (line: 153) MethodCallExprContext{wrapped=loggingServices.getFactory(LoggingManagerInternal.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.internal.logging.LoggingManagerInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot resolve field access null
Cannot solve field access JavaVersion.VERSION_1_7
Method 'displayName' cannot be resolved in context ServiceRegistryBuilder.builder().displayName("Connection services") (line: 103) MethodCallExprContext{wrapped=ServiceRegistryBuilder.builder().displayName("Connection services")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'displayName' cannot be resolved in context ServiceRegistryBuilder.builder().displayName("Connection services") (line: 103) MethodCallExprContext{wrapped=ServiceRegistryBuilder.builder().displayName("Connection services")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'displayName' cannot be resolved in context ServiceRegistryBuilder.builder().displayName("Connection services") (line: 103) MethodCallExprContext{wrapped=ServiceRegistryBuilder.builder().displayName("Connection services")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'displayName' cannot be resolved in context ServiceRegistryBuilder.builder().displayName("Connection services") (line: 103) MethodCallExprContext{wrapped=ServiceRegistryBuilder.builder().displayName("Connection services")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve field access JavaVersion.VERSION_1_7
Method 'builder' cannot be resolved in context adapter.builder(ProviderOperationParameters.class) (line: 242) MethodCallExprContext{wrapped=adapter.builder(ProviderOperationParameters.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.tooling.internal.provider.connection.ProviderOperationParameters, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'builder' cannot be resolved in context adapter.builder(ProviderOperationParameters.class) (line: 242) MethodCallExprContext{wrapped=adapter.builder(ProviderOperationParameters.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.tooling.internal.provider.connection.ProviderOperationParameters, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'asMap' cannot be resolved in context classLoaderDetails.asMap() (line: 89) MethodCallExprContext{wrapped=classLoaderDetails.asMap()}. Parameter types: []
Method 'getInterfaces' cannot be resolved in context cl.getInterfaces() (line: 53) MethodCallExprContext{wrapped=cl.getInterfaces()}. Parameter types: []
Cannot solve method call writeInt(cl.getInterfaces().length) java.lang.RuntimeException: Method 'getInterfaces' cannot be resolved in context cl.getInterfaces() (line: 53) MethodCallExprContext{wrapped=cl.getInterfaces()}. Parameter types: [] /repo/subprojects/launcher/src/main/java/org/gradle/tooling/internal/provider/serialization/PayloadSerializer.java
Cannot solve method call writeUTF(targetClass.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context targetClass.getName() (line: 61) MethodCallExprContext{wrapped=targetClass.getName()}. Parameter types: [] /repo/subprojects/launcher/src/main/java/org/gradle/tooling/internal/provider/serialization/PayloadSerializer.java
Cannot solve method call Proxy.getProxyClass(actualInterfaces[0].getClassLoader(), actualInterfaces) java.lang.RuntimeException: Method 'getClassLoader' cannot be resolved in context actualInterfaces[0].getClassLoader() (line: 115) MethodCallExprContext{wrapped=actualInterfaces[0].getClassLoader()}. Parameter types: [] /repo/subprojects/launcher/src/main/java/org/gradle/tooling/internal/provider/serialization/PayloadSerializer.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call candidates.add(target.getClassLoader()) java.lang.RuntimeException: Method 'getClassLoader' cannot be resolved in context target.getClassLoader() (line: 79) MethodCallExprContext{wrapped=target.getClassLoader()}. Parameter types: [] /repo/subprojects/launcher/src/main/java/org/gradle/tooling/internal/provider/serialization/ClientSidePayloadClassLoaderRegistry.java
Method 'weakKeys' cannot be resolved in context new MapMaker().weakKeys() (line: 51) MethodCallExprContext{wrapped=new MapMaker().weakKeys()}. Parameter types: []
Method 'getName' cannot be resolved in context target.getName() (line: 84) MethodCallExprContext{wrapped=target.getName()}. Parameter types: []
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call className.equals(target.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context target.getName() (line: 126) MethodCallExprContext{wrapped=target.getName()}. Parameter types: [] /repo/subprojects/launcher/src/main/java/org/gradle/tooling/internal/provider/serialization/ClasspathInferer.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call classReader.accept(detector, ClassReader.SKIP_DEBUG | ClassReader.SKIP_CODE) UnsolvedSymbolException{context='unknown', name='SKIP_DEBUG', typeSolver=null} /repo/subprojects/launcher/src/main/java/org/gradle/tooling/internal/provider/serialization/ClientSidePayloadClassLoaderFactory.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call emptyWriter.visit(Opcodes.V1_5, Opcodes.ACC_PUBLIC | Opcodes.ACC_INTERFACE, detector.interfaceName.replace('.', '/'), null, Type.getType(Object.class).getInternalName(), null) UnsolvedSymbolException{context='unknown', name='V1_5', typeSolver=null} /repo/subprojects/launcher/src/main/java/org/gradle/tooling/internal/provider/serialization/ClientSidePayloadClassLoaderFactory.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call allInterfaces.add(mixInInterface.replace('.', '/')) java.lang.RuntimeException: Method 'replace' cannot be resolved in context mixInInterface.replace('.', '/') (line: 122) MethodCallExprContext{wrapped=mixInInterface.replace('.', '/')}. Parameter types: [PrimitiveTypeUsage{name='char'}, PrimitiveTypeUsage{name='char'}] /repo/subprojects/launcher/src/main/java/org/gradle/tooling/internal/provider/serialization/ClientSidePayloadClassLoaderFactory.java
Cannot solve method call super.visit(version, access, name, signature, superName, allInterfaces.toArray(new String[0])) java.lang.RuntimeException: String[] T[] /repo/subprojects/launcher/src/main/java/org/gradle/tooling/internal/provider/serialization/ClientSidePayloadClassLoaderFactory.java
Cannot resolve field access null
Cannot solve method call classLoaderFactory.getClassLoaderFor(SystemClassLoaderSpec.INSTANCE, ImmutableList.<ClassLoader>of()) UnsolvedSymbolException{context='Method 'of' with parameterTypes []', name='ReflectionClassDeclaration{clazz=ImmutableList}'} /repo/subprojects/launcher/src/main/java/org/gradle/tooling/internal/provider/serialization/DefaultPayloadClassLoaderRegistry.java
Cannot solve method call parents.add(classLoaderFactory.getClassLoaderFor(SystemClassLoaderSpec.INSTANCE, ImmutableList.<ClassLoader>of())) java.lang.RuntimeException: Error calculating the type of parameter ImmutableList.<ClassLoader>of() of method call classLoaderFactory.getClassLoaderFor(SystemClassLoaderSpec.INSTANCE, ImmutableList.<ClassLoader>of()) /repo/subprojects/launcher/src/main/java/org/gradle/tooling/internal/provider/serialization/DefaultPayloadClassLoaderRegistry.java
Cannot solve field access LogLevel.DEBUG
Method 'insert' cannot be resolved in context builder.insert(0, " > ") (line: 39) MethodCallExprContext{wrapped=builder.insert(0, " > ")}. Parameter types: [PrimitiveTypeUsage{name='int'}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call ansi.fg(DEFAULT) UnsolvedSymbolException{context='Solving DEFAULT', name='DEFAULT', typeSolver=null} /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/console/DefaultColorMap.java
Cannot resolve field access null
Cannot solve method call ansi.eraseLine(Ansi.Erase.FORWARD) UnsolvedSymbolException{context='unknown', name='FORWARD', typeSolver=null} /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/console/AnsiConsole.java
Cannot resolve field access null
Cannot solve method call ansi.eraseLine(Ansi.Erase.FORWARD) UnsolvedSymbolException{context='unknown', name='FORWARD', typeSolver=null} /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/console/AnsiConsole.java
Cannot solve method call charactersWritten(writePos, text.length()) java.lang.RuntimeException: Method 'length' cannot be resolved in context text.length() (line: 193) MethodCallExprContext{wrapped=text.length()}. Parameter types: [] /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/console/AnsiConsole.java
Cannot solve method call textStr.substring(pos, textStr.length()) java.lang.RuntimeException: Method 'length' cannot be resolved in context textStr.length() (line: 231) MethodCallExprContext{wrapped=textStr.length()}. Parameter types: [] /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/console/AnsiConsole.java
Cannot solve method call ansi.a(textStr.substring(pos, textStr.length())) java.lang.RuntimeException: Error calculating the type of parameter textStr.length() of method call textStr.substring(pos, textStr.length()) /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/console/AnsiConsole.java
Cannot solve method call charactersWritten(writePos, textStr.length() - pos) java.lang.RuntimeException: Method 'length' cannot be resolved in context textStr.length() (line: 232) MethodCallExprContext{wrapped=textStr.length()}. Parameter types: [] /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/console/AnsiConsole.java
Cannot solve method call ansi.a(textStr.substring(pos, next)) java.lang.RuntimeException: Method 'substring' cannot be resolved in context textStr.substring(pos, next) (line: 227) MethodCallExprContext{wrapped=textStr.substring(pos, next)}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}] /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/console/AnsiConsole.java
Cannot resolve field access null
Cannot solve method call ansi.eraseLine(Ansi.Erase.FORWARD) UnsolvedSymbolException{context='unknown', name='FORWARD', typeSolver=null} /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/console/AnsiConsole.java
Cannot solve field access LogLevel.DEBUG
Cannot solve field access LogLevel.ERROR
Cannot solve field access State.None
Cannot solve field access State.None
Cannot solve field access State.HeaderCompleted
Cannot solve field access State.HeaderStarted
Cannot solve field access LogLevel.LIFECYCLE
Empty name expression None
Cannot solve field access LogLevel.LIFECYCLE
Empty name expression HeaderStarted
Cannot solve field access LogLevel.LIFECYCLE
Empty name expression HeaderCompleted
Cannot solve field access State.HeaderCompleted
Empty name expression None
Cannot solve field access LogLevel.LIFECYCLE
Cannot solve field access LogLevel.LIFECYCLE
Cannot solve field access Style.ProgressStatus
Empty name expression HeaderStarted
Cannot solve field access LogLevel.LIFECYCLE
Cannot solve field access LogLevel.LIFECYCLE
Cannot solve field access Style.ProgressStatus
Empty name expression HeaderCompleted
Cannot solve field access LogLevel.LIFECYCLE
Cannot solve field access Style.ProgressStatus
Cannot solve field access State.Completed
Cannot solve field access LogLevel.LIFECYCLE
Cannot solve field access LogLevel.ERROR
Cannot solve field access LogLevel.ERROR
Cannot solve field access ConsoleOutput.Plain
Cannot solve field access ConsoleOutput.Auto
Cannot solve field access ConsoleOutput.Rich
Cannot resolve field access null
Cannot solve field access LogLevel.ERROR
Cannot solve method call put(Project.MSG_ERR, LogLevel.ERROR) UnsolvedSymbolException{context='unknown', name='MSG_ERR', typeSolver=null} /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/LogLevelMapping.java
Cannot resolve field access null
Cannot solve field access LogLevel.WARN
Cannot solve method call put(Project.MSG_WARN, LogLevel.WARN) UnsolvedSymbolException{context='unknown', name='MSG_WARN', typeSolver=null} /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/LogLevelMapping.java
Cannot resolve field access null
Cannot solve field access LogLevel.INFO
Cannot solve method call put(Project.MSG_INFO, LogLevel.INFO) UnsolvedSymbolException{context='unknown', name='MSG_INFO', typeSolver=null} /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/LogLevelMapping.java
Cannot resolve field access null
Cannot solve field access LogLevel.DEBUG
Cannot solve method call put(Project.MSG_DEBUG, LogLevel.DEBUG) UnsolvedSymbolException{context='unknown', name='MSG_DEBUG', typeSolver=null} /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/LogLevelMapping.java
Cannot resolve field access null
Cannot solve field access LogLevel.DEBUG
Cannot solve method call put(Project.MSG_VERBOSE, LogLevel.DEBUG) UnsolvedSymbolException{context='unknown', name='MSG_VERBOSE', typeSolver=null} /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/LogLevelMapping.java
Cannot resolve field access null
Cannot solve field access LogLevel.LIFECYCLE
Cannot solve field access LogLevel.QUIET
Cannot solve field access LogLevel.ERROR
Cannot solve field access LogLevel.DEBUG
Cannot solve field access LogLevel.LIFECYCLE
Cannot solve field access LogLevel.LIFECYCLE
Cannot solve field access LogLevel.LIFECYCLE
Cannot solve field access LogLevel.LIFECYCLE
Cannot resolve field access null
Cannot solve field access StyledTextOutput.Style.Normal
Cannot resolve field access null
Cannot solve field access StyledTextOutput.Style.Normal
Method 'append' cannot be resolved in context builder.append('[') (line: 63) MethodCallExprContext{wrapped=builder.append('[')}. Parameter types: [PrimitiveTypeUsage{name='char'}]
Method 'append' cannot be resolved in context builder.append('[') (line: 63) MethodCallExprContext{wrapped=builder.append('[')}. Parameter types: [PrimitiveTypeUsage{name='char'}]
Method 'append' cannot be resolved in context builder.append(getCategory()) (line: 64) MethodCallExprContext{wrapped=builder.append(getCategory())}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot resolve field access null
Cannot solve field access StyledTextOutput.Style.Normal
Cannot solve method call newOperation(loggerCategory.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context loggerCategory.getName() (line: 40) MethodCallExprContext{wrapped=loggerCategory.getName()}. Parameter types: [] /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/progress/DefaultProgressLoggerFactory.java
Cannot solve field access State.idle
Cannot solve field access State.started
Cannot solve field access State.completed
Cannot solve field access State.started
Cannot solve field access State.completed
Cannot solve field access State.idle
Cannot solve field access State.completed
Cannot solve field access State.idle
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call doLineText(eol.substring(0, seenCharsFromEol)) java.lang.RuntimeException: Method 'substring' cannot be resolved in context eol.substring(0, seenCharsFromEol) (line: 56) MethodCallExprContext{wrapped=eol.substring(0, seenCharsFromEol)}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}] /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/text/AbstractLineChoppingStyledTextOutput.java
Cannot resolve field access null
Cannot solve method call doLineText(text.substring(start, pos - seenCharsFromEol)) java.lang.RuntimeException: Method 'substring' cannot be resolved in context text.substring(start, pos - seenCharsFromEol) (line: 49) MethodCallExprContext{wrapped=text.substring(start, pos - seenCharsFromEol)}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}] /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/text/AbstractLineChoppingStyledTextOutput.java
Cannot solve method call doLineText(text.substring(start, pos - seenCharsFromEol)) java.lang.RuntimeException: Method 'substring' cannot be resolved in context text.substring(start, pos - seenCharsFromEol) (line: 64) MethodCallExprContext{wrapped=text.substring(start, pos - seenCharsFromEol)}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}] /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/text/AbstractLineChoppingStyledTextOutput.java
Cannot solve method call create(logCategory.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context logCategory.getName() (line: 23) MethodCallExprContext{wrapped=logCategory.getName()}. Parameter types: [] /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/text/AbstractStyledTextOutputFactory.java
Cannot solve method call create(logCategory, null) com.github.javaparser.resolution.MethodAmbiguityException: Ambiguous method call: cannot find a most applicable method: JavaParserMethodDeclaration{wrappedNode=/**
 * Creates a {@code StyledTextOutput} with the given category and log level.
 *
 * @param logCategory The log category.
 * @param logLevel The log level. Can be null to use the standard output log level.
 * @return the output
 */
StyledTextOutput create(Class logCategory, LogLevel logLevel);, typeSolver=com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver@6fb0d3ed}, JavaParserMethodDeclaration{wrappedNode=/**
 * Creates a {@code StyledTextOutput} with the given category and log level.
 *
 * @param logCategory The log category.
 * @param logLevel The log level. Can be null to use the standard output log level.
 * @return the output
 */
StyledTextOutput create(String logCategory, LogLevel logLevel);, typeSolver=com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver@6fb0d3ed} /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/text/AbstractStyledTextOutputFactory.java
Cannot solve method call create(logCategory.getName(), logLevel) java.lang.RuntimeException: Method 'getName' cannot be resolved in context logCategory.getName() (line: 31) MethodCallExprContext{wrapped=logCategory.getName()}. Parameter types: [] /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/text/AbstractStyledTextOutputFactory.java
Cannot solve field access Style.Normal
Cannot solve method call text(String.valueOf(c)) UnsolvedSymbolException{context='Method 'valueOf' with parameterTypes [PrimitiveTypeUsage{name='char'}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/text/AbstractStyledTextOutput.java
Cannot solve method call text(String.format(pattern, args)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ResolvedArrayType{ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/text/AbstractStyledTextOutput.java
Object[] Object
Cannot solve field access LogLevel.QUIET
Cannot solve field access LogLevel.INFO
Cannot solve field access LogLevel.DEBUG
Cannot solve field access ShowStacktrace.ALWAYS_FULL
Cannot solve field access ShowStacktrace.ALWAYS
Cannot solve method call StringUtils.capitalize(value.toLowerCase(Locale.ENGLISH)) java.lang.RuntimeException: Method 'toLowerCase' cannot be resolved in context value.toLowerCase(Locale.ENGLISH) (line: 72) MethodCallExprContext{wrapped=value.toLowerCase(Locale.ENGLISH)}. Parameter types: [ReferenceType{java.util.Locale, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/LoggingCommandLineConverter.java
Method 'hasArgument' cannot be resolved in context parser.option(CONSOLE).hasArgument() (line: 90) MethodCallExprContext{wrapped=parser.option(CONSOLE).hasArgument()}. Parameter types: []
Method 'inverse' cannot be resolved in context logLevelMap.inverse() (line: 119) MethodCallExprContext{wrapped=logLevelMap.inverse()}. Parameter types: []
Cannot solve field access LogLevel.DEBUG
Cannot solve field access LogLevel.INFO
Cannot solve field access LogLevel.LIFECYCLE
Cannot solve field access LogLevel.QUIET
Method 'inverse' cannot be resolved in context showStacktraceMap.inverse() (line: 165) MethodCallExprContext{wrapped=showStacktraceMap.inverse()}. Parameter types: []
Cannot solve field access LogLevel.LIFECYCLE
Cannot solve field access ShowStacktrace.INTERNAL_EXCEPTIONS
Cannot solve field access ConsoleOutput.Auto
Cannot solve field access LogLevel.LIFECYCLE
Cannot solve field access LogLevel.DEBUG
Cannot solve field access LogLevel.INFO
Cannot solve field access LogLevel.WARN
Cannot solve field access LogLevel.ERROR
Cannot solve field access LogLevel.LIFECYCLE
Cannot solve field access LogLevel.QUIET
Cannot solve method call log(logLevel, loggedThrowable, tuple.getMessage()) UnsolvedSymbolException{context='unknown', name='FormattingTuple', typeSolver=null} /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/slf4j/OutputEventListenerBackedLogger.java
Cannot solve field access LogLevel.DEBUG
Cannot solve method call log(LogLevel.DEBUG, null, message) com.github.javaparser.resolution.MethodAmbiguityException: Ambiguous method call: cannot find a most applicable method: JavaParserMethodDeclaration{wrappedNode=@Override
public void log(LogLevel level, String message, Throwable throwable) {
    if (isEnabled(level)) {
        log(level, throwable, message);
    }
}, typeSolver=com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver@6fb0d3ed}, JavaParserMethodDeclaration{wrappedNode=/**
 * Logs the given message at the given log level.
 *
 * @param level the log level.
 * @param message the log message.
 * @param throwable the exception to log.
 */
void log(LogLevel level, String message, Throwable throwable);, typeSolver=com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver@6fb0d3ed} /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/slf4j/OutputEventListenerBackedLogger.java
Cannot solve field access LogLevel.DEBUG
Cannot solve field access LogLevel.DEBUG
Cannot solve field access LogLevel.DEBUG
Cannot solve field access LogLevel.DEBUG
Cannot solve field access LogLevel.DEBUG
Cannot solve method call log(LogLevel.DEBUG, null, msg) com.github.javaparser.resolution.MethodAmbiguityException: Ambiguous method call: cannot find a most applicable method: JavaParserMethodDeclaration{wrappedNode=private void log(LogLevel logLevel, Throwable throwable, String message) {
    LogEvent logEvent = new LogEvent(timeProvider.getCurrentTime(), name, logLevel, message, throwable);
    OutputEventListener outputEventListener = context.getOutputEventListener();
    try {
        outputEventListener.onOutput(logEvent);
    } catch (Throwable e) {
        // fall back to standard out
        e.printStackTrace(System.out);
    }
}, typeSolver=com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver@6fb0d3ed}, JavaParserMethodDeclaration{wrappedNode=/**
 * Logs the given message at the given log level.
 *
 * @param level the log level.
 * @param message the log message.
 * @param throwable the exception to log.
 */
void log(LogLevel level, String message, Throwable throwable);, typeSolver=com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver@6fb0d3ed} /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/slf4j/OutputEventListenerBackedLogger.java
Cannot solve field access LogLevel.DEBUG
Cannot solve field access LogLevel.DEBUG
Cannot solve field access LogLevel.DEBUG
Cannot solve field access LogLevel.DEBUG
Cannot solve field access LogLevel.INFO
Cannot solve method call log(LogLevel.INFO, null, message) com.github.javaparser.resolution.MethodAmbiguityException: Ambiguous method call: cannot find a most applicable method: JavaParserMethodDeclaration{wrappedNode=private void log(LogLevel logLevel, Throwable throwable, String message) {
    LogEvent logEvent = new LogEvent(timeProvider.getCurrentTime(), name, logLevel, message, throwable);
    OutputEventListener outputEventListener = context.getOutputEventListener();
    try {
        outputEventListener.onOutput(logEvent);
    } catch (Throwable e) {
        // fall back to standard out
        e.printStackTrace(System.out);
    }
}, typeSolver=com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver@6fb0d3ed}, JavaParserMethodDeclaration{wrappedNode=/**
 * Logs the given message at the given log level.
 *
 * @param level the log level.
 * @param message the log message.
 * @param throwable the exception to log.
 */
void log(LogLevel level, String message, Throwable throwable);, typeSolver=com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver@6fb0d3ed} /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/slf4j/OutputEventListenerBackedLogger.java
Cannot solve field access LogLevel.INFO
Cannot solve field access LogLevel.INFO
Cannot solve field access LogLevel.INFO
Cannot solve field access LogLevel.LIFECYCLE
Cannot solve method call log(LogLevel.LIFECYCLE, null, message) com.github.javaparser.resolution.MethodAmbiguityException: Ambiguous method call: cannot find a most applicable method: JavaParserMethodDeclaration{wrappedNode=@Override
public void log(LogLevel level, String message, Throwable throwable) {
    if (isEnabled(level)) {
        log(level, throwable, message);
    }
}, typeSolver=com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver@6fb0d3ed}, JavaParserMethodDeclaration{wrappedNode=/**
 * Logs the given message at the given log level.
 *
 * @param level the log level.
 * @param message the log message.
 * @param throwable the exception to log.
 */
void log(LogLevel level, String message, Throwable throwable);, typeSolver=com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver@6fb0d3ed} /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/slf4j/OutputEventListenerBackedLogger.java
Cannot solve field access LogLevel.LIFECYCLE
Cannot solve field access LogLevel.LIFECYCLE
Cannot solve field access LogLevel.QUIET
Cannot solve method call log(LogLevel.QUIET, null, message) com.github.javaparser.resolution.MethodAmbiguityException: Ambiguous method call: cannot find a most applicable method: JavaParserMethodDeclaration{wrappedNode=private void log(LogLevel logLevel, Throwable throwable, String message) {
    LogEvent logEvent = new LogEvent(timeProvider.getCurrentTime(), name, logLevel, message, throwable);
    OutputEventListener outputEventListener = context.getOutputEventListener();
    try {
        outputEventListener.onOutput(logEvent);
    } catch (Throwable e) {
        // fall back to standard out
        e.printStackTrace(System.out);
    }
}, typeSolver=com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver@6fb0d3ed}, JavaParserMethodDeclaration{wrappedNode=/**
 * Logs the given message at the given log level.
 *
 * @param level the log level.
 * @param message the log message.
 * @param throwable the exception to log.
 */
void log(LogLevel level, String message, Throwable throwable);, typeSolver=com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver@6fb0d3ed} /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/slf4j/OutputEventListenerBackedLogger.java
Cannot solve field access LogLevel.QUIET
Cannot solve field access LogLevel.QUIET
Cannot solve method call log(level, null, message) com.github.javaparser.resolution.MethodAmbiguityException: Ambiguous method call: cannot find a most applicable method: JavaParserMethodDeclaration{wrappedNode=private void log(LogLevel logLevel, Throwable throwable, String message) {
    LogEvent logEvent = new LogEvent(timeProvider.getCurrentTime(), name, logLevel, message, throwable);
    OutputEventListener outputEventListener = context.getOutputEventListener();
    try {
        outputEventListener.onOutput(logEvent);
    } catch (Throwable e) {
        // fall back to standard out
        e.printStackTrace(System.out);
    }
}, typeSolver=com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver@6fb0d3ed}, JavaParserMethodDeclaration{wrappedNode=/**
 * Logs the given message at the given log level.
 *
 * @param level the log level.
 * @param message the log message.
 * @param throwable the exception to log.
 */
void log(LogLevel level, String message, Throwable throwable);, typeSolver=com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver@6fb0d3ed} /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/slf4j/OutputEventListenerBackedLogger.java
Cannot solve field access LogLevel.INFO
Cannot solve field access LogLevel.INFO
Cannot solve field access LogLevel.LIFECYCLE
Cannot solve field access LogLevel.QUIET
Cannot solve field access LogLevel.INFO
Cannot solve method call log(toLogLevel(marker), null, msg) com.github.javaparser.resolution.MethodAmbiguityException: Ambiguous method call: cannot find a most applicable method: JavaParserMethodDeclaration{wrappedNode=private void log(LogLevel logLevel, Throwable throwable, String message) {
    LogEvent logEvent = new LogEvent(timeProvider.getCurrentTime(), name, logLevel, message, throwable);
    OutputEventListener outputEventListener = context.getOutputEventListener();
    try {
        outputEventListener.onOutput(logEvent);
    } catch (Throwable e) {
        // fall back to standard out
        e.printStackTrace(System.out);
    }
}, typeSolver=com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver@6fb0d3ed}, JavaParserMethodDeclaration{wrappedNode=/**
 * Logs the given message at the given log level.
 *
 * @param level the log level.
 * @param message the log message.
 * @param throwable the exception to log.
 */
void log(LogLevel level, String message, Throwable throwable);, typeSolver=com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver@6fb0d3ed} /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/slf4j/OutputEventListenerBackedLogger.java
Cannot solve field access LogLevel.WARN
Cannot solve field access LogLevel.WARN
Cannot solve field access LogLevel.WARN
Cannot solve field access LogLevel.WARN
Cannot solve field access LogLevel.WARN
Cannot solve field access LogLevel.WARN
Cannot solve field access LogLevel.WARN
Cannot solve field access LogLevel.WARN
Cannot solve field access LogLevel.WARN
Cannot solve field access LogLevel.WARN
Cannot solve field access LogLevel.ERROR
Cannot solve method call log(LogLevel.ERROR, null, message) com.github.javaparser.resolution.MethodAmbiguityException: Ambiguous method call: cannot find a most applicable method: JavaParserMethodDeclaration{wrappedNode=private void log(LogLevel logLevel, Throwable throwable, String message) {
    LogEvent logEvent = new LogEvent(timeProvider.getCurrentTime(), name, logLevel, message, throwable);
    OutputEventListener outputEventListener = context.getOutputEventListener();
    try {
        outputEventListener.onOutput(logEvent);
    } catch (Throwable e) {
        // fall back to standard out
        e.printStackTrace(System.out);
    }
}, typeSolver=com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver@6fb0d3ed}, JavaParserMethodDeclaration{wrappedNode=/**
 * Logs the given message at the given log level.
 *
 * @param level the log level.
 * @param message the log message.
 * @param throwable the exception to log.
 */
void log(LogLevel level, String message, Throwable throwable);, typeSolver=com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver@6fb0d3ed} /repo/subprojects/logging/src/main/java/org/gradle/internal/logging/slf4j/OutputEventListenerBackedLogger.java
Cannot solve field access LogLevel.ERROR
Cannot solve field access LogLevel.ERROR
Cannot solve field access LogLevel.ERROR
Cannot solve field access LogLevel.ERROR
Cannot solve field access LogLevel.ERROR
Cannot solve field access LogLevel.ERROR
Cannot solve field access LogLevel.ERROR
Cannot solve field access LogLevel.ERROR
Cannot solve field access LogLevel.ERROR
Method 'getClassName' cannot be resolved in context current.getClassName() (line: 74) MethodCallExprContext{wrapped=current.getClassName()}. Parameter types: []
Method 'getClassName' cannot be resolved in context current.getClassName() (line: 70) MethodCallExprContext{wrapped=current.getClassName()}. Parameter types: []
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call nagUserWith(String.format("The %s plugin %s. Please use the %s plugin instead.", pluginName, getDeprecationMessage(), replacement)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/logging/src/main/java/org/gradle/util/SingleMessageLogger.java
Cannot solve method call nagUserWith(String.format("The %s plugin %s. Consider using the %s plugin instead.", pluginName, getDeprecationMessage(), replacement)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/logging/src/main/java/org/gradle/util/SingleMessageLogger.java
Cannot solve method call nagUserWith(String.format("The %s task %s. Please use the %s task instead.", taskName, getDeprecationMessage(), replacement)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/logging/src/main/java/org/gradle/util/SingleMessageLogger.java
Cannot solve method call nagUserWith(String.format("The %s task type %s. Please use the %s instead.", taskName, getDeprecationMessage(), replacement)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/logging/src/main/java/org/gradle/util/SingleMessageLogger.java
Cannot solve method call nagUserWith(String.format("The %s method %s. Please use the %s method instead.", methodName, getDeprecationMessage(), replacement)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/logging/src/main/java/org/gradle/util/SingleMessageLogger.java
Cannot solve method call nagUserWith(String.format("The %s property %s. Please use the %s property instead.", propertyName, getDeprecationMessage(), replacement)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/logging/src/main/java/org/gradle/util/SingleMessageLogger.java
Cannot solve method call nagUserWith(String.format("The %s method %s.", methodName, getDeprecationMessage())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/logging/src/main/java/org/gradle/util/SingleMessageLogger.java
Cannot solve method call nagUserWith(String.format("The %s method %s. %s", methodName, getDeprecationMessage(), advice)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/logging/src/main/java/org/gradle/util/SingleMessageLogger.java
Cannot solve method call nagUserWith(String.format("The %s property %s. %s", propertyName, getDeprecationMessage(), advice)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/logging/src/main/java/org/gradle/util/SingleMessageLogger.java
Cannot solve method call nagUserWith(String.format("The %s %s. %s", api, getDeprecationMessage(), advice)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/logging/src/main/java/org/gradle/util/SingleMessageLogger.java
Cannot solve method call nagUserWith(String.format("The %s named parameter %s. Please use the %s named parameter instead.", parameterName, getDeprecationMessage(), replacement)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/logging/src/main/java/org/gradle/util/SingleMessageLogger.java
Cannot solve method call nagUserWith(String.format("%s %s", thing, getDeprecationMessage())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/logging/src/main/java/org/gradle/util/SingleMessageLogger.java
Cannot solve method call nagUserWith(String.format("%s %s. %s.", thing, getDeprecationMessage(), explanation)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/logging/src/main/java/org/gradle/util/SingleMessageLogger.java
Cannot solve method call nagUserOfDeprecated(String.format("%s. This behaviour", behaviour)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/logging/src/main/java/org/gradle/util/SingleMessageLogger.java
Method 'withType' cannot be resolved in context project.getTasks().withType(Upload.class) (line: 134) MethodCallExprContext{wrapped=project.getTasks().withType(Upload.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.tasks.Upload, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot resolve field access null
Cannot solve method call pom.getGroupId().equals(MavenProject.EMPTY_PROJECT_GROUP_ID) UnsolvedSymbolException{context='unknown', name='EMPTY_PROJECT_GROUP_ID', typeSolver=null} /repo/subprojects/maven/src/main/java/org/gradle/api/plugins/MavenPlugin.java
Cannot resolve field access null
Cannot solve method call pom.getArtifactId().equals(MavenProject.EMPTY_PROJECT_ARTIFACT_ID) UnsolvedSymbolException{context='unknown', name='EMPTY_PROJECT_ARTIFACT_ID', typeSolver=null} /repo/subprojects/maven/src/main/java/org/gradle/api/plugins/MavenPlugin.java
Cannot resolve field access null
Cannot solve method call pom.getVersion().equals(MavenProject.EMPTY_PROJECT_VERSION) UnsolvedSymbolException{context='unknown', name='EMPTY_PROJECT_VERSION', typeSolver=null} /repo/subprojects/maven/src/main/java/org/gradle/api/plugins/MavenPlugin.java
Cannot solve field access ArtifactType.MAVEN_POM
Method 'maybeRegisterComponentType' cannot be resolved in context componentTypeRegistry.maybeRegisterComponentType(MavenModule.class) (line: 51) MethodCallExprContext{wrapped=componentTypeRegistry.maybeRegisterComponentType(MavenModule.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.maven.MavenModule, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'candidate' cannot be resolved in context visitor.candidate("Instances of AbstractArchiveTask") (line: 75) MethodCallExprContext{wrapped=visitor.candidate("Instances of AbstractArchiveTask")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'candidate' cannot be resolved in context visitor.candidate("Maps containing a 'source' entry") (line: 130) MethodCallExprContext{wrapped=visitor.candidate("Maps containing a 'source' entry")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve field access LogLevel.INFO
Method 'field' cannot be resolved in context field(publication, "groupId", projectIdentity.getGroupId()) (line: 54) MethodCallExprContext{wrapped=field(publication, "groupId", projectIdentity.getGroupId())}. Parameter types: [ReferenceType{org.gradle.api.publish.maven.internal.publisher.MavenNormalizedPublication, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'field' cannot be resolved in context field(publication, "groupId", projectIdentity.getGroupId()) (line: 54) MethodCallExprContext{wrapped=field(publication, "groupId", projectIdentity.getGroupId())}. Parameter types: [ReferenceType{org.gradle.api.publish.maven.internal.publisher.MavenNormalizedPublication, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'field' cannot be resolved in context field(publication, "artifactId", projectIdentity.getArtifactId()) (line: 57) MethodCallExprContext{wrapped=field(publication, "artifactId", projectIdentity.getArtifactId())}. Parameter types: [ReferenceType{org.gradle.api.publish.maven.internal.publisher.MavenNormalizedPublication, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'field' cannot be resolved in context field(publication, "artifactId", projectIdentity.getArtifactId()) (line: 57) MethodCallExprContext{wrapped=field(publication, "artifactId", projectIdentity.getArtifactId())}. Parameter types: [ReferenceType{org.gradle.api.publish.maven.internal.publisher.MavenNormalizedPublication, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'field' cannot be resolved in context field(publication, "version", projectIdentity.getVersion()) (line: 60) MethodCallExprContext{wrapped=field(publication, "version", projectIdentity.getVersion())}. Parameter types: [ReferenceType{org.gradle.api.publish.maven.internal.publisher.MavenNormalizedPublication, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'field' cannot be resolved in context field(publication, "version", projectIdentity.getVersion()) (line: 60) MethodCallExprContext{wrapped=field(publication, "version", projectIdentity.getVersion())}. Parameter types: [ReferenceType{org.gradle.api.publish.maven.internal.publisher.MavenNormalizedPublication, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'field' cannot be resolved in context field(publication, "version", projectIdentity.getVersion()) (line: 60) MethodCallExprContext{wrapped=field(publication, "version", projectIdentity.getVersion())}. Parameter types: [ReferenceType{org.gradle.api.publish.maven.internal.publisher.MavenNormalizedPublication, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'field' cannot be resolved in context field(publication, "artifact extension", artifact.getExtension()) (line: 92) MethodCallExprContext{wrapped=field(publication, "artifact extension", artifact.getExtension())}. Parameter types: [ReferenceType{org.gradle.api.publish.maven.internal.publisher.MavenNormalizedPublication, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'field' cannot be resolved in context field(publication, "artifact extension", artifact.getExtension()) (line: 92) MethodCallExprContext{wrapped=field(publication, "artifact extension", artifact.getExtension())}. Parameter types: [ReferenceType{org.gradle.api.publish.maven.internal.publisher.MavenNormalizedPublication, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'field' cannot be resolved in context field(publication, "artifact classifier", artifact.getClassifier()) (line: 95) MethodCallExprContext{wrapped=field(publication, "artifact classifier", artifact.getClassifier())}. Parameter types: [ReferenceType{org.gradle.api.publish.maven.internal.publisher.MavenNormalizedPublication, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'field' cannot be resolved in context field(publication, "artifact classifier", artifact.getClassifier()) (line: 95) MethodCallExprContext{wrapped=field(publication, "artifact classifier", artifact.getClassifier())}. Parameter types: [ReferenceType{org.gradle.api.publish.maven.internal.publisher.MavenNormalizedPublication, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call failure(String.format("%s is not a valid Maven identifier (%s).", name, ID_REGEX)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/maven/src/main/java/org/gradle/api/publish/maven/internal/publisher/ValidatingMavenPublisher.java
Cannot solve method call failure(String.format("supplied %s does not match POM file (cannot edit %1$s directly in the POM file).", name)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/maven/src/main/java/org/gradle/api/publish/maven/internal/publisher/ValidatingMavenPublisher.java
Method 'files' cannot be resolved in context getInputs().files(new Callable<FileCollection>() {

    public FileCollection call() throws Exception {
        MavenPublicationInternal publicationInternal = getPublicationInternal();
        return publicationInternal == null ? null : publicationInternal.getPublishableFiles();
    }
}) (line: 45) MethodCallExprContext{wrapped=getInputs().files(new Callable<FileCollection>() {

    public FileCollection call() throws Exception {
        MavenPublicationInternal publicationInternal = getPublicationInternal();
        return publicationInternal == null ? null : publicationInternal.getPublishableFiles();
    }
})}. Parameter types: [ReferenceType{java.util.concurrent.Callable, typeParametersMap=TypeParametersMap{nameToValue={java.util.concurrent.Callable.V=ReferenceType{org.gradle.api.file.FileCollection, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call extension.getPublications().registerFactory(MavenPublication.class, new MavenPublicationFactory(dependencyMetaDataProvider, instantiator, fileResolver)) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/maven/src/main/java/org/gradle/api/publish/maven/plugins/MavenPublishPlugin.java
No matching between ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual)
No matching between ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual)
Method 'getConfigProperties' cannot be resolved in context session.getConfigProperties() (line: 65) MethodCallExprContext{wrapped=session.getConfigProperties()}. Parameter types: []
Cannot solve method call createTypedArtifact(pom.getPackaging(), null) java.lang.RuntimeException: Method 'getPackaging' cannot be resolved in context pom.getPackaging() (line: 69) MethodCallExprContext{wrapped=pom.getPackaging()}. Parameter types: [] /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/action/AbstractMavenPublishAction.java
Cannot solve method call attached.add(createTypedArtifact(type, classifier).setFile(file)) java.lang.RuntimeException: Method 'setFile' cannot be resolved in context createTypedArtifact(type, classifier).setFile(file) (line: 82) MethodCallExprContext{wrapped=createTypedArtifact(type, classifier).setFile(file)}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/action/AbstractMavenPublishAction.java
Cannot solve method call UncheckedException.throwAsUncheckedException(e) UnsolvedSymbolException{context='unknown', name='PlexusContainerException', typeSolver=null} /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/action/AbstractMavenPublishAction.java
Cannot solve method call UncheckedException.throwAsUncheckedException(e) UnsolvedSymbolException{context='unknown', name='ComponentLookupException', typeSolver=null} /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/action/AbstractMavenPublishAction.java
Cannot solve method call getContainer().lookup(Deployer.class) UnsolvedSymbolException{context='unknown', name='Deployer', typeSolver=null} /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/action/AbstractMavenPublishAction.java
Method 'getArtifactTypeRegistry' cannot be resolved in context session.getArtifactTypeRegistry() (line: 157) MethodCallExprContext{wrapped=session.getArtifactTypeRegistry()}. Parameter types: []
Cannot solve method call artifact.setVersion(artifact.getBaseVersion()) java.lang.RuntimeException: Method 'getBaseVersion' cannot be resolved in context artifact.getBaseVersion() (line: 60) MethodCallExprContext{wrapped=artifact.getBaseVersion()}. Parameter types: [] /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/action/SnapshotVersionManager.java
Method 'getException' cannot be resolved in context event.getException() (line: 30) MethodCallExprContext{wrapped=event.getException()}. Parameter types: []
Cannot solve method call LOGGER.error(event.getException().getMessage()) java.lang.RuntimeException: Method 'getException' cannot be resolved in context event.getException() (line: 30) MethodCallExprContext{wrapped=event.getException()}. Parameter types: [] /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/action/LoggingMavenTransferListener.java
Method 'getResource' cannot be resolved in context event.getResource() (line: 35) MethodCallExprContext{wrapped=event.getResource()}. Parameter types: []
Method 'getResource' cannot be resolved in context event.getResource() (line: 35) MethodCallExprContext{wrapped=event.getResource()}. Parameter types: []
Cannot solve method call LOGGER.info(message, event.getResource().getResourceName(), "remote", event.getResource().getRepositoryUrl()) java.lang.RuntimeException: Method 'getResource' cannot be resolved in context event.getResource() (line: 35) MethodCallExprContext{wrapped=event.getResource()}. Parameter types: [] /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/action/LoggingMavenTransferListener.java
Method 'getResource' cannot be resolved in context event.getResource() (line: 39) MethodCallExprContext{wrapped=event.getResource()}. Parameter types: []
Method 'getResource' cannot be resolved in context event.getResource() (line: 46) MethodCallExprContext{wrapped=event.getResource()}. Parameter types: []
Cannot solve method call proxySelector.add(new Proxy(proxy.getType(), proxy.getHost(), proxy.getPort(), proxyAuth), proxy.getNonProxyHosts()) java.lang.RuntimeException: Method 'getNonProxyHosts' cannot be resolved in context proxy.getNonProxyHosts() (line: 84) MethodCallExprContext{wrapped=proxy.getNonProxyHosts()}. Parameter types: [] /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/action/MavenDeployAction.java
Cannot solve method call repo.setProxy(proxySelector.getProxy(repo)) java.lang.RuntimeException: Method 'getProxy' cannot be resolved in context proxySelector.getProxy(repo) (line: 85) MethodCallExprContext{wrapped=proxySelector.getProxy(repo)}. Parameter types: [ReferenceType{RemoteRepository, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/action/MavenDeployAction.java
Cannot solve method call setProp(executeManager.getClass(), executeManager, "log", new PlexusLoggerAdapter(LoggerFactory.getLogger(ExecuteManagerImpl.class))) UnsolvedSymbolException{context='unknown', name='ExecuteManager', typeSolver=null} /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/pom/CustomModelBuilder.java
Cannot solve method call setProp(ModelBuilder.class, this, "executeManager", executeManager) UnsolvedSymbolException{context='unknown', name='ExecuteManager', typeSolver=null} /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/pom/CustomModelBuilder.java
Cannot solve method call registerFactory(modelFactory.getName(), null, modelFactory) java.lang.RuntimeException: Method 'getName' cannot be resolved in context modelFactory.getName() (line: 50) MethodCallExprContext{wrapped=modelFactory.getName()}. Parameter types: [] /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/pom/CustomModelBuilder.java
Cannot solve method call conf2ScopeMappingContainer.getMapping(dependencyToConfigurations.get(dependency)) java.lang.RuntimeException: Method 'get' cannot be resolved in context dependencyToConfigurations.get(dependency) (line: 67) MethodCallExprContext{wrapped=dependencyToConfigurations.get(dependency)}. Parameter types: [ReferenceType{org.gradle.api.artifacts.ModuleDependency, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/pom/DefaultPomDependenciesConverter.java
Method 'get' cannot be resolved in context dependencySetMap.get(dependency) (line: 96) MethodCallExprContext{wrapped=dependencySetMap.get(dependency)}. Parameter types: [ReferenceType{org.gradle.api.artifacts.ModuleDependency, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call findEqualIgnoreScopeVersionAndExclusions(dependenciesWithPriorities.keySet(), mavenDependency) java.lang.RuntimeException: Method 'keySet' cannot be resolved in context dependenciesWithPriorities.keySet() (line: 148) MethodCallExprContext{wrapped=dependenciesWithPriorities.keySet()}. Parameter types: [] /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/pom/DefaultPomDependenciesConverter.java
Cannot solve method call dependenciesWithPriorities.get(duplicateDependency.get()) java.lang.RuntimeException: Method 'get' cannot be resolved in context duplicateDependency.get() (line: 154) MethodCallExprContext{wrapped=duplicateDependency.get()}. Parameter types: [] /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/pom/DefaultPomDependenciesConverter.java
Method 'get' cannot be resolved in context duplicateDependency.get() (line: 157) MethodCallExprContext{wrapped=duplicateDependency.get()}. Parameter types: []
Cannot solve method call compareMavenVersionStrings(mavenDependency.getVersion(), duplicateDependency.get().getVersion()) java.lang.RuntimeException: Method 'getVersion' cannot be resolved in context mavenDependency.getVersion() (line: 157) MethodCallExprContext{wrapped=mavenDependency.getVersion()}. Parameter types: [] /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/pom/DefaultPomDependenciesConverter.java
Cannot solve method call dependenciesWithPriorities.remove(duplicateDependency.get()) java.lang.RuntimeException: Method 'get' cannot be resolved in context duplicateDependency.get() (line: 160) MethodCallExprContext{wrapped=duplicateDependency.get()}. Parameter types: [] /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/pom/DefaultPomDependenciesConverter.java
Method 'get' cannot be resolved in context duplicateDependency.get() (line: 163) MethodCallExprContext{wrapped=duplicateDependency.get()}. Parameter types: []
Cannot solve method call mavenDependency.setScope(duplicateDependency.get().getScope()) java.lang.RuntimeException: Method 'get' cannot be resolved in context duplicateDependency.get() (line: 163) MethodCallExprContext{wrapped=duplicateDependency.get()}. Parameter types: [] /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/pom/DefaultPomDependenciesConverter.java
Method 'get' cannot be resolved in context duplicateDependency.get() (line: 165) MethodCallExprContext{wrapped=duplicateDependency.get()}. Parameter types: []
Cannot solve method call mavenDependency.setExclusions(duplicateDependency.get().getExclusions()) java.lang.RuntimeException: Method 'get' cannot be resolved in context duplicateDependency.get() (line: 165) MethodCallExprContext{wrapped=duplicateDependency.get()}. Parameter types: [] /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/pom/DefaultPomDependenciesConverter.java
Method 'getManagementKey' cannot be resolved in context dependency.getManagementKey() (line: 203) MethodCallExprContext{wrapped=dependency.getManagementKey()}. Parameter types: []
Cannot resolve field access null
Cannot solve method call artifactId.equals(MavenProject.EMPTY_PROJECT_ARTIFACT_ID) UnsolvedSymbolException{context='unknown', name='EMPTY_PROJECT_ARTIFACT_ID', typeSolver=null} /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/pom/ProjectDependencyArtifactIdExtractorHack.java
Cannot resolve field access null
Cannot solve method call new ClosureBackedAction<RemoteRepository>(closure, Closure.OWNER_FIRST).execute(repository) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/deployer/DefaultGroovyMavenDeployer.java
Method 'getType' cannot be resolved in context artifact.getType() (line: 106) MethodCallExprContext{wrapped=artifact.getType()}. Parameter types: []
Cannot solve field access LogLevel.INFO
Cannot solve method call ConfigureUtil.configure(configureClosure, pom(name)) com.github.javaparser.symbolsolver.logic.ConfilictingGenericTypesException: No matching between ReferenceType{groovy.lang.Closure, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual) /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/BasePomFilterContainer.java
Cannot solve method call container.addRepository(createMavenDeployer(), DEFAULT_MAVEN_DEPLOYER_NAME, Actions.<GroovyMavenDeployer>composite(new ConfigureByMapAction<GroovyMavenDeployer>(args), ConfigureUtil.configureUsing(configureClosure))) UnsolvedSymbolException{context='Method 'composite' with parameterTypes [ReferenceType{org.gradle.api.internal.ConfigureByMapAction, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.api.internal.ConfigureByMapAction.T=ReferenceType{org.gradle.api.artifacts.maven.GroovyMavenDeployer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{org.gradle.api.Action, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.api.Action.T=TypeVariable {org.gradle.util.ConfigureUtil.configureUsing(groovy.lang.Closure).T}}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class Actions {

    private static final Action<?> DO_NOTHING = new NullAction<Object>();

    /**
     * Creates an action implementation that simply does nothing.
     *
     * A new action instance is created each time.
     *
     * @return An action object with an empty implementation
     */
    @SuppressWarnings("unchecked")
    public static <T> Action<T> doNothing() {
        return (Action<T>) DO_NOTHING;
    }

    private static class NullAction<T> implements Action<T>, Serializable {

        public void execute(T t) {
        }
    }

    /**
     * Creates an action that will call each of the given actions in order.
     *
     * @param actions The actions to make a composite of.
     * @param <T> The type of the object that action is for
     * @return The composite action.
     */
    public static <T> Action<T> composite(Iterable<? extends Action<? super T>> actions) {
        return new CompositeAction<T>(actions);
    }

    /**
     * Creates an action that will call each of the given actions in order.
     *
     * @param actions The actions to make a composite of.
     * @param <T> The type of the object that action is for
     * @return The composite action.
     */
    public static <T> Action<T> composite(Action<? super T>... actions) {
        return composite(Arrays.asList(actions));
    }

    private static class CompositeAction<T> implements Action<T> {

        private final Iterable<? extends Action<? super T>> actions;

        private CompositeAction(Iterable<? extends Action<? super T>> actions) {
            this.actions = actions;
        }

        public void execute(T item) {
            for (Action<? super T> action : actions) {
                action.execute(item);
            }
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }
            CompositeAction that = (CompositeAction) o;
            if (!actions.equals(that.actions)) {
                return false;
            }
            return true;
        }

        @Override
        public int hashCode() {
            return actions.hashCode();
        }
    }

    /**
     * Creates a new composite action, where the argument is first transformed.
     *
     * @param action The action.
     * @param transformer The transformer to transform the argument with
     * @param <T> The type the action is expecting (that the argument is transformed to)
     * @param <I> The type of the original argument
     * @return An action that transforms an object of type I to type O to give to the given action
     */
    public static <T, I> Action<I> transformBefore(final Action<? super T> action, final Transformer<? extends T, ? super I> transformer) {
        return new TransformingActionAdapter<T, I>(transformer, action);
    }

    private static class TransformingActionAdapter<T, I> implements Action<I> {

        private final Transformer<? extends T, ? super I> transformer;

        private final Action<? super T> action;

        private TransformingActionAdapter(Transformer<? extends T, ? super I> transformer, Action<? super T> action) {
            this.transformer = transformer;
            this.action = action;
        }

        public void execute(I thing) {
            T transformed = transformer.transform(thing);
            action.execute(transformed);
        }
    }

    /**
     * Adapts an action to a different type by casting the object before giving it to the action.
     *
     * @param actionType The type the action is expecting
     * @param action The action
     * @param <T> The type the action is expecting
     * @param <I> The type before casting
     * @return An action that casts the object to the given type before giving it to the given action
     */
    public static <T, I> Action<I> castBefore(final Class<T> actionType, final Action<? super T> action) {
        return transformBefore(action, Transformers.cast(actionType));
    }

    /**
     * Wraps the given runnable in an {@link Action}, where the execute implementation runs the runnable ignoring the argument.
     *
     * If the given runnable is {@code null}, the action returned is effectively a noop.
     *
     * @param runnable The runnable to run for the action execution.
     * @return An action that runs the given runnable, ignoring the argument.
     */
    public static <T> Action<T> toAction(Runnable runnable) {
        // TODO SF this method accepts Closure instance as parameter but does not work correctly for it
        if (runnable == null) {
            return Actions.doNothing();
        } else {
            return new RunnableActionAdapter<T>(runnable);
        }
    }

    private static class RunnableActionAdapter<T> implements Action<T> {

        private final Runnable runnable;

        private RunnableActionAdapter(Runnable runnable) {
            this.runnable = runnable;
        }

        public void execute(T t) {
            runnable.run();
        }

        @Override
        public String toString() {
            return "RunnableActionAdapter{runnable=" + runnable + "}";
        }
    }

    /**
     * Creates a new action that only forwards arguments on to the given filter is they are satisfied by the given spec.
     *
     * @param action The action to delegate filtered items to
     * @param filter The spec to use to filter items by
     * @param <T> The type of item the action expects
     * @return A new action that only forwards arguments on to the given filter is they are satisfied by the given spec.
     */
    public static <T> Action<T> filter(Action<? super T> action, Spec<? super T> filter) {
        return new FilteredAction<T>(action, filter);
    }

    private static class FilteredAction<T> implements Action<T> {

        private final Spec<? super T> filter;

        private final Action<? super T> action;

        public FilteredAction(Action<? super T> action, Spec<? super T> filter) {
            this.filter = filter;
            this.action = action;
        }

        public void execute(T t) {
            if (filter.isSatisfiedBy(t)) {
                action.execute(t);
            }
        }
    }

    public static <T> T with(T instance, Action<? super T> action) {
        action.execute(instance);
        return instance;
    }

    public static <T> Action<T> add(final Collection<? super T> collection) {
        return new Action<T>() {

            @Override
            public void execute(T t) {
                collection.add(t);
            }
        };
    }
}}'} /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/DefaultMavenRepositoryHandlerConvention.java
Cannot solve method call container.addRepository(createMavenInstaller(), DEFAULT_MAVEN_INSTALLER_NAME, Actions.<MavenResolver>composite(new ConfigureByMapAction<MavenResolver>(args), ConfigureUtil.configureUsing(configureClosure))) UnsolvedSymbolException{context='Method 'composite' with parameterTypes [ReferenceType{org.gradle.api.internal.ConfigureByMapAction, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.api.internal.ConfigureByMapAction.T=ReferenceType{org.gradle.api.artifacts.maven.MavenResolver, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{org.gradle.api.Action, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.api.Action.T=TypeVariable {org.gradle.util.ConfigureUtil.configureUsing(groovy.lang.Closure).T}}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class Actions {

    private static final Action<?> DO_NOTHING = new NullAction<Object>();

    /**
     * Creates an action implementation that simply does nothing.
     *
     * A new action instance is created each time.
     *
     * @return An action object with an empty implementation
     */
    @SuppressWarnings("unchecked")
    public static <T> Action<T> doNothing() {
        return (Action<T>) DO_NOTHING;
    }

    private static class NullAction<T> implements Action<T>, Serializable {

        public void execute(T t) {
        }
    }

    /**
     * Creates an action that will call each of the given actions in order.
     *
     * @param actions The actions to make a composite of.
     * @param <T> The type of the object that action is for
     * @return The composite action.
     */
    public static <T> Action<T> composite(Iterable<? extends Action<? super T>> actions) {
        return new CompositeAction<T>(actions);
    }

    /**
     * Creates an action that will call each of the given actions in order.
     *
     * @param actions The actions to make a composite of.
     * @param <T> The type of the object that action is for
     * @return The composite action.
     */
    public static <T> Action<T> composite(Action<? super T>... actions) {
        return composite(Arrays.asList(actions));
    }

    private static class CompositeAction<T> implements Action<T> {

        private final Iterable<? extends Action<? super T>> actions;

        private CompositeAction(Iterable<? extends Action<? super T>> actions) {
            this.actions = actions;
        }

        public void execute(T item) {
            for (Action<? super T> action : actions) {
                action.execute(item);
            }
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }
            CompositeAction that = (CompositeAction) o;
            if (!actions.equals(that.actions)) {
                return false;
            }
            return true;
        }

        @Override
        public int hashCode() {
            return actions.hashCode();
        }
    }

    /**
     * Creates a new composite action, where the argument is first transformed.
     *
     * @param action The action.
     * @param transformer The transformer to transform the argument with
     * @param <T> The type the action is expecting (that the argument is transformed to)
     * @param <I> The type of the original argument
     * @return An action that transforms an object of type I to type O to give to the given action
     */
    public static <T, I> Action<I> transformBefore(final Action<? super T> action, final Transformer<? extends T, ? super I> transformer) {
        return new TransformingActionAdapter<T, I>(transformer, action);
    }

    private static class TransformingActionAdapter<T, I> implements Action<I> {

        private final Transformer<? extends T, ? super I> transformer;

        private final Action<? super T> action;

        private TransformingActionAdapter(Transformer<? extends T, ? super I> transformer, Action<? super T> action) {
            this.transformer = transformer;
            this.action = action;
        }

        public void execute(I thing) {
            T transformed = transformer.transform(thing);
            action.execute(transformed);
        }
    }

    /**
     * Adapts an action to a different type by casting the object before giving it to the action.
     *
     * @param actionType The type the action is expecting
     * @param action The action
     * @param <T> The type the action is expecting
     * @param <I> The type before casting
     * @return An action that casts the object to the given type before giving it to the given action
     */
    public static <T, I> Action<I> castBefore(final Class<T> actionType, final Action<? super T> action) {
        return transformBefore(action, Transformers.cast(actionType));
    }

    /**
     * Wraps the given runnable in an {@link Action}, where the execute implementation runs the runnable ignoring the argument.
     *
     * If the given runnable is {@code null}, the action returned is effectively a noop.
     *
     * @param runnable The runnable to run for the action execution.
     * @return An action that runs the given runnable, ignoring the argument.
     */
    public static <T> Action<T> toAction(Runnable runnable) {
        // TODO SF this method accepts Closure instance as parameter but does not work correctly for it
        if (runnable == null) {
            return Actions.doNothing();
        } else {
            return new RunnableActionAdapter<T>(runnable);
        }
    }

    private static class RunnableActionAdapter<T> implements Action<T> {

        private final Runnable runnable;

        private RunnableActionAdapter(Runnable runnable) {
            this.runnable = runnable;
        }

        public void execute(T t) {
            runnable.run();
        }

        @Override
        public String toString() {
            return "RunnableActionAdapter{runnable=" + runnable + "}";
        }
    }

    /**
     * Creates a new action that only forwards arguments on to the given filter is they are satisfied by the given spec.
     *
     * @param action The action to delegate filtered items to
     * @param filter The spec to use to filter items by
     * @param <T> The type of item the action expects
     * @return A new action that only forwards arguments on to the given filter is they are satisfied by the given spec.
     */
    public static <T> Action<T> filter(Action<? super T> action, Spec<? super T> filter) {
        return new FilteredAction<T>(action, filter);
    }

    private static class FilteredAction<T> implements Action<T> {

        private final Spec<? super T> filter;

        private final Action<? super T> action;

        public FilteredAction(Action<? super T> action, Spec<? super T> filter) {
            this.filter = filter;
            this.action = action;
        }

        public void execute(T t) {
            if (filter.isSatisfiedBy(t)) {
                action.execute(t);
            }
        }
    }

    public static <T> T with(T instance, Action<? super T> action) {
        action.execute(instance);
        return instance;
    }

    public static <T> Action<T> add(final Collection<? super T> collection) {
        return new Action<T>() {

            @Override
            public void execute(T t) {
                collection.add(t);
            }
        };
    }
}}'} /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/DefaultMavenRepositoryHandlerConvention.java
Cannot solve method call transferEvent(resource, TRANSFER_INITIATED, REQUEST_GET) UnsolvedSymbolException{context='Solving TRANSFER_INITIATED', name='TRANSFER_INITIATED', typeSolver=null} /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/wagon/RepositoryTransportDeployWagon.java
Cannot solve method call this.transferEventSupport.fireTransferInitiated(transferEvent(resource, TRANSFER_INITIATED, REQUEST_GET)) java.lang.RuntimeException: Error calculating the type of parameter TRANSFER_INITIATED of method call transferEvent(resource, TRANSFER_INITIATED, REQUEST_GET) /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/wagon/RepositoryTransportDeployWagon.java
Cannot solve method call transferEvent(resource, TRANSFER_STARTED, REQUEST_GET) UnsolvedSymbolException{context='Solving TRANSFER_STARTED', name='TRANSFER_STARTED', typeSolver=null} /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/wagon/RepositoryTransportDeployWagon.java
Cannot solve method call this.transferEventSupport.fireTransferStarted(transferEvent(resource, TRANSFER_STARTED, REQUEST_GET)) java.lang.RuntimeException: Error calculating the type of parameter TRANSFER_STARTED of method call transferEvent(resource, TRANSFER_STARTED, REQUEST_GET) /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/wagon/RepositoryTransportDeployWagon.java
Cannot solve method call transferEvent(resource, e, REQUEST_GET) UnsolvedSymbolException{context='Solving REQUEST_GET', name='REQUEST_GET', typeSolver=null} /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/wagon/RepositoryTransportDeployWagon.java
Cannot solve method call this.transferEventSupport.fireTransferError(transferEvent(resource, e, REQUEST_GET)) java.lang.RuntimeException: Error calculating the type of parameter REQUEST_GET of method call transferEvent(resource, e, REQUEST_GET) /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/wagon/RepositoryTransportDeployWagon.java
Cannot solve method call transferEvent(resource, e, REQUEST_GET) UnsolvedSymbolException{context='Solving REQUEST_GET', name='REQUEST_GET', typeSolver=null} /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/wagon/RepositoryTransportDeployWagon.java
Cannot solve method call this.transferEventSupport.fireTransferError(transferEvent(resource, e, REQUEST_GET)) java.lang.RuntimeException: Error calculating the type of parameter REQUEST_GET of method call transferEvent(resource, e, REQUEST_GET) /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/wagon/RepositoryTransportDeployWagon.java
Cannot solve method call transferEvent(resource, TRANSFER_COMPLETED, REQUEST_GET) UnsolvedSymbolException{context='Solving TRANSFER_COMPLETED', name='TRANSFER_COMPLETED', typeSolver=null} /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/wagon/RepositoryTransportDeployWagon.java
Cannot solve method call this.transferEventSupport.fireTransferCompleted(transferEvent(resource, TRANSFER_COMPLETED, REQUEST_GET)) java.lang.RuntimeException: Error calculating the type of parameter TRANSFER_COMPLETED of method call transferEvent(resource, TRANSFER_COMPLETED, REQUEST_GET) /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/wagon/RepositoryTransportDeployWagon.java
Cannot solve method call transferEvent(resource, TRANSFER_INITIATED, REQUEST_PUT) UnsolvedSymbolException{context='Solving TRANSFER_INITIATED', name='TRANSFER_INITIATED', typeSolver=null} /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/wagon/RepositoryTransportDeployWagon.java
Cannot solve method call this.transferEventSupport.fireTransferInitiated(transferEvent(resource, TRANSFER_INITIATED, REQUEST_PUT)) java.lang.RuntimeException: Error calculating the type of parameter TRANSFER_INITIATED of method call transferEvent(resource, TRANSFER_INITIATED, REQUEST_PUT) /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/wagon/RepositoryTransportDeployWagon.java
Cannot solve method call transferEvent(resource, e, REQUEST_PUT) UnsolvedSymbolException{context='Solving REQUEST_PUT', name='REQUEST_PUT', typeSolver=null} /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/wagon/RepositoryTransportDeployWagon.java
Cannot solve method call this.transferEventSupport.fireTransferError(transferEvent(resource, e, REQUEST_PUT)) java.lang.RuntimeException: Error calculating the type of parameter REQUEST_PUT of method call transferEvent(resource, e, REQUEST_PUT) /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/wagon/RepositoryTransportDeployWagon.java
Cannot solve method call transferEvent(resource, TRANSFER_COMPLETED, REQUEST_PUT) UnsolvedSymbolException{context='Solving TRANSFER_COMPLETED', name='TRANSFER_COMPLETED', typeSolver=null} /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/wagon/RepositoryTransportDeployWagon.java
Cannot solve method call this.transferEventSupport.fireTransferCompleted(transferEvent(resource, TRANSFER_COMPLETED, REQUEST_PUT)) java.lang.RuntimeException: Error calculating the type of parameter TRANSFER_COMPLETED of method call transferEvent(resource, TRANSFER_COMPLETED, REQUEST_PUT) /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/wagon/RepositoryTransportDeployWagon.java
Cannot solve method call sessionEvent(SESSION_LOGGED_IN) UnsolvedSymbolException{context='Solving SESSION_LOGGED_IN', name='SESSION_LOGGED_IN', typeSolver=null} /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/wagon/RepositoryTransportDeployWagon.java
Cannot solve method call this.sessionEventSupport.fireSessionLoggedIn(sessionEvent(SESSION_LOGGED_IN)) java.lang.RuntimeException: Error calculating the type of parameter SESSION_LOGGED_IN of method call sessionEvent(SESSION_LOGGED_IN) /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/wagon/RepositoryTransportDeployWagon.java
Cannot solve method call sessionEvent(SESSION_OPENED) UnsolvedSymbolException{context='Solving SESSION_OPENED', name='SESSION_OPENED', typeSolver=null} /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/wagon/RepositoryTransportDeployWagon.java
Cannot solve method call this.sessionEventSupport.fireSessionOpened(sessionEvent(SESSION_OPENED)) java.lang.RuntimeException: Error calculating the type of parameter SESSION_OPENED of method call sessionEvent(SESSION_OPENED) /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/wagon/RepositoryTransportDeployWagon.java
Cannot solve method call sessionEvent(SESSION_DISCONNECTING) UnsolvedSymbolException{context='Solving SESSION_DISCONNECTING', name='SESSION_DISCONNECTING', typeSolver=null} /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/wagon/RepositoryTransportDeployWagon.java
Cannot solve method call this.sessionEventSupport.fireSessionDisconnecting(sessionEvent(SESSION_DISCONNECTING)) java.lang.RuntimeException: Error calculating the type of parameter SESSION_DISCONNECTING of method call sessionEvent(SESSION_DISCONNECTING) /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/wagon/RepositoryTransportDeployWagon.java
Cannot solve method call sessionEvent(SESSION_LOGGED_OFF) UnsolvedSymbolException{context='Solving SESSION_LOGGED_OFF', name='SESSION_LOGGED_OFF', typeSolver=null} /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/wagon/RepositoryTransportDeployWagon.java
Cannot solve method call this.sessionEventSupport.fireSessionLoggedOff(sessionEvent(SESSION_LOGGED_OFF)) java.lang.RuntimeException: Error calculating the type of parameter SESSION_LOGGED_OFF of method call sessionEvent(SESSION_LOGGED_OFF) /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/wagon/RepositoryTransportDeployWagon.java
Cannot solve method call sessionEvent(SESSION_LOGGED_OFF) UnsolvedSymbolException{context='Solving SESSION_LOGGED_OFF', name='SESSION_LOGGED_OFF', typeSolver=null} /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/wagon/RepositoryTransportDeployWagon.java
Cannot solve method call this.sessionEventSupport.fireSessionDisconnected(sessionEvent(SESSION_LOGGED_OFF)) java.lang.RuntimeException: Error calculating the type of parameter SESSION_LOGGED_OFF of method call sessionEvent(SESSION_LOGGED_OFF) /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/wagon/RepositoryTransportDeployWagon.java
Cannot solve method call transferEvent(resource, TRANSFER_STARTED, REQUEST_PUT) UnsolvedSymbolException{context='Solving TRANSFER_STARTED', name='TRANSFER_STARTED', typeSolver=null} /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/wagon/RepositoryTransportDeployWagon.java
Cannot solve method call transferEventSupport.fireTransferStarted(transferEvent(resource, TRANSFER_STARTED, REQUEST_PUT)) java.lang.RuntimeException: Error calculating the type of parameter TRANSFER_STARTED of method call transferEvent(resource, TRANSFER_STARTED, REQUEST_PUT) /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/wagon/RepositoryTransportDeployWagon.java
Cannot resolve field access null
Cannot solve method call transferEvent(resource, TransferEvent.TRANSFER_PROGRESS, REQUEST_PUT) UnsolvedSymbolException{context='unknown', name='TRANSFER_PROGRESS', typeSolver=null} /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/wagon/RepositoryTransportDeployWagon.java
Cannot solve method call PACKAGING_TYPES.contains(artifact.getType()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context artifact.getType() (line: 77) MethodCallExprContext{wrapped=artifact.getType()}. Parameter types: [] /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/DefaultArtifactPom.java
Cannot resolve field access null
Cannot solve method call pom.getGroupId().equals(MavenProject.EMPTY_PROJECT_GROUP_ID) UnsolvedSymbolException{context='unknown', name='EMPTY_PROJECT_GROUP_ID', typeSolver=null} /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/DefaultArtifactPom.java
Method 'getModuleRevisionId' cannot be resolved in context artifact.getModuleRevisionId() (line: 103) MethodCallExprContext{wrapped=artifact.getModuleRevisionId()}. Parameter types: []
Cannot solve method call pom.setGroupId(artifact.getModuleRevisionId().getOrganisation()) java.lang.RuntimeException: Method 'getModuleRevisionId' cannot be resolved in context artifact.getModuleRevisionId() (line: 103) MethodCallExprContext{wrapped=artifact.getModuleRevisionId()}. Parameter types: [] /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/DefaultArtifactPom.java
Cannot resolve field access null
Cannot solve method call pom.getArtifactId().equals(MavenProject.EMPTY_PROJECT_ARTIFACT_ID) UnsolvedSymbolException{context='unknown', name='EMPTY_PROJECT_ARTIFACT_ID', typeSolver=null} /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/DefaultArtifactPom.java
Cannot solve method call pom.setArtifactId(artifact.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context artifact.getName() (line: 106) MethodCallExprContext{wrapped=artifact.getName()}. Parameter types: [] /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/DefaultArtifactPom.java
Cannot resolve field access null
Cannot solve method call pom.getVersion().equals(MavenProject.EMPTY_PROJECT_VERSION) UnsolvedSymbolException{context='unknown', name='EMPTY_PROJECT_VERSION', typeSolver=null} /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/DefaultArtifactPom.java
Method 'getModuleRevisionId' cannot be resolved in context artifact.getModuleRevisionId() (line: 109) MethodCallExprContext{wrapped=artifact.getModuleRevisionId()}. Parameter types: []
Cannot solve method call pom.setVersion(artifact.getModuleRevisionId().getRevision()) java.lang.RuntimeException: Method 'getModuleRevisionId' cannot be resolved in context artifact.getModuleRevisionId() (line: 109) MethodCallExprContext{wrapped=artifact.getModuleRevisionId()}. Parameter types: [] /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/DefaultArtifactPom.java
Cannot solve method call pom.setPackaging(artifact.getType()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context artifact.getType() (line: 112) MethodCallExprContext{wrapped=artifact.getType()}. Parameter types: [] /repo/subprojects/maven/src/main/java/org/gradle/api/publication/maven/internal/DefaultArtifactPom.java
Method 'getProject' cannot be resolved in context getProject() (line: 71) MethodCallExprContext{wrapped=getProject()}. Parameter types: []
Cannot solve method call setHost(proxy.getHost()) java.lang.RuntimeException: Method 'getHost' cannot be resolved in context proxy.getHost() (line: 38) MethodCallExprContext{wrapped=proxy.getHost()}. Parameter types: [] /repo/subprojects/maven/src/main/java/org/apache/maven/artifact/ant/Proxy.java
Cannot solve method call setPort(proxy.getPort()) java.lang.RuntimeException: Method 'getPort' cannot be resolved in context proxy.getPort() (line: 39) MethodCallExprContext{wrapped=proxy.getPort()}. Parameter types: [] /repo/subprojects/maven/src/main/java/org/apache/maven/artifact/ant/Proxy.java
Cannot solve method call setNonProxyHosts(proxy.getNonProxyHosts()) java.lang.RuntimeException: Method 'getNonProxyHosts' cannot be resolved in context proxy.getNonProxyHosts() (line: 40) MethodCallExprContext{wrapped=proxy.getNonProxyHosts()}. Parameter types: [] /repo/subprojects/maven/src/main/java/org/apache/maven/artifact/ant/Proxy.java
Cannot solve method call setUserName(proxy.getUsername()) java.lang.RuntimeException: Method 'getUsername' cannot be resolved in context proxy.getUsername() (line: 41) MethodCallExprContext{wrapped=proxy.getUsername()}. Parameter types: [] /repo/subprojects/maven/src/main/java/org/apache/maven/artifact/ant/Proxy.java
Cannot solve method call setPassword(proxy.getPassword()) java.lang.RuntimeException: Method 'getPassword' cannot be resolved in context proxy.getPassword() (line: 42) MethodCallExprContext{wrapped=proxy.getPassword()}. Parameter types: [] /repo/subprojects/maven/src/main/java/org/apache/maven/artifact/ant/Proxy.java
Cannot solve method call setType(proxy.getProtocol()) java.lang.RuntimeException: Method 'getProtocol' cannot be resolved in context proxy.getProtocol() (line: 43) MethodCallExprContext{wrapped=proxy.getProtocol()}. Parameter types: [] /repo/subprojects/maven/src/main/java/org/apache/maven/artifact/ant/Proxy.java
Cannot solve method call setUserName(server.getUsername()) java.lang.RuntimeException: Method 'getUsername' cannot be resolved in context server.getUsername() (line: 39) MethodCallExprContext{wrapped=server.getUsername()}. Parameter types: [] /repo/subprojects/maven/src/main/java/org/apache/maven/artifact/ant/Authentication.java
Cannot solve method call setPassword(server.getPassword()) java.lang.RuntimeException: Method 'getPassword' cannot be resolved in context server.getPassword() (line: 40) MethodCallExprContext{wrapped=server.getPassword()}. Parameter types: [] /repo/subprojects/maven/src/main/java/org/apache/maven/artifact/ant/Authentication.java
Cannot solve method call setPassphrase(server.getPassphrase()) java.lang.RuntimeException: Method 'getPassphrase' cannot be resolved in context server.getPassphrase() (line: 41) MethodCallExprContext{wrapped=server.getPassphrase()}. Parameter types: [] /repo/subprojects/maven/src/main/java/org/apache/maven/artifact/ant/Authentication.java
Cannot solve method call setPrivateKey(server.getPrivateKey()) java.lang.RuntimeException: Method 'getPrivateKey' cannot be resolved in context server.getPrivateKey() (line: 42) MethodCallExprContext{wrapped=server.getPrivateKey()}. Parameter types: [] /repo/subprojects/maven/src/main/java/org/apache/maven/artifact/ant/Authentication.java
Cannot solve method call String.format("[MethodInvocation method: %s(%s)]", method.getName(), Joiner.on(", ").join(arguments)) UnsolvedSymbolException{context='Method 'on' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=Joiner}'} /repo/subprojects/messaging/src/main/java/org/gradle/internal/dispatch/MethodInvocation.java
Cannot solve method call logger.error(String.format("Could not dispatch message %s. Discarding message.", message), failure) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, TypeVariable {org.gradle.internal.dispatch.DiscardingFailureHandler.T}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/messaging/src/main/java/org/gradle/internal/dispatch/DiscardingFailureHandler.java
Cannot solve field access State.Init
Cannot solve field access State.Init
Cannot solve field access State.Stopped
Cannot solve field access State.Stopped
Cannot solve field access State.Stopped
Cannot solve field access State.Stopped
Cannot solve field access State.Stopped
Cannot solve method call logger.error(failure.getMessage(), failure) java.lang.RuntimeException: Method 'getMessage' cannot be resolved in context failure.getMessage() (line: 32) MethodCallExprContext{wrapped=failure.getMessage()}. Parameter types: [] /repo/subprojects/messaging/src/main/java/org/gradle/internal/dispatch/ExceptionTrackingFailureHandler.java
Cannot solve method call candidate.loadClass(type.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context type.getName() (line: 42) MethodCallExprContext{wrapped=type.getName()}. Parameter types: [] /repo/subprojects/messaging/src/main/java/org/gradle/internal/dispatch/ProxyDispatchAdapter.java
Cannot solve method call Proxy.newProxyInstance(classLoader, types.toArray(new Class<?>[0]), new DispatchingInvocationHandler(type, dispatch)) java.lang.RuntimeException: Class<?>[] T[] /repo/subprojects/messaging/src/main/java/org/gradle/internal/dispatch/ProxyDispatchAdapter.java
Cannot solve method call type.cast(Proxy.newProxyInstance(classLoader, types.toArray(new Class<?>[0]), new DispatchingInvocationHandler(type, dispatch))) java.lang.RuntimeException: Error calculating the type of parameter types.toArray(new Class<?>[0]) of method call Proxy.newProxyInstance(classLoader, types.toArray(new Class<?>[0]), new DispatchingInvocationHandler(type, dispatch)) /repo/subprojects/messaging/src/main/java/org/gradle/internal/dispatch/ProxyDispatchAdapter.java
Cannot solve method call String.format("Socket connected to itself on %s port %s.", candidate, address.getPort()) java.lang.RuntimeException: Method 'getPort' cannot be resolved in context address.getPort() (line: 94) MethodCallExprContext{wrapped=address.getPort()}. Parameter types: [] /repo/subprojects/messaging/src/main/java/org/gradle/internal/remote/internal/inet/TcpOutgoingConnector.java
Cannot solve method call Lists.newArrayList(Iterables.concat(candidates, this.candidates)) UnsolvedSymbolException{context='Method 'concat' with parameterTypes [ReferenceType{Iterable, typeParametersMap=TypeParametersMap{nameToValue={empty.BlockDoc=ReferenceType{java.net.InetAddress, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.net.InetAddress, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/messaging/src/main/java/org/gradle/internal/remote/internal/inet/MultiChoiceAddress.java
Cannot solve method call Objects.equal(e.getMessage(), "An existing connection was forcibly closed by the remote host") java.lang.RuntimeException: Method 'getMessage' cannot be resolved in context e.getMessage() (line: 94) MethodCallExprContext{wrapped=e.getMessage()}. Parameter types: [] /repo/subprojects/messaging/src/main/java/org/gradle/internal/remote/internal/inet/SocketConnection.java
Cannot solve method call Objects.equal(e.getMessage(), "An established connection was aborted by the software in your host machine") java.lang.RuntimeException: Method 'getMessage' cannot be resolved in context e.getMessage() (line: 97) MethodCallExprContext{wrapped=e.getMessage()}. Parameter types: [] /repo/subprojects/messaging/src/main/java/org/gradle/internal/remote/internal/inet/SocketConnection.java
Cannot solve method call Objects.equal(e.getMessage(), "Connection reset by peer") java.lang.RuntimeException: Method 'getMessage' cannot be resolved in context e.getMessage() (line: 100) MethodCallExprContext{wrapped=e.getMessage()}. Parameter types: [] /repo/subprojects/messaging/src/main/java/org/gradle/internal/remote/internal/inet/SocketConnection.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve field access Delivery.Stateful
Cannot solve field access Delivery.AllHandlers
Cannot solve field access Delivery.SingleHandler
Empty name expression Stateful
Empty name expression AllHandlers
Cannot resolve field access null
Cannot solve field access InterHubMessage.Delivery.Stateful
Empty name expression SingleHandler
Cannot resolve field access null
Cannot solve field access InterHubMessage.Delivery.Stateful
Cannot resolve field access null
Cannot solve field access InterHubMessage.Delivery.Stateful
Cannot resolve field access null
Cannot solve field access InterHubMessage.Delivery.AllHandlers
Cannot resolve field access null
Cannot solve field access State.Running
Method 'getChannel' cannot be resolved in context incomingQueue.getChannel(identifier) (line: 123) MethodCallExprContext{wrapped=incomingQueue.getChannel(identifier)}. Parameter types: [ReferenceType{org.gradle.internal.remote.internal.hub.protocol.ChannelIdentifier, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve field access State.Running
Cannot solve field access State.Running
Cannot solve field access State.Stopping
Cannot solve field access State.Stopped
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call encoder.writeString(paramType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context paramType.getName() (line: 90) MethodCallExprContext{wrapped=paramType.getName()}. Parameter types: [] /repo/subprojects/messaging/src/main/java/org/gradle/internal/remote/internal/hub/MethodInvocationSerializer.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call PRIMITIVE_TYPES.put(Integer.TYPE.getName(), Integer.TYPE) UnsolvedSymbolException{context='unknown', name='TYPE', typeSolver=null} /repo/subprojects/messaging/src/main/java/org/gradle/internal/remote/internal/hub/MethodInvocationSerializer.java
Cannot resolve field access null
Cannot solve method call hub.addHandler(type.getName(), handler) java.lang.RuntimeException: Method 'getName' cannot be resolved in context type.getName() (line: 64) MethodCallExprContext{wrapped=type.getName()}. Parameter types: [] /repo/subprojects/messaging/src/main/java/org/gradle/internal/remote/internal/hub/MessageHubBackedObjectConnection.java
Cannot solve method call hub.getOutgoing(type.getName(), MethodInvocation.class) java.lang.RuntimeException: Method 'getName' cannot be resolved in context type.getName() (line: 71) MethodCallExprContext{wrapped=type.getName()}. Parameter types: [] /repo/subprojects/messaging/src/main/java/org/gradle/internal/remote/internal/hub/MessageHubBackedObjectConnection.java
Cannot solve method call writer.write(type.cast(value)) java.lang.RuntimeException: Method 'cast' cannot be resolved in context type.cast(value) (line: 43) MethodCallExprContext{wrapped=type.cast(value)}. Parameter types: [ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/messaging/src/main/java/org/gradle/internal/serialize/kryo/TypeSafeSerializer.java
Cannot solve method call input.setPosition(input.limit()) java.lang.RuntimeException: Method 'limit' cannot be resolved in context input.limit() (line: 66) MethodCallExprContext{wrapped=input.limit()}. Parameter types: [] /repo/subprojects/messaging/src/main/java/org/gradle/internal/serialize/kryo/KryoBackedDecoder.java
Cannot solve method call input.setPosition(input.position() + (int) count) java.lang.RuntimeException: Method 'position' cannot be resolved in context input.position() (line: 63) MethodCallExprContext{wrapped=input.position()}. Parameter types: [] /repo/subprojects/messaging/src/main/java/org/gradle/internal/serialize/kryo/KryoBackedDecoder.java
Method 'getMessage' cannot be resolved in context e.getMessage() (line: 72) MethodCallExprContext{wrapped=e.getMessage()}. Parameter types: []
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
Cannot resolve field access null
Method 'loadClass' cannot be resolved in context classLoader.loadClass(type) (line: 160) MethodCallExprContext{wrapped=classLoader.loadClass(type)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot resolve field access null
Cannot resolve field access null
Method 'getName' cannot be resolved in context o1.getName() (line: 24) MethodCallExprContext{wrapped=o1.getName()}. Parameter types: []
Cannot solve method call String.format("Don't know how to serialize objects of type %s.", baseType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context baseType.getName() (line: 54) MethodCallExprContext{wrapped=baseType.getName()}. Parameter types: [] /repo/subprojects/messaging/src/main/java/org/gradle/internal/serialize/DefaultSerializerRegistry.java
Cannot resolve field access null
Cannot solve method call map(value.getClass()) java.lang.RuntimeException: Method 'getClass' cannot be resolved in context value.getClass() (line: 114) MethodCallExprContext{wrapped=value.getClass()}. Parameter types: [] /repo/subprojects/messaging/src/main/java/org/gradle/internal/serialize/DefaultSerializerRegistry.java
Cannot solve method call String.format("Don't know how to serialize an object of type %s.", valueType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context valueType.getName() (line: 129) MethodCallExprContext{wrapped=valueType.getName()}. Parameter types: [] /repo/subprojects/messaging/src/main/java/org/gradle/internal/serialize/DefaultSerializerRegistry.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call String.format("Method %s() not found for listener type %s.", methodName, type.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context type.getSimpleName() (line: 65) MethodCallExprContext{wrapped=type.getSimpleName()}. Parameter types: [] /repo/subprojects/messaging/src/main/java/org/gradle/internal/event/BroadcastDispatch.java
Method 'getSimpleName' cannot be resolved in context type.getSimpleName() (line: 35) MethodCallExprContext{wrapped=type.getSimpleName()}. Parameter types: []
Method 'getSimpleName' cannot be resolved in context type.getSimpleName() (line: 35) MethodCallExprContext{wrapped=type.getSimpleName()}. Parameter types: []
Method 'getSimpleName' cannot be resolved in context type.getSimpleName() (line: 35) MethodCallExprContext{wrapped=type.getSimpleName()}. Parameter types: []
Cannot solve method call failures.add(e.getCause()) java.lang.RuntimeException: Method 'getCause' cannot be resolved in context e.getCause() (line: 46) MethodCallExprContext{wrapped=e.getCause()}. Parameter types: [] /repo/subprojects/messaging/src/main/java/org/gradle/internal/event/AbstractBroadcastDispatch.java
Cannot solve method call details.untilNotInUse(Thread.currentThread()) UnsolvedSymbolException{context='Method 'currentThread' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Thread}'} /repo/subprojects/messaging/src/main/java/org/gradle/internal/event/DefaultListenerManager.java
Cannot solve method call String.format("Cannot notify listeners of type %s as these listeners are already being notified.", type.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context type.getSimpleName() (line: 170) MethodCallExprContext{wrapped=type.getSimpleName()}. Parameter types: [] /repo/subprojects/messaging/src/main/java/org/gradle/internal/event/DefaultListenerManager.java
Cannot solve method call writer.println(Joiner.on(", ").join(input.getSuggestedPaths())) UnsolvedSymbolException{context='Method 'on' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=Joiner}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/report/unbound/UnboundRulesReporter.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call type(ModelType.of(type)) java.lang.UnsupportedOperationException: com.github.javaparser.resolution.types.ResolvedWildcard /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/report/unbound/UnboundRuleInput.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call String.format("%s and returning a model element", super.getDescription()) java.lang.RuntimeException: Method 'getDescription' cannot be resolved in context super.getDescription() (line: 40) MethodCallExprContext{wrapped=super.getDescription()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/inspect/UnmanagedModelCreationRuleExtractor.java
Cannot solve method call ModelReference.of(modelPath) UnsolvedSymbolException{context='Solving modelPath', name='modelPath', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/inspect/UnmanagedModelCreationRuleExtractor.java
Cannot solve field access ModelActionRole.Create
Cannot solve method call registration.action(ModelActionRole.Create, context.contextualize(new UnmanagedElementCreationAction<R>(descriptor, subjectReference, inputs, modelType))) java.lang.RuntimeException: Method 'contextualize' cannot be resolved in context context.contextualize(new UnmanagedElementCreationAction<R>(descriptor, subjectReference, inputs, modelType)) (line: 100) MethodCallExprContext{wrapped=context.contextualize(new UnmanagedElementCreationAction<R>(descriptor, subjectReference, inputs, modelType))}. Parameter types: [ReferenceType{org.gradle.model.internal.inspect.UnmanagedModelCreationRuleExtractor.UnmanagedElementCreationAction, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.inspect.UnmanagedModelCreationRuleExtractor.UnmanagedElementCreationAction.T=TypeVariable {org.gradle.model.internal.inspect.UnmanagedModelCreationRuleExtractor.ExtractedUnmanagedCreationRule.R}}}}] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/inspect/UnmanagedModelCreationRuleExtractor.java
Cannot resolve field access null
Cannot solve method call ModelType.of(Void.TYPE) UnsolvedSymbolException{context='unknown', name='TYPE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/inspect/AbstractAnnotationDrivenModelRuleExtractor.java
Cannot solve method call String.format("annotated with @%s", annotationType.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context annotationType.getSimpleName() (line: 46) MethodCallExprContext{wrapped=annotationType.getSimpleName()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/inspect/AbstractAnnotationDrivenModelRuleExtractor.java
Cannot solve method call add(method.getMethod().getMethod(), problem + ": " + cause.getMessage()) java.lang.RuntimeException: Method 'getMessage' cannot be resolved in context cause.getMessage() (line: 52) MethodCallExprContext{wrapped=cause.getMessage()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/inspect/DefaultRuleSourceValidationProblemCollector.java
Method 'getName' cannot be resolved in context left.getName() (line: 46) MethodCallExprContext{wrapped=left.getName()}. Parameter types: []
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Error calculating the type of parameter cache.get(container) of method call FluentIterable.from(cache.get(container))
Error calculating the type of parameter cache.get(container) of method call FluentIterable.from(cache.get(container))
Method 'getAnnotation' cannot be resolved in context ruleDefinition.getAnnotation(Model.class) (line: 34) MethodCallExprContext{wrapped=ruleDefinition.getAnnotation(Model.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.model.Model, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve field access ModelActionRole.Validate
Method 'append' cannot be resolved in context message.append(method.getDeclaringClass().getSimpleName()) (line: 65) MethodCallExprContext{wrapped=message.append(method.getDeclaringClass().getSimpleName())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context message.append(method.getDeclaringClass().getSimpleName()) (line: 65) MethodCallExprContext{wrapped=message.append(method.getDeclaringClass().getSimpleName())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context message.append(' ') (line: 69) MethodCallExprContext{wrapped=message.append(' ')}. Parameter types: [PrimitiveTypeUsage{name='char'}]
Cannot solve method call errorString.append(String.format("\n- %s", problem)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/inspect/FormattingValidationProblemCollector.java
Cannot solve method call problems.add(ruleDefinition, String.format("Rule parameter #%d should not be annotated with @Each.", paramIndex + 1)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, PrimitiveTypeUsage{name='int'}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/inspect/RuleApplicationScope.java
Cannot solve field access ModelActionRole.Finalize
Cannot solve method call UncheckedException.throwAsUncheckedException(e.getCause()) UnsolvedSymbolException{context='unknown', name='UncheckedExecutionException', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/inspect/ModelRuleExtractor.java
Method 'get' cannot be resolved in context cache.get(source) (line: 111) MethodCallExprContext{wrapped=cache.get(source)}. Parameter types: [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=TypeVariable {org.gradle.model.internal.inspect.ModelRuleExtractor.extract(Class<T>).T}}}}]
Cannot solve method call Arrays.asList(source.getDeclaredMethods()) java.lang.RuntimeException: Method 'getDeclaredMethods' cannot be resolved in context source.getDeclaredMethods() (line: 133) MethodCallExprContext{wrapped=source.getDeclaredMethods()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/inspect/ModelRuleExtractor.java
Cannot solve method call methods.addAll(Arrays.asList(source.getDeclaredMethods())) java.lang.RuntimeException: Error calculating the type of parameter source.getDeclaredMethods() of method call Arrays.asList(source.getDeclaredMethods()) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/inspect/ModelRuleExtractor.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call Modifier.isAbstract(source.getModifiers()) java.lang.RuntimeException: Method 'getModifiers' cannot be resolved in context source.getModifiers() (line: 164) MethodCallExprContext{wrapped=source.getModifiers()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/inspect/ModelRuleExtractor.java
Method 'getSuperclass' cannot be resolved in context source.getSuperclass() (line: 171) MethodCallExprContext{wrapped=source.getSuperclass()}. Parameter types: []
Cannot resolve field access null
Cannot resolve field access null
Cannot solve field access ModelActionRole.Discover
Error calculating the type of parameter AddProjectionsAction.of(subject, descriptor, projections) of method call ImmutableSetMultimap.<ModelActionRole, ModelAction>builder().put(ModelActionRole.Discover, AddProjectionsAction.of(subject, descriptor, projections))
Cannot solve method call String.format("%s and taking a managed model element", super.getDescription()) java.lang.RuntimeException: Method 'getDescription' cannot be resolved in context super.getDescription() (line: 47) MethodCallExprContext{wrapped=super.getDescription()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/inspect/ManagedModelCreationRuleExtractor.java
Method 'getReferences' cannot be resolved in context ruleDefinition.getReferences() (line: 57) MethodCallExprContext{wrapped=ruleDefinition.getReferences()}. Parameter types: []
Method 'getSubjectReference' cannot be resolved in context ruleDefinition.getSubjectReference() (line: 64) MethodCallExprContext{wrapped=ruleDefinition.getSubjectReference()}. Parameter types: []
Cannot solve field access ModelActionRole.Discover
Cannot solve method call ModelReference.of(modelPath) UnsolvedSymbolException{context='Solving modelPath', name='modelPath', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/inspect/ManagedModelCreationRuleExtractor.java
Cannot solve method call initializer.getActions(ModelReference.of(modelPath), descriptor) java.lang.RuntimeException: Error calculating the type of parameter modelPath of method call ModelReference.of(modelPath) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/inspect/ManagedModelCreationRuleExtractor.java
Error calculating the type of parameter ModelReference.of(modelPath) of method call initializer.getActions(ModelReference.of(modelPath), descriptor)
Cannot solve method call ModelReference.of(modelPath) UnsolvedSymbolException{context='Solving modelPath', name='modelPath', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/inspect/ManagedModelCreationRuleExtractor.java
Cannot solve method call SpecializedMapNodeInitializer.getActions(ModelReference.of(modelPath), descriptor, (SpecializedMapSchema<S, ?>) modelSchema) java.lang.RuntimeException: Error calculating the type of parameter modelPath of method call ModelReference.of(modelPath) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/inspect/ManagedModelCreationRuleExtractor.java
Cannot solve method call registration.actions(SpecializedMapNodeInitializer.getActions(ModelReference.of(modelPath), descriptor, (SpecializedMapSchema<S, ?>) modelSchema)) java.lang.RuntimeException: Error calculating the type of parameter ModelReference.of(modelPath) of method call SpecializedMapNodeInitializer.getActions(ModelReference.of(modelPath), descriptor, (SpecializedMapSchema<S, ?>) modelSchema) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/inspect/ManagedModelCreationRuleExtractor.java
Cannot solve field access ModelActionRole.Initialize
Cannot solve method call ModelReference.of(modelPath, modelSchema.getType()) UnsolvedSymbolException{context='Solving modelPath', name='modelPath', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/inspect/ManagedModelCreationRuleExtractor.java
Cannot solve method call registration.action(ModelActionRole.Initialize, context.contextualize(new MethodBackedModelAction<S>(descriptor, ModelReference.of(modelPath, modelSchema.getType()), inputs))) java.lang.RuntimeException: Method 'contextualize' cannot be resolved in context context.contextualize(new MethodBackedModelAction<S>(descriptor, ModelReference.of(modelPath, modelSchema.getType()), inputs)) (line: 118) MethodCallExprContext{wrapped=context.contextualize(new MethodBackedModelAction<S>(descriptor, ModelReference.of(modelPath, modelSchema.getType()), inputs))}. Parameter types: [ReferenceType{MethodBackedModelAction, typeParametersMap=TypeParametersMap{nameToValue={empty.S=TypeVariable {org.gradle.model.internal.inspect.ManagedModelCreationRuleExtractor.ExtractedManagedCreationRule.S}}}}] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/inspect/ManagedModelCreationRuleExtractor.java
Cannot solve field access ModelActionRole.Defaults
Cannot resolve field access null
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot resolve field access null
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call pathAnnotation.value() java.lang.UnsupportedOperationException: com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnnotationDeclaration /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/inspect/DefaultMethodRuleDefinition.java
Cannot solve method call ModelPath.path(pathAnnotation.value()) java.lang.UnsupportedOperationException: com.github.javaparser.symbolsolver.javaparsermodel.declarations.JavaParserAnnotationDeclaration@3999970d /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/inspect/DefaultMethodRuleDefinition.java
Cannot solve field access ModelActionRole.Mutate
Cannot solve field access ModelActionRole.Create
Cannot solve method call Arrays.<ModelReference<?>>asList(ModelReference.of(ModelSchemaStore.class), ModelReference.of(NodeInitializerRegistry.class)) UnsolvedSymbolException{context='Method 'of' with parameterTypes [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{ModelSchemaStore, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * A model reference is a speculative reference to a potential model element.
 * <p>
 * Rule subjects/inputs are defined in terms of references, as opposed to concrete identity.
 * The reference may be by type only, or by path only.
 * <p>
 * A reference doesn't include the notion of readonly vs. writable as the context of the reference implies this.
 * Having this be part of the reference would open opportunities for mismatch of that flag in the context.
 *
 * @param <T> the type of the reference.
 */
@ThreadSafe
public class ModelReference<T> {

    public static final ModelReference<Object> ANY = of(ModelType.untyped());

    @Nullable
    private final ModelPath path;

    private final ModelType<T> type;

    @Nullable
    private final ModelPath scope;

    private final ModelNode.State state;

    @Nullable
    private final String description;

    private int hashCode;

    private ModelReference(@Nullable ModelPath path, ModelType<T> type, @Nullable ModelPath scope, @Nullable ModelNode.State state, @Nullable String description) {
        this.path = path;
        this.type = Preconditions.checkNotNull(type, "type");
        this.scope = scope;
        this.description = description;
        this.state = state != null ? state : ModelNode.State.GraphClosed;
    }

    public static ModelReference<Object> any() {
        return ANY;
    }

    public static <T> ModelReference<T> of(ModelPath path, ModelType<T> type, String description) {
        return Cast.uncheckedCast(new ModelReference<T>(path, type, null, null, description));
    }

    public static <T> ModelReference<T> of(String path, ModelType<T> type, String description) {
        return of(ModelPath.path(path), type, description);
    }

    public static <T> ModelReference<T> of(ModelPath path, ModelType<T> type) {
        return Cast.uncheckedCast(new ModelReference<T>(path, type, null, null, null));
    }

    public static <T> ModelReference<T> of(ModelPath path, ModelType<T> type, ModelNode.State state) {
        return Cast.uncheckedCast(new ModelReference<T>(path, type, null, state, null));
    }

    public static <T> ModelReference<T> of(ModelPath path, Class<T> type) {
        return of(path, ModelType.of(type));
    }

    public static <T> ModelReference<T> of(String path, Class<T> type) {
        return of(ModelPath.path(path), ModelType.of(type));
    }

    public static <T> ModelReference<T> of(String path, ModelType<T> type) {
        return of(path == null ? null : ModelPath.path(path), type);
    }

    public static <T> ModelReference<T> of(Class<T> type) {
        return of((ModelPath) null, ModelType.of(type));
    }

    public static <T> ModelReference<T> of(ModelType<T> type) {
        return of((ModelPath) null, type);
    }

    public static ModelReference<Object> of(String path) {
        return of(ModelPath.path(path), ModelType.UNTYPED);
    }

    public static ModelReference<Object> of(ModelPath path) {
        return of(path, ModelType.UNTYPED);
    }

    public static ModelReference<Object> untyped(ModelPath path) {
        return untyped(path, null);
    }

    public static ModelReference<Object> untyped(ModelPath path, String description) {
        return of(path, ModelType.UNTYPED, description);
    }

    @Nullable
    public ModelPath getPath() {
        return path;
    }

    /**
     * Return the path of the scope of the node to select, or null if scope is not relevant.
     *
     * <p>A node will be selected if its path or its parent's path equals the specified path.</p>
     */
    @Nullable
    public ModelPath getScope() {
        return scope;
    }

    @Nullable
    public String getDescription() {
        return description;
    }

    public ModelType<T> getType() {
        return type;
    }

    public ModelNode.State getState() {
        return state;
    }

    public boolean isUntyped() {
        return type.equals(ModelType.UNTYPED);
    }

    public ModelReference<T> inScope(ModelPath scope) {
        if (scope.equals(this.scope)) {
            return this;
        }
        return Cast.uncheckedCast(new ModelReference<T>(path, type, scope, state, description));
    }

    public ModelReference<T> withPath(ModelPath path) {
        return Cast.uncheckedCast(new ModelReference<T>(path, type, scope, state, description));
    }

    public ModelReference<T> atState(ModelNode.State state) {
        if (state.equals(this.state)) {
            return this;
        }
        return Cast.uncheckedCast(new ModelReference<T>(path, type, scope, state, description));
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ModelReference<?> that = (ModelReference<?>) o;
        return Objects.equal(path, that.path) && Objects.equal(scope, that.scope) && type.equals(that.type) && state.equals(that.state) && Objects.equal(description, that.description);
    }

    @Override
    public int hashCode() {
        int result = hashCode;
        if (result != 0) {
            return result;
        }
        result = path == null ? 0 : path.hashCode();
        result = 31 * result + (scope == null ? 0 : scope.hashCode());
        result = 31 * result + type.hashCode();
        result = 31 * result + state.hashCode();
        result = 31 * result + (description == null ? 0 : description.hashCode());
        hashCode = result;
        return result;
    }

    @Override
    public String toString() {
        return "ModelReference{path=" + path + ", scope=" + scope + ", type=" + type + ", state=" + state + '}';
    }
}}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/inspect/StructNodeInitializer.java
Cannot solve method call DirectNodeInputUsingModelAction.of(subject, descriptor, Arrays.<ModelReference<?>>asList(ModelReference.of(ModelSchemaStore.class), ModelReference.of(NodeInitializerRegistry.class)), new BiAction<MutableModelNode, List<ModelView<?>>>() {

    @Override
    public void execute(MutableModelNode modelNode, List<ModelView<?>> modelViews) {
        ModelSchemaStore schemaStore = getInstance(modelViews, 0, ModelSchemaStore.class);
        NodeInitializerRegistry nodeInitializerRegistry = getInstance(modelViews, 1, NodeInitializerRegistry.class);
        addPropertyLinks(modelNode, schemaStore, nodeInitializerRegistry);
        initializePrivateData(modelNode);
    }
}) java.lang.RuntimeException: Error calculating the type of parameter ModelReference.of(ModelSchemaStore.class) of method call Arrays.<ModelReference<?>>asList(ModelReference.of(ModelSchemaStore.class), ModelReference.of(NodeInitializerRegistry.class)) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/inspect/StructNodeInitializer.java
Cannot solve field access ModelActionRole.Discover
Cannot solve method call Arrays.<ModelReference<?>>asList(ModelReference.of(ManagedProxyFactory.class), ModelReference.of(TypeConverter.class)) UnsolvedSymbolException{context='Method 'of' with parameterTypes [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.model.internal.manage.instance.ManagedProxyFactory, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * A model reference is a speculative reference to a potential model element.
 * <p>
 * Rule subjects/inputs are defined in terms of references, as opposed to concrete identity.
 * The reference may be by type only, or by path only.
 * <p>
 * A reference doesn't include the notion of readonly vs. writable as the context of the reference implies this.
 * Having this be part of the reference would open opportunities for mismatch of that flag in the context.
 *
 * @param <T> the type of the reference.
 */
@ThreadSafe
public class ModelReference<T> {

    public static final ModelReference<Object> ANY = of(ModelType.untyped());

    @Nullable
    private final ModelPath path;

    private final ModelType<T> type;

    @Nullable
    private final ModelPath scope;

    private final ModelNode.State state;

    @Nullable
    private final String description;

    private int hashCode;

    private ModelReference(@Nullable ModelPath path, ModelType<T> type, @Nullable ModelPath scope, @Nullable ModelNode.State state, @Nullable String description) {
        this.path = path;
        this.type = Preconditions.checkNotNull(type, "type");
        this.scope = scope;
        this.description = description;
        this.state = state != null ? state : ModelNode.State.GraphClosed;
    }

    public static ModelReference<Object> any() {
        return ANY;
    }

    public static <T> ModelReference<T> of(ModelPath path, ModelType<T> type, String description) {
        return Cast.uncheckedCast(new ModelReference<T>(path, type, null, null, description));
    }

    public static <T> ModelReference<T> of(String path, ModelType<T> type, String description) {
        return of(ModelPath.path(path), type, description);
    }

    public static <T> ModelReference<T> of(ModelPath path, ModelType<T> type) {
        return Cast.uncheckedCast(new ModelReference<T>(path, type, null, null, null));
    }

    public static <T> ModelReference<T> of(ModelPath path, ModelType<T> type, ModelNode.State state) {
        return Cast.uncheckedCast(new ModelReference<T>(path, type, null, state, null));
    }

    public static <T> ModelReference<T> of(ModelPath path, Class<T> type) {
        return of(path, ModelType.of(type));
    }

    public static <T> ModelReference<T> of(String path, Class<T> type) {
        return of(ModelPath.path(path), ModelType.of(type));
    }

    public static <T> ModelReference<T> of(String path, ModelType<T> type) {
        return of(path == null ? null : ModelPath.path(path), type);
    }

    public static <T> ModelReference<T> of(Class<T> type) {
        return of((ModelPath) null, ModelType.of(type));
    }

    public static <T> ModelReference<T> of(ModelType<T> type) {
        return of((ModelPath) null, type);
    }

    public static ModelReference<Object> of(String path) {
        return of(ModelPath.path(path), ModelType.UNTYPED);
    }

    public static ModelReference<Object> of(ModelPath path) {
        return of(path, ModelType.UNTYPED);
    }

    public static ModelReference<Object> untyped(ModelPath path) {
        return untyped(path, null);
    }

    public static ModelReference<Object> untyped(ModelPath path, String description) {
        return of(path, ModelType.UNTYPED, description);
    }

    @Nullable
    public ModelPath getPath() {
        return path;
    }

    /**
     * Return the path of the scope of the node to select, or null if scope is not relevant.
     *
     * <p>A node will be selected if its path or its parent's path equals the specified path.</p>
     */
    @Nullable
    public ModelPath getScope() {
        return scope;
    }

    @Nullable
    public String getDescription() {
        return description;
    }

    public ModelType<T> getType() {
        return type;
    }

    public ModelNode.State getState() {
        return state;
    }

    public boolean isUntyped() {
        return type.equals(ModelType.UNTYPED);
    }

    public ModelReference<T> inScope(ModelPath scope) {
        if (scope.equals(this.scope)) {
            return this;
        }
        return Cast.uncheckedCast(new ModelReference<T>(path, type, scope, state, description));
    }

    public ModelReference<T> withPath(ModelPath path) {
        return Cast.uncheckedCast(new ModelReference<T>(path, type, scope, state, description));
    }

    public ModelReference<T> atState(ModelNode.State state) {
        if (state.equals(this.state)) {
            return this;
        }
        return Cast.uncheckedCast(new ModelReference<T>(path, type, scope, state, description));
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ModelReference<?> that = (ModelReference<?>) o;
        return Objects.equal(path, that.path) && Objects.equal(scope, that.scope) && type.equals(that.type) && state.equals(that.state) && Objects.equal(description, that.description);
    }

    @Override
    public int hashCode() {
        int result = hashCode;
        if (result != 0) {
            return result;
        }
        result = path == null ? 0 : path.hashCode();
        result = 31 * result + (scope == null ? 0 : scope.hashCode());
        result = 31 * result + type.hashCode();
        result = 31 * result + state.hashCode();
        result = 31 * result + (description == null ? 0 : description.hashCode());
        hashCode = result;
        return result;
    }

    @Override
    public String toString() {
        return "ModelReference{path=" + path + ", scope=" + scope + ", type=" + type + ", state=" + state + '}';
    }
}}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/inspect/StructNodeInitializer.java
Cannot solve method call DirectNodeInputUsingModelAction.of(subject, descriptor, Arrays.<ModelReference<?>>asList(ModelReference.of(ManagedProxyFactory.class), ModelReference.of(TypeConverter.class)), new BiAction<MutableModelNode, List<ModelView<?>>>() {

    @Override
    public void execute(MutableModelNode modelNode, List<ModelView<?>> modelViews) {
        ManagedProxyFactory proxyFactory = getInstance(modelViews.get(0), ManagedProxyFactory.class);
        TypeConverter typeConverter = getInstance(modelViews, 1, TypeConverter.class);
        for (StructSchema<?> viewSchema : bindings.getDeclaredViewSchemas()) {
            addProjection(modelNode, viewSchema, proxyFactory, typeConverter);
        }
        modelNode.addProjection(new ModelElementProjection(bindings.getPublicSchema().getType()));
    }
}) java.lang.RuntimeException: Error calculating the type of parameter ModelReference.of(ManagedProxyFactory.class) of method call Arrays.<ModelReference<?>>asList(ModelReference.of(ManagedProxyFactory.class), ModelReference.of(TypeConverter.class)) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/inspect/StructNodeInitializer.java
Error calculating the type of parameter DirectNodeInputUsingModelAction.of(subject, descriptor, Arrays.<ModelReference<?>>asList(ModelReference.of(ManagedProxyFactory.class), ModelReference.of(TypeConverter.class)), new BiAction<MutableModelNode, List<ModelView<?>>>() {

    @Override
    public void execute(MutableModelNode modelNode, List<ModelView<?>> modelViews) {
        ManagedProxyFactory proxyFactory = getInstance(modelViews.get(0), ManagedProxyFactory.class);
        TypeConverter typeConverter = getInstance(modelViews, 1, TypeConverter.class);
        for (StructSchema<?> viewSchema : bindings.getDeclaredViewSchemas()) {
            addProjection(modelNode, viewSchema, proxyFactory, typeConverter);
        }
        modelNode.addProjection(new ModelElementProjection(bindings.getPublicSchema().getType()));
    }
}) of method call ImmutableSetMultimap.<ModelActionRole, ModelAction>builder().put(ModelActionRole.Discover, DirectNodeInputUsingModelAction.of(subject, descriptor, Arrays.<ModelReference<?>>asList(ModelReference.of(ManagedProxyFactory.class), ModelReference.of(TypeConverter.class)), new BiAction<MutableModelNode, List<ModelView<?>>>() {

    @Override
    public void execute(MutableModelNode modelNode, List<ModelView<?>> modelViews) {
        ManagedProxyFactory proxyFactory = getInstance(modelViews.get(0), ManagedProxyFactory.class);
        TypeConverter typeConverter = getInstance(modelViews, 1, TypeConverter.class);
        for (StructSchema<?> viewSchema : bindings.getDeclaredViewSchemas()) {
            addProjection(modelNode, viewSchema, proxyFactory, typeConverter);
        }
        modelNode.addProjection(new ModelElementProjection(bindings.getPublicSchema().getType()));
    }
}))
Error calculating the type of parameter DirectNodeInputUsingModelAction.of(subject, descriptor, Arrays.<ModelReference<?>>asList(ModelReference.of(ModelSchemaStore.class), ModelReference.of(NodeInitializerRegistry.class)), new BiAction<MutableModelNode, List<ModelView<?>>>() {

    @Override
    public void execute(MutableModelNode modelNode, List<ModelView<?>> modelViews) {
        ModelSchemaStore schemaStore = getInstance(modelViews, 0, ModelSchemaStore.class);
        NodeInitializerRegistry nodeInitializerRegistry = getInstance(modelViews, 1, NodeInitializerRegistry.class);
        addPropertyLinks(modelNode, schemaStore, nodeInitializerRegistry);
        initializePrivateData(modelNode);
    }
}) of method call ImmutableSetMultimap.<ModelActionRole, ModelAction>builder().put(ModelActionRole.Discover, DirectNodeInputUsingModelAction.of(subject, descriptor, Arrays.<ModelReference<?>>asList(ModelReference.of(ManagedProxyFactory.class), ModelReference.of(TypeConverter.class)), new BiAction<MutableModelNode, List<ModelView<?>>>() {

    @Override
    public void execute(MutableModelNode modelNode, List<ModelView<?>> modelViews) {
        ManagedProxyFactory proxyFactory = getInstance(modelViews.get(0), ManagedProxyFactory.class);
        TypeConverter typeConverter = getInstance(modelViews, 1, TypeConverter.class);
        for (StructSchema<?> viewSchema : bindings.getDeclaredViewSchemas()) {
            addProjection(modelNode, viewSchema, proxyFactory, typeConverter);
        }
        modelNode.addProjection(new ModelElementProjection(bindings.getPublicSchema().getType()));
    }
})).put(ModelActionRole.Create, DirectNodeInputUsingModelAction.of(subject, descriptor, Arrays.<ModelReference<?>>asList(ModelReference.of(ModelSchemaStore.class), ModelReference.of(NodeInitializerRegistry.class)), new BiAction<MutableModelNode, List<ModelView<?>>>() {

    @Override
    public void execute(MutableModelNode modelNode, List<ModelView<?>> modelViews) {
        ModelSchemaStore schemaStore = getInstance(modelViews, 0, ModelSchemaStore.class);
        NodeInitializerRegistry nodeInitializerRegistry = getInstance(modelViews, 1, NodeInitializerRegistry.class);
        addPropertyLinks(modelNode, schemaStore, nodeInitializerRegistry);
        initializePrivateData(modelNode);
    }
}))
Cannot solve method call ModelRegistrations.of(childPath, nodeInitializerRegistry.getNodeInitializer(forProperty(property.getType(), property, publicType))) java.lang.RuntimeException: T ? /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/inspect/StructNodeInitializer.java
Cannot solve field access ModelActionRole.Defaults
Cannot resolve field access null
Cannot solve method call bound.collectClasses(builder) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/type/TypeVariableTypeWrapper.java
Cannot solve method call componentType.collectClasses(builder) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/type/GenericArrayTypeWrapper.java
Cannot resolve field access null
Cannot solve method call rawType.collectClasses(builder) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/type/ParameterizedTypeWrapper.java
Cannot solve method call actualTypeArgument.collectClasses(builder) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/type/ParameterizedTypeWrapper.java
Cannot solve method call sb.append(rawType.unwrap().getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context rawType.unwrap().getSimpleName() (line: 161) MethodCallExprContext{wrapped=rawType.unwrap().getSimpleName()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/type/ParameterizedTypeWrapper.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call wrap(new TypeToken<T>(getClass()) {
}.getType()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context new TypeToken<T>(getClass()) {
}.getType() (line: 52) MethodCallExprContext{wrapped=new TypeToken<T>(getClass()) {
}.getType()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/type/ModelType.java
Cannot resolve field access null
Cannot solve method call Cast.uncheckedCast(wrapper.getRawClass()) java.lang.RuntimeException: Method 'getRawClass' cannot be resolved in context wrapper.getRawClass() (line: 96) MethodCallExprContext{wrapped=wrapper.getRawClass()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/type/ModelType.java
Cannot solve method call Cast.uncheckedCast(wrapper.getRawClass()) java.lang.RuntimeException: Method 'getRawClass' cannot be resolved in context wrapper.getRawClass() (line: 100) MethodCallExprContext{wrapped=wrapper.getRawClass()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/type/ModelType.java
Method 'unwrap' cannot be resolved in context ((ClassTypeWrapper) wrapper).unwrap() (line: 104) MethodCallExprContext{wrapped=((ClassTypeWrapper) wrapper).unwrap()}. Parameter types: []
Method 'unwrap' cannot be resolved in context ((ClassTypeWrapper) wrapper).unwrap() (line: 104) MethodCallExprContext{wrapped=((ClassTypeWrapper) wrapper).unwrap()}. Parameter types: []
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call Simple.typed(wildcardType.getUpperBound()) java.lang.RuntimeException: Method 'getUpperBound' cannot be resolved in context wildcardType.getUpperBound() (line: 171) MethodCallExprContext{wrapped=wildcardType.getUpperBound()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/type/ModelType.java
Cannot solve method call wrapper.collectClasses(builder) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/type/ModelType.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call wrap(new TypeToken<T>(getClass()) {
}.getType()) java.lang.RuntimeException: Method 'getType' cannot be resolved in context new TypeToken<T>(getClass()) {
}.getType() (line: 258) MethodCallExprContext{wrapped=new TypeToken<T>(getClass()) {
}.getType()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/type/ModelType.java
Cannot resolve field access null
Cannot resolve field access null
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Method 'getName' cannot be resolved in context pkg.getName() (line: 86) MethodCallExprContext{wrapped=pkg.getName()}. Parameter types: []
Method 'getName' cannot be resolved in context clazz.getName() (line: 87) MethodCallExprContext{wrapped=clazz.getName()}. Parameter types: []
Method 'getName' cannot be resolved in context clazz.getName() (line: 87) MethodCallExprContext{wrapped=clazz.getName()}. Parameter types: []
Cannot solve method call sb.append(clazz.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context clazz.getSimpleName() (line: 76) MethodCallExprContext{wrapped=clazz.getSimpleName()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/type/ClassTypeWrapper.java
Cannot solve method call sb.insert(0, c.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context c.getSimpleName() (line: 79) MethodCallExprContext{wrapped=c.getSimpleName()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/type/ClassTypeWrapper.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call upperBound.collectClasses(builder) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/type/WildcardTypeWrapper.java
Cannot solve method call lowerBound.collectClasses(builder) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/type/WildcardTypeWrapper.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call registration.withInternalView(ModelType.of(internalView)) java.lang.UnsupportedOperationException: com.github.javaparser.resolution.types.ResolvedWildcard /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/typeregistration/BaseInstanceFactory.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call Modifier.isAbstract(implementationType.getConcreteClass().getModifiers()) java.lang.RuntimeException: Method 'getModifiers' cannot be resolved in context implementationType.getConcreteClass().getModifiers() (line: 214) MethodCallExprContext{wrapped=implementationType.getConcreteClass().getModifiers()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/typeregistration/BaseInstanceFactory.java
Cannot solve method call String.format("No factory registered to create an instance of implementation class '%s'.", implementationClass.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context implementationClass.getName() (line: 225) MethodCallExprContext{wrapped=implementationClass.getName()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/typeregistration/BaseInstanceFactory.java
Cannot solve method call String.format("Factory registration for '%s' is invalid because the default implementation type '%s' does not implement unmanaged internal view '%s', " + "internal view was registered by %s", publicType, delegateType, type.getName(), internalViewRegistration.getSource()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context type.getName() (line: 269) MethodCallExprContext{wrapped=type.getName()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/typeregistration/BaseInstanceFactory.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Method 'getName' cannot be resolved in context cl.getName() (line: 88) MethodCallExprContext{wrapped=cl.getName()}. Parameter types: []
Cannot solve method call builder.append(cl.getName().replace('.', '/')) java.lang.RuntimeException: Method 'getName' cannot be resolved in context cl.getName() (line: 88) MethodCallExprContext{wrapped=cl.getName()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/asm/AsmClassGeneratorUtils.java
Method 'getName' cannot be resolved in context cl.getName() (line: 85) MethodCallExprContext{wrapped=cl.getName()}. Parameter types: []
Cannot solve method call builder.append(cl.getName().replace('.', '/')) java.lang.RuntimeException: Method 'getName' cannot be resolved in context cl.getName() (line: 85) MethodCallExprContext{wrapped=cl.getName()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/asm/AsmClassGeneratorUtils.java
Cannot solve method call builder.append(Type.getType(cl).getDescriptor()) UnsolvedSymbolException{context='Method 'getType' with parameterTypes [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=null, boundedType=null}}}}]', name='ReflectionClassDeclaration{clazz=org.objectweb.asm.Type}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/asm/AsmClassGeneratorUtils.java
Method 'getName' cannot be resolved in context cl.getName() (line: 138) MethodCallExprContext{wrapped=cl.getName()}. Parameter types: []
Cannot solve method call builder.append(cl.getName().replace('.', '/')) java.lang.RuntimeException: Method 'getName' cannot be resolved in context cl.getName() (line: 138) MethodCallExprContext{wrapped=cl.getName()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/asm/AsmClassGeneratorUtils.java
Cannot solve method call builder.append(Type.getType(cl).getDescriptor()) UnsolvedSymbolException{context='Method 'getType' with parameterTypes [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=null, boundedType=null}}}}]', name='ReflectionClassDeclaration{clazz=org.objectweb.asm.Type}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/asm/AsmClassGeneratorUtils.java
Method 'get' cannot be resolved in context STACK.get() (line: 36) MethodCallExprContext{wrapped=STACK.get()}. Parameter types: []
Method 'get' cannot be resolved in context STACK.get() (line: 40) MethodCallExprContext{wrapped=STACK.get()}. Parameter types: []
Method 'get' cannot be resolved in context STACK.get() (line: 44) MethodCallExprContext{wrapped=STACK.get()}. Parameter types: []
Cannot solve method call scopeReferences.addNodeToScope(node.getPath(), node) java.lang.RuntimeException: Method 'getPath' cannot be resolved in context node.getPath() (line: 45) MethodCallExprContext{wrapped=node.getPath()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/RuleBindings.java
Method 'getPath' cannot be resolved in context node.getPath() (line: 46) MethodCallExprContext{wrapped=node.getPath()}. Parameter types: []
Cannot solve method call scopeReferences.addNodeToScope(node.getPath().getParent(), node) java.lang.RuntimeException: Method 'getPath' cannot be resolved in context node.getPath() (line: 46) MethodCallExprContext{wrapped=node.getPath()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/RuleBindings.java
Cannot resolve field access null
Cannot solve method call scopeReferences.removeNodeFromScope(node.getPath(), node) java.lang.RuntimeException: Method 'getPath' cannot be resolved in context node.getPath() (line: 58) MethodCallExprContext{wrapped=node.getPath()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/RuleBindings.java
Method 'getPath' cannot be resolved in context node.getPath() (line: 59) MethodCallExprContext{wrapped=node.getPath()}. Parameter types: []
Cannot solve method call scopeReferences.removeNodeFromScope(node.getPath().getParent(), node) java.lang.RuntimeException: Method 'getPath' cannot be resolved in context node.getPath() (line: 59) MethodCallExprContext{wrapped=node.getPath()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/RuleBindings.java
Cannot solve method call addRule(ruleBinder, rulesBySubject, ruleBinder.getSubjectBinding()) java.lang.RuntimeException: Method 'getSubjectBinding' cannot be resolved in context ruleBinder.getSubjectBinding() (line: 65) MethodCallExprContext{wrapped=ruleBinder.getSubjectBinding()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/RuleBindings.java
Cannot resolve field access null
Cannot solve field access ModelNode.State.Registered
Method 'getSubjectBinding' cannot be resolved in context rule.getSubjectBinding() (line: 91) MethodCallExprContext{wrapped=rule.getSubjectBinding()}. Parameter types: []
Cannot solve method call predicatesForPath(node.getPath()) java.lang.RuntimeException: Method 'getPath' cannot be resolved in context node.getPath() (line: 155) MethodCallExprContext{wrapped=node.getPath()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/RuleBindings.java
Error calculating the type of parameter node.getPath() of method call predicatesForPath(node.getPath())
Method 'getPredicate' cannot be resolved in context reference.binding.getPredicate() (line: 159) MethodCallExprContext{wrapped=reference.binding.getPredicate()}. Parameter types: []
Cannot solve method call predicatesForPath(node.getPath()) java.lang.RuntimeException: Method 'getPath' cannot be resolved in context node.getPath() (line: 173) MethodCallExprContext{wrapped=node.getPath()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/RuleBindings.java
Error calculating the type of parameter node.getPath() of method call predicatesForPath(node.getPath())
Method 'getPredicate' cannot be resolved in context reference.binding.getPredicate() (line: 200) MethodCallExprContext{wrapped=reference.binding.getPredicate()}. Parameter types: []
Method 'getPredicate' cannot be resolved in context reference.binding.getPredicate() (line: 230) MethodCallExprContext{wrapped=reference.binding.getPredicate()}. Parameter types: []
Method 'getPath' cannot be resolved in context node.getPath() (line: 266) MethodCallExprContext{wrapped=node.getPath()}. Parameter types: []
Cannot solve method call byState.remove(node.getPath().toString()) java.lang.RuntimeException: Method 'getPath' cannot be resolved in context node.getPath() (line: 266) MethodCallExprContext{wrapped=node.getPath()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/RuleBindings.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call getByState(nodeAtState.state) UnsolvedSymbolException{context='unknown', name='state', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/RuleBindings.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call getByState(nodeAtState.state) UnsolvedSymbolException{context='unknown', name='state', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/RuleBindings.java
Cannot resolve field access null
Cannot solve method call getByPath(getByState(nodeAtState.state), nodeAtState.path.toString()) java.lang.RuntimeException: Error calculating the type of parameter nodeAtState.state of method call getByState(nodeAtState.state) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/RuleBindings.java
Method 'getPath' cannot be resolved in context node.getPath() (line: 304) MethodCallExprContext{wrapped=node.getPath()}. Parameter types: []
Cannot solve method call getByPath(byState, node.getPath().toString()) java.lang.RuntimeException: Method 'getPath' cannot be resolved in context node.getPath() (line: 304) MethodCallExprContext{wrapped=node.getPath()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/RuleBindings.java
Error calculating the type of parameter node.getPath().toString() of method call getByPath(byState, node.getPath().toString())
Cannot resolve field access null
Cannot solve method call flattened.put(root.getPath(), root) java.lang.RuntimeException: Method 'getPath' cannot be resolved in context root.getPath() (line: 45) MethodCallExprContext{wrapped=root.getPath()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/ModelGraph.java
Cannot solve field access PendingState.ADD
Cannot solve field access PendingState.NOTIFY
Cannot solve method call flattened.put(node.getPath(), node) java.lang.RuntimeException: Method 'getPath' cannot be resolved in context node.getPath() (line: 79) MethodCallExprContext{wrapped=node.getPath()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/ModelGraph.java
Cannot resolve field access null
Cannot solve field access ModelNode.State.Discovered
Cannot solve method call pathListeners.get(node.getPath()) java.lang.RuntimeException: Method 'getPath' cannot be resolved in context node.getPath() (line: 88) MethodCallExprContext{wrapped=node.getPath()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/ModelGraph.java
Cannot solve method call notifyListeners(node, pathListeners.get(node.getPath())) java.lang.RuntimeException: Error calculating the type of parameter node.getPath() of method call pathListeners.get(node.getPath()) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/ModelGraph.java
Method 'getPath' cannot be resolved in context node.getPath() (line: 89) MethodCallExprContext{wrapped=node.getPath()}. Parameter types: []
Cannot solve method call parentListeners.get(node.getPath().getParent()) java.lang.RuntimeException: Method 'getPath' cannot be resolved in context node.getPath() (line: 89) MethodCallExprContext{wrapped=node.getPath()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/ModelGraph.java
Cannot solve method call notifyListeners(node, parentListeners.get(node.getPath().getParent())) java.lang.RuntimeException: Error calculating the type of parameter node.getPath().getParent() of method call parentListeners.get(node.getPath().getParent()) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/ModelGraph.java
Cannot solve method call notifyListeners(node, ancestorListeners.get(path)) java.lang.RuntimeException: Method 'get' cannot be resolved in context ancestorListeners.get(path) (line: 94) MethodCallExprContext{wrapped=ancestorListeners.get(path)}. Parameter types: [ReferenceType{org.gradle.model.internal.core.ModelPath, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/ModelGraph.java
Method 'getPath' cannot be resolved in context node.getPath() (line: 93) MethodCallExprContext{wrapped=node.getPath()}. Parameter types: []
Cannot solve method call ModelPath.ROOT.equals(listener.getAncestor()) java.lang.RuntimeException: Method 'getAncestor' cannot be resolved in context listener.getAncestor() (line: 147) MethodCallExprContext{wrapped=listener.getAncestor()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/ModelGraph.java
Cannot solve method call flattened.get(listener.getAncestor()) java.lang.RuntimeException: Method 'getAncestor' cannot be resolved in context listener.getAncestor() (line: 153) MethodCallExprContext{wrapped=listener.getAncestor()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/ModelGraph.java
Cannot solve method call ancestorListeners.put(listener.getAncestor(), listener) java.lang.RuntimeException: Method 'getAncestor' cannot be resolved in context listener.getAncestor() (line: 165) MethodCallExprContext{wrapped=listener.getAncestor()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/ModelGraph.java
Cannot solve method call flattened.get(listener.getParent()) java.lang.RuntimeException: Method 'getParent' cannot be resolved in context listener.getParent() (line: 169) MethodCallExprContext{wrapped=listener.getParent()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/ModelGraph.java
Cannot solve method call parentListeners.put(listener.getParent(), listener) java.lang.RuntimeException: Method 'getParent' cannot be resolved in context listener.getParent() (line: 175) MethodCallExprContext{wrapped=listener.getParent()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/ModelGraph.java
Cannot solve method call flattened.get(listener.getPath()) java.lang.RuntimeException: Method 'getPath' cannot be resolved in context listener.getPath() (line: 179) MethodCallExprContext{wrapped=listener.getPath()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/ModelGraph.java
Cannot solve method call pathListeners.put(listener.getPath(), listener) java.lang.RuntimeException: Method 'getPath' cannot be resolved in context listener.getPath() (line: 183) MethodCallExprContext{wrapped=listener.getPath()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/ModelGraph.java
Empty name expression ADD
Empty name expression NOTIFY
Cannot resolve field access null
Cannot solve field access ModelNode.State.Discovered
Cannot resolve field access null
Cannot solve method call String.format("Cannot set target for model element '%s' as this element is not mutable.", getPath()) java.lang.RuntimeException: Method 'getPath' cannot be resolved in context getPath() (line: 51) MethodCallExprContext{wrapped=getPath()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/ModelReferenceNode.java
Cannot solve method call LOGGER.debug("Project {} - Setting the target of model element '{}' to point at {}.", modelRegistry.getProjectPath(), getPath(), targetPath) UnsolvedSymbolException{context='Solving modelRegistry', name='modelRegistry', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/ModelReferenceNode.java
Cannot solve method call Optional.of("reference to element '" + target.getPath() + "'") java.lang.RuntimeException: Method 'getPath' cannot be resolved in context target.getPath() (line: 70) MethodCallExprContext{wrapped=target.getPath()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/ModelReferenceNode.java
Cannot solve method call InstanceModelView.of(getPath(), type, null) java.lang.RuntimeException: Method 'getPath' cannot be resolved in context getPath() (line: 82) MethodCallExprContext{wrapped=getPath()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/ModelReferenceNode.java
Cannot solve method call InstanceModelView.of(getPath(), type, null) java.lang.RuntimeException: Method 'getPath' cannot be resolved in context getPath() (line: 91) MethodCallExprContext{wrapped=getPath()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/ModelReferenceNode.java
Cannot resolve field access null
Cannot solve field access ModelNode.State.Discovered
Cannot solve method call setPrivateData(ModelType.of(type), object) java.lang.UnsupportedOperationException: com.github.javaparser.resolution.types.ResolvedWildcard /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/ModelElementNode.java
Cannot solve method call Iterables.size(Iterables.filter(links.values(), predicate)) UnsolvedSymbolException{context='Method 'filter' with parameterTypes [ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=ReferenceType{org.gradle.model.internal.registry.ModelNodeInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{Predicate, typeParametersMap=TypeParametersMap{nameToValue={empty.? super ScriptBlock=WildcardUsage{type=SUPER, boundedType=ReferenceType{org.gradle.model.internal.core.MutableModelNode, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/ModelElementNode.java
Cannot resolve field access null
Cannot solve field access ModelNode.State.Registered
Cannot solve method call executedRules.add(binder.getDescriptor()) java.lang.RuntimeException: Method 'getDescriptor' cannot be resolved in context binder.getDescriptor() (line: 97) MethodCallExprContext{wrapped=binder.getDescriptor()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/ModelNodeInternal.java
Cannot resolve field access null
Cannot solve method call state.isAtLeast(State.Discovered) UnsolvedSymbolException{context='unknown', name='Discovered', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/ModelNodeInternal.java
Cannot resolve field access null
Cannot solve method call state.isAtLeast(State.Created) UnsolvedSymbolException{context='unknown', name='Created', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/ModelNodeInternal.java
Cannot solve method call Math.min(3, unavailable.toString().length() / 2) java.lang.RuntimeException: Method 'length' cannot be resolved in context unavailable.toString().length() (line: 78) MethodCallExprContext{wrapped=unavailable.toString().length()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/ModelPathSuggestionProvider.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call ModelRegistrations.of(ModelPath.ROOT) UnsolvedSymbolException{context='unknown', name='ROOT', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Error calculating the type of parameter ModelPath.ROOT of method call ModelRegistrations.of(ModelPath.ROOT)
Error calculating the type of parameter ModelPath.ROOT of method call ModelRegistrations.of(ModelPath.ROOT)
Error calculating the type of parameter EmptyModelProjection.INSTANCE of method call ModelRegistrations.of(ModelPath.ROOT).descriptor("<root>").withProjection(EmptyModelProjection.INSTANCE)
Cannot solve method call transition(modelGraph.getRoot(), Created, false) java.lang.RuntimeException: Method 'getRoot' cannot be resolved in context modelGraph.getRoot() (line: 58) MethodCallExprContext{wrapped=modelGraph.getRoot()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Cannot resolve field access null
Cannot solve method call LOGGER.debug("Project {} - Registering model element '{}' (hidden = {})", projectPath, node.getPath(), node.isHidden()) java.lang.RuntimeException: Method 'getPath' cannot be resolved in context node.getPath() (line: 82) MethodCallExprContext{wrapped=node.getPath()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Cannot solve method call bindInternal(action.getSubject(), role, action) java.lang.RuntimeException: Method 'getSubject' cannot be resolved in context action.getSubject() (line: 93) MethodCallExprContext{wrapped=action.getSubject()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Cannot solve method call bindInternal(action.getSubject(), role, action) java.lang.RuntimeException: Method 'getSubject' cannot be resolved in context action.getSubject() (line: 100) MethodCallExprContext{wrapped=action.getSubject()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Method 'getSubject' cannot be resolved in context action.getSubject() (line: 106) MethodCallExprContext{wrapped=action.getSubject()}. Parameter types: []
Method 'getSubject' cannot be resolved in context action.getSubject() (line: 110) MethodCallExprContext{wrapped=action.getSubject()}. Parameter types: []
Cannot solve method call ModelReference.of(node.getPath(), subjectType) java.lang.RuntimeException: Method 'getPath' cannot be resolved in context node.getPath() (line: 120) MethodCallExprContext{wrapped=node.getPath()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Cannot solve method call bind(ModelReference.of(node.getPath(), subjectType), role, action) java.lang.RuntimeException: Error calculating the type of parameter node.getPath() of method call ModelReference.of(node.getPath(), subjectType) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Method 'getSubject' cannot be resolved in context action.getSubject() (line: 151) MethodCallExprContext{wrapped=action.getSubject()}. Parameter types: []
Method 'getPath' cannot be resolved in context node.getPath() (line: 151) MethodCallExprContext{wrapped=node.getPath()}. Parameter types: []
Method 'getSubject' cannot be resolved in context action.getSubject() (line: 152) MethodCallExprContext{wrapped=action.getSubject()}. Parameter types: []
Cannot solve method call String.format("Element action reference has path (%s) which does not reference this node (%s).", action.getSubject().getPath(), node.getPath()) java.lang.RuntimeException: Method 'getSubject' cannot be resolved in context action.getSubject() (line: 152) MethodCallExprContext{wrapped=action.getSubject()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Cannot solve method call mapInputs(mutator.getInputs()) java.lang.RuntimeException: Method 'getInputs' cannot be resolved in context mutator.getInputs() (line: 163) MethodCallExprContext{wrapped=mutator.getInputs()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Cannot solve method call realize(ModelPath.path(path), type) UnsolvedSymbolException{context='Method 'path' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=ModelPath}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Cannot solve method call find(ModelPath.path(path), type) UnsolvedSymbolException{context='Method 'path' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=ModelPath}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Method 'asImmutable' cannot be resolved in context node.asImmutable(type, new SimpleModelRuleDescriptor(msg)) (line: 226) MethodCallExprContext{wrapped=node.asImmutable(type, new SimpleModelRuleDescriptor(msg))}. Parameter types: [ReferenceType{org.gradle.model.internal.type.ModelType, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.type.ModelType.T=TypeVariable {org.gradle.model.internal.registry.DefaultModelRegistry.toType(org.gradle.model.internal.type.ModelType<T>, ModelNodeInternal, String).T}}}}, ReferenceType{org.gradle.model.internal.core.rule.describe.SimpleModelRuleDescriptor, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call unboundRules.removeAll(nodeToRemove.getRegistrationActionBinders()) java.lang.RuntimeException: Method 'getRegistrationActionBinders' cannot be resolved in context nodeToRemove.getRegistrationActionBinders() (line: 253) MethodCallExprContext{wrapped=nodeToRemove.getRegistrationActionBinders()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Cannot solve method call Iterables.isEmpty(node.getDependents()) java.lang.RuntimeException: Method 'getDependents' cannot be resolved in context node.getDependents() (line: 263) MethodCallExprContext{wrapped=node.getDependents()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Cannot solve method call String.format("Tried to remove model '%s' but it is depended on by: '%s'", node.getPath(), Joiner.on(", ").join(node.getDependents())) java.lang.RuntimeException: Method 'getPath' cannot be resolved in context node.getPath() (line: 264) MethodCallExprContext{wrapped=node.getPath()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Method 'getFlattened' cannot be resolved in context modelGraph.getFlattened() (line: 272) MethodCallExprContext{wrapped=modelGraph.getFlattened()}. Parameter types: []
Cannot solve method call String.valueOf(o2.getDescriptor()) java.lang.RuntimeException: Method 'getDescriptor' cannot be resolved in context o2.getDescriptor() (line: 295) MethodCallExprContext{wrapped=o2.getDescriptor()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Cannot solve method call String.valueOf(o1.getDescriptor()) java.lang.RuntimeException: Method 'getDescriptor' cannot be resolved in context o1.getDescriptor() (line: 295) MethodCallExprContext{wrapped=o1.getDescriptor()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Error calculating the type of parameter o1.getDescriptor() of method call String.valueOf(o1.getDescriptor())
Method 'getFlattened' cannot be resolved in context modelGraph.getFlattened() (line: 304) MethodCallExprContext{wrapped=modelGraph.getFlattened()}. Parameter types: []
Cannot resolve field access null
Cannot solve field access ModelGoal.State.Achieved
Cannot resolve field access null
Cannot solve field access ModelGoal.State.NotSeen
Cannot resolve field access null
Cannot solve field access ModelGoal.State.Achieved
Cannot resolve field access null
Cannot solve field access ModelGoal.State.VisitingDependencies
Cannot resolve field access null
Cannot solve field access ModelGoal.State.Achieved
Cannot resolve field access null
Cannot solve field access ModelGoal.State.DiscoveringDependencies
Cannot resolve field access null
Cannot solve field access ModelGoal.State.VisitingDependencies
Cannot resolve field access null
Cannot solve field access ModelGoal.State.Achieved
Cannot resolve field access null
Cannot solve field access ModelGoal.State.NotSeen
Cannot solve method call ruleCycle(dependency, Lists.newArrayList(queue)) UnsolvedSymbolException{context='Method 'newArrayList' with parameterTypes [ReferenceType{Deque, typeParametersMap=TypeParametersMap{nameToValue={empty.LazyTaskExecution=ReferenceType{org.gradle.model.internal.registry.DefaultModelRegistry.ModelGoal, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Lists}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Cannot solve method call LOGGER.debug("Project {} - Transitioning model element '{}' from state {} to {}", projectPath, path, state.name(), desired.name()) java.lang.RuntimeException: Method 'name' cannot be resolved in context state.name() (line: 424) MethodCallExprContext{wrapped=state.name()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Method 'getAction' cannot be resolved in context boundMutator.getAction() (line: 443) MethodCallExprContext{wrapped=boundMutator.getAction()}. Parameter types: []
Cannot solve method call toViews(boundMutator.getInputBindings(), boundMutator.getAction().getDescriptor()) java.lang.RuntimeException: Method 'getInputBindings' cannot be resolved in context boundMutator.getInputBindings() (line: 443) MethodCallExprContext{wrapped=boundMutator.getInputBindings()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Cannot solve method call LOGGER.debug("Project {} - Mutating {} using {}", projectPath, node.getPath(), descriptor) java.lang.RuntimeException: Method 'getPath' cannot be resolved in context node.getPath() (line: 449) MethodCallExprContext{wrapped=node.getPath()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Method 'getPredicate' cannot be resolved in context binding.getPredicate() (line: 470) MethodCallExprContext{wrapped=binding.getPredicate()}. Parameter types: []
Cannot solve method call element.asImmutable(binding.getPredicate().getType(), descriptor) java.lang.RuntimeException: Method 'getPredicate' cannot be resolved in context binding.getPredicate() (line: 470) MethodCallExprContext{wrapped=binding.getPredicate()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Cannot solve method call subjectReference.atState(role.getTargetState()) java.lang.RuntimeException: Method 'getTargetState' cannot be resolved in context role.getTargetState() (line: 491) MethodCallExprContext{wrapped=role.getTargetState()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Cannot resolve field access null
Cannot solve method call input.inScope(ModelPath.ROOT) UnsolvedSymbolException{context='unknown', name='ROOT', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Cannot solve name expression Registered
Cannot solve name expression node
Cannot solve name expression goal
Cannot solve name expression Discovered
Cannot solve name expression node
Cannot solve name expression goal
Cannot solve name expression GraphClosed
Cannot solve name expression node
Cannot solve name expression goal
Cannot solve name expression node
Cannot solve name expression goal
Cannot resolve field access null
Cannot solve field access State.NotSeen
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Method 'getState' cannot be resolved in context node.getState() (line: 671) MethodCallExprContext{wrapped=node.getState()}. Parameter types: []
Cannot solve method call String.format("Cannot transition model element '%s' to state %s as it does not exist.", getPath(), getTargetState().name()) java.lang.RuntimeException: Method 'name' cannot be resolved in context getTargetState().name() (line: 686) MethodCallExprContext{wrapped=getTargetState().name()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Method 'getState' cannot be resolved in context node.getState() (line: 697) MethodCallExprContext{wrapped=node.getState()}. Parameter types: []
Cannot solve method call String.format("Cannot transition model element '%s' to state %s as it is already at state %s.", node.getPath(), getTargetState(), node.getState()) java.lang.RuntimeException: Method 'getPath' cannot be resolved in context node.getPath() (line: 698) MethodCallExprContext{wrapped=node.getPath()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Cannot solve method call LOGGER.debug("Project {} - Transitioning model element '{}' to state {}.", projectPath, node.getPath(), getTargetState().name()) java.lang.RuntimeException: Method 'getPath' cannot be resolved in context node.getPath() (line: 700) MethodCallExprContext{wrapped=node.getPath()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Method 'getNode' cannot be resolved in context subjectBinding.getNode() (line: 748) MethodCallExprContext{wrapped=subjectBinding.getNode()}. Parameter types: []
Cannot resolve field access null
Cannot solve method call targetPath.equals(input.path) UnsolvedSymbolException{context='unknown', name='path', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Method 'getPredicate' cannot be resolved in context subjectBinding.getPredicate() (line: 753) MethodCallExprContext{wrapped=subjectBinding.getPredicate()}. Parameter types: []
Cannot resolve field access null
Cannot resolve field access null
Method 'getPath' cannot be resolved in context target.getPath() (line: 779) MethodCallExprContext{wrapped=target.getPath()}. Parameter types: []
Cannot solve method call modelGraph.find(getPath().getParent()) java.lang.RuntimeException: Method 'getParent' cannot be resolved in context getPath().getParent() (line: 862) MethodCallExprContext{wrapped=getPath().getParent()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Method 'getTarget' cannot be resolved in context parent.getTarget() (line: 932) MethodCallExprContext{wrapped=parent.getTarget()}. Parameter types: []
Method 'getTarget' cannot be resolved in context parent.getTarget() (line: 932) MethodCallExprContext{wrapped=parent.getTarget()}. Parameter types: []
Cannot solve method call parentTarget.getLink(path.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context path.getName() (line: 940) MethodCallExprContext{wrapped=path.getName()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Error calculating the type of parameter parent.getDescriptor() of method call ModelRegistrations.of(path).descriptor(parent.getDescriptor())
Error calculating the type of parameter childTarget.getProjection() of method call ModelRegistrations.of(path).descriptor(parent.getDescriptor()).withProjection(childTarget.getProjection())
Cannot solve method call registerNode(childNode, ImmutableMultimap.<ModelActionRole, ModelAction>of()) UnsolvedSymbolException{context='Solving ImmutableMultimap', name='ImmutableMultimap', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Method 'getInputBindings' cannot be resolved in context ruleBinder.getInputBindings() (line: 1002) MethodCallExprContext{wrapped=ruleBinder.getInputBindings()}. Parameter types: []
Method 'getPromise' cannot be resolved in context child.getPromise() (line: 1032) MethodCallExprContext{wrapped=child.getPromise()}. Parameter types: []
Cannot solve method call maybeBind(binder.getSubjectBinding(), dependencies) java.lang.RuntimeException: Method 'getSubjectBinding' cannot be resolved in context binder.getSubjectBinding() (line: 1095) MethodCallExprContext{wrapped=binder.getSubjectBinding()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Method 'getSubjectBinding' cannot be resolved in context binder.getSubjectBinding() (line: 1125) MethodCallExprContext{wrapped=binder.getSubjectBinding()}. Parameter types: []
Method 'getNode' cannot be resolved in context binding.getNode() (line: 1141) MethodCallExprContext{wrapped=binding.getNode()}. Parameter types: []
Method 'getPredicate' cannot be resolved in context binding.getPredicate() (line: 1141) MethodCallExprContext{wrapped=binding.getPredicate()}. Parameter types: []
Method 'getDescriptor' cannot be resolved in context binder.getDescriptor() (line: 1148) MethodCallExprContext{wrapped=binder.getDescriptor()}. Parameter types: []
Cannot solve method call displayValue.add(binder.getDescriptor().toString()) java.lang.RuntimeException: Method 'getDescriptor' cannot be resolved in context binder.getDescriptor() (line: 1148) MethodCallExprContext{wrapped=binder.getDescriptor()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Cannot solve method call LOGGER.debug("Project {} - Running model element '{}' rule action {}", projectPath, getPath(), binder.getDescriptor()) java.lang.RuntimeException: Method 'getDescriptor' cannot be resolved in context binder.getDescriptor() (line: 1153) MethodCallExprContext{wrapped=binder.getDescriptor()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/DefaultModelRegistry.java
Cannot solve method call UnboundRule.descriptor(String.valueOf(binder.getDescriptor())) UnsolvedSymbolException{context='Method 'valueOf' with parameterTypes [ReferenceType{org.gradle.model.internal.core.rule.describe.ModelRuleDescriptor, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/registry/UnboundRulesProcessor.java
Cannot resolve field access null
Cannot solve field access ModelNode.State.Created
Cannot resolve field access null
Cannot solve field access ModelNode.State.Discovered
Cannot solve method call UncheckedException.throwAsUncheckedException(e.getCause()) UnsolvedSymbolException{context='unknown', name='UncheckedExecutionException', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Cannot solve method call Cast.uncheckedCast(bindings.get(new CacheKey(publicType, internalViewTypes, delegateType))) java.lang.RuntimeException: Method 'get' cannot be resolved in context bindings.get(new CacheKey(publicType, internalViewTypes, delegateType)) (line: 98) MethodCallExprContext{wrapped=bindings.get(new CacheKey(publicType, internalViewTypes, delegateType))}. Parameter types: [ReferenceType{org.gradle.model.internal.manage.binding.DefaultStructBindingsStore.CacheKey, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Cannot solve method call Modifier.isAbstract(delegateType.getConcreteClass().getModifiers()) java.lang.RuntimeException: Method 'getModifiers' cannot be resolved in context delegateType.getConcreteClass().getModifiers() (line: 107) MethodCallExprContext{wrapped=delegateType.getConcreteClass().getModifiers()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Cannot solve method call getStructSchemas(Iterables.concat(Collections.singleton(publicType), internalViewTypes)) UnsolvedSymbolException{context='Method 'concat' with parameterTypes [ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{org.gradle.model.internal.type.ModelType, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.type.ModelType.T=TypeVariable {org.gradle.model.internal.manage.binding.DefaultStructBindingsStore.extract(org.gradle.model.internal.type.ModelType<T>, Iterable<? extends org.gradle.model.internal.type.ModelType<?>>, org.gradle.model.internal.type.ModelType<D>).T}}}}}}}, ReferenceType{Iterable, typeParametersMap=TypeParametersMap{nameToValue={empty.BlockDoc=WildcardUsage{type=EXTENDS, boundedType=ReferenceType{org.gradle.model.internal.type.ModelType, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.type.ModelType.T=WildcardUsage{type=null, boundedType=null}}}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call Modifier.isAbstract(typeClass.getModifiers()) java.lang.RuntimeException: Method 'getModifiers' cannot be resolved in context typeClass.getModifiers() (line: 154) MethodCallExprContext{wrapped=typeClass.getModifiers()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Method 'getTypeParameters' cannot be resolved in context typeClass.getTypeParameters() (line: 158) MethodCallExprContext{wrapped=typeClass.getTypeParameters()}. Parameter types: []
Cannot solve method call Arrays.sort(methods, Ordering.usingToString()) UnsolvedSymbolException{context='Method 'usingToString' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Ordering}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Cannot resolve field access null
Cannot solve method call Arrays.asList(typeClass.getDeclaredFields()) java.lang.RuntimeException: Method 'getDeclaredFields' cannot be resolved in context typeClass.getDeclaredFields() (line: 190) MethodCallExprContext{wrapped=typeClass.getDeclaredFields()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Cannot solve method call hasSetter(accessorBindings.keySet()) java.lang.RuntimeException: Method 'keySet' cannot be resolved in context accessorBindings.keySet() (line: 232) MethodCallExprContext{wrapped=accessorBindings.keySet()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Cannot solve method call hasGetter(accessorBindings.keySet()) java.lang.RuntimeException: Method 'keySet' cannot be resolved in context accessorBindings.keySet() (line: 232) MethodCallExprContext{wrapped=accessorBindings.keySet()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
Method 'asMap' cannot be resolved in context accessorBindings.asMap() (line: 247) MethodCallExprContext{wrapped=accessorBindings.asMap()}. Parameter types: []
Cannot solve method call implMethods.add(((StructMethodImplementationBinding) binding).getImplementorMethod()) java.lang.RuntimeException: Method 'getImplementorMethod' cannot be resolved in context ((StructMethodImplementationBinding) binding).getImplementorMethod() (line: 266) MethodCallExprContext{wrapped=((StructMethodImplementationBinding) binding).getImplementorMethod()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Cannot solve method call String.format("it has multiple implementations for accessor method: %s", Joiner.on(", ").join(implMethods)) UnsolvedSymbolException{context='Method 'on' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=Joiner}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Cannot solve method call extractionContext.add(propertyName, String.format("it has multiple implementations for accessor method: %s", Joiner.on(", ").join(implMethods))) java.lang.RuntimeException: Error calculating the type of parameter Joiner.on(", ").join(implMethods) of method call String.format("it has multiple implementations for accessor method: %s", Joiner.on(", ").join(implMethods)) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Cannot resolve field access null
Cannot solve method call ModelType.of(Boolean.TYPE) UnsolvedSymbolException{context='unknown', name='TYPE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Method 'getDeclaredPropertyType' cannot be resolved in context ((ManagedPropertyMethodBinding) isGetterBinding).getDeclaredPropertyType() (line: 284) MethodCallExprContext{wrapped=((ManagedPropertyMethodBinding) isGetterBinding).getDeclaredPropertyType()}. Parameter types: []
Cannot solve method call String.format("it should either return 'boolean', or its name should be '%s()'", "get" + isGetterMethod.getName().substring(2)) java.lang.RuntimeException: Method 'substring' cannot be resolved in context isGetterMethod.getName().substring(2) (line: 287) MethodCallExprContext{wrapped=isGetterMethod.getName().substring(2)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Cannot solve method call extractionContext.add(isGetterMethod, String.format("it should either return 'boolean', or its name should be '%s()'", "get" + isGetterMethod.getName().substring(2))) java.lang.RuntimeException: Error calculating the type of parameter "get" + isGetterMethod.getName().substring(2) of method call String.format("it should either return 'boolean', or its name should be '%s()'", "get" + isGetterMethod.getName().substring(2)) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Cannot solve method call potentialPropertyTypes.add(propertyBinding.getDeclaredPropertyType()) java.lang.RuntimeException: Method 'getDeclaredPropertyType' cannot be resolved in context propertyBinding.getDeclaredPropertyType() (line: 296) MethodCallExprContext{wrapped=propertyBinding.getDeclaredPropertyType()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Cannot solve method call String.format("it must have a consistent type, but it's defined as %s", Joiner.on(", ").join(ModelTypes.getDisplayNames(convergingPropertyTypes))) java.lang.RuntimeException: Error calculating the type of parameter ModelTypes.getDisplayNames(convergingPropertyTypes) of method call Joiner.on(", ").join(ModelTypes.getDisplayNames(convergingPropertyTypes)) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Cannot solve method call extractionContext.add(propertyName, String.format("it must have a consistent type, but it's defined as %s", Joiner.on(", ").join(ModelTypes.getDisplayNames(convergingPropertyTypes)))) java.lang.RuntimeException: Error calculating the type of parameter Joiner.on(", ").join(ModelTypes.getDisplayNames(convergingPropertyTypes)) of method call String.format("it must have a consistent type, but it's defined as %s", Joiner.on(", ").join(ModelTypes.getDisplayNames(convergingPropertyTypes))) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Cannot solve method call extractionContext.add(setterBinding.getViewMethod(), String.format("it should take parameter with type '%s'", propertyType.getDisplayName())) java.lang.RuntimeException: Method 'getViewMethod' cannot be resolved in context setterBinding.getViewMethod() (line: 310) MethodCallExprContext{wrapped=setterBinding.getViewMethod()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Cannot solve method call viewsToImplement.add(ModelType.of(type)) java.lang.UnsupportedOperationException: com.github.javaparser.resolution.types.ResolvedWildcard /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Cannot solve method call collectImplementedMethods(extractionContext.getImplementedSchemas()) java.lang.RuntimeException: Method 'getImplementedSchemas' cannot be resolved in context extractionContext.getImplementedSchemas() (line: 338) MethodCallExprContext{wrapped=extractionContext.getImplementedSchemas()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Cannot solve method call collectPublicViewImplMethods(extractionContext.getPublicSchema()) java.lang.RuntimeException: Method 'getPublicSchema' cannot be resolved in context extractionContext.getPublicSchema() (line: 339) MethodCallExprContext{wrapped=extractionContext.getPublicSchema()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Cannot solve method call collectDelegateMethods(extractionContext.getDelegateSchema()) java.lang.RuntimeException: Method 'getDelegateSchema' cannot be resolved in context extractionContext.getDelegateSchema() (line: 340) MethodCallExprContext{wrapped=extractionContext.getDelegateSchema()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Method 'getPublicSchema' cannot be resolved in context extractionContext.getPublicSchema() (line: 352) MethodCallExprContext{wrapped=extractionContext.getPublicSchema()}. Parameter types: []
Method 'getPublicSchema' cannot be resolved in context extractionContext.getPublicSchema() (line: 352) MethodCallExprContext{wrapped=extractionContext.getPublicSchema()}. Parameter types: []
Method 'getDelegateSchema' cannot be resolved in context extractionContext.getDelegateSchema() (line: 353) MethodCallExprContext{wrapped=extractionContext.getDelegateSchema()}. Parameter types: []
Method 'getDelegateSchema' cannot be resolved in context extractionContext.getDelegateSchema() (line: 353) MethodCallExprContext{wrapped=extractionContext.getDelegateSchema()}. Parameter types: []
Cannot solve method call String.format("it is both implemented by the view '%s' and the delegate type '%s'", extractionContext.getPublicSchema().getType().getDisplayName(), extractionContext.getDelegateSchema().getType().getDisplayName()) java.lang.RuntimeException: Method 'getPublicSchema' cannot be resolved in context extractionContext.getPublicSchema() (line: 352) MethodCallExprContext{wrapped=extractionContext.getPublicSchema()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Cannot solve method call extractionContext.add(weakImplementedMethod, String.format("it is both implemented by the view '%s' and the delegate type '%s'", extractionContext.getPublicSchema().getType().getDisplayName(), extractionContext.getDelegateSchema().getType().getDisplayName())) java.lang.RuntimeException: Error calculating the type of parameter extractionContext.getPublicSchema().getType().getDisplayName() of method call String.format("it is both implemented by the view '%s' and the delegate type '%s'", extractionContext.getPublicSchema().getType().getDisplayName(), extractionContext.getDelegateSchema().getType().getDisplayName()) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Empty name expression GET_GETTER
Empty name expression IS_GETTER
Empty name expression SETTER
Cannot solve method call indexBySignature(Sets.filter(publicSchema.getAllMethods(), new Predicate<WeaklyTypeReferencingMethod<?, ?>>() {

    @Override
    public boolean apply(WeaklyTypeReferencingMethod<?, ?> weakMethod) {
        return !Modifier.isAbstract(weakMethod.getModifiers());
    }
})) UnsolvedSymbolException{context='Method 'filter' with parameterTypes [ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{org.gradle.model.internal.method.WeaklyTypeReferencingMethod, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.method.WeaklyTypeReferencingMethod.T=WildcardUsage{type=null, boundedType=null}, org.gradle.model.internal.method.WeaklyTypeReferencingMethod.R=WildcardUsage{type=null, boundedType=null}}}}}}}, ReferenceType{Predicate, typeParametersMap=TypeParametersMap{nameToValue={empty.? super ScriptBlock=ReferenceType{org.gradle.model.internal.method.WeaklyTypeReferencingMethod, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.method.WeaklyTypeReferencingMethod.T=WildcardUsage{type=null, boundedType=null}, org.gradle.model.internal.method.WeaklyTypeReferencingMethod.R=WildcardUsage{type=null, boundedType=null}}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Sets}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Cannot solve method call implementedMethodsBuilder.put(DESCRIPTOR_EQUIVALENCE.wrap(viewMethod.getMethod()), viewMethod) java.lang.RuntimeException: Method 'wrap' cannot be resolved in context DESCRIPTOR_EQUIVALENCE.wrap(viewMethod.getMethod()) (line: 443) MethodCallExprContext{wrapped=DESCRIPTOR_EQUIVALENCE.wrap(viewMethod.getMethod())}. Parameter types: [ReferenceType{java.lang.reflect.Method, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Cannot solve method call isDeclaredAsHavingUnmanagedType(accessors.get(GET_GETTER)) java.lang.RuntimeException: Method 'get' cannot be resolved in context accessors.get(GET_GETTER) (line: 451) MethodCallExprContext{wrapped=accessors.get(GET_GETTER)}. Parameter types: [ReferenceType{org.gradle.internal.reflect.PropertyAccessorType, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Cannot solve method call isDeclaredAsHavingUnmanagedType(accessors.get(IS_GETTER)) java.lang.RuntimeException: Method 'get' cannot be resolved in context accessors.get(IS_GETTER) (line: 452) MethodCallExprContext{wrapped=accessors.get(IS_GETTER)}. Parameter types: [ReferenceType{org.gradle.internal.reflect.PropertyAccessorType, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Method 'getPublicSchema' cannot be resolved in context extractionContext.getPublicSchema() (line: 453) MethodCallExprContext{wrapped=extractionContext.getPublicSchema()}. Parameter types: []
Method 'getPublicSchema' cannot be resolved in context extractionContext.getPublicSchema() (line: 461) MethodCallExprContext{wrapped=extractionContext.getPublicSchema()}. Parameter types: []
Method 'getPublicSchema' cannot be resolved in context extractionContext.getPublicSchema() (line: 461) MethodCallExprContext{wrapped=extractionContext.getPublicSchema()}. Parameter types: []
Cannot solve method call Named.class.isAssignableFrom(extractionContext.getPublicSchema().getType().getRawClass()) java.lang.RuntimeException: Method 'getPublicSchema' cannot be resolved in context extractionContext.getPublicSchema() (line: 461) MethodCallExprContext{wrapped=extractionContext.getPublicSchema()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Cannot solve method call extractionContext.add(propertyName, String.format("it must not have a setter, because the type implements '%s'", Named.class.getName())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Cannot solve method call extractionContext.add(propertyName, String.format("it is marked as @Unmanaged, but is of @Managed type '%s'; please remove the @Managed annotation", propertyType.getDisplayName())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Cannot solve method call String.format("it cannot have a setter (%s properties must be read only)", propertyType.getRawClass().getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context propertyType.getRawClass().getSimpleName() (line: 488) MethodCallExprContext{wrapped=propertyType.getRawClass().getSimpleName()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Cannot solve method call extractionContext.add(propertyName, String.format("it cannot have a setter (%s properties must be read only)", propertyType.getRawClass().getSimpleName())) java.lang.RuntimeException: Error calculating the type of parameter propertyType.getRawClass().getSimpleName() of method call String.format("it cannot have a setter (%s properties must be read only)", propertyType.getRawClass().getSimpleName()) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindingsStore.java
Method 'getViewMethod' cannot be resolved in context accessorBinding.getViewMethod() (line: 496) MethodCallExprContext{wrapped=accessorBinding.getViewMethod()}. Parameter types: []
Method 'getViewMethod' cannot be resolved in context accessorBinding.getViewMethod() (line: 496) MethodCallExprContext{wrapped=accessorBinding.getViewMethod()}. Parameter types: []
Cannot solve method call ImmutableSortedMap.copyOf(managedProperties, Ordering.natural()) UnsolvedSymbolException{context='Method 'natural' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Ordering}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/binding/DefaultStructBindings.java
Cannot solve method call Cast.uncheckedCast(generatedImplementationTypes.get(new CacheKey(GeneratedViewState.class, viewSchema, bindings))) java.lang.RuntimeException: Method 'get' cannot be resolved in context generatedImplementationTypes.get(new CacheKey(GeneratedViewState.class, viewSchema, bindings)) (line: 50) MethodCallExprContext{wrapped=generatedImplementationTypes.get(new CacheKey(GeneratedViewState.class, viewSchema, bindings))}. Parameter types: [ReferenceType{org.gradle.model.internal.manage.instance.ManagedProxyFactory.CacheKey, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/instance/ManagedProxyFactory.java
Cannot solve method call Cast.uncheckedCast(generatedImplementationTypes.get(new CacheKey(ModelElementState.class, viewSchema, bindings))) java.lang.RuntimeException: Method 'get' cannot be resolved in context generatedImplementationTypes.get(new CacheKey(ModelElementState.class, viewSchema, bindings)) (line: 65) MethodCallExprContext{wrapped=generatedImplementationTypes.get(new CacheKey(ModelElementState.class, viewSchema, bindings))}. Parameter types: [ReferenceType{org.gradle.model.internal.manage.instance.ManagedProxyFactory.CacheKey, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/instance/ManagedProxyFactory.java
Cannot solve method call ClosureBackedAction.execute(get(name), action) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/projection/ManagedModelProjection.java
Cannot solve method call Lists.newArrayList(Iterables.transform(classes, TO_WEAK_REF)) UnsolvedSymbolException{context='Method 'transform' with parameterTypes [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=null, boundedType=null}}}}}}}, ReferenceType{Function, typeParametersMap=TypeParametersMap{nameToValue={empty.Equivalence.Wrapper<Method>=ReferenceType{java.lang.ref.WeakReference, typeParametersMap=TypeParametersMap{nameToValue={java.lang.ref.WeakReference.T=ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=null, boundedType=null}}}}}}}, empty.Method=ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=null, boundedType=null}}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/cache/MultiWeakClassSet.java
Cannot solve method call Iterables.elementsEqual(Iterables.transform(other.references, UNPACK_REF), Iterables.transform(references, UNPACK_REF)) UnsolvedSymbolException{context='Method 'transform' with parameterTypes [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.lang.ref.WeakReference, typeParametersMap=TypeParametersMap{nameToValue={java.lang.ref.WeakReference.T=ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=null, boundedType=null}}}}}}}}}}, ReferenceType{Function, typeParametersMap=TypeParametersMap{nameToValue={empty.Equivalence.Wrapper<Method>=ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}, empty.Method=ReferenceType{java.lang.ref.WeakReference, typeParametersMap=TypeParametersMap{nameToValue={java.lang.ref.WeakReference.T=ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=null, boundedType=null}}}}}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/cache/MultiWeakClassSet.java
Cannot solve method call hasSetter(accessors.keySet()) java.lang.RuntimeException: Method 'keySet' cannot be resolved in context accessors.keySet() (line: 71) MethodCallExprContext{wrapped=accessors.keySet()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/ModelProperty.java
Cannot solve field access PropertyAccessorType.GET_GETTER
Cannot solve field access PropertyAccessorType.IS_GETTER
Cannot solve field access PropertyAccessorType.GET_GETTER
Cannot solve field access PropertyAccessorType.IS_GETTER
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
Cannot solve method call Predicates.not(Predicates.in(excludes)) UnsolvedSymbolException{context='Method 'in' with parameterTypes [ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=ReferenceType{Wrapper, typeParametersMap=TypeParametersMap{nameToValue={empty.Method=ReferenceType{java.lang.reflect.Method, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.base.Predicates}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/CandidateMethods.java
Cannot solve method call Maps.filterKeys(overloadedMethodsNamed(methodName), Predicates.not(Predicates.in(excludes))) java.lang.RuntimeException: Error calculating the type of parameter Predicates.in(excludes) of method call Predicates.not(Predicates.in(excludes)) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/CandidateMethods.java
Cannot solve method call getNodeInitializer(Cast.<ModelSchema<? extends T>>uncheckedCast(schema)) UnsolvedSymbolException{context='Method 'uncheckedCast' with parameterTypes [ReferenceType{org.gradle.model.internal.manage.schema.ModelSchema, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.manage.schema.ModelSchema.T=TypeVariable {org.gradle.model.internal.manage.schema.extract.FactoryBasedStructNodeInitializerExtractionStrategy.extractNodeInitializer(org.gradle.model.internal.manage.schema.ModelSchema<S>, org.gradle.model.internal.core.NodeInitializerContext<S>).S}}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class Cast {

    /**
     * Casts the given object to the given type, providing a better error message than the default.
     *
     * The standard {@link Class#cast(Object)} method produces unsatisfactory error messages on some platforms
     * when it fails. All this method does is provide a better, consistent, error message.
     *
     * This should be used whenever there is a chance the cast could fail. If in doubt, use this.
     *
     * @param outputType The type to cast the input to
     * @param object The object to be cast
     * @param <O> The type to be cast to
     * @param <I> The type of the object to be vast
     * @return The input object, cast to the output type
     */
    public static <O, I> O cast(Class<O> outputType, I object) {
        try {
            return outputType.cast(object);
        } catch (ClassCastException e) {
            throw new ClassCastException(String.format("Failed to cast object %s of type %s to target type %s", object, object.getClass().getName(), outputType.getName()));
        }
    }

    @SuppressWarnings("unchecked")
    public static <T> T uncheckedCast(Object object) {
        return (T) object;
    }
}}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/FactoryBasedStructNodeInitializerExtractionStrategy.java
Cannot resolve field access null
Cannot solve method call Type.getMethodDescriptor(Type.VOID_TYPE, STRING_TYPE, OBJECT_TYPE) UnsolvedSymbolException{context='unknown', name='VOID_TYPE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call Type.getMethodDescriptor(Type.VOID_TYPE, STRING_TYPE, CLOSURE_TYPE) UnsolvedSymbolException{context='unknown', name='VOID_TYPE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call Type.getMethodDescriptor(Type.getType(MutableModelNode.class)) UnsolvedSymbolException{context='Method 'getType' with parameterTypes [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.model.internal.core.MutableModelNode, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=org.objectweb.asm.Type}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call Type.getMethodDescriptor(Type.getType(int.class)) UnsolvedSymbolException{context='Method 'getType' with parameterTypes [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=PrimitiveTypeUsage{name='int'}}}}]', name='ReflectionClassDeclaration{clazz=org.objectweb.asm.Type}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call Type.getMethodDescriptor(Type.getType(boolean.class), OBJECT_TYPE) UnsolvedSymbolException{context='Method 'getType' with parameterTypes [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=PrimitiveTypeUsage{name='boolean'}}}}]', name='ReflectionClassDeclaration{clazz=org.objectweb.asm.Type}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call Type.getMethodDescriptor(Type.VOID_TYPE, STRING_TYPE, CLASS_TYPE) UnsolvedSymbolException{context='unknown', name='VOID_TYPE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call Type.getMethodDescriptor(Type.VOID_TYPE, STRING_TYPE, CLASS_TYPE, Type.getType(Object[].class)) UnsolvedSymbolException{context='unknown', name='VOID_TYPE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call Type.getMethodDescriptor(Type.VOID_TYPE, OBJECT_TYPE) UnsolvedSymbolException{context='unknown', name='VOID_TYPE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call Type.getMethodDescriptor(OBJECT_TYPE, OBJECT_TYPE, CLASS_TYPE, Type.getType(boolean.class)) UnsolvedSymbolException{context='Method 'getType' with parameterTypes [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=PrimitiveTypeUsage{name='boolean'}}}}]', name='ReflectionClassDeclaration{clazz=org.objectweb.asm.Type}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot resolve field access null
Method 'append' cannot be resolved in context generatedTypeNameBuilder.append("$") (line: 169) MethodCallExprContext{wrapped=generatedTypeNameBuilder.append("$")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call Type.getType("L" + generatedTypeName.replaceAll("\\.", "/") + ";") java.lang.RuntimeException: Method 'replaceAll' cannot be resolved in context generatedTypeName.replaceAll("\\.", "/") (line: 173) MethodCallExprContext{wrapped=generatedTypeName.replaceAll("\\.", "/")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call generateProxyClass(visitor, viewSchema, structBindings, interfacesToImplement.build(), typesToDelegate.build(), generatedType, Type.getType(superclass), backingStateType) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Method 'getClassLoader' cannot be resolved in context viewClass.getClassLoader() (line: 211) MethodCallExprContext{wrapped=viewClass.getClassLoader()}. Parameter types: []
Cannot solve method call writeConstructor(visitor, generatedType, superclassType, delegateSchema, Type.getType(backingStateType)) UnsolvedSymbolException{context='Method 'getType' with parameterTypes [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=EXTENDS, boundedType=ReferenceType{org.gradle.model.internal.manage.instance.GeneratedViewState, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}]', name='ReflectionClassDeclaration{clazz=org.objectweb.asm.Type}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call visitor.visit(V1_6, ACC_PUBLIC, generatedType.getInternalName(), null, superclassType.getInternalName(), Iterables.toArray(interfaceInternalNames, String.class)) UnsolvedSymbolException{context='Solving V1_6', name='V1_6', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call declareField(visitor, CAN_CALL_SETTERS_FIELD_NAME, Boolean.TYPE) UnsolvedSymbolException{context='unknown', name='TYPE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call visitor.visitField(ACC_PRIVATE | ACC_FINAL | ACC_SYNTHETIC, name, Type.getDescriptor(fieldClass), null, null) UnsolvedSymbolException{context='Solving ACC_PRIVATE', name='ACC_PRIVATE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call visitor.visitField(ACC_PRIVATE | ACC_FINAL | ACC_STATIC | ACC_SYNTHETIC, name, Type.getDescriptor(fieldClass), null, null) UnsolvedSymbolException{context='Solving ACC_PRIVATE', name='ACC_PRIVATE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call Type.getMethodDescriptor(Type.VOID_TYPE, backingStateType, TYPE_CONVERTER_TYPE, delegateType) UnsolvedSymbolException{context='unknown', name='VOID_TYPE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call Type.getMethodDescriptor(Type.VOID_TYPE, backingStateType, TYPE_CONVERTER_TYPE) UnsolvedSymbolException{context='unknown', name='VOID_TYPE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call declareMethod(visitor, CONSTRUCTOR_NAME, constructorDescriptor, CONCRETE_SIGNATURE) UnsolvedSymbolException{context='Solving CONSTRUCTOR_NAME', name='CONSTRUCTOR_NAME', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call declareMethod(visitor, STATIC_CONSTRUCTOR_NAME, "()V", CONCRETE_SIGNATURE, ACC_STATIC) UnsolvedSymbolException{context='Solving STATIC_CONSTRUCTOR_NAME', name='STATIC_CONSTRUCTOR_NAME', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call constructorVisitor.visitLdcInsn(Type.getType(managedTypeClass)) UnsolvedSymbolException{context='Method 'getType' with parameterTypes [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=null, boundedType=null}}}}]', name='ReflectionClassDeclaration{clazz=org.objectweb.asm.Type}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call constructorVisitor.visitMethodInsn(INVOKESTATIC, MODEL_TYPE_INTERNAL_NAME, "of", MODEL_TYPE_OF_METHOD_DESCRIPTOR, false) UnsolvedSymbolException{context='Solving INVOKESTATIC', name='INVOKESTATIC', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call constructorVisitor.visitFieldInsn(PUTSTATIC, generatedType.getInternalName(), MANAGED_TYPE_FIELD_NAME, Type.getDescriptor(ModelType.class)) UnsolvedSymbolException{context='Solving PUTSTATIC', name='PUTSTATIC', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call Type.getMethodDescriptor(Type.VOID_TYPE) UnsolvedSymbolException{context='unknown', name='VOID_TYPE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call constructorVisitor.visitMethodInsn(INVOKESPECIAL, superclassType.getInternalName(), CONSTRUCTOR_NAME, Type.getMethodDescriptor(Type.VOID_TYPE), false) UnsolvedSymbolException{context='Solving INVOKESPECIAL', name='INVOKESPECIAL', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call writeDelegatingToString(visitor, generatedType, Type.getType(delegateSchema.getType().getConcreteClass())) UnsolvedSymbolException{context='Method 'getType' with parameterTypes [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=null, boundedType=null}}}}]', name='ReflectionClassDeclaration{clazz=org.objectweb.asm.Type}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call declareMethod(visitor, "toString", TO_STRING_METHOD_DESCRIPTOR, CONCRETE_SIGNATURE) UnsolvedSymbolException{context='Solving CONCRETE_SIGNATURE', name='CONCRETE_SIGNATURE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitMethodInsn(INVOKEVIRTUAL, delegateType.getInternalName(), "getDisplayName", TO_STRING_METHOD_DESCRIPTOR, false) UnsolvedSymbolException{context='Solving INVOKEVIRTUAL', name='INVOKEVIRTUAL', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call finishVisitingMethod(methodVisitor, ARETURN) UnsolvedSymbolException{context='Solving ARETURN', name='ARETURN', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call declareMethod(visitor, "toString", TO_STRING_METHOD_DESCRIPTOR, CONCRETE_SIGNATURE) UnsolvedSymbolException{context='Solving CONCRETE_SIGNATURE', name='CONCRETE_SIGNATURE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitMethodInsn(INVOKEINTERFACE, GENERATED_VIEW_STATE_TYPE_NAME, "getDisplayName", TO_STRING_METHOD_DESCRIPTOR, true) UnsolvedSymbolException{context='Solving INVOKEINTERFACE', name='INVOKEINTERFACE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call finishVisitingMethod(methodVisitor, ARETURN) UnsolvedSymbolException{context='Solving ARETURN', name='ARETURN', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call declareMethod(visitor, "propertyMissing", GET_PROPERTY_MISSING_METHOD_DESCRIPTOR, CONCRETE_SIGNATURE) UnsolvedSymbolException{context='Solving CONCRETE_SIGNATURE', name='CONCRETE_SIGNATURE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitTypeInsn(NEW, MISSING_PROPERTY_EXCEPTION_TYPE) UnsolvedSymbolException{context='Solving NEW', name='NEW', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitInsn(DUP) UnsolvedSymbolException{context='Solving DUP', name='DUP', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitMethodInsn(INVOKESPECIAL, MISSING_PROPERTY_EXCEPTION_TYPE, "<init>", MISSING_PROPERTY_CONSTRUCTOR_DESCRIPTOR, false) UnsolvedSymbolException{context='Solving INVOKESPECIAL', name='INVOKESPECIAL', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call finishVisitingMethod(methodVisitor, ATHROW) UnsolvedSymbolException{context='Solving ATHROW', name='ATHROW', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call declareMethod(visitor, "propertyMissing", SET_PROPERTY_MISSING_METHOD_DESCRIPTOR, CONCRETE_SIGNATURE) UnsolvedSymbolException{context='Solving CONCRETE_SIGNATURE', name='CONCRETE_SIGNATURE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitTypeInsn(NEW, MISSING_PROPERTY_EXCEPTION_TYPE) UnsolvedSymbolException{context='Solving NEW', name='NEW', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitInsn(DUP) UnsolvedSymbolException{context='Solving DUP', name='DUP', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitMethodInsn(INVOKESPECIAL, MISSING_PROPERTY_EXCEPTION_TYPE, "<init>", MISSING_PROPERTY_CONSTRUCTOR_DESCRIPTOR, false) UnsolvedSymbolException{context='Solving INVOKESPECIAL', name='INVOKESPECIAL', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call finishVisitingMethod(methodVisitor, ATHROW) UnsolvedSymbolException{context='Solving ATHROW', name='ATHROW', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call declareMethod(visitor, "methodMissing", METHOD_MISSING_METHOD_DESCRIPTOR, CONCRETE_SIGNATURE) UnsolvedSymbolException{context='Solving CONCRETE_SIGNATURE', name='CONCRETE_SIGNATURE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitTypeInsn(NEW, MISSING_METHOD_EXCEPTION_TYPE) UnsolvedSymbolException{context='Solving NEW', name='NEW', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitInsn(DUP) UnsolvedSymbolException{context='Solving DUP', name='DUP', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitTypeInsn(CHECKCAST, OBJECT_ARRAY_TYPE) UnsolvedSymbolException{context='Solving CHECKCAST', name='CHECKCAST', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitMethodInsn(INVOKESPECIAL, MISSING_METHOD_EXCEPTION_TYPE, "<init>", MISSING_METHOD_EXCEPTION_CONSTRUCTOR_DESCRIPTOR, false) UnsolvedSymbolException{context='Solving INVOKESPECIAL', name='INVOKESPECIAL', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call finishVisitingMethod(methodVisitor, ATHROW) UnsolvedSymbolException{context='Solving ATHROW', name='ATHROW', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call putConstantOnStack(methodVisitor, managedTypeClass.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context managedTypeClass.getName() (line: 389) MethodCallExprContext{wrapped=managedTypeClass.getName()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitMethodInsn(INVOKESTATIC, CLASS_INTERNAL_NAME, "forName", FOR_NAME_METHOD_DESCRIPTOR, false) UnsolvedSymbolException{context='Solving INVOKESTATIC', name='INVOKESTATIC', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call declareMethod(visitor, "__view_state__", GET_VIEW_STATE_METHOD_DESCRIPTOR, CONCRETE_SIGNATURE, ACC_PUBLIC | ACC_SYNTHETIC) UnsolvedSymbolException{context='Solving CONCRETE_SIGNATURE', name='CONCRETE_SIGNATURE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call finishVisitingMethod(methodVisitor, ARETURN) UnsolvedSymbolException{context='Solving ARETURN', name='ARETURN', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call declareMethod(visitor, "getBackingNode", GET_BACKING_NODE_METHOD_DESCRIPTOR, CONCRETE_SIGNATURE, ACC_PUBLIC | ACC_SYNTHETIC) UnsolvedSymbolException{context='Solving CONCRETE_SIGNATURE', name='CONCRETE_SIGNATURE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitMethodInsn(INVOKEINTERFACE, MODEL_ELEMENT_STATE_TYPE_INTERNAL_NAME, "getBackingNode", GET_BACKING_NODE_METHOD_DESCRIPTOR, true) UnsolvedSymbolException{context='Solving INVOKEINTERFACE', name='INVOKEINTERFACE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call finishVisitingMethod(methodVisitor, ARETURN) UnsolvedSymbolException{context='Solving ARETURN', name='ARETURN', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call declareMethod(visitor, "getManagedType", GET_MANAGED_TYPE_METHOD_DESCRIPTOR, CONCRETE_SIGNATURE, ACC_PUBLIC | ACC_SYNTHETIC) UnsolvedSymbolException{context='Solving CONCRETE_SIGNATURE', name='CONCRETE_SIGNATURE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call finishVisitingMethod(managedTypeVisitor, ARETURN) UnsolvedSymbolException{context='Solving ARETURN', name='ARETURN', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call constructorVisitor.visitFieldInsn(PUTFIELD, generatedType.getInternalName(), STATE_FIELD_NAME, GENERATED_VIEW_STATE_TYPE.getDescriptor()) UnsolvedSymbolException{context='Solving PUTFIELD', name='PUTFIELD', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call constructorVisitor.visitFieldInsn(PUTFIELD, generatedType.getInternalName(), TYPE_CONVERTER_FIELD_NAME, TYPE_CONVERTER_TYPE.getDescriptor()) UnsolvedSymbolException{context='Solving PUTFIELD', name='PUTFIELD', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call constructorVisitor.visitFieldInsn(PUTFIELD, generatedType.getInternalName(), DELEGATE_FIELD_NAME, delegateType.getDescriptor()) UnsolvedSymbolException{context='Solving PUTFIELD', name='PUTFIELD', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitFieldInsn(PUTFIELD, generatedType.getInternalName(), CAN_CALL_SETTERS_FIELD_NAME, Type.BOOLEAN_TYPE.getDescriptor()) UnsolvedSymbolException{context='Solving PUTFIELD', name='PUTFIELD', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call viewMethods.add(SIGNATURE_EQUIVALENCE.wrap(viewMethod.getMethod())) java.lang.RuntimeException: Method 'wrap' cannot be resolved in context SIGNATURE_EQUIVALENCE.wrap(viewMethod.getMethod()) (line: 462) MethodCallExprContext{wrapped=SIGNATURE_EQUIVALENCE.wrap(viewMethod.getMethod())}. Parameter types: [ReferenceType{java.lang.reflect.Method, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Method 'asMap' cannot be resolved in context viewPropertiesByNameBuilder.asMap() (line: 470) MethodCallExprContext{wrapped=viewPropertiesByNameBuilder.asMap()}. Parameter types: []
Empty name expression GET_GETTER
Empty name expression IS_GETTER
Empty name expression SETTER
Cannot solve method call declareMethod(visitor, setterName, SET_OBJECT_PROPERTY_DESCRIPTOR, null, ACC_PUBLIC | ACC_SYNTHETIC) UnsolvedSymbolException{context='Solving ACC_PUBLIC', name='ACC_PUBLIC', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitTypeInsn(NEW, READ_ONLY_PROPERTY_EXCEPTION_TYPE) UnsolvedSymbolException{context='Solving NEW', name='NEW', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitInsn(DUP) UnsolvedSymbolException{context='Solving DUP', name='DUP', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitMethodInsn(INVOKESPECIAL, READ_ONLY_PROPERTY_EXCEPTION_TYPE, "<init>", MISSING_PROPERTY_CONSTRUCTOR_DESCRIPTOR, false) UnsolvedSymbolException{context='Solving INVOKESPECIAL', name='INVOKESPECIAL', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call finishVisitingMethod(methodVisitor, ATHROW) UnsolvedSymbolException{context='Solving ATHROW', name='ATHROW', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call Type.getMethodDescriptor(Type.VOID_TYPE, OBJECT_TYPE) UnsolvedSymbolException{context='unknown', name='VOID_TYPE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call declareMethod(visitor, property.getName(), Type.getMethodDescriptor(Type.VOID_TYPE, OBJECT_TYPE), null) java.lang.RuntimeException: Error calculating the type of parameter Type.VOID_TYPE of method call Type.getMethodDescriptor(Type.VOID_TYPE, OBJECT_TYPE) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call Type.getMethodDescriptor(Type.VOID_TYPE, OBJECT_TYPE) UnsolvedSymbolException{context='unknown', name='VOID_TYPE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitMethodInsn(INVOKEVIRTUAL, generatedType.getInternalName(), setter.getName(), Type.getMethodDescriptor(Type.VOID_TYPE, OBJECT_TYPE), false) UnsolvedSymbolException{context='Solving INVOKEVIRTUAL', name='INVOKEVIRTUAL', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call Type.getMethodDescriptor(Type.VOID_TYPE, CLOSURE_TYPE) UnsolvedSymbolException{context='unknown', name='VOID_TYPE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call declareMethod(visitor, property.getName(), Type.getMethodDescriptor(Type.VOID_TYPE, CLOSURE_TYPE), null) java.lang.RuntimeException: Error calculating the type of parameter Type.VOID_TYPE of method call Type.getMethodDescriptor(Type.VOID_TYPE, CLOSURE_TYPE) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitMethodInsn(INVOKEINTERFACE, MODEL_ELEMENT_STATE_TYPE_INTERNAL_NAME, "apply", STATE_APPLY_METHOD_DESCRIPTOR, true) UnsolvedSymbolException{context='Solving INVOKEINTERFACE', name='INVOKEINTERFACE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call Type.getMethodDescriptor(Type.VOID_TYPE, CLOSURE_TYPE) UnsolvedSymbolException{context='unknown', name='VOID_TYPE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call declareMethod(visitor, property.getName(), Type.getMethodDescriptor(Type.VOID_TYPE, CLOSURE_TYPE), null) java.lang.RuntimeException: Error calculating the type of parameter Type.VOID_TYPE of method call Type.getMethodDescriptor(Type.VOID_TYPE, CLOSURE_TYPE) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call Type.getMethodDescriptor(Type.getType(property.getType().getConcreteClass())) UnsolvedSymbolException{context='Method 'getType' with parameterTypes [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=null, boundedType=null}}}}]', name='ReflectionClassDeclaration{clazz=org.objectweb.asm.Type}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitMethodInsn(INVOKEVIRTUAL, generatedType.getInternalName(), property.getGetter().getName(), Type.getMethodDescriptor(Type.getType(property.getType().getConcreteClass())), false) UnsolvedSymbolException{context='Solving INVOKEVIRTUAL', name='INVOKEVIRTUAL', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call Type.getMethodDescriptor(Type.VOID_TYPE, OBJECT_TYPE, CLOSURE_TYPE) UnsolvedSymbolException{context='unknown', name='VOID_TYPE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitMethodInsn(INVOKESTATIC, Type.getInternalName(ClosureBackedAction.class), "execute", Type.getMethodDescriptor(Type.VOID_TYPE, OBJECT_TYPE, CLOSURE_TYPE), false) UnsolvedSymbolException{context='Solving INVOKESTATIC', name='INVOKESTATIC', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call Type.getMethodDescriptor(Type.VOID_TYPE, CLOSURE_TYPE) UnsolvedSymbolException{context='unknown', name='VOID_TYPE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call declareMethod(visitor, property.getName(), Type.getMethodDescriptor(Type.VOID_TYPE, CLOSURE_TYPE), null) java.lang.RuntimeException: Error calculating the type of parameter Type.VOID_TYPE of method call Type.getMethodDescriptor(Type.VOID_TYPE, CLOSURE_TYPE) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitInsn(Opcodes.ICONST_1) UnsolvedSymbolException{context='unknown', name='ICONST_1', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, OBJECT_TYPE.getInternalName()) UnsolvedSymbolException{context='unknown', name='ANEWARRAY', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitInsn(Opcodes.DUP) UnsolvedSymbolException{context='unknown', name='DUP', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitInsn(Opcodes.ICONST_0) UnsolvedSymbolException{context='unknown', name='ICONST_0', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitInsn(Opcodes.AASTORE) UnsolvedSymbolException{context='unknown', name='AASTORE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitMethodInsn(INVOKEVIRTUAL, generatedType.getInternalName(), "methodMissing", METHOD_MISSING_METHOD_DESCRIPTOR, false) UnsolvedSymbolException{context='Solving INVOKEVIRTUAL', name='INVOKEVIRTUAL', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call Type.getMethodDescriptor(Type.VOID_TYPE, propertyType) UnsolvedSymbolException{context='unknown', name='VOID_TYPE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitVarInsn(ALOAD, 1) UnsolvedSymbolException{context='Solving ALOAD', name='ALOAD', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitInsn(propertyClass.isPrimitive() ? ICONST_1 : ICONST_0) UnsolvedSymbolException{context='Solving ICONST_1', name='ICONST_1', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitMethodInsn(INVOKEINTERFACE, TYPE_CONVERTER_TYPE.getInternalName(), "convert", COERCE_TO_SCALAR_DESCRIPTOR, true) UnsolvedSymbolException{context='Solving INVOKEINTERFACE', name='INVOKEINTERFACE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitTypeInsn(CHECKCAST, boxedType.getInternalName()) UnsolvedSymbolException{context='Solving CHECKCAST', name='CHECKCAST', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call Type.getMethodDescriptor(Type.VOID_TYPE, propertyType) UnsolvedSymbolException{context='unknown', name='VOID_TYPE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitMethodInsn(INVOKEVIRTUAL, generatedType.getInternalName(), setter.getName(), Type.getMethodDescriptor(Type.VOID_TYPE, propertyType), false) UnsolvedSymbolException{context='Solving INVOKEVIRTUAL', name='INVOKEVIRTUAL', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitInsn(RETURN) UnsolvedSymbolException{context='Solving RETURN', name='RETURN', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitTryCatchBlock(startTry, endTry, startCatch, TYPE_CONVERSION_EXCEPTION_TYPE.getInternalName()) java.lang.RuntimeException: Method 'getInternalName' cannot be resolved in context TYPE_CONVERSION_EXCEPTION_TYPE.getInternalName() (line: 679) MethodCallExprContext{wrapped=TYPE_CONVERSION_EXCEPTION_TYPE.getInternalName()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitVarInsn(ASTORE, 2) UnsolvedSymbolException{context='Solving ASTORE', name='ASTORE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitVarInsn(ALOAD, 2) UnsolvedSymbolException{context='Solving ALOAD', name='ALOAD', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call Type.getMethodDescriptor(Type.VOID_TYPE, CLASS_TYPE, STRING_TYPE, OBJECT_TYPE, TYPE_CONVERSION_EXCEPTION_TYPE) UnsolvedSymbolException{context='unknown', name='VOID_TYPE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitMethodInsn(INVOKESTATIC, Type.getInternalName(ManagedProxyClassGenerator.class), "propertyValueConvertFailure", Type.getMethodDescriptor(Type.VOID_TYPE, CLASS_TYPE, STRING_TYPE, OBJECT_TYPE, TYPE_CONVERSION_EXCEPTION_TYPE), false) UnsolvedSymbolException{context='Solving INVOKESTATIC', name='INVOKESTATIC', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitMethodInsn(INVOKEINTERFACE, GENERATED_VIEW_STATE_TYPE_NAME, "hashCode", HASH_CODE_METHOD_DESCRIPTOR, true) UnsolvedSymbolException{context='Solving INVOKEINTERFACE', name='INVOKEINTERFACE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call finishVisitingMethod(methodVisitor, Opcodes.IRETURN) UnsolvedSymbolException{context='unknown', name='IRETURN', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call cw.visitMethod(Opcodes.ACC_PUBLIC, "equals", EQUALS_METHOD_DESCRIPTOR, null, null) UnsolvedSymbolException{context='unknown', name='ACC_PUBLIC', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitVarInsn(ALOAD, 0) UnsolvedSymbolException{context='Solving ALOAD', name='ALOAD', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitVarInsn(ALOAD, 1) UnsolvedSymbolException{context='Solving ALOAD', name='ALOAD', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitJumpInsn(IF_ACMPNE, notSameLabel) UnsolvedSymbolException{context='Solving IF_ACMPNE', name='IF_ACMPNE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitInsn(ICONST_1) UnsolvedSymbolException{context='Solving ICONST_1', name='ICONST_1', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitInsn(IRETURN) UnsolvedSymbolException{context='Solving IRETURN', name='IRETURN', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitVarInsn(ALOAD, 1) UnsolvedSymbolException{context='Solving ALOAD', name='ALOAD', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitTypeInsn(INSTANCEOF, GENERATED_VIEW_TYPE.getInternalName()) UnsolvedSymbolException{context='Solving INSTANCEOF', name='INSTANCEOF', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitJumpInsn(IFNE, generatedViewLabel) UnsolvedSymbolException{context='Solving IFNE', name='IFNE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitInsn(ICONST_0) UnsolvedSymbolException{context='Solving ICONST_0', name='ICONST_0', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitInsn(IRETURN) UnsolvedSymbolException{context='Solving IRETURN', name='IRETURN', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitVarInsn(ALOAD, 1) UnsolvedSymbolException{context='Solving ALOAD', name='ALOAD', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitTypeInsn(CHECKCAST, GENERATED_VIEW_TYPE.getInternalName()) UnsolvedSymbolException{context='Solving CHECKCAST', name='CHECKCAST', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitMethodInsn(INVOKEINTERFACE, GENERATED_VIEW_TYPE.getInternalName(), "__view_state__", GET_VIEW_STATE_METHOD_DESCRIPTOR, true) UnsolvedSymbolException{context='Solving INVOKEINTERFACE', name='INVOKEINTERFACE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitMethodInsn(INVOKEINTERFACE, GENERATED_VIEW_STATE_TYPE_NAME, "equals", EQUALS_METHOD_DESCRIPTOR, true) UnsolvedSymbolException{context='Solving INVOKEINTERFACE', name='INVOKEINTERFACE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call finishVisitingMethod(methodVisitor, Opcodes.IRETURN) UnsolvedSymbolException{context='unknown', name='IRETURN', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitTypeInsn(NEW, exceptionInternalName) UnsolvedSymbolException{context='Solving NEW', name='NEW', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitInsn(DUP) UnsolvedSymbolException{context='Solving DUP', name='DUP', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call Type.getMethodDescriptor(Type.VOID_TYPE, STRING_TYPE) UnsolvedSymbolException{context='unknown', name='VOID_TYPE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitMethodInsn(INVOKESPECIAL, exceptionInternalName, CONSTRUCTOR_NAME, constructorDescriptor, false) UnsolvedSymbolException{context='Solving INVOKESPECIAL', name='INVOKESPECIAL', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitInsn(ATHROW) UnsolvedSymbolException{context='Solving ATHROW', name='ATHROW', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitJumpInsn(IFNE, label) UnsolvedSymbolException{context='Solving IFNE', name='IFNE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitMethodInsn(INVOKEINTERFACE, GENERATED_VIEW_STATE_TYPE_NAME, "set", STATE_SET_METHOD_DESCRIPTOR, true) UnsolvedSymbolException{context='Solving INVOKEINTERFACE', name='INVOKEINTERFACE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call declareMethod(visitor, method.getName(), Type.getMethodDescriptor(method)) UnsolvedSymbolException{context='Method 'getMethodDescriptor' with parameterTypes [ReferenceType{java.lang.reflect.Method, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=org.objectweb.asm.Type}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call declareMethod(visitor, methodName, methodDescriptor, CONCRETE_SIGNATURE) UnsolvedSymbolException{context='Solving CONCRETE_SIGNATURE', name='CONCRETE_SIGNATURE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call declareMethod(visitor, methodName, methodDescriptor, methodSignature, ACC_PUBLIC) UnsolvedSymbolException{context='Solving ACC_PUBLIC', name='ACC_PUBLIC', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call visitor.visitMethod(access, methodName, methodDescriptor, methodSignature, NO_EXCEPTIONS) UnsolvedSymbolException{context='Solving NO_EXCEPTIONS', name='NO_EXCEPTIONS', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call argType.getOpcode(ILOAD) UnsolvedSymbolException{context='Solving ILOAD', name='ILOAD', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitVarInsn(ALOAD, 2) UnsolvedSymbolException{context='Solving ALOAD', name='ALOAD', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitVarInsn(ALOAD, 3) UnsolvedSymbolException{context='Solving ALOAD', name='ALOAD', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitVarInsn(ALOAD, index) UnsolvedSymbolException{context='Solving ALOAD', name='ALOAD', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call type.getOpcode(ILOAD) UnsolvedSymbolException{context='Solving ILOAD', name='ILOAD', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitVarInsn(type.getOpcode(ILOAD), index) java.lang.RuntimeException: Error calculating the type of parameter ILOAD of method call type.getOpcode(ILOAD) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, MODEL_ELEMENT_STATE_TYPE_INTERNAL_NAME) UnsolvedSymbolException{context='unknown', name='CHECKCAST', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call putFieldValueOnStack(methodVisitor, generatedType, CAN_CALL_SETTERS_FIELD_NAME, Type.BOOLEAN_TYPE) UnsolvedSymbolException{context='unknown', name='BOOLEAN_TYPE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitFieldInsn(GETFIELD, generatedType.getInternalName(), name, fieldType.getDescriptor()) UnsolvedSymbolException{context='Solving GETFIELD', name='GETFIELD', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitFieldInsn(GETSTATIC, generatedType.getInternalName(), name, fieldType.getDescriptor()) UnsolvedSymbolException{context='Solving GETSTATIC', name='GETSTATIC', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call declareMethod(visitor, getter.getName(), Type.getMethodDescriptor(propertyType), AsmClassGeneratorUtils.signature(getter)) UnsolvedSymbolException{context='Method 'getMethodDescriptor' with parameterTypes [ReferenceType{org.objectweb.asm.Type, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=org.objectweb.asm.Type}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call returnType.getOpcode(IRETURN) UnsolvedSymbolException{context='Solving IRETURN', name='IRETURN', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitTypeInsn(CHECKCAST, Type.getInternalName(returnType)) UnsolvedSymbolException{context='Solving CHECKCAST', name='CHECKCAST', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitMethodInsn(INVOKESTATIC, Type.getInternalName(boxedType), "valueOf", "(" + Type.getDescriptor(primitiveType) + ")" + Type.getDescriptor(boxedType), false) UnsolvedSymbolException{context='Solving INVOKESTATIC', name='INVOKESTATIC', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitTypeInsn(CHECKCAST, Type.getInternalName(boxedType)) UnsolvedSymbolException{context='Solving CHECKCAST', name='CHECKCAST', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitInsn(DUP) UnsolvedSymbolException{context='Solving DUP', name='DUP', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitJumpInsn(IFNONNULL, elseValue) UnsolvedSymbolException{context='Solving IFNONNULL', name='IFNONNULL', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitInsn(POP) UnsolvedSymbolException{context='Solving POP', name='POP', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitJumpInsn(GOTO, exit) UnsolvedSymbolException{context='Solving GOTO', name='GOTO', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(boxedType), primitiveClass.getSimpleName() + "Value", Type.getMethodDescriptor(primitiveType), false) UnsolvedSymbolException{context='Solving INVOKEVIRTUAL', name='INVOKEVIRTUAL', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitMethodInsn(INVOKEINTERFACE, GENERATED_VIEW_STATE_TYPE_NAME, "get", STATE_GET_METHOD_DESCRIPTOR, true) UnsolvedSymbolException{context='Solving INVOKEINTERFACE', name='INVOKEINTERFACE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitInsn(ARETURN) UnsolvedSymbolException{context='Solving ARETURN', name='ARETURN', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitInsn(ATHROW) UnsolvedSymbolException{context='Solving ATHROW', name='ATHROW', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call declareMethod(visitor, method.getName(), Type.getMethodDescriptor(method), AsmClassGeneratorUtils.signature(method)) UnsolvedSymbolException{context='Method 'getMethodDescriptor' with parameterTypes [ReferenceType{java.lang.reflect.Method, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=org.objectweb.asm.Type}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call returnCode(Type.getType(returnType)) UnsolvedSymbolException{context='Method 'getType' with parameterTypes [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=null, boundedType=null}}}}]', name='ReflectionClassDeclaration{clazz=org.objectweb.asm.Type}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call finishVisitingMethod(methodVisitor, returnCode(Type.getType(returnType))) java.lang.RuntimeException: Error calculating the type of parameter Type.getType(returnType) of method call returnCode(Type.getType(returnType)) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call putMethodArgumentOnStack(methodVisitor, Type.getType(parameterTypes[paramNo]), paramNo + 1) UnsolvedSymbolException{context='Method 'getType' with parameterTypes [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=null, boundedType=null}}}}]', name='ReflectionClassDeclaration{clazz=org.objectweb.asm.Type}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(INVOKEVIRTUAL, generatedType.getInternalName(), method.getName(), Type.getMethodDescriptor(method), false) UnsolvedSymbolException{context='Solving INVOKEVIRTUAL', name='INVOKEVIRTUAL', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call declareMethod(visitor, method.getName(), Type.getMethodDescriptor(method), AsmClassGeneratorUtils.signature(method)) UnsolvedSymbolException{context='Method 'getMethodDescriptor' with parameterTypes [ReferenceType{java.lang.reflect.Method, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=org.objectweb.asm.Type}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call returnCode(Type.getType(returnType)) UnsolvedSymbolException{context='Method 'getType' with parameterTypes [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=null, boundedType=null}}}}]', name='ReflectionClassDeclaration{clazz=org.objectweb.asm.Type}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call finishVisitingMethod(methodVisitor, returnCode(Type.getType(returnType))) java.lang.RuntimeException: Error calculating the type of parameter Type.getType(returnType) of method call returnCode(Type.getType(returnType)) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call putMethodArgumentOnStack(methodVisitor, Type.getType(parameterTypes[paramNo]), paramNo + 1) UnsolvedSymbolException{context='Method 'getType' with parameterTypes [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=null, boundedType=null}}}}]', name='ReflectionClassDeclaration{clazz=org.objectweb.asm.Type}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call methodVisitor.visitMethodInsn(INVOKEVIRTUAL, delegateType.getInternalName(), method.getName(), Type.getMethodDescriptor(method), false) UnsolvedSymbolException{context='Solving INVOKEVIRTUAL', name='INVOKEVIRTUAL', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call methodVisitor.visitMethodInsn(INVOKESPECIAL, Type.getInternalName(superClass), method.getName(), Type.getMethodDescriptor(method), false) UnsolvedSymbolException{context='Solving INVOKESPECIAL', name='INVOKESPECIAL', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot solve method call String.format("Cannot set property: %s for class: %s to value: %s.", propertyName, viewType.getName(), value) java.lang.RuntimeException: Method 'getName' cannot be resolved in context viewType.getName() (line: 961) MethodCallExprContext{wrapped=viewType.getName()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedProxyClassGenerator.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call Type.getType("L" + generatedTypeName.replaceAll("\\.", "/") + ";") java.lang.RuntimeException: Method 'replaceAll' cannot be resolved in context generatedTypeName.replaceAll("\\.", "/") (line: 42) MethodCallExprContext{wrapped=generatedTypeName.replaceAll("\\.", "/")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedCollectionProxyClassGenerator.java
Cannot solve method call defineClass(visitor, publicContractType.getClassLoader(), generatedTypeName) java.lang.RuntimeException: Method 'getClassLoader' cannot be resolved in context publicContractType.getClassLoader() (line: 51) MethodCallExprContext{wrapped=publicContractType.getClassLoader()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedCollectionProxyClassGenerator.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call Type.getMethodDescriptor(Type.VOID_TYPE, paramTypes) UnsolvedSymbolException{context='unknown', name='VOID_TYPE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedCollectionProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call visitor.visitMethod(Opcodes.ACC_PUBLIC, CONSTRUCTOR_NAME, methodDescriptor, CONCRETE_SIGNATURE, NO_EXCEPTIONS) UnsolvedSymbolException{context='unknown', name='ACC_PUBLIC', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedCollectionProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call paramTypes[i].getOpcode(Opcodes.ILOAD) UnsolvedSymbolException{context='unknown', name='ILOAD', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedCollectionProxyClassGenerator.java
Cannot solve method call constructorVisitor.visitVarInsn(paramTypes[i].getOpcode(Opcodes.ILOAD), i + 1) java.lang.RuntimeException: Error calculating the type of parameter Opcodes.ILOAD of method call paramTypes[i].getOpcode(Opcodes.ILOAD) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedCollectionProxyClassGenerator.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call constructorVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL, superclassType.getInternalName(), CONSTRUCTOR_NAME, methodDescriptor, false) UnsolvedSymbolException{context='unknown', name='INVOKESPECIAL', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedCollectionProxyClassGenerator.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call visitor.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC, generatedType.getInternalName(), null, superclassType.getInternalName(), new String[] { publicType.getInternalName() }) UnsolvedSymbolException{context='unknown', name='V1_6', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ManagedCollectionProxyClassGenerator.java
Cannot solve method call Sets.newLinkedHashSet(Iterables.transform(candidateMethods.allMethods().keySet(), new Function<Wrapper<Method>, Method>() {

    @Override
    public Method apply(Wrapper<Method> method) {
        return method.get();
    }
})) UnsolvedSymbolException{context='Method 'transform' with parameterTypes [ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{Wrapper, typeParametersMap=TypeParametersMap{nameToValue={empty.Method=ReferenceType{java.lang.reflect.Method, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}}}, ReferenceType{Function, typeParametersMap=TypeParametersMap{nameToValue={empty.Equivalence.Wrapper<Method>=ReferenceType{java.lang.reflect.Method, typeParametersMap=TypeParametersMap{nameToValue={}}}, empty.Method=ReferenceType{Wrapper, typeParametersMap=TypeParametersMap{nameToValue={empty.Method=ReferenceType{java.lang.reflect.Method, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/StructSchemaExtractionStrategySupport.java
Cannot solve method call Sets.newLinkedHashSet(Iterables.transform(nonPropertyMethods, new Function<Method, WeaklyTypeReferencingMethod<?, ?>>() {

    @Override
    public WeaklyTypeReferencingMethod<?, ?> apply(Method method) {
        return WeaklyTypeReferencingMethod.of(method);
    }
})) UnsolvedSymbolException{context='Method 'transform' with parameterTypes [ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{java.lang.reflect.Method, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{Function, typeParametersMap=TypeParametersMap{nameToValue={empty.Equivalence.Wrapper<Method>=ReferenceType{org.gradle.model.internal.method.WeaklyTypeReferencingMethod, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.method.WeaklyTypeReferencingMethod.T=WildcardUsage{type=null, boundedType=null}, org.gradle.model.internal.method.WeaklyTypeReferencingMethod.R=WildcardUsage{type=null, boundedType=null}}}}, empty.Method=ReferenceType{java.lang.reflect.Method, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/StructSchemaExtractionStrategySupport.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve field access PropertyAccessorType.GET_GETTER
Cannot solve field access PropertyAccessorType.IS_GETTER
Cannot solve field access PropertyAccessorType.SETTER
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
Cannot solve method call Iterables.transform(property.getDeclaredBy(), Functions.toStringFunction()) UnsolvedSymbolException{context='Solving Functions', name='Functions', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/StructSchemaExtractionStrategySupport.java
Cannot solve method call String.format("property '%s' declared by %s", property.getName(), Joiner.on(", ").join(declaredBy)) java.lang.RuntimeException: Error calculating the type of parameter declaredBy of method call Joiner.on(", ").join(declaredBy) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/StructSchemaExtractionStrategySupport.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call JavaReflectionUtil.method(ClassLoader.class, Class.class, "defineClass", String.class, byte[].class, Integer.TYPE, Integer.TYPE) UnsolvedSymbolException{context='unknown', name='TYPE', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/AbstractProxyClassGenerator.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call methodVisitor.visitVarInsn(Opcodes.ALOAD, 0) UnsolvedSymbolException{context='unknown', name='ALOAD', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/AbstractProxyClassGenerator.java
Cannot resolve field access null
Cannot solve method call finishVisitingMethod(methodVisitor, Opcodes.RETURN) UnsolvedSymbolException{context='unknown', name='RETURN', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/AbstractProxyClassGenerator.java
Cannot solve method call Cast.uncheckedCast(modelNode.getPrivateData(Collection.class)) java.lang.RuntimeException: Method 'getPrivateData' cannot be resolved in context modelNode.getPrivateData(Collection.class) (line: 56) MethodCallExprContext{wrapped=modelNode.getPrivateData(Collection.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ScalarCollectionModelView.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve field access PropertyAccessorType.GET_GETTER
Cannot solve field access PropertyAccessorType.IS_GETTER
Cannot solve field access PropertyAccessorType.GET_GETTER
Method 'append' cannot be resolved in context out.append("Invalid managed model type ") (line: 56) MethodCallExprContext{wrapped=out.append("Invalid managed model type ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context out.append("Invalid managed model type ") (line: 56) MethodCallExprContext{wrapped=out.append("Invalid managed model type ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context out.append("Invalid managed model type ") (line: 56) MethodCallExprContext{wrapped=out.append("Invalid managed model type ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'get' cannot be resolved in context propertyContext.get() (line: 57) MethodCallExprContext{wrapped=propertyContext.get()}. Parameter types: []
Cannot solve method call Iterables.addAll(dependencyQueue, Iterables.filter(allDependencies, new Predicate<ModelSchemaExtractionContext<?>>() {

    public boolean apply(ModelSchemaExtractionContext<?> dependency) {
        return cache.get(dependency.getType()) == null;
    }
})) UnsolvedSymbolException{context='Method 'filter' with parameterTypes [ReferenceType{Iterable, typeParametersMap=TypeParametersMap{nameToValue={empty.BlockDoc=WildcardUsage{type=EXTENDS, boundedType=ReferenceType{org.gradle.model.internal.manage.schema.extract.DefaultModelSchemaExtractionContext, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.manage.schema.extract.DefaultModelSchemaExtractionContext.T=WildcardUsage{type=null, boundedType=null}}}}}}}}, ReferenceType{Predicate, typeParametersMap=TypeParametersMap{nameToValue={empty.? super ScriptBlock=ReferenceType{org.gradle.model.internal.manage.schema.extract.ModelSchemaExtractionContext, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.manage.schema.extract.ModelSchemaExtractionContext.T=WildcardUsage{type=null, boundedType=null}}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/DefaultModelSchemaExtractor.java
Cannot resolve field access null
Cannot solve field access ModelActionRole.Create
Cannot solve method call DirectNodeInputUsingModelAction.of(subject, descriptor, ModelReference.of(NodeInitializerRegistry.class), new BiAction<MutableModelNode, NodeInitializerRegistry>() {

    @Override
    public void execute(MutableModelNode modelNode, NodeInitializerRegistry nodeInitializerRegistry) {
        ChildNodeInitializerStrategy<E> childStrategy = NodeBackedModelMap.createUsingRegistry(nodeInitializerRegistry);
        modelNode.setPrivateData(ChildNodeInitializerStrategy.class, childStrategy);
    }
}) UnsolvedSymbolException{context='Method 'of' with parameterTypes [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.model.internal.core.NodeInitializerRegistry, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * A model reference is a speculative reference to a potential model element.
 * <p>
 * Rule subjects/inputs are defined in terms of references, as opposed to concrete identity.
 * The reference may be by type only, or by path only.
 * <p>
 * A reference doesn't include the notion of readonly vs. writable as the context of the reference implies this.
 * Having this be part of the reference would open opportunities for mismatch of that flag in the context.
 *
 * @param <T> the type of the reference.
 */
@ThreadSafe
public class ModelReference<T> {

    public static final ModelReference<Object> ANY = of(ModelType.untyped());

    @Nullable
    private final ModelPath path;

    private final ModelType<T> type;

    @Nullable
    private final ModelPath scope;

    private final ModelNode.State state;

    @Nullable
    private final String description;

    private int hashCode;

    private ModelReference(@Nullable ModelPath path, ModelType<T> type, @Nullable ModelPath scope, @Nullable ModelNode.State state, @Nullable String description) {
        this.path = path;
        this.type = Preconditions.checkNotNull(type, "type");
        this.scope = scope;
        this.description = description;
        this.state = state != null ? state : ModelNode.State.GraphClosed;
    }

    public static ModelReference<Object> any() {
        return ANY;
    }

    public static <T> ModelReference<T> of(ModelPath path, ModelType<T> type, String description) {
        return Cast.uncheckedCast(new ModelReference<T>(path, type, null, null, description));
    }

    public static <T> ModelReference<T> of(String path, ModelType<T> type, String description) {
        return of(ModelPath.path(path), type, description);
    }

    public static <T> ModelReference<T> of(ModelPath path, ModelType<T> type) {
        return Cast.uncheckedCast(new ModelReference<T>(path, type, null, null, null));
    }

    public static <T> ModelReference<T> of(ModelPath path, ModelType<T> type, ModelNode.State state) {
        return Cast.uncheckedCast(new ModelReference<T>(path, type, null, state, null));
    }

    public static <T> ModelReference<T> of(ModelPath path, Class<T> type) {
        return of(path, ModelType.of(type));
    }

    public static <T> ModelReference<T> of(String path, Class<T> type) {
        return of(ModelPath.path(path), ModelType.of(type));
    }

    public static <T> ModelReference<T> of(String path, ModelType<T> type) {
        return of(path == null ? null : ModelPath.path(path), type);
    }

    public static <T> ModelReference<T> of(Class<T> type) {
        return of((ModelPath) null, ModelType.of(type));
    }

    public static <T> ModelReference<T> of(ModelType<T> type) {
        return of((ModelPath) null, type);
    }

    public static ModelReference<Object> of(String path) {
        return of(ModelPath.path(path), ModelType.UNTYPED);
    }

    public static ModelReference<Object> of(ModelPath path) {
        return of(path, ModelType.UNTYPED);
    }

    public static ModelReference<Object> untyped(ModelPath path) {
        return untyped(path, null);
    }

    public static ModelReference<Object> untyped(ModelPath path, String description) {
        return of(path, ModelType.UNTYPED, description);
    }

    @Nullable
    public ModelPath getPath() {
        return path;
    }

    /**
     * Return the path of the scope of the node to select, or null if scope is not relevant.
     *
     * <p>A node will be selected if its path or its parent's path equals the specified path.</p>
     */
    @Nullable
    public ModelPath getScope() {
        return scope;
    }

    @Nullable
    public String getDescription() {
        return description;
    }

    public ModelType<T> getType() {
        return type;
    }

    public ModelNode.State getState() {
        return state;
    }

    public boolean isUntyped() {
        return type.equals(ModelType.UNTYPED);
    }

    public ModelReference<T> inScope(ModelPath scope) {
        if (scope.equals(this.scope)) {
            return this;
        }
        return Cast.uncheckedCast(new ModelReference<T>(path, type, scope, state, description));
    }

    public ModelReference<T> withPath(ModelPath path) {
        return Cast.uncheckedCast(new ModelReference<T>(path, type, scope, state, description));
    }

    public ModelReference<T> atState(ModelNode.State state) {
        if (state.equals(this.state)) {
            return this;
        }
        return Cast.uncheckedCast(new ModelReference<T>(path, type, scope, state, description));
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ModelReference<?> that = (ModelReference<?>) o;
        return Objects.equal(path, that.path) && Objects.equal(scope, that.scope) && type.equals(that.type) && state.equals(that.state) && Objects.equal(description, that.description);
    }

    @Override
    public int hashCode() {
        int result = hashCode;
        if (result != 0) {
            return result;
        }
        result = path == null ? 0 : path.hashCode();
        result = 31 * result + (scope == null ? 0 : scope.hashCode());
        result = 31 * result + type.hashCode();
        result = 31 * result + state.hashCode();
        result = 31 * result + (description == null ? 0 : description.hashCode());
        hashCode = result;
        return result;
    }

    @Override
    public String toString() {
        return "ModelReference{path=" + path + ", scope=" + scope + ", type=" + type + ", state=" + state + '}';
    }
}}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ModelMapNodeInitializerExtractionStrategy.java
Cannot solve field access ModelActionRole.Discover
Error calculating the type of parameter AddProjectionsAction.of(subject, descriptor, ModelMapModelProjection.managed(schema.getType(), schema.getElementType(), ChildNodeInitializerStrategyAccessors.fromPrivateData())) of method call ImmutableSetMultimap.<ModelActionRole, ModelAction>builder().put(ModelActionRole.Discover, AddProjectionsAction.of(subject, descriptor, ModelMapModelProjection.managed(schema.getType(), schema.getElementType(), ChildNodeInitializerStrategyAccessors.fromPrivateData())))
Error calculating the type of parameter DirectNodeInputUsingModelAction.of(subject, descriptor, ModelReference.of(NodeInitializerRegistry.class), new BiAction<MutableModelNode, NodeInitializerRegistry>() {

    @Override
    public void execute(MutableModelNode modelNode, NodeInitializerRegistry nodeInitializerRegistry) {
        ChildNodeInitializerStrategy<E> childStrategy = NodeBackedModelMap.createUsingRegistry(nodeInitializerRegistry);
        modelNode.setPrivateData(ChildNodeInitializerStrategy.class, childStrategy);
    }
}) of method call ImmutableSetMultimap.<ModelActionRole, ModelAction>builder().put(ModelActionRole.Discover, AddProjectionsAction.of(subject, descriptor, ModelMapModelProjection.managed(schema.getType(), schema.getElementType(), ChildNodeInitializerStrategyAccessors.fromPrivateData()))).put(ModelActionRole.Create, DirectNodeInputUsingModelAction.of(subject, descriptor, ModelReference.of(NodeInitializerRegistry.class), new BiAction<MutableModelNode, NodeInitializerRegistry>() {

    @Override
    public void execute(MutableModelNode modelNode, NodeInitializerRegistry nodeInitializerRegistry) {
        ChildNodeInitializerStrategy<E> childStrategy = NodeBackedModelMap.createUsingRegistry(nodeInitializerRegistry);
        modelNode.setPrivateData(ChildNodeInitializerStrategy.class, childStrategy);
    }
}))
Cannot solve method call extractionContext.add(String.format("subtyping %s is not supported.", ModelMap.class.getName())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ModelMapStrategy.java
Cannot solve method call extractionContext.add(String.format("type parameter of %s cannot be a wildcard.", ModelMap.class.getName())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ModelMapStrategy.java
Cannot solve method call extractionContext.add(String.format("type parameter of %s has to be specified.", ModelMap.class.getName())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ModelMapStrategy.java
Method 'getGenericInterfaces' cannot be resolved in context contractType.getGenericInterfaces() (line: 58) MethodCallExprContext{wrapped=contractType.getGenericInterfaces()}. Parameter types: []
Cannot solve field access ModelActionRole.Create
Cannot solve method call DirectNodeInputUsingModelAction.of(subject, descriptor, ModelReference.of(NodeInitializerRegistry.class), new BiAction<MutableModelNode, NodeInitializerRegistry>() {

    @Override
    public void execute(MutableModelNode modelNode, NodeInitializerRegistry nodeInitializerRegistry) {
        ChildNodeInitializerStrategy<E> childFactory = NodeBackedModelMap.createUsingRegistry(nodeInitializerRegistry);
        modelNode.setPrivateData(ModelType.of(ChildNodeInitializerStrategy.class), childFactory);
    }
}) UnsolvedSymbolException{context='Method 'of' with parameterTypes [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.model.internal.core.NodeInitializerRegistry, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * A model reference is a speculative reference to a potential model element.
 * <p>
 * Rule subjects/inputs are defined in terms of references, as opposed to concrete identity.
 * The reference may be by type only, or by path only.
 * <p>
 * A reference doesn't include the notion of readonly vs. writable as the context of the reference implies this.
 * Having this be part of the reference would open opportunities for mismatch of that flag in the context.
 *
 * @param <T> the type of the reference.
 */
@ThreadSafe
public class ModelReference<T> {

    public static final ModelReference<Object> ANY = of(ModelType.untyped());

    @Nullable
    private final ModelPath path;

    private final ModelType<T> type;

    @Nullable
    private final ModelPath scope;

    private final ModelNode.State state;

    @Nullable
    private final String description;

    private int hashCode;

    private ModelReference(@Nullable ModelPath path, ModelType<T> type, @Nullable ModelPath scope, @Nullable ModelNode.State state, @Nullable String description) {
        this.path = path;
        this.type = Preconditions.checkNotNull(type, "type");
        this.scope = scope;
        this.description = description;
        this.state = state != null ? state : ModelNode.State.GraphClosed;
    }

    public static ModelReference<Object> any() {
        return ANY;
    }

    public static <T> ModelReference<T> of(ModelPath path, ModelType<T> type, String description) {
        return Cast.uncheckedCast(new ModelReference<T>(path, type, null, null, description));
    }

    public static <T> ModelReference<T> of(String path, ModelType<T> type, String description) {
        return of(ModelPath.path(path), type, description);
    }

    public static <T> ModelReference<T> of(ModelPath path, ModelType<T> type) {
        return Cast.uncheckedCast(new ModelReference<T>(path, type, null, null, null));
    }

    public static <T> ModelReference<T> of(ModelPath path, ModelType<T> type, ModelNode.State state) {
        return Cast.uncheckedCast(new ModelReference<T>(path, type, null, state, null));
    }

    public static <T> ModelReference<T> of(ModelPath path, Class<T> type) {
        return of(path, ModelType.of(type));
    }

    public static <T> ModelReference<T> of(String path, Class<T> type) {
        return of(ModelPath.path(path), ModelType.of(type));
    }

    public static <T> ModelReference<T> of(String path, ModelType<T> type) {
        return of(path == null ? null : ModelPath.path(path), type);
    }

    public static <T> ModelReference<T> of(Class<T> type) {
        return of((ModelPath) null, ModelType.of(type));
    }

    public static <T> ModelReference<T> of(ModelType<T> type) {
        return of((ModelPath) null, type);
    }

    public static ModelReference<Object> of(String path) {
        return of(ModelPath.path(path), ModelType.UNTYPED);
    }

    public static ModelReference<Object> of(ModelPath path) {
        return of(path, ModelType.UNTYPED);
    }

    public static ModelReference<Object> untyped(ModelPath path) {
        return untyped(path, null);
    }

    public static ModelReference<Object> untyped(ModelPath path, String description) {
        return of(path, ModelType.UNTYPED, description);
    }

    @Nullable
    public ModelPath getPath() {
        return path;
    }

    /**
     * Return the path of the scope of the node to select, or null if scope is not relevant.
     *
     * <p>A node will be selected if its path or its parent's path equals the specified path.</p>
     */
    @Nullable
    public ModelPath getScope() {
        return scope;
    }

    @Nullable
    public String getDescription() {
        return description;
    }

    public ModelType<T> getType() {
        return type;
    }

    public ModelNode.State getState() {
        return state;
    }

    public boolean isUntyped() {
        return type.equals(ModelType.UNTYPED);
    }

    public ModelReference<T> inScope(ModelPath scope) {
        if (scope.equals(this.scope)) {
            return this;
        }
        return Cast.uncheckedCast(new ModelReference<T>(path, type, scope, state, description));
    }

    public ModelReference<T> withPath(ModelPath path) {
        return Cast.uncheckedCast(new ModelReference<T>(path, type, scope, state, description));
    }

    public ModelReference<T> atState(ModelNode.State state) {
        if (state.equals(this.state)) {
            return this;
        }
        return Cast.uncheckedCast(new ModelReference<T>(path, type, scope, state, description));
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ModelReference<?> that = (ModelReference<?>) o;
        return Objects.equal(path, that.path) && Objects.equal(scope, that.scope) && type.equals(that.type) && state.equals(that.state) && Objects.equal(description, that.description);
    }

    @Override
    public int hashCode() {
        int result = hashCode;
        if (result != 0) {
            return result;
        }
        result = path == null ? 0 : path.hashCode();
        result = 31 * result + (scope == null ? 0 : scope.hashCode());
        result = 31 * result + type.hashCode();
        result = 31 * result + state.hashCode();
        result = 31 * result + (description == null ? 0 : description.hashCode());
        hashCode = result;
        return result;
    }

    @Override
    public String toString() {
        return "ModelReference{path=" + path + ", scope=" + scope + ", type=" + type + ", state=" + state + '}';
    }
}}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/SpecializedMapNodeInitializer.java
Cannot solve field access ModelActionRole.Discover
Error calculating the type of parameter DirectNodeNoInputsModelAction.of(subject, descriptor, new Action<MutableModelNode>() {

    @Override
    public void execute(MutableModelNode modelNode) {
        ChildNodeInitializerStrategyAccessor<E> strategyAccessor = ChildNodeInitializerStrategyAccessors.fromPrivateData();
        Class<? extends T> implementationType = schema.getImplementationType().asSubclass(schema.getType().getConcreteClass());
        modelNode.addProjection(new SpecializedModelMapProjection<T, E>(schema.getType(), schema.getElementType(), implementationType, strategyAccessor));
        modelNode.addProjection(ModelMapModelProjection.managed(schema.getType(), schema.getElementType(), strategyAccessor));
    }
}) of method call ImmutableSetMultimap.<ModelActionRole, ModelAction>builder().put(ModelActionRole.Discover, DirectNodeNoInputsModelAction.of(subject, descriptor, new Action<MutableModelNode>() {

    @Override
    public void execute(MutableModelNode modelNode) {
        ChildNodeInitializerStrategyAccessor<E> strategyAccessor = ChildNodeInitializerStrategyAccessors.fromPrivateData();
        Class<? extends T> implementationType = schema.getImplementationType().asSubclass(schema.getType().getConcreteClass());
        modelNode.addProjection(new SpecializedModelMapProjection<T, E>(schema.getType(), schema.getElementType(), implementationType, strategyAccessor));
        modelNode.addProjection(ModelMapModelProjection.managed(schema.getType(), schema.getElementType(), strategyAccessor));
    }
}))
Error calculating the type of parameter DirectNodeInputUsingModelAction.of(subject, descriptor, ModelReference.of(NodeInitializerRegistry.class), new BiAction<MutableModelNode, NodeInitializerRegistry>() {

    @Override
    public void execute(MutableModelNode modelNode, NodeInitializerRegistry nodeInitializerRegistry) {
        ChildNodeInitializerStrategy<E> childFactory = NodeBackedModelMap.createUsingRegistry(nodeInitializerRegistry);
        modelNode.setPrivateData(ModelType.of(ChildNodeInitializerStrategy.class), childFactory);
    }
}) of method call ImmutableSetMultimap.<ModelActionRole, ModelAction>builder().put(ModelActionRole.Discover, DirectNodeNoInputsModelAction.of(subject, descriptor, new Action<MutableModelNode>() {

    @Override
    public void execute(MutableModelNode modelNode) {
        ChildNodeInitializerStrategyAccessor<E> strategyAccessor = ChildNodeInitializerStrategyAccessors.fromPrivateData();
        Class<? extends T> implementationType = schema.getImplementationType().asSubclass(schema.getType().getConcreteClass());
        modelNode.addProjection(new SpecializedModelMapProjection<T, E>(schema.getType(), schema.getElementType(), implementationType, strategyAccessor));
        modelNode.addProjection(ModelMapModelProjection.managed(schema.getType(), schema.getElementType(), strategyAccessor));
    }
})).put(ModelActionRole.Create, DirectNodeInputUsingModelAction.of(subject, descriptor, ModelReference.of(NodeInitializerRegistry.class), new BiAction<MutableModelNode, NodeInitializerRegistry>() {

    @Override
    public void execute(MutableModelNode modelNode, NodeInitializerRegistry nodeInitializerRegistry) {
        ChildNodeInitializerStrategy<E> childFactory = NodeBackedModelMap.createUsingRegistry(nodeInitializerRegistry);
        modelNode.setPrivateData(ModelType.of(ChildNodeInitializerStrategy.class), childFactory);
    }
}))
Cannot solve method call extractionContext.add(String.format("subtyping %s is not supported", ModelSet.class.getName())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ModelSetStrategy.java
Cannot solve method call extractionContext.add(String.format("type parameter of %s cannot be a wildcard", ModelSet.class.getName())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ModelSetStrategy.java
Cannot solve method call extractionContext.add(String.format("type parameter of %s has to be specified", ModelSet.class.getName())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ModelSetStrategy.java
Cannot solve method call Cast.uncheckedCast(modelNode.getPrivateData(ChildNodeInitializerStrategy.class)) java.lang.RuntimeException: Method 'getPrivateData' cannot be resolved in context modelNode.getPrivateData(ChildNodeInitializerStrategy.class) (line: 60) MethodCallExprContext{wrapped=modelNode.getPrivateData(ChildNodeInitializerStrategy.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.model.internal.core.ChildNodeInitializerStrategy, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ModelSetNodeInitializerExtractionStrategy.java
Cannot solve field access ModelActionRole.Create
Cannot solve method call DirectNodeInputUsingModelAction.of(subject, descriptor, ModelReference.of(NodeInitializerRegistry.class), new BiAction<MutableModelNode, NodeInitializerRegistry>() {

    @Override
    public void execute(MutableModelNode modelNode, NodeInitializerRegistry nodeInitializerRegistry) {
        ChildNodeInitializerStrategy<T> childStrategy = new ManagedChildNodeCreatorStrategy<T>(nodeInitializerRegistry);
        modelNode.setPrivateData(ChildNodeInitializerStrategy.class, childStrategy);
    }
}) UnsolvedSymbolException{context='Method 'of' with parameterTypes [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.model.internal.core.NodeInitializerRegistry, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * A model reference is a speculative reference to a potential model element.
 * <p>
 * Rule subjects/inputs are defined in terms of references, as opposed to concrete identity.
 * The reference may be by type only, or by path only.
 * <p>
 * A reference doesn't include the notion of readonly vs. writable as the context of the reference implies this.
 * Having this be part of the reference would open opportunities for mismatch of that flag in the context.
 *
 * @param <T> the type of the reference.
 */
@ThreadSafe
public class ModelReference<T> {

    public static final ModelReference<Object> ANY = of(ModelType.untyped());

    @Nullable
    private final ModelPath path;

    private final ModelType<T> type;

    @Nullable
    private final ModelPath scope;

    private final ModelNode.State state;

    @Nullable
    private final String description;

    private int hashCode;

    private ModelReference(@Nullable ModelPath path, ModelType<T> type, @Nullable ModelPath scope, @Nullable ModelNode.State state, @Nullable String description) {
        this.path = path;
        this.type = Preconditions.checkNotNull(type, "type");
        this.scope = scope;
        this.description = description;
        this.state = state != null ? state : ModelNode.State.GraphClosed;
    }

    public static ModelReference<Object> any() {
        return ANY;
    }

    public static <T> ModelReference<T> of(ModelPath path, ModelType<T> type, String description) {
        return Cast.uncheckedCast(new ModelReference<T>(path, type, null, null, description));
    }

    public static <T> ModelReference<T> of(String path, ModelType<T> type, String description) {
        return of(ModelPath.path(path), type, description);
    }

    public static <T> ModelReference<T> of(ModelPath path, ModelType<T> type) {
        return Cast.uncheckedCast(new ModelReference<T>(path, type, null, null, null));
    }

    public static <T> ModelReference<T> of(ModelPath path, ModelType<T> type, ModelNode.State state) {
        return Cast.uncheckedCast(new ModelReference<T>(path, type, null, state, null));
    }

    public static <T> ModelReference<T> of(ModelPath path, Class<T> type) {
        return of(path, ModelType.of(type));
    }

    public static <T> ModelReference<T> of(String path, Class<T> type) {
        return of(ModelPath.path(path), ModelType.of(type));
    }

    public static <T> ModelReference<T> of(String path, ModelType<T> type) {
        return of(path == null ? null : ModelPath.path(path), type);
    }

    public static <T> ModelReference<T> of(Class<T> type) {
        return of((ModelPath) null, ModelType.of(type));
    }

    public static <T> ModelReference<T> of(ModelType<T> type) {
        return of((ModelPath) null, type);
    }

    public static ModelReference<Object> of(String path) {
        return of(ModelPath.path(path), ModelType.UNTYPED);
    }

    public static ModelReference<Object> of(ModelPath path) {
        return of(path, ModelType.UNTYPED);
    }

    public static ModelReference<Object> untyped(ModelPath path) {
        return untyped(path, null);
    }

    public static ModelReference<Object> untyped(ModelPath path, String description) {
        return of(path, ModelType.UNTYPED, description);
    }

    @Nullable
    public ModelPath getPath() {
        return path;
    }

    /**
     * Return the path of the scope of the node to select, or null if scope is not relevant.
     *
     * <p>A node will be selected if its path or its parent's path equals the specified path.</p>
     */
    @Nullable
    public ModelPath getScope() {
        return scope;
    }

    @Nullable
    public String getDescription() {
        return description;
    }

    public ModelType<T> getType() {
        return type;
    }

    public ModelNode.State getState() {
        return state;
    }

    public boolean isUntyped() {
        return type.equals(ModelType.UNTYPED);
    }

    public ModelReference<T> inScope(ModelPath scope) {
        if (scope.equals(this.scope)) {
            return this;
        }
        return Cast.uncheckedCast(new ModelReference<T>(path, type, scope, state, description));
    }

    public ModelReference<T> withPath(ModelPath path) {
        return Cast.uncheckedCast(new ModelReference<T>(path, type, scope, state, description));
    }

    public ModelReference<T> atState(ModelNode.State state) {
        if (state.equals(this.state)) {
            return this;
        }
        return Cast.uncheckedCast(new ModelReference<T>(path, type, scope, state, description));
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ModelReference<?> that = (ModelReference<?>) o;
        return Objects.equal(path, that.path) && Objects.equal(scope, that.scope) && type.equals(that.type) && state.equals(that.state) && Objects.equal(description, that.description);
    }

    @Override
    public int hashCode() {
        int result = hashCode;
        if (result != 0) {
            return result;
        }
        result = path == null ? 0 : path.hashCode();
        result = 31 * result + (scope == null ? 0 : scope.hashCode());
        result = 31 * result + type.hashCode();
        result = 31 * result + state.hashCode();
        result = 31 * result + (description == null ? 0 : description.hashCode());
        hashCode = result;
        return result;
    }

    @Override
    public String toString() {
        return "ModelReference{path=" + path + ", scope=" + scope + ", type=" + type + ", state=" + state + '}';
    }
}}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ModelSetNodeInitializerExtractionStrategy.java
Cannot solve field access ModelActionRole.Discover
Error calculating the type of parameter AddProjectionsAction.of(subject, descriptor, TypedModelProjection.of(ModelTypes.modelSet(schema.getElementType()), new ModelSetModelViewFactory<E>(schema.getElementType()))) of method call ImmutableSetMultimap.<ModelActionRole, ModelAction>builder().put(ModelActionRole.Discover, AddProjectionsAction.of(subject, descriptor, TypedModelProjection.of(ModelTypes.modelSet(schema.getElementType()), new ModelSetModelViewFactory<E>(schema.getElementType()))))
Error calculating the type of parameter DirectNodeInputUsingModelAction.of(subject, descriptor, ModelReference.of(NodeInitializerRegistry.class), new BiAction<MutableModelNode, NodeInitializerRegistry>() {

    @Override
    public void execute(MutableModelNode modelNode, NodeInitializerRegistry nodeInitializerRegistry) {
        ChildNodeInitializerStrategy<T> childStrategy = new ManagedChildNodeCreatorStrategy<T>(nodeInitializerRegistry);
        modelNode.setPrivateData(ChildNodeInitializerStrategy.class, childStrategy);
    }
}) of method call ImmutableSetMultimap.<ModelActionRole, ModelAction>builder().put(ModelActionRole.Discover, AddProjectionsAction.of(subject, descriptor, TypedModelProjection.of(ModelTypes.modelSet(schema.getElementType()), new ModelSetModelViewFactory<E>(schema.getElementType())))).put(ModelActionRole.Create, DirectNodeInputUsingModelAction.of(subject, descriptor, ModelReference.of(NodeInitializerRegistry.class), new BiAction<MutableModelNode, NodeInitializerRegistry>() {

    @Override
    public void execute(MutableModelNode modelNode, NodeInitializerRegistry nodeInitializerRegistry) {
        ChildNodeInitializerStrategy<T> childStrategy = new ManagedChildNodeCreatorStrategy<T>(nodeInitializerRegistry);
        modelNode.setPrivateData(ChildNodeInitializerStrategy.class, childStrategy);
    }
}))
Cannot solve method call Arrays.sort(declaredMethods, Ordering.usingToString()) UnsolvedSymbolException{context='Method 'usingToString' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Ordering}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ModelSchemaUtils.java
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
Cannot solve method call method.getDeclaringClass().isAnnotationPresent(Managed.class) java.lang.UnsupportedOperationException /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/manage/schema/extract/ModelSchemaUtils.java
Cannot solve method call allLinks(Predicates.<MutableModelNode>alwaysTrue()) UnsolvedSymbolException{context='Method 'alwaysTrue' with parameterTypes []', name='ReflectionClassDeclaration{clazz=com.google.common.base.Predicates}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/NodePredicate.java
Cannot solve method call allDescendants(Predicates.<MutableModelNode>alwaysTrue()) UnsolvedSymbolException{context='Method 'alwaysTrue' with parameterTypes []', name='ReflectionClassDeclaration{clazz=com.google.common.base.Predicates}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/NodePredicate.java
Cannot solve method call withType(ModelType.of(type)) java.lang.UnsupportedOperationException: com.github.javaparser.resolution.types.ResolvedWildcard /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/NodePredicate.java
Cannot solve method call CollectionUtils.sort(Iterables.transform(creatableTypes, new Function<Class<?>, String>() {

    public String apply(Class<?> input) {
        return input.getName();
    }
})) UnsolvedSymbolException{context='Method 'transform' with parameterTypes [ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=WildcardUsage{type=EXTENDS, boundedType=ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=null, boundedType=null}}}}}}}}, ReferenceType{Function, typeParametersMap=TypeParametersMap{nameToValue={empty.Equivalence.Wrapper<Method>=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, empty.Method=ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=null, boundedType=null}}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelMapModelProjection.java
Method 'append' cannot be resolved in context sb.append("<") (line: 72) MethodCallExprContext{wrapped=sb.append("<")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context sb.append("<") (line: 72) MethodCallExprContext{wrapped=sb.append("<")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call builder.withType(itemType) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelMapModelProjection.java
Cannot solve method call InstanceModelView.of(node.getPath(), ModelTypes.modelMap(itemType), builder.withType(itemType), state.closer()) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelMapModelProjection.java
Cannot solve method call Collections.singleton(getContainerTypeDescription(ModelMap.class, creatableTypes)) java.lang.RuntimeException: Method 'getContainerTypeDescription' cannot be resolved in context getContainerTypeDescription(ModelMap.class, creatableTypes) (line: 143) MethodCallExprContext{wrapped=getContainerTypeDescription(ModelMap.class, creatableTypes)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.model.ModelMap, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=WildcardUsage{type=EXTENDS, boundedType=ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=null, boundedType=null}}}}}}}}] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelMapModelProjection.java
Cannot resolve field access null
Cannot solve field access ModelNode.State.Created
Method 'append' cannot be resolved in context new StringBuilder(type.toString()).append("#toString() returned null") (line: 81) MethodCallExprContext{wrapped=new StringBuilder(type.toString()).append("#toString() returned null")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getInterfaces' cannot be resolved in context type.getRawClass().getInterfaces() (line: 85) MethodCallExprContext{wrapped=type.getRawClass().getInterfaces()}. Parameter types: []
Cannot solve field access ModelActionRole.Initialize
Cannot solve field access ModelActionRole.Finalize
Cannot solve method call NoInputsModelAction.of(elementTypeReference, descriptor.append("afterEach()"), configAction) java.lang.RuntimeException: Method 'append' cannot be resolved in context descriptor.append("afterEach()") (line: 103) MethodCallExprContext{wrapped=descriptor.append("afterEach()")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/NodeBackedModelSet.java
Cannot solve method call modelNode.applyTo(allLinks(), ModelActionRole.Finalize, NoInputsModelAction.of(elementTypeReference, descriptor.append("afterEach()"), configAction)) java.lang.RuntimeException: Error calculating the type of parameter descriptor.append("afterEach()") of method call NoInputsModelAction.of(elementTypeReference, descriptor.append("afterEach()"), configAction) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/NodeBackedModelSet.java
Cannot solve field access ModelActionRole.Defaults
Cannot solve method call NoInputsModelAction.of(elementTypeReference, descriptor.append("afterEach()"), configAction) java.lang.RuntimeException: Method 'append' cannot be resolved in context descriptor.append("afterEach()") (line: 109) MethodCallExprContext{wrapped=descriptor.append("afterEach()")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/NodeBackedModelSet.java
Cannot solve method call modelNode.applyTo(allLinks(), ModelActionRole.Defaults, NoInputsModelAction.of(elementTypeReference, descriptor.append("afterEach()"), configAction)) java.lang.RuntimeException: Error calculating the type of parameter descriptor.append("afterEach()") of method call NoInputsModelAction.of(elementTypeReference, descriptor.append("afterEach()"), configAction) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/NodeBackedModelSet.java
Cannot solve method call ClosureBackedAction.of(closure) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/NodeBackedModelSet.java
Cannot solve method call create(ClosureBackedAction.of(closure)) java.lang.RuntimeException: Error calculating the type of parameter closure of method call ClosureBackedAction.of(closure) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/NodeBackedModelSet.java
Cannot solve method call ClosureBackedAction.of(closure) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/NodeBackedModelSet.java
Cannot solve method call afterEach(ClosureBackedAction.of(closure)) java.lang.RuntimeException: Error calculating the type of parameter closure of method call ClosureBackedAction.of(closure) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/NodeBackedModelSet.java
Cannot solve method call ClosureBackedAction.of(closure) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/NodeBackedModelSet.java
Cannot solve method call beforeEach(ClosureBackedAction.of(closure)) java.lang.RuntimeException: Error calculating the type of parameter closure of method call ClosureBackedAction.of(closure) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/NodeBackedModelSet.java
Cannot solve method call Lists.newArrayList(Iterables.transform(modelNode.getLinks(ModelNodes.withType(elementType)), new Function<MutableModelNode, T>() {

    @Override
    public T apply(MutableModelNode input) {
        return input.asImmutable(elementType, descriptor).getInstance();
    }
})) UnsolvedSymbolException{context='Method 'transform' with parameterTypes [ReferenceType{Iterable, typeParametersMap=TypeParametersMap{nameToValue={empty.BlockDoc=WildcardUsage{type=EXTENDS, boundedType=ReferenceType{org.gradle.model.internal.core.MutableModelNode, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}, ReferenceType{Function, typeParametersMap=TypeParametersMap{nameToValue={empty.Equivalence.Wrapper<Method>=TypeVariable {org.gradle.model.internal.core.NodeBackedModelSet.T}, empty.Method=ReferenceType{org.gradle.model.internal.core.MutableModelNode, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/NodeBackedModelSet.java
Cannot solve method call withType(ModelType.of(type)) java.lang.UnsupportedOperationException: com.github.javaparser.resolution.types.ResolvedWildcard /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelNodes.java
Cannot solve method call withType(type, Predicates.<MutableModelNode>alwaysTrue()) UnsolvedSymbolException{context='Method 'alwaysTrue' with parameterTypes []', name='ReflectionClassDeclaration{clazz=com.google.common.base.Predicates}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelNodes.java
Cannot solve method call withType(ModelType.of(type), predicate) java.lang.UnsupportedOperationException: com.github.javaparser.resolution.types.ResolvedWildcard /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelNodes.java
Cannot resolve field access null
Cannot solve field access ModelNode.State.Discovered
Cannot solve method call Optional.of(String.valueOf(defaultValueOf(getType()))) UnsolvedSymbolException{context='Method 'valueOf' with parameterTypes [ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/UnmanagedModelProjection.java
Method 'getConstraints' cannot be resolved in context context.getConstraints() (line: 68) MethodCallExprContext{wrapped=context.getConstraints()}. Parameter types: []
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call UncheckedException.throwAsUncheckedException(e.getCause()) UnsolvedSymbolException{context='unknown', name='UncheckedExecutionException', typeSolver=null} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/DefaultNodeInitializerRegistry.java
Cannot solve method call schemaStore.getSchema(context.getModelType()) java.lang.RuntimeException: Method 'getModelType' cannot be resolved in context context.getModelType() (line: 88) MethodCallExprContext{wrapped=context.getModelType()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/DefaultNodeInitializerRegistry.java
Cannot solve field access ModelActionRole.Create
Cannot solve field access ModelActionRole.Discover
Error calculating the type of parameter DirectNodeNoInputsModelAction.of(subject, descriptor, new Action<MutableModelNode>() {

    @Override
    public void execute(MutableModelNode modelNode) {
        NamedEntityInstantiator<T> instantiator = instantiatorTransform.transform(modelNode.getParent());
        S item = instantiator.create(modelNode.getPath().getName(), type.getConcreteClass());
        modelNode.setPrivateData(type, item);
    }
}) of method call ImmutableSetMultimap.<ModelActionRole, ModelAction>builder().put(ModelActionRole.Discover, AddProjectionsAction.of(subject, descriptor, UnmanagedModelProjection.of(type), new ModelElementProjection(type))).put(ModelActionRole.Create, DirectNodeNoInputsModelAction.of(subject, descriptor, new Action<MutableModelNode>() {

    @Override
    public void execute(MutableModelNode modelNode) {
        NamedEntityInstantiator<T> instantiator = instantiatorTransform.transform(modelNode.getParent());
        S item = instantiator.create(modelNode.getPath().getName(), type.getConcreteClass());
        modelNode.setPrivateData(type, item);
    }
}))
Cannot solve method call allLinks(elementFilter.withType(filterType)) java.lang.RuntimeException: E ? /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/NodeBackedModelMap.java
Cannot solve method call modelNode.applyTo(allLinks(elementFilter.withType(filterType)), role, NoInputsModelAction.of(subject, descriptor, configAction)) java.lang.RuntimeException: Error calculating the type of parameter elementFilter.withType(filterType) of method call allLinks(elementFilter.withType(filterType)) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/NodeBackedModelMap.java
Cannot solve method call allLinks(elementFilter.withType(filterType)) java.lang.RuntimeException: E ? /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/NodeBackedModelMap.java
Cannot solve method call modelNode.defineRulesFor(allLinks(elementFilter.withType(filterType)), role, new DeferredActionWrapper<E>(subject, role, configAction)) java.lang.RuntimeException: Error calculating the type of parameter elementFilter.withType(filterType) of method call allLinks(elementFilter.withType(filterType)) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/NodeBackedModelMap.java
Cannot solve field access ModelActionRole.Finalize
Cannot solve field access ModelActionRole.Finalize
Cannot solve field access ModelActionRole.Finalize
Cannot solve field access ModelActionRole.Finalize
Cannot solve field access ModelActionRole.Mutate
Cannot solve field access ModelActionRole.Initialize
Cannot solve field access ModelActionRole.Defaults
Cannot solve field access ModelActionRole.Defaults
Cannot solve field access ModelActionRole.Defaults
Cannot solve field access ModelActionRole.Defaults
Cannot solve method call Cast.uncheckedCast(instance.getClass()) java.lang.RuntimeException: Method 'getClass' cannot be resolved in context instance.getClass() (line: 277) MethodCallExprContext{wrapped=instance.getClass()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/NodeBackedModelMap.java
Cannot solve field access ModelActionRole.Initialize
Cannot solve field access ModelActionRole.Initialize
Cannot solve field access ModelActionRole.Mutate
Cannot solve method call sourceDescriptor.append("named(%s, %s)", name, ruleSource.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context ruleSource.getName() (line: 385) MethodCallExprContext{wrapped=ruleSource.getName()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/NodeBackedModelMap.java
Cannot solve field access ModelActionRole.Defaults
Cannot solve field access ModelActionRole.Initialize
Cannot solve field access ModelActionRole.Mutate
Cannot solve field access ModelActionRole.Mutate
Cannot solve field access ModelActionRole.Mutate
Cannot solve method call allLinks(elementFilter.withType(type)) java.lang.RuntimeException: S ? /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/NodeBackedModelMap.java
Cannot solve method call modelNode.applyTo(allLinks(elementFilter.withType(type)), rules) java.lang.RuntimeException: Error calculating the type of parameter elementFilter.withType(type) of method call allLinks(elementFilter.withType(type)) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/NodeBackedModelMap.java
Cannot solve method call withType(type) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/NodeBackedModelMap.java
Cannot resolve field access null
Cannot solve method call doCreate(name, ModelType.of(itemType), action) java.lang.UnsupportedOperationException: com.github.javaparser.resolution.types.ResolvedWildcard /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/NodeBackedModelMap.java
Cannot resolve field access null
Cannot solve method call named(name, action) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/NodeBackedModelMap.java
Cannot solve method call withType(ModelType.of(elementType)) java.lang.UnsupportedOperationException: com.github.javaparser.resolution.types.ResolvedWildcard /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/NodeBackedModelMap.java
Cannot resolve field access null
Cannot solve field access ModelNode.State.Discovered
Cannot resolve field access null
Cannot solve field access ModelNode.State.Discovered
Cannot resolve field access null
Cannot solve field access ModelNode.State.Discovered
Cannot resolve field access null
Cannot solve field access ModelNode.State.Created
Cannot resolve field access null
Cannot solve field access ModelNode.State.DefaultsApplied
Cannot resolve field access null
Cannot solve field access ModelNode.State.Initialized
Cannot resolve field access null
Cannot solve field access ModelNode.State.Mutated
Cannot resolve field access null
Cannot solve field access ModelNode.State.Finalized
Cannot resolve field access null
Cannot solve field access ModelNode.State.SelfClosed
Cannot solve method call s.append(String.format("A model element of type: '%s' can not be constructed.%n", context.getModelType().getName())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelTypeInitializationException.java
Cannot solve method call s.append(String.format("It must be one of:%n")) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelTypeInitializationException.java
Cannot solve method call s.append(String.format("    - %s", MANAGED_TYPE_DESCRIPTION)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelTypeInitializationException.java
Cannot solve method call s.append(String.format("A model element of type: '%s' can not be constructed.%n", propertyContext.getDeclaringType().getName())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelTypeInitializationException.java
Cannot solve method call s.append(String.format("Its property '%s %s' can not be constructed%n", propertyType.getName(), propertyName)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelTypeInitializationException.java
Cannot solve method call s.append(String.format("It must be one of:%n")) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelTypeInitializationException.java
Cannot solve method call s.append(String.format("    - %s%n", MANAGED_TYPE_DESCRIPTION)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelTypeInitializationException.java
Cannot solve method call s.append(String.format("%n    - A scalar collection. %s%n    - %s", explainScalarCollections(scalarTypes), UNMANAGED_PROPERTY_DESCRIPTION)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelTypeInitializationException.java
Cannot solve method call s.append(String.format("Its property '%s %s' is not a valid scalar collection%n", propertyType.getName(), propertyName)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelTypeInitializationException.java
Cannot solve method call s.append(String.format("A scalar collection can not contain '%s's%n", innerType)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.model.internal.type.ModelType, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.type.ModelType.T=WildcardUsage{type=null, boundedType=null}}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelTypeInitializationException.java
Cannot solve method call s.append(String.format("Its property '%s %s' is not a valid managed collection%n", propertyType.getName(), propertyName)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelTypeInitializationException.java
Cannot solve method call s.append(String.format("A managed collection can not contain '%s's%n", schema.getElementType())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.model.internal.type.ModelType, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.type.ModelType.T=WildcardUsage{type=null, boundedType=null}}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelTypeInitializationException.java
Cannot solve method call s.append(String.format("A valid managed collection takes the form of ModelSet<T> or ModelMap<T> where 'T' is:%n        - %s", MANAGED_TYPE_DESCRIPTION)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelTypeInitializationException.java
Cannot solve method call s.append(String.format("%n%s- or a type which Gradle is capable of constructing:", padding)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelTypeInitializationException.java
Cannot solve method call s.append(String.format("%n    %s- %s", padding, modelType.getName())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelTypeInitializationException.java
Cannot solve method call ImmutableSet.copyOf(Iterables.transform(types, new Function<ModelType<?>, String>() {

    @Override
    public String apply(ModelType<?> input) {
        return input.getDisplayName();
    }
})) UnsolvedSymbolException{context='Method 'transform' with parameterTypes [ReferenceType{Iterable, typeParametersMap=TypeParametersMap{nameToValue={empty.BlockDoc=WildcardUsage{type=EXTENDS, boundedType=ReferenceType{org.gradle.model.internal.type.ModelType, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.type.ModelType.T=WildcardUsage{type=null, boundedType=null}}}}}}}}, ReferenceType{Function, typeParametersMap=TypeParametersMap{nameToValue={empty.Equivalence.Wrapper<Method>=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, empty.Method=ReferenceType{org.gradle.model.internal.type.ModelType, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.type.ModelType.T=WildcardUsage{type=null, boundedType=null}}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelTypeInitializationException.java
Cannot solve field access ModelActionRole.Create
Cannot resolve field access null
Cannot solve field access ModelNode.State.GraphClosed
Cannot solve method call of(path == null ? null : ModelPath.path(path), type) com.github.javaparser.resolution.MethodAmbiguityException: Ambiguous method call: cannot find a most applicable method: JavaParserMethodDeclaration{wrappedNode=public static <T> ModelReference<T> of(String path, ModelType<T> type) {
    return of(path == null ? null : ModelPath.path(path), type);
}, typeSolver=com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver@6fb0d3ed}, JavaParserMethodDeclaration{wrappedNode=public static <T> ModelReference<T> of(ModelPath path, ModelType<T> type) {
    return Cast.uncheckedCast(new ModelReference<T>(path, type, null, null, null));
}, typeSolver=com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver@6fb0d3ed} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelReference.java
Cannot resolve field access null
Cannot solve method call PARAM_JOINER.join(Iterables.transform(genericParameterTypes, TYPE_DISPLAYNAME_FUNCTION)) UnsolvedSymbolException{context='Method 'transform' with parameterTypes [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{org.gradle.model.internal.type.ModelType, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.type.ModelType.T=WildcardUsage{type=null, boundedType=null}}}}}}}, ReferenceType{Function, typeParametersMap=TypeParametersMap{nameToValue={empty.Equivalence.Wrapper<Method>=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, empty.Method=ReferenceType{org.gradle.model.internal.type.ModelType, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.type.ModelType.T=WildcardUsage{type=null, boundedType=null}}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/rule/describe/MethodModelRuleDescriptor.java
Method 'getDeclaredMethods' cannot be resolved in context clazz.getDeclaredMethods() (line: 131) MethodCallExprContext{wrapped=clazz.getDeclaredMethods()}. Parameter types: []
Cannot solve method call append(String.format(child, args)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ResolvedArrayType{ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/rule/describe/AbstractModelRuleDescriptor.java
Cannot solve method call create(name, new ClosureBackedAction<I>(configAction)) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelMapGroovyView.java
Cannot solve method call create(name, type, new ClosureBackedAction<I>(configAction)) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelMapGroovyView.java
Cannot solve method call named(name, new ClosureBackedAction<I>(configAction)) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelMapGroovyView.java
Cannot solve method call all(new ClosureBackedAction<I>(configAction)) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelMapGroovyView.java
Cannot solve method call withType(type, new ClosureBackedAction<S>(configAction)) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelMapGroovyView.java
Cannot solve method call beforeEach(new ClosureBackedAction<I>(configAction)) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelMapGroovyView.java
Cannot solve method call beforeEach(type, new ClosureBackedAction<S>(configAction)) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelMapGroovyView.java
Cannot solve method call afterEach(new ClosureBackedAction<I>(configAction)) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelMapGroovyView.java
Cannot solve method call afterEach(type, new ClosureBackedAction<S>(configAction)) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelMapGroovyView.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call named(name, closure) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelMapGroovyView.java
Cannot solve method call create(name, itemType, closure) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelMapGroovyView.java
Cannot solve method call create(name, itemType) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelMapGroovyView.java
Cannot solve method call String.format("Cannot create an item of type %s as this is not a subtype of %s.", type.getName(), baseClass.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context type.getName() (line: 24) MethodCallExprContext{wrapped=type.getName()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/NamedEntityInstantiators.java
Error calculating the type of parameter CharMatcher.inRange('A', 'Z') of method call CharMatcher.inRange('a', 'z').or(CharMatcher.inRange('A', 'Z'))
Method 'negate' cannot be resolved in context VALID_FIRST_CHAR_MATCHER.negate() (line: 40) MethodCallExprContext{wrapped=VALID_FIRST_CHAR_MATCHER.negate()}. Parameter types: []
Error calculating the type of parameter CharMatcher.is('-') of method call CharMatcher.inRange('0', '9').or(VALID_FIRST_CHAR_MATCHER).or(CharMatcher.is('-'))
Error calculating the type of parameter CharMatcher.is('-') of method call CharMatcher.inRange('0', '9').or(VALID_FIRST_CHAR_MATCHER).or(CharMatcher.is('-'))
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call path(path.substring(0, parentPathLength), parentComponents) java.lang.RuntimeException: Method 'substring' cannot be resolved in context path.substring(0, parentPathLength) (line: 181) MethodCallExprContext{wrapped=path.substring(0, parentPathLength)}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelPath.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call Lists.newArrayListWithCapacity(path.length()) java.lang.RuntimeException: Method 'length' cannot be resolved in context path.length() (line: 314) MethodCallExprContext{wrapped=path.length()}. Parameter types: [] /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelPath.java
Cannot solve method call Iterables.concat(Iterables.transform(projections, new Function<ModelProjection, Iterable<String>>() {

    public Iterable<String> apply(ModelProjection projection) {
        return projection.getTypeDescriptions(node);
    }
})) UnsolvedSymbolException{context='Method 'transform' with parameterTypes [ReferenceType{Iterable, typeParametersMap=TypeParametersMap{nameToValue={empty.BlockDoc=WildcardUsage{type=EXTENDS, boundedType=ReferenceType{org.gradle.model.internal.core.ModelProjection, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}, ReferenceType{Function, typeParametersMap=TypeParametersMap{nameToValue={empty.Equivalence.Wrapper<Method>=ReferenceType{Iterable, typeParametersMap=TypeParametersMap{nameToValue={empty.BlockDoc=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, empty.Method=ReferenceType{org.gradle.model.internal.core.ModelProjection, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ChainingModelProjection.java
Cannot solve field access ModelActionRole.Create
Cannot solve field access ModelActionRole.Discover
Cannot solve method call action(ModelActionRole.Discover, AddProjectionsAction.of(reference, descriptor, projections)) UnsolvedSymbolException{context='Method 'of' with parameterTypes [ReferenceType{org.gradle.model.internal.core.ModelReference, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.core.ModelReference.T=ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{org.gradle.model.internal.core.rule.describe.ModelRuleDescriptor, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{org.gradle.model.internal.core.ModelProjection, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public class AddProjectionsAction<T> extends AbstractModelAction<T> {

    private final Iterable<ModelProjection> projections;

    private AddProjectionsAction(ModelReference<T> subject, ModelRuleDescriptor descriptor, Iterable<ModelProjection> projections) {
        super(subject, descriptor);
        this.projections = projections;
    }

    public static <T> AddProjectionsAction<T> of(ModelReference<T> subject, ModelRuleDescriptor descriptor, ModelProjection... projections) {
        return of(subject, descriptor, Arrays.asList(projections));
    }

    public static <T> AddProjectionsAction<T> of(ModelReference<T> subject, ModelRuleDescriptor descriptor, Iterable<ModelProjection> projections) {
        return new AddProjectionsAction<T>(subject, descriptor, projections);
    }

    @Override
    public void execute(MutableModelNode modelNode, List<ModelView<?>> inputs) {
        for (ModelProjection projection : projections) {
            modelNode.addProjection(projection);
        }
    }
}}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/core/ModelRegistrations.java
Cannot solve method call ImmutableList.copyOf(Iterables.transform(Arrays.asList(method.getGenericParameterTypes()), new Function<Type, ModelType<?>>() {

    public ModelType<?> apply(Type type) {
        return ModelType.of(type);
    }
})) UnsolvedSymbolException{context='Method 'transform' with parameterTypes [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.lang.reflect.Type, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{Function, typeParametersMap=TypeParametersMap{nameToValue={empty.Equivalence.Wrapper<Method>=ReferenceType{org.gradle.model.internal.type.ModelType, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.type.ModelType.T=WildcardUsage{type=null, boundedType=null}}}}, empty.Method=ReferenceType{java.lang.reflect.Type, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/method/WeaklyTypeReferencingMethod.java
Cannot solve method call Iterables.toArray(Iterables.transform(paramTypes, new Function<ModelType<?>, Class<?>>() {

    public Class<?> apply(ModelType<?> modelType) {
        return modelType.getRawClass();
    }
}), Class.class) UnsolvedSymbolException{context='Method 'transform' with parameterTypes [ReferenceType{ImmutableList, typeParametersMap=TypeParametersMap{nameToValue={empty.String=ReferenceType{org.gradle.model.internal.type.ModelType, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.type.ModelType.T=WildcardUsage{type=null, boundedType=null}}}}}}}, ReferenceType{Function, typeParametersMap=TypeParametersMap{nameToValue={empty.Equivalence.Wrapper<Method>=ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=null, boundedType=null}}}}, empty.Method=ReferenceType{org.gradle.model.internal.type.ModelType, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.type.ModelType.T=WildcardUsage{type=null, boundedType=null}}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/method/WeaklyTypeReferencingMethod.java
Method 'append' cannot be resolved in context new HashCodeBuilder().append(declaringType) (line: 129) MethodCallExprContext{wrapped=new HashCodeBuilder().append(declaringType)}. Parameter types: [ReferenceType{org.gradle.model.internal.type.ModelType, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.type.ModelType.T=TypeVariable {org.gradle.model.internal.method.WeaklyTypeReferencingMethod.T}}}}]
Method 'append' cannot be resolved in context new HashCodeBuilder().append(declaringType) (line: 129) MethodCallExprContext{wrapped=new HashCodeBuilder().append(declaringType)}. Parameter types: [ReferenceType{org.gradle.model.internal.type.ModelType, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.type.ModelType.T=TypeVariable {org.gradle.model.internal.method.WeaklyTypeReferencingMethod.T}}}}]
Method 'append' cannot be resolved in context new HashCodeBuilder().append(declaringType) (line: 129) MethodCallExprContext{wrapped=new HashCodeBuilder().append(declaringType)}. Parameter types: [ReferenceType{org.gradle.model.internal.type.ModelType, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.type.ModelType.T=TypeVariable {org.gradle.model.internal.method.WeaklyTypeReferencingMethod.T}}}}]
Method 'append' cannot be resolved in context new HashCodeBuilder().append(declaringType) (line: 129) MethodCallExprContext{wrapped=new HashCodeBuilder().append(declaringType)}. Parameter types: [ReferenceType{org.gradle.model.internal.type.ModelType, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.type.ModelType.T=TypeVariable {org.gradle.model.internal.method.WeaklyTypeReferencingMethod.T}}}}]
Method 'append' cannot be resolved in context new EqualsBuilder().append(declaringType, other.declaringType) (line: 149) MethodCallExprContext{wrapped=new EqualsBuilder().append(declaringType, other.declaringType)}. Parameter types: [ReferenceType{org.gradle.model.internal.type.ModelType, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.type.ModelType.T=TypeVariable {org.gradle.model.internal.method.WeaklyTypeReferencingMethod.T}}}}, ReferenceType{org.gradle.model.internal.type.ModelType, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.type.ModelType.T=WildcardUsage{type=null, boundedType=null}}}}]
Method 'append' cannot be resolved in context new EqualsBuilder().append(declaringType, other.declaringType) (line: 149) MethodCallExprContext{wrapped=new EqualsBuilder().append(declaringType, other.declaringType)}. Parameter types: [ReferenceType{org.gradle.model.internal.type.ModelType, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.type.ModelType.T=TypeVariable {org.gradle.model.internal.method.WeaklyTypeReferencingMethod.T}}}}, ReferenceType{org.gradle.model.internal.type.ModelType, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.type.ModelType.T=WildcardUsage{type=null, boundedType=null}}}}]
Method 'append' cannot be resolved in context new EqualsBuilder().append(declaringType, other.declaringType) (line: 149) MethodCallExprContext{wrapped=new EqualsBuilder().append(declaringType, other.declaringType)}. Parameter types: [ReferenceType{org.gradle.model.internal.type.ModelType, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.type.ModelType.T=TypeVariable {org.gradle.model.internal.method.WeaklyTypeReferencingMethod.T}}}}, ReferenceType{org.gradle.model.internal.type.ModelType, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.type.ModelType.T=WildcardUsage{type=null, boundedType=null}}}}]
Method 'append' cannot be resolved in context new EqualsBuilder().append(declaringType, other.declaringType) (line: 149) MethodCallExprContext{wrapped=new EqualsBuilder().append(declaringType, other.declaringType)}. Parameter types: [ReferenceType{org.gradle.model.internal.type.ModelType, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.type.ModelType.T=TypeVariable {org.gradle.model.internal.method.WeaklyTypeReferencingMethod.T}}}}, ReferenceType{org.gradle.model.internal.type.ModelType, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.type.ModelType.T=WildcardUsage{type=null, boundedType=null}}}}]
Cannot solve method call String.format("%s.%s(%s)", declaringType.getDisplayName(), name, Joiner.on(", ").join(Iterables.transform(paramTypes, new Function<ModelType<?>, String>() {

    @Override
    public String apply(ModelType<?> paramType) {
        return paramType.getDisplayName();
    }
}))) java.lang.RuntimeException: Error calculating the type of parameter Iterables.transform(paramTypes, new Function<ModelType<?>, String>() {

    @Override
    public String apply(ModelType<?> paramType) {
        return paramType.getDisplayName();
    }
}) of method call Joiner.on(", ").join(Iterables.transform(paramTypes, new Function<ModelType<?>, String>() {

    @Override
    public String apply(ModelType<?> paramType) {
        return paramType.getDisplayName();
    }
})) /repo/subprojects/model-core/src/main/java/org/gradle/model/internal/method/WeaklyTypeReferencingMethod.java
Method 'append' cannot be resolved in context result.append("Attempt to modify a ") (line: 40) MethodCallExprContext{wrapped=result.append("Attempt to modify a ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context result.append("Attempt to modify a ") (line: 40) MethodCallExprContext{wrapped=result.append("Attempt to modify a ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call terminals.isTerminal(Stdout) UnsolvedSymbolException{context='Solving Stdout', name='Stdout', typeSolver=null} /repo/subprojects/native/src/main/java/org/gradle/internal/nativeintegration/console/NativePlatformConsoleDetector.java
Cannot solve method call terminals.isTerminal(Stderr) UnsolvedSymbolException{context='Solving Stderr', name='Stderr', typeSolver=null} /repo/subprojects/native/src/main/java/org/gradle/internal/nativeintegration/console/NativePlatformConsoleDetector.java
Cannot solve method call terminals.getTerminal(Stderr) UnsolvedSymbolException{context='Solving Stderr', name='Stderr', typeSolver=null} /repo/subprojects/native/src/main/java/org/gradle/internal/nativeintegration/console/NativePlatformConsoleDetector.java
Cannot solve method call terminals.getTerminal(Stdout) UnsolvedSymbolException{context='Solving Stdout', name='Stdout', typeSolver=null} /repo/subprojects/native/src/main/java/org/gradle/internal/nativeintegration/console/NativePlatformConsoleDetector.java
Method 'getTerminalSize' cannot be resolved in context terminal.getTerminalSize() (line: 44) MethodCallExprContext{wrapped=terminal.getTerminalSize()}. Parameter types: []
Cannot solve method call format(ex) UnsolvedSymbolException{context='unknown', name='NativeException', typeSolver=null} /repo/subprojects/native/src/main/java/org/gradle/internal/nativeintegration/services/NativeServices.java
Cannot solve method call LOGGER.debug("Unable to initialize native-platform. Failure: {}", format(ex)) java.lang.RuntimeException: Error calculating the type of parameter ex of method call format(ex) /repo/subprojects/native/src/main/java/org/gradle/internal/nativeintegration/services/NativeServices.java
Cannot solve method call System.getProperty(NATIVE_DIR_OVERRIDE, System.getenv(NATIVE_DIR_OVERRIDE)) UnsolvedSymbolException{context='Method 'getenv' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=java.lang.System}'} /repo/subprojects/native/src/main/java/org/gradle/internal/nativeintegration/services/NativeServices.java
Cannot solve method call format(ex) UnsolvedSymbolException{context='unknown', name='NativeException', typeSolver=null} /repo/subprojects/native/src/main/java/org/gradle/internal/nativeintegration/services/NativeServices.java
Cannot solve method call LOGGER.debug("Unable to load from native-platform backed ConsoleDetector. Continuing with fallback. Failure: {}", format(ex)) java.lang.RuntimeException: Error calculating the type of parameter ex of method call format(ex) /repo/subprojects/native/src/main/java/org/gradle/internal/nativeintegration/services/NativeServices.java
Cannot solve method call LOGGER.debug("Unable to load native library. Continuing with fallback. Failure: {}", format(e)) java.lang.RuntimeException: Method 'format' cannot be resolved in context format(e) (line: 159) MethodCallExprContext{wrapped=format(e)}. Parameter types: [ReferenceType{java.lang.LinkageError, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/native/src/main/java/org/gradle/internal/nativeintegration/services/NativeServices.java
Cannot solve method call Proxy.newProxyInstance(type.getClassLoader(), new Class[] { type }, new BrokenService(type.getSimpleName())) java.lang.RuntimeException: Method 'getClassLoader' cannot be resolved in context type.getClassLoader() (line: 205) MethodCallExprContext{wrapped=type.getClassLoader()}. Parameter types: [] /repo/subprojects/native/src/main/java/org/gradle/internal/nativeintegration/services/NativeServices.java
Cannot solve method call Long.valueOf(process.getProcessId()) java.lang.RuntimeException: Method 'getProcessId' cannot be resolved in context process.getProcessId() (line: 51) MethodCallExprContext{wrapped=process.getProcessId()}. Parameter types: [] /repo/subprojects/native/src/main/java/org/gradle/internal/nativeintegration/processenvironment/NativePlatformBackedProcessEnvironment.java
Cannot solve method call Lists.newArrayList(Sets.difference(System.getenv().keySet(), source.keySet())) UnsolvedSymbolException{context='Method 'difference' with parameterTypes [ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Sets}'} /repo/subprojects/native/src/main/java/org/gradle/internal/nativeintegration/processenvironment/AbstractProcessEnvironment.java
Cannot solve method call Long.parseLong(runtimeMXBeanName.substring(0, separatorPos)) java.lang.RuntimeException: Method 'substring' cannot be resolved in context runtimeMXBeanName.substring(0, separatorPos) (line: 50) MethodCallExprContext{wrapped=runtimeMXBeanName.substring(0, separatorPos)}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}] /repo/subprojects/native/src/main/java/org/gradle/internal/nativeintegration/jna/UnsupportedEnvironment.java
Method 'toRealPath' cannot be resolved in context file.toPath().toRealPath() (line: 29) MethodCallExprContext{wrapped=file.toPath().toRealPath()}. Parameter types: []
Method 'stat' cannot be resolved in context posixFiles.stat(suspect) (line: 46) MethodCallExprContext{wrapped=posixFiles.stat(suspect)}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot resolve field access null
Error calculating the type of parameter Charsets.UTF_8 of method call Files.readFirstLine(file, Charsets.UTF_8)
Cannot solve method call LOGGER.debug("Unable to load {}. Continuing with fallback {}.", jdk7Type, fallbackType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context fallbackType.getName() (line: 76) MethodCallExprContext{wrapped=fallbackType.getName()}. Parameter types: [] /repo/subprojects/native/src/main/java/org/gradle/internal/nativeintegration/filesystem/services/FileSystemServices.java
Cannot resolve field access null
Cannot solve method call effectiveManifest.getAttributes().put(Analyzer.BND_LASTMODIFIED, mod) UnsolvedSymbolException{context='unknown', name='BND_LASTMODIFIED', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call instructionNames.contains(Analyzer.IMPORT_PACKAGE) UnsolvedSymbolException{context='unknown', name='IMPORT_PACKAGE', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call analyzer.setProperty(Analyzer.IMPORT_PACKAGE, "*, !org.apache.ant.*, !org.junit.*, !org.jmock.*, !org.easymock.*, !org.mockito.*") UnsolvedSymbolException{context='unknown', name='IMPORT_PACKAGE', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call instructionNames.contains(Analyzer.BUNDLE_VERSION) UnsolvedSymbolException{context='unknown', name='BUNDLE_VERSION', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call analyzer.setProperty(Analyzer.BUNDLE_VERSION, getVersion()) UnsolvedSymbolException{context='unknown', name='BUNDLE_VERSION', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call instructionNames.contains(Analyzer.BUNDLE_NAME) UnsolvedSymbolException{context='unknown', name='BUNDLE_NAME', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call analyzer.setProperty(Analyzer.BUNDLE_NAME, getName()) UnsolvedSymbolException{context='unknown', name='BUNDLE_NAME', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call instructionNames.contains(Analyzer.BUNDLE_SYMBOLICNAME) UnsolvedSymbolException{context='unknown', name='BUNDLE_SYMBOLICNAME', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call analyzer.setProperty(Analyzer.BUNDLE_SYMBOLICNAME, getSymbolicName()) UnsolvedSymbolException{context='unknown', name='BUNDLE_SYMBOLICNAME', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call instructionNames.contains(Analyzer.EXPORT_PACKAGE) UnsolvedSymbolException{context='unknown', name='EXPORT_PACKAGE', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call analyzer.setProperty(Analyzer.EXPORT_PACKAGE, "*;-noimport:=false;version=" + getVersion()) UnsolvedSymbolException{context='unknown', name='EXPORT_PACKAGE', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot solve method call analyzer.setClasspath(getClasspath().getFiles().toArray(new File[0])) java.lang.RuntimeException: java.io.File[] T[] /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call instructionName.equals(Analyzer.BUNDLE_SYMBOLICNAME) UnsolvedSymbolException{context='unknown', name='BUNDLE_SYMBOLICNAME', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call instructionName.equals(Analyzer.BUNDLE_NAME) UnsolvedSymbolException{context='unknown', name='BUNDLE_NAME', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call instructionName.equals(Analyzer.BUNDLE_VERSION) UnsolvedSymbolException{context='unknown', name='BUNDLE_VERSION', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call instructionName.equals(Analyzer.BUNDLE_DESCRIPTION) UnsolvedSymbolException{context='unknown', name='BUNDLE_DESCRIPTION', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call instructionName.equals(Analyzer.BUNDLE_LICENSE) UnsolvedSymbolException{context='unknown', name='BUNDLE_LICENSE', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call instructionName.equals(Analyzer.BUNDLE_VENDOR) UnsolvedSymbolException{context='unknown', name='BUNDLE_VENDOR', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call instructionName.equals(Analyzer.BUNDLE_DOCURL) UnsolvedSymbolException{context='unknown', name='BUNDLE_DOCURL', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call name.equals(Analyzer.BUNDLE_SYMBOLICNAME) UnsolvedSymbolException{context='unknown', name='BUNDLE_SYMBOLICNAME', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call name.equals(Analyzer.BUNDLE_NAME) UnsolvedSymbolException{context='unknown', name='BUNDLE_NAME', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call name.equals(Analyzer.BUNDLE_VERSION) UnsolvedSymbolException{context='unknown', name='BUNDLE_VERSION', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call name.equals(Analyzer.BUNDLE_DESCRIPTION) UnsolvedSymbolException{context='unknown', name='BUNDLE_DESCRIPTION', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call name.equals(Analyzer.BUNDLE_LICENSE) UnsolvedSymbolException{context='unknown', name='BUNDLE_LICENSE', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call name.equals(Analyzer.BUNDLE_VENDOR) UnsolvedSymbolException{context='unknown', name='BUNDLE_VENDOR', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call name.equals(Analyzer.BUNDLE_DOCURL) UnsolvedSymbolException{context='unknown', name='BUNDLE_DOCURL', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call name.equals(Analyzer.BUNDLE_SYMBOLICNAME) UnsolvedSymbolException{context='unknown', name='BUNDLE_SYMBOLICNAME', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call name.equals(Analyzer.BUNDLE_NAME) UnsolvedSymbolException{context='unknown', name='BUNDLE_NAME', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call name.equals(Analyzer.BUNDLE_VERSION) UnsolvedSymbolException{context='unknown', name='BUNDLE_VERSION', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call name.equals(Analyzer.BUNDLE_DESCRIPTION) UnsolvedSymbolException{context='unknown', name='BUNDLE_DESCRIPTION', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call name.equals(Analyzer.BUNDLE_LICENSE) UnsolvedSymbolException{context='unknown', name='BUNDLE_LICENSE', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call name.equals(Analyzer.BUNDLE_VENDOR) UnsolvedSymbolException{context='unknown', name='BUNDLE_VENDOR', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call name.equals(Analyzer.BUNDLE_DOCURL) UnsolvedSymbolException{context='unknown', name='BUNDLE_DOCURL', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call name.equals(Analyzer.BUNDLE_SYMBOLICNAME) UnsolvedSymbolException{context='unknown', name='BUNDLE_SYMBOLICNAME', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call name.equals(Analyzer.BUNDLE_NAME) UnsolvedSymbolException{context='unknown', name='BUNDLE_NAME', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call name.equals(Analyzer.BUNDLE_VERSION) UnsolvedSymbolException{context='unknown', name='BUNDLE_VERSION', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call name.equals(Analyzer.BUNDLE_DESCRIPTION) UnsolvedSymbolException{context='unknown', name='BUNDLE_DESCRIPTION', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call name.equals(Analyzer.BUNDLE_LICENSE) UnsolvedSymbolException{context='unknown', name='BUNDLE_LICENSE', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call name.equals(Analyzer.BUNDLE_VENDOR) UnsolvedSymbolException{context='unknown', name='BUNDLE_VENDOR', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call name.equals(Analyzer.BUNDLE_DOCURL) UnsolvedSymbolException{context='unknown', name='BUNDLE_DOCURL', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot solve method call Arrays.asList(propertyString.split(",")) java.lang.RuntimeException: Method 'split' cannot be resolved in context propertyString.split(",") (line: 305) MethodCallExprContext{wrapped=propertyString.split(",")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call modelledInstructions.put(Analyzer.BUNDLE_SYMBOLICNAME, createListFromPropertyString(symbolicName)) UnsolvedSymbolException{context='unknown', name='BUNDLE_SYMBOLICNAME', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call modelledInstructions.put(Analyzer.BUNDLE_NAME, createListFromPropertyString(name)) UnsolvedSymbolException{context='unknown', name='BUNDLE_NAME', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call modelledInstructions.put(Analyzer.BUNDLE_VERSION, createListFromPropertyString(version)) UnsolvedSymbolException{context='unknown', name='BUNDLE_VERSION', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call modelledInstructions.put(Analyzer.BUNDLE_DESCRIPTION, createListFromPropertyString(description)) UnsolvedSymbolException{context='unknown', name='BUNDLE_DESCRIPTION', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call modelledInstructions.put(Analyzer.BUNDLE_LICENSE, createListFromPropertyString(description)) UnsolvedSymbolException{context='unknown', name='BUNDLE_LICENSE', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call modelledInstructions.put(Analyzer.BUNDLE_VENDOR, createListFromPropertyString(vendor)) UnsolvedSymbolException{context='unknown', name='BUNDLE_VENDOR', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Cannot resolve field access null
Cannot solve method call modelledInstructions.put(Analyzer.BUNDLE_DOCURL, createListFromPropertyString(docURL)) UnsolvedSymbolException{context='unknown', name='BUNDLE_DOCURL', typeSolver=null} /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/DefaultOsgiManifest.java
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(BasePluginConvention.class) (line: 62) MethodCallExprContext{wrapped=project.getConvention().getPlugin(BasePluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.BasePluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call archiveBaseName.substring(lastSection.length()) java.lang.RuntimeException: Method 'length' cannot be resolved in context lastSection.length() (line: 72) MethodCallExprContext{wrapped=lastSection.length()}. Parameter types: [] /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/OsgiHelper.java
Cannot solve method call Character.isLetterOrDigit(artifactId.charAt(0)) java.lang.RuntimeException: Method 'charAt' cannot be resolved in context artifactId.charAt(0) (line: 73) MethodCallExprContext{wrapped=artifactId.charAt(0)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/OsgiHelper.java
Cannot solve method call getBundleSymbolicName(group, artifactId.substring(1)) java.lang.RuntimeException: Method 'substring' cannot be resolved in context artifactId.substring(1) (line: 76) MethodCallExprContext{wrapped=artifactId.substring(1)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/osgi/src/main/java/org/gradle/api/internal/plugins/osgi/OsgiHelper.java
Method 'matcher' cannot be resolved in context ONLY_NUMBERS.matcher(token) (line: 106) MethodCallExprContext{wrapped=ONLY_NUMBERS.matcher(token)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'matcher' cannot be resolved in context OSGI_VERSION_PATTERN.matcher(result) (line: 133) MethodCallExprContext{wrapped=OSGI_VERSION_PATTERN.matcher(result)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'matcher' cannot be resolved in context QUALIFIER.matcher(token) (line: 143) MethodCallExprContext{wrapped=QUALIFIER.matcher(token)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getPlugins' cannot be resolved in context project.getConvention().getPlugins() (line: 35) MethodCallExprContext{wrapped=project.getConvention().getPlugins()}. Parameter types: []
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 41) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 41) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 41) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 41) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call osgiManifest.setClassesDir(project.getConvention().getPlugin(JavaPluginConvention.class).getSourceSets().getByName("main").getOutput().getClassesDir()) java.lang.RuntimeException: Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 41) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/osgi/src/main/java/org/gradle/api/plugins/osgi/OsgiPlugin.java
Cannot solve method call osgiManifest.setClasspath(project.getConfigurations().getByName("runtime")) java.lang.RuntimeException: Method 'getByName' cannot be resolved in context project.getConfigurations().getByName("runtime") (line: 42) MethodCallExprContext{wrapped=project.getConfigurations().getByName("runtime")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/osgi/src/main/java/org/gradle/api/plugins/osgi/OsgiPlugin.java
Cannot solve method call mapping.map("version", new Callable<Object>() {

    public Object call() throws Exception {
        return osgiHelper.getVersion(project.getVersion().toString());
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/osgi/src/main/java/org/gradle/api/plugins/osgi/OsgiPluginConvention.java
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(BasePluginConvention.class) (line: 83) MethodCallExprContext{wrapped=project.getConvention().getPlugin(BasePluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.BasePluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call mapping.map("name", new Callable<Object>() {

    public Object call() throws Exception {
        return project.getConvention().getPlugin(BasePluginConvention.class).getArchivesBaseName();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/osgi/src/main/java/org/gradle/api/plugins/osgi/OsgiPluginConvention.java
Cannot solve method call mapping.map("symbolicName", new Callable<Object>() {

    public Object call() throws Exception {
        return osgiHelper.getBundleSymbolicName(project);
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/osgi/src/main/java/org/gradle/api/plugins/osgi/OsgiPluginConvention.java
Cannot solve method call uncheckedCast(collection.matching(Specs.isInstance(type))) java.lang.RuntimeException: T ? super T /repo/subprojects/platform-base/src/main/java/org/gradle/model/internal/core/DomainObjectCollectionBackedModelMap.java
Cannot solve method call Sets.newHashSet(Iterables.transform(collection, new ToName<T>(namer))) UnsolvedSymbolException{context='Method 'transform' with parameterTypes [ReferenceType{org.gradle.api.DomainObjectCollection, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.api.DomainObjectCollection.T=TypeVariable {org.gradle.model.internal.core.DomainObjectCollectionBackedModelMap.T}}}}, ReferenceType{org.gradle.model.internal.core.DomainObjectCollectionBackedModelMap.ToName, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.model.internal.core.DomainObjectCollectionBackedModelMap.ToName.T=TypeVariable {org.gradle.model.internal.core.DomainObjectCollectionBackedModelMap.T}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/platform-base/src/main/java/org/gradle/model/internal/core/DomainObjectCollectionBackedModelMap.java
Method 'determineName' cannot be resolved in context namer.determineName(input) (line: 107) MethodCallExprContext{wrapped=namer.determineName(input)}. Parameter types: [TypeVariable {org.gradle.model.internal.core.DomainObjectCollectionBackedModelMap.HasNamePredicate.T}]
T ? super T
Cannot solve method call metaData.addConfiguration(configurationName, String.format("Request metadata: %s", componentId.getDisplayName()), Collections.<String>emptySet(), Collections.singleton(configurationName), true, true, null, entry.getValue()) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/platform-base/src/main/java/org/gradle/language/base/internal/model/DefaultLibraryLocalComponentMetadata.java
Cannot solve method call DefaultModuleVersionSelector.of(nullToEmpty(projectPath), nullToEmpty(libraryName), getId().getVersion()) java.lang.RuntimeException: Method 'nullToEmpty' cannot be resolved in context nullToEmpty(projectPath) (line: 135) MethodCallExprContext{wrapped=nullToEmpty(projectPath)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-base/src/main/java/org/gradle/language/base/internal/model/DefaultLibraryLocalComponentMetadata.java
Cannot solve method call taskName.substring(CLEAN.length()) java.lang.RuntimeException: Method 'length' cannot be resolved in context CLEAN.length() (line: 50) MethodCallExprContext{wrapped=CLEAN.length()}. Parameter types: [] /repo/subprojects/platform-base/src/main/java/org/gradle/language/base/internal/plugins/CleanRule.java
Cannot solve method call Character.isLowerCase(targetTaskName.charAt(0)) java.lang.RuntimeException: Method 'charAt' cannot be resolved in context targetTaskName.charAt(0) (line: 51) MethodCallExprContext{wrapped=targetTaskName.charAt(0)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/platform-base/src/main/java/org/gradle/language/base/internal/plugins/CleanRule.java
Cannot solve method call tasks.findByName(StringUtils.uncapitalize(targetTaskName)) UnsolvedSymbolException{context='Method 'uncapitalize' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=org.apache.commons.lang.StringUtils}'} /repo/subprojects/platform-base/src/main/java/org/gradle/language/base/internal/plugins/CleanRule.java
Method 'replaceAll' cannot be resolved in context typeName.replaceAll("LanguageSourceSet$", "") (line: 43) MethodCallExprContext{wrapped=typeName.replaceAll("LanguageSourceSet$", "")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'replaceAll' cannot be resolved in context typeName.replaceAll("LanguageSourceSet$", "") (line: 43) MethodCallExprContext{wrapped=typeName.replaceAll("LanguageSourceSet$", "")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'replaceAll' cannot be resolved in context typeName.replaceAll("LanguageSourceSet$", "") (line: 43) MethodCallExprContext{wrapped=typeName.replaceAll("LanguageSourceSet$", "")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'toLowerCase' cannot be resolved in context languageName.toLowerCase() (line: 77) MethodCallExprContext{wrapped=languageName.toLowerCase()}. Parameter types: []
Method 'withType' cannot be resolved in context componentSpec.getBinaries().withType(BinarySpecInternal.class) (line: 165) MethodCallExprContext{wrapped=componentSpec.getBinaries().withType(BinarySpecInternal.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.platform.base.internal.BinarySpecInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call String.format("Could not create LanguageSourceSet of type %s", publicType.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context publicType.getSimpleName() (line: 45) MethodCallExprContext{wrapped=publicType.getSimpleName()}. Parameter types: [] /repo/subprojects/platform-base/src/main/java/org/gradle/language/base/sources/BaseLanguageSourceSet.java
Method 'append' cannot be resolved in context new StringBuilder("Project '").append(projectPath) (line: 104) MethodCallExprContext{wrapped=new StringBuilder("Project '").append(projectPath)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context sb.append(" does not contain library '") (line: 121) MethodCallExprContext{wrapped=sb.append(" does not contain library '")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context sb.append(" does not contain library '") (line: 121) MethodCallExprContext{wrapped=sb.append(" does not contain library '")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context sb.append(" contains a library named '") (line: 117) MethodCallExprContext{wrapped=sb.append(" contains a library named '")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context sb.append(" contains a library named '") (line: 117) MethodCallExprContext{wrapped=sb.append(" contains a library named '")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context sb.append(" contains a library named '") (line: 117) MethodCallExprContext{wrapped=sb.append(" contains a library named '")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call makeName(dimensions.toArray(new String[0])) java.lang.RuntimeException: String[] T[] /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/DefaultBinaryNamingScheme.java
Cannot solve method call builder.append(makeSeparated(elements)) java.lang.RuntimeException: Method 'makeSeparated' cannot be resolved in context makeSeparated(elements) (line: 151) MethodCallExprContext{wrapped=makeSeparated(elements)}. Parameter types: [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/DefaultBinaryNamingScheme.java
Cannot solve method call Character.toTitleCase(word.charAt(0)) java.lang.RuntimeException: Method 'charAt' cannot be resolved in context word.charAt(0) (line: 239) MethodCallExprContext{wrapped=word.charAt(0)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/DefaultBinaryNamingScheme.java
Cannot solve method call builder.append(Character.toTitleCase(word.charAt(0))) java.lang.RuntimeException: Error calculating the type of parameter word.charAt(0) of method call Character.toTitleCase(word.charAt(0)) /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/DefaultBinaryNamingScheme.java
Error calculating the type of parameter Character.toTitleCase(word.charAt(0)) of method call builder.append(Character.toTitleCase(word.charAt(0)))
Cannot solve method call Character.toLowerCase(word.charAt(0)) java.lang.RuntimeException: Method 'charAt' cannot be resolved in context word.charAt(0) (line: 246) MethodCallExprContext{wrapped=word.charAt(0)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/DefaultBinaryNamingScheme.java
Cannot solve method call builder.append(Character.toLowerCase(word.charAt(0))) java.lang.RuntimeException: Error calculating the type of parameter word.charAt(0) of method call Character.toLowerCase(word.charAt(0)) /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/DefaultBinaryNamingScheme.java
Error calculating the type of parameter Character.toLowerCase(word.charAt(0)) of method call builder.append(Character.toLowerCase(word.charAt(0)))
Cannot solve method call String.format("Multiple tasks with type '%s' found.", type.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context type.getSimpleName() (line: 66) MethodCallExprContext{wrapped=type.getSimpleName()}. Parameter types: [] /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/DefaultBinaryTasksCollection.java
Cannot solve method call String.format("Invalid %s: %s", type.getSimpleName(), target) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context type.getSimpleName() (line: 66) MethodCallExprContext{wrapped=type.getSimpleName()}. Parameter types: [] /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/DefaultPlatformResolvers.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call checkNotNull(emptyToNull(projectScopeName), "Name must be non empty") java.lang.RuntimeException: Method 'emptyToNull' cannot be resolved in context emptyToNull(projectScopeName) (line: 37) MethodCallExprContext{wrapped=emptyToNull(projectScopeName)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/dependents/DefaultDependentBinariesResolvedResult.java
Cannot solve field access PropertyAccessorType.SETTER
Cannot solve method call String.format("@Variant annotation only allowed for properties of type String and %s, but property has type %s", Named.class.getName(), propertyType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context propertyType.getName() (line: 48) MethodCallExprContext{wrapped=propertyType.getName()}. Parameter types: [] /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/VariantAspectExtractionStrategy.java
Cannot solve method call invalidProperty(extractionContext, property, String.format("@Variant annotation only allowed for properties of type String and %s, but property has type %s", Named.class.getName(), propertyType.getName())) java.lang.RuntimeException: Error calculating the type of parameter propertyType.getName() of method call String.format("@Variant annotation only allowed for properties of type String and %s, but property has type %s", Named.class.getName(), propertyType.getName()) /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/VariantAspectExtractionStrategy.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call String.format("Multiple tasks with type '%s' found.", type.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context type.getSimpleName() (line: 41) MethodCallExprContext{wrapped=type.getSimpleName()}. Parameter types: [] /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/BinaryTasksCollectionWrapper.java
Cannot solve method call String.format("A method %s must have a single parameter of type %s.", getDescription(), TypeBuilder.class.getName()) java.lang.RuntimeException: Method 'getDescription' cannot be resolved in context getDescription() (line: 79) MethodCallExprContext{wrapped=getDescription()}. Parameter types: [] /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/registry/ComponentTypeModelRuleExtractor.java
Cannot solve method call context.add(ruleDefinition, String.format("A method %s must have a single parameter of type %s.", getDescription(), TypeBuilder.class.getName())) java.lang.RuntimeException: Error calculating the type of parameter getDescription() of method call String.format("A method %s must have a single parameter of type %s.", getDescription(), TypeBuilder.class.getName()) /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/registry/ComponentTypeModelRuleExtractor.java
Cannot solve method call String.format("A method %s must have a single parameter of type %s.", getDescription(), TypeBuilder.class.getName()) java.lang.RuntimeException: Method 'getDescription' cannot be resolved in context getDescription() (line: 87) MethodCallExprContext{wrapped=getDescription()}. Parameter types: [] /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/registry/ComponentTypeModelRuleExtractor.java
Cannot solve method call context.add(ruleDefinition, String.format("A method %s must have a single parameter of type %s.", getDescription(), TypeBuilder.class.getName())) java.lang.RuntimeException: Error calculating the type of parameter getDescription() of method call String.format("A method %s must have a single parameter of type %s.", getDescription(), TypeBuilder.class.getName()) /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/registry/ComponentTypeModelRuleExtractor.java
Cannot solve method call String.format("Parameter of type %s must declare a type parameter.", rawSubjectType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context rawSubjectType.getName() (line: 93) MethodCallExprContext{wrapped=rawSubjectType.getName()}. Parameter types: [] /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/registry/ComponentTypeModelRuleExtractor.java
Cannot solve method call context.add(ruleDefinition, String.format("Parameter of type %s must declare a type parameter.", rawSubjectType.getName())) java.lang.RuntimeException: Error calculating the type of parameter rawSubjectType.getName() of method call String.format("Parameter of type %s must declare a type parameter.", rawSubjectType.getName()) /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/registry/ComponentTypeModelRuleExtractor.java
Cannot solve method call context.add(ruleDefinition, String.format("Type '%s' cannot be a wildcard type (i.e. cannot use ? super, ? extends etc.).", builtType.toString())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/registry/ComponentTypeModelRuleExtractor.java
Cannot solve method call context.add(ruleDefinition, String.format("Type '%s' is not a subtype of '%s'.", builtType.toString(), COMPONENT_SPEC_MODEL_TYPE.toString())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/registry/ComponentTypeModelRuleExtractor.java
Cannot solve method call String.format("Internal view %s must be an interface.", internalView.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context internalView.getName() (line: 142) MethodCallExprContext{wrapped=internalView.getName()}. Parameter types: [] /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/registry/ComponentTypeModelRuleExtractor.java
Cannot solve field access ModelActionRole.Mutate
Cannot solve method call sb.append(String.format(" is not a valid %s model rule method.", modelName)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/registry/ComponentTypeModelRuleExtractor.java
Cannot solve method call problems.add(ruleDefinition, String.format("The first parameter of a method %s must be of type %s.", getDescription(), ModelMap.class.getName())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/registry/AbstractAnnotationDrivenComponentModelRuleExtractor.java
Cannot solve method call problems.add(ruleDefinition, String.format("Parameter of type %s must declare a type parameter extending %s.", ModelMap.class.getSimpleName(), typeParameter.getDisplayName())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/registry/AbstractAnnotationDrivenComponentModelRuleExtractor.java
Cannot solve method call problems.add(ruleDefinition, String.format("%s type %s cannot be a wildcard type (i.e. cannot use ? super, ? extends etc.).", typeParameter.getDisplayName(), elementType.getDisplayName())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/registry/AbstractAnnotationDrivenComponentModelRuleExtractor.java
Cannot solve method call problems.add(ruleDefinition, String.format("A method %s must have one parameter extending %s. Found multiple parameter extending %s.", getDescription(), expectedDependency.getDisplayName(), expectedDependency.getDisplayName())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/registry/AbstractAnnotationDrivenComponentModelRuleExtractor.java
Cannot solve method call problems.add(ruleDefinition, String.format("A method %s must have one parameter extending %s. Found no parameter extending %s.", getDescription(), expectedDependency.getDisplayName(), expectedDependency.getDisplayName())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/registry/AbstractAnnotationDrivenComponentModelRuleExtractor.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot resolve field access null
Cannot resolve field access null
Method 'getSubject' cannot be resolved in context getSubject() (line: 93) MethodCallExprContext{wrapped=getSubject()}. Parameter types: []
Method 'getSubject' cannot be resolved in context getSubject() (line: 93) MethodCallExprContext{wrapped=getSubject()}. Parameter types: []
Cannot solve method call InstanceModelView.of(getSubject().getPath(), getSubject().getType(), binary) java.lang.RuntimeException: Method 'getSubject' cannot be resolved in context getSubject() (line: 93) MethodCallExprContext{wrapped=getSubject()}. Parameter types: [] /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/registry/BinaryTasksModelRuleExtractor.java
Cannot solve method call inputsWithBinary.add(InstanceModelView.of(getSubject().getPath(), getSubject().getType(), binary)) java.lang.RuntimeException: Error calculating the type of parameter getSubject().getPath() of method call InstanceModelView.of(getSubject().getPath(), getSubject().getType(), binary) /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/registry/BinaryTasksModelRuleExtractor.java
Cannot solve field access ModelActionRole.Defaults
Cannot solve field access ModelActionRole.Finalize
Cannot solve method call DirectNodeNoInputsModelAction.of(BINARIES_CONTAINER, ruleDefinition.getDescriptor(), new Action<MutableModelNode>() {

    @Override
    public void execute(MutableModelNode modelNode) {
        modelNode.applyTo(allLinks(), ModelActionRole.Finalize, binaryTaskAction);
    }
}) java.lang.RuntimeException: Method 'getDescriptor' cannot be resolved in context ruleDefinition.getDescriptor() (line: 114) MethodCallExprContext{wrapped=ruleDefinition.getDescriptor()}. Parameter types: [] /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/registry/BinaryTasksModelRuleExtractor.java
Method 'getRegistry' cannot be resolved in context context.getRegistry() (line: 112) MethodCallExprContext{wrapped=context.getRegistry()}. Parameter types: []
Cannot solve field access RuleApplicationScope.DESCENDANTS
Cannot solve field access ModelActionRole.Finalize
Cannot solve method call String.format("Method annotated with @%s cannot set default implementation for managed type %s.", markerAnnotation.getSimpleName(), schema.getType().getName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context markerAnnotation.getSimpleName() (line: 42) MethodCallExprContext{wrapped=markerAnnotation.getSimpleName()}. Parameter types: [] /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/registry/DefaultTypeBuilder.java
Cannot solve method call String.format("Method annotated with @%s cannot set default implementation multiple times.", markerAnnotation.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context markerAnnotation.getSimpleName() (line: 45) MethodCallExprContext{wrapped=markerAnnotation.getSimpleName()}. Parameter types: [] /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/registry/DefaultTypeBuilder.java
Cannot solve method call String.format("Internal view '%s' must not be specified multiple times.", internalView.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context internalView.getName() (line: 59) MethodCallExprContext{wrapped=internalView.getName()}. Parameter types: [] /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/internal/registry/DefaultTypeBuilder.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call String.format("Could not create binary of type %s", publicType.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context publicType.getSimpleName() (line: 70) MethodCallExprContext{wrapped=publicType.getSimpleName()}. Parameter types: [] /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/binary/BaseBinarySpec.java
Cannot solve field access ModelActionRole.Create
Cannot solve method call ModelRegistrations.of(modelNode.getPath().child("tasks")) java.lang.RuntimeException: Method 'child' cannot be resolved in context modelNode.getPath().child("tasks") (line: 89) MethodCallExprContext{wrapped=modelNode.getPath().child("tasks")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/binary/BaseBinarySpec.java
Error calculating the type of parameter modelNode.getPath().child("tasks") of method call ModelRegistrations.of(modelNode.getPath().child("tasks"))
Error calculating the type of parameter modelNode.getPath().child("tasks") of method call ModelRegistrations.of(modelNode.getPath().child("tasks"))
Error calculating the type of parameter modelNode.getPath().child("tasks") of method call ModelRegistrations.of(modelNode.getPath().child("tasks"))
Error calculating the type of parameter modelNode.getPath().child("tasks") of method call ModelRegistrations.of(modelNode.getPath().child("tasks"))
Cannot solve method call String.format("Could not create component of type %s", publicType.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context publicType.getSimpleName() (line: 35) MethodCallExprContext{wrapped=publicType.getSimpleName()}. Parameter types: [] /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/component/internal/DefaultComponentSpec.java
Cannot solve method call tasks.addAll(binary.getTasks()) java.lang.RuntimeException: Method 'getTasks' cannot be resolved in context binary.getTasks() (line: 60) MethodCallExprContext{wrapped=binary.getTasks()}. Parameter types: [] /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/plugins/BinaryBasePlugin.java
Cannot solve method call binaryLifecycleTask.setDescription(String.format("Assembles %s.", binary)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.platform.base.internal.BinarySpecInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/platform-base/src/main/java/org/gradle/platform/base/plugins/BinaryBasePlugin.java
Cannot solve field access SysProp.VERSION
Cannot solve field access InstallType.IS_JDK
Cannot solve field access InstallType.NO_SUCH_DIRECTORY
Cannot solve field access SysProp.VERSION
Cannot solve field access InstallType.INVALID_JDK
Cannot solve field access SysProp.Z_ERROR
Cannot solve field access InstallType.INVALID_JDK
Method 'javaExe' cannot be resolved in context javaExe(jdkPath, "javac") (line: 135) MethodCallExprContext{wrapped=javaExe(jdkPath, "javac")}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve field access InstallType.IS_JDK
Cannot solve field access InstallType.IS_JRE
Cannot solve method call exec.executable(javaExe(jdkPath, "java")) java.lang.RuntimeException: Method 'javaExe' cannot be resolved in context javaExe(jdkPath, "java") (line: 143) MethodCallExprContext{wrapped=javaExe(jdkPath, "java")}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/toolchain/internal/JavaInstallationProbe.java
Cannot solve method call error(ex.getMessage()) java.lang.RuntimeException: Method 'getMessage' cannot be resolved in context ex.getMessage() (line: 162) MethodCallExprContext{wrapped=ex.getMessage()}. Parameter types: [] /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/toolchain/internal/JavaInstallationProbe.java
Cannot solve field access InstallType.IS_JDK
Cannot resolve field access null
Cannot solve field access JavaInstallationProbe.SysProp.VENDOR
Cannot resolve field access null
Cannot solve field access JavaInstallationProbe.SysProp.VM
Cannot solve field access InstallType.IS_JDK
Cannot solve method call cw.visit(V1_1, ACC_PUBLIC + ACC_SUPER, CLASSNAME, null, "java/lang/Object", null) UnsolvedSymbolException{context='Solving V1_1', name='V1_1', typeSolver=null} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/toolchain/internal/JavaInstallationProbe.java
Cannot solve method call cw.visitMethod(ACC_PUBLIC + ACC_STATIC, "main", "([Ljava/lang/String;)V", null, null) UnsolvedSymbolException{context='Solving ACC_PUBLIC', name='ACC_PUBLIC', typeSolver=null} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/toolchain/internal/JavaInstallationProbe.java
Cannot solve field access SysProp.Z_ERROR
Cannot solve method call mv.visitInsn(RETURN) UnsolvedSymbolException{context='Solving RETURN', name='RETURN', typeSolver=null} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/toolchain/internal/JavaInstallationProbe.java
Cannot solve method call mv.visitFieldInsn(GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;") UnsolvedSymbolException{context='Solving GETSTATIC', name='GETSTATIC', typeSolver=null} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/toolchain/internal/JavaInstallationProbe.java
Cannot solve method call mv.visitMethodInsn(INVOKESTATIC, "java/lang/System", "getProperty", "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;", false) UnsolvedSymbolException{context='Solving INVOKESTATIC', name='INVOKESTATIC', typeSolver=null} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/toolchain/internal/JavaInstallationProbe.java
Cannot solve method call mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V", false) UnsolvedSymbolException{context='Solving INVOKEVIRTUAL', name='INVOKEVIRTUAL', typeSolver=null} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/toolchain/internal/JavaInstallationProbe.java
Cannot solve method call cw.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null) UnsolvedSymbolException{context='Solving ACC_PUBLIC', name='ACC_PUBLIC', typeSolver=null} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/toolchain/internal/JavaInstallationProbe.java
Cannot solve method call mv.visitVarInsn(ALOAD, 0) UnsolvedSymbolException{context='Solving ALOAD', name='ALOAD', typeSolver=null} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/toolchain/internal/JavaInstallationProbe.java
Cannot solve method call mv.visitMethodInsn(INVOKESPECIAL, "java/lang/Object", "<init>", "()V", false) UnsolvedSymbolException{context='Solving INVOKESPECIAL', name='INVOKESPECIAL', typeSolver=null} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/toolchain/internal/JavaInstallationProbe.java
Cannot solve method call mv.visitInsn(RETURN) UnsolvedSymbolException{context='Solving RETURN', name='RETURN', typeSolver=null} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/toolchain/internal/JavaInstallationProbe.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve field access SysProp.Z_ERROR
Cannot solve field access SysProp.Z_ERROR
Cannot solve method call result.put(type, System.getProperty(type.sysProp, UNKNOWN)) UnsolvedSymbolException{context='Method 'getProperty' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=java.lang.System}'} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/toolchain/internal/JavaInstallationProbe.java
Cannot solve method call registration.add(VariantAxisCompatibilityFactory.class, DefaultVariantAxisCompatibilityFactory.of(JavaPlatform.class, new DefaultJavaPlatformVariantAxisCompatibility())) UnsolvedSymbolException{context='Method 'of' with parameterTypes [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.jvm.platform.JavaPlatform, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{org.gradle.jvm.internal.resolve.DefaultJavaPlatformVariantAxisCompatibility, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=public class DefaultVariantAxisCompatibilityFactory implements VariantAxisCompatibilityFactory {

    private final Class<?> predicate;

    private final VariantAxisCompatibility<?> selector;

    public static <T> DefaultVariantAxisCompatibilityFactory of(Class<T> clazz, VariantAxisCompatibility<T> selector) {
        return new DefaultVariantAxisCompatibilityFactory(clazz, selector);
    }

    private DefaultVariantAxisCompatibilityFactory(Class<?> clazz, VariantAxisCompatibility<?> selector) {
        this.predicate = clazz;
        this.selector = selector;
    }

    @Override
    public <T> VariantAxisCompatibility<T> getVariantAxisCompatibility(T o) {
        if (o != null && predicate.isAssignableFrom(o.getClass())) {
            return Cast.uncheckedCast(selector);
        }
        return null;
    }
}}'} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/internal/services/PlatformJvmServices.java
Cannot solve method call format("Invalid public API specification: %s", cause.getMessage()) java.lang.RuntimeException: Method 'getMessage' cannot be resolved in context cause.getMessage() (line: 50) MethodCallExprContext{wrapped=cause.getMessage()}. Parameter types: [] /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/internal/DefaultJvmApiSpec.java
Cannot solve method call ConfigureUtil.configure(configureAction, dependencies) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/internal/DefaultJvmApiSpec.java
Method 'append' cannot be resolved in context variantDescriptor.append("    - ") (line: 53) MethodCallExprContext{wrapped=variantDescriptor.append("    - ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context variantDescriptor.append("    - ") (line: 53) MethodCallExprContext{wrapped=variantDescriptor.append("    - ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context variantDescriptor.append(renderAxisName(axis)) (line: 62) MethodCallExprContext{wrapped=variantDescriptor.append(renderAxisName(axis))}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context variantDescriptor.append(renderAxisName(axis)) (line: 62) MethodCallExprContext{wrapped=variantDescriptor.append(renderAxisName(axis))}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context variantDescriptor.append(renderAxisName(axis)) (line: 62) MethodCallExprContext{wrapped=variantDescriptor.append(renderAxisName(axis))}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call variantDescriptor.append(TextUtil.toPlatformLineSeparators("]\n")) UnsolvedSymbolException{context='Method 'toPlatformLineSeparators' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=public class TextUtil {

    private static final Pattern WHITESPACE = Pattern.compile("\\s*");

    /**
     * Returns the line separator for Windows.
     */
    public static String getWindowsLineSeparator() {
        return "\r\n";
    }

    /**
     * Returns the line separator for Unix.
     */
    public static String getUnixLineSeparator() {
        return "\n";
    }

    /**
     * Returns the line separator for this platform.
     */
    public static String getPlatformLineSeparator() {
        return SystemProperties.getInstance().getLineSeparator();
    }

    /**
     * Converts all line separators in the specified string to the specified line separator.
     */
    public static String convertLineSeparators(String str, String sep) {
        return str == null ? null : str.replaceAll("\r\n|\r|\n", sep);
    }

    /**
     * Converts all line separators in the specified string to the platform's line separator.
     */
    public static String toPlatformLineSeparators(String str) {
        return str == null ? null : convertLineSeparators(str, getPlatformLineSeparator());
    }

    /**
     * Converts all line separators in the specified string to a single new line character.
     */
    public static String normaliseLineSeparators(String str) {
        return str == null ? null : convertLineSeparators(str, "\n");
    }

    /**
     * Converts all native file separators in the specified string to '/'.
     */
    public static String normaliseFileSeparators(String path) {
        return path.replaceAll(Pattern.quote(File.separator), "/");
    }

    /**
     * Escapes the toString() representation of {@code obj} for use in a literal string.
     * This is useful for interpolating variables into script strings, as well as in other situations.
     */
    public static String escapeString(Object obj) {
        return obj == null ? null : StringEscapeUtils.escapeJava(obj.toString());
    }

    /**
     * Tells whether the specified string contains any whitespace characters.
     */
    public static boolean containsWhitespace(String str) {
        for (int i = 0; i < str.length(); i++) {
            if (Character.isWhitespace(str.charAt(i))) {
                return true;
            }
        }
        return false;
    }

    /**
     * Indents every line of {@code text} by {@code indent}. Empty lines
     * and lines that only contain whitespace are not indented.
     */
    public static String indent(String text, String indent) {
        StringBuilder builder = new StringBuilder();
        String[] lines = text.split("\n");
        for (int i = 0; i < lines.length; i++) {
            String line = lines[i];
            if (!WHITESPACE.matcher(line).matches()) {
                builder.append(indent);
            }
            builder.append(line);
            if (i < lines.length - 1) {
                builder.append('\n');
            }
        }
        return builder.toString();
    }

    public static String shorterOf(String s1, String s2) {
        if (s2.length() >= s1.length()) {
            return s1;
        } else {
            return s2;
        }
    }

    public static String normaliseFileAndLineSeparators(String in) {
        return normaliseLineSeparators(normaliseFileSeparators(in));
    }
}}'} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/internal/resolve/DefaultLibraryResolutionErrorMessageBuilder.java
Cannot solve method call String.format(TextUtil.toPlatformLineSeparators("Multiple compatible variants found for library '%s':\n"), libraryName) UnsolvedSymbolException{context='Method 'toPlatformLineSeparators' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=public class TextUtil {

    private static final Pattern WHITESPACE = Pattern.compile("\\s*");

    /**
     * Returns the line separator for Windows.
     */
    public static String getWindowsLineSeparator() {
        return "\r\n";
    }

    /**
     * Returns the line separator for Unix.
     */
    public static String getUnixLineSeparator() {
        return "\n";
    }

    /**
     * Returns the line separator for this platform.
     */
    public static String getPlatformLineSeparator() {
        return SystemProperties.getInstance().getLineSeparator();
    }

    /**
     * Converts all line separators in the specified string to the specified line separator.
     */
    public static String convertLineSeparators(String str, String sep) {
        return str == null ? null : str.replaceAll("\r\n|\r|\n", sep);
    }

    /**
     * Converts all line separators in the specified string to the platform's line separator.
     */
    public static String toPlatformLineSeparators(String str) {
        return str == null ? null : convertLineSeparators(str, getPlatformLineSeparator());
    }

    /**
     * Converts all line separators in the specified string to a single new line character.
     */
    public static String normaliseLineSeparators(String str) {
        return str == null ? null : convertLineSeparators(str, "\n");
    }

    /**
     * Converts all native file separators in the specified string to '/'.
     */
    public static String normaliseFileSeparators(String path) {
        return path.replaceAll(Pattern.quote(File.separator), "/");
    }

    /**
     * Escapes the toString() representation of {@code obj} for use in a literal string.
     * This is useful for interpolating variables into script strings, as well as in other situations.
     */
    public static String escapeString(Object obj) {
        return obj == null ? null : StringEscapeUtils.escapeJava(obj.toString());
    }

    /**
     * Tells whether the specified string contains any whitespace characters.
     */
    public static boolean containsWhitespace(String str) {
        for (int i = 0; i < str.length(); i++) {
            if (Character.isWhitespace(str.charAt(i))) {
                return true;
            }
        }
        return false;
    }

    /**
     * Indents every line of {@code text} by {@code indent}. Empty lines
     * and lines that only contain whitespace are not indented.
     */
    public static String indent(String text, String indent) {
        StringBuilder builder = new StringBuilder();
        String[] lines = text.split("\n");
        for (int i = 0; i < lines.length; i++) {
            String line = lines[i];
            if (!WHITESPACE.matcher(line).matches()) {
                builder.append(indent);
            }
            builder.append(line);
            if (i < lines.length - 1) {
                builder.append('\n');
            }
        }
        return builder.toString();
    }

    public static String shorterOf(String s1, String s2) {
        if (s2.length() >= s1.length()) {
            return s1;
        } else {
            return s2;
        }
    }

    public static String normaliseFileAndLineSeparators(String in) {
        return normaliseLineSeparators(normaliseFileSeparators(in));
    }
}}'} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/internal/resolve/DefaultLibraryResolutionErrorMessageBuilder.java
Cannot solve method call String.format("%s but with an incompatible type (expected '%s' was '%s')", message, variantsMetaData.getVariantAxisType(variantAxis).getConcreteClass().getName(), md.getVariantAxisType(variantAxis).getConcreteClass().getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context variantsMetaData.getVariantAxisType(variantAxis).getConcreteClass().getName() (line: 86) MethodCallExprContext{wrapped=variantsMetaData.getVariantAxisType(variantAxis).getConcreteClass().getName()}. Parameter types: [] /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/internal/resolve/DefaultLibraryResolutionErrorMessageBuilder.java
Cannot solve method call String.format(TextUtil.toPlatformLineSeparators("Cannot find a compatible variant for library '%s'.\n"), libraryName) UnsolvedSymbolException{context='Method 'toPlatformLineSeparators' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=public class TextUtil {

    private static final Pattern WHITESPACE = Pattern.compile("\\s*");

    /**
     * Returns the line separator for Windows.
     */
    public static String getWindowsLineSeparator() {
        return "\r\n";
    }

    /**
     * Returns the line separator for Unix.
     */
    public static String getUnixLineSeparator() {
        return "\n";
    }

    /**
     * Returns the line separator for this platform.
     */
    public static String getPlatformLineSeparator() {
        return SystemProperties.getInstance().getLineSeparator();
    }

    /**
     * Converts all line separators in the specified string to the specified line separator.
     */
    public static String convertLineSeparators(String str, String sep) {
        return str == null ? null : str.replaceAll("\r\n|\r|\n", sep);
    }

    /**
     * Converts all line separators in the specified string to the platform's line separator.
     */
    public static String toPlatformLineSeparators(String str) {
        return str == null ? null : convertLineSeparators(str, getPlatformLineSeparator());
    }

    /**
     * Converts all line separators in the specified string to a single new line character.
     */
    public static String normaliseLineSeparators(String str) {
        return str == null ? null : convertLineSeparators(str, "\n");
    }

    /**
     * Converts all native file separators in the specified string to '/'.
     */
    public static String normaliseFileSeparators(String path) {
        return path.replaceAll(Pattern.quote(File.separator), "/");
    }

    /**
     * Escapes the toString() representation of {@code obj} for use in a literal string.
     * This is useful for interpolating variables into script strings, as well as in other situations.
     */
    public static String escapeString(Object obj) {
        return obj == null ? null : StringEscapeUtils.escapeJava(obj.toString());
    }

    /**
     * Tells whether the specified string contains any whitespace characters.
     */
    public static boolean containsWhitespace(String str) {
        for (int i = 0; i < str.length(); i++) {
            if (Character.isWhitespace(str.charAt(i))) {
                return true;
            }
        }
        return false;
    }

    /**
     * Indents every line of {@code text} by {@code indent}. Empty lines
     * and lines that only contain whitespace are not indented.
     */
    public static String indent(String text, String indent) {
        StringBuilder builder = new StringBuilder();
        String[] lines = text.split("\n");
        for (int i = 0; i < lines.length; i++) {
            String line = lines[i];
            if (!WHITESPACE.matcher(line).matches()) {
                builder.append(indent);
            }
            builder.append(line);
            if (i < lines.length - 1) {
                builder.append('\n');
            }
        }
        return builder.toString();
    }

    public static String shorterOf(String s1, String s2) {
        if (s2.length() >= s1.length()) {
            return s1;
        } else {
            return s2;
        }
    }

    public static String normaliseFileAndLineSeparators(String in) {
        return normaliseLineSeparators(normaliseFileSeparators(in));
    }
}}'} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/internal/resolve/DefaultLibraryResolutionErrorMessageBuilder.java
Method 'append' cannot be resolved in context error.append("    Required ") (line: 97) MethodCallExprContext{wrapped=error.append("    Required ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context error.append("    Required ") (line: 97) MethodCallExprContext{wrapped=error.append("    Required ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context error.append("    Required ") (line: 97) MethodCallExprContext{wrapped=error.append("    Required ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context error.append("    Required ") (line: 97) MethodCallExprContext{wrapped=error.append("    Required ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context error.append(", available: ") (line: 100) MethodCallExprContext{wrapped=error.append(", available: ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Error calculating the type of parameter joiner.join(available) of method call error.append(", available: ").append(joiner.join(available))
Cannot solve method call toStringMap(buildDependenciesPerUsage) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/internal/resolve/JvmLocalLibraryMetaDataAdapter.java
Cannot solve method call toStringMap(dependenciesPerUsage) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/internal/resolve/JvmLocalLibraryMetaDataAdapter.java
Cannot solve method call newResolvedLibraryMetadata(selectedBinary.getId(), toStringMap(buildDependenciesPerUsage), toStringMap(dependenciesPerUsage), projectPath) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/internal/resolve/JvmLocalLibraryMetaDataAdapter.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call UsageKind.valueOf(tEntry.getKey().name()) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/internal/resolve/JvmLocalLibraryMetaDataAdapter.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve field access UsageKind.API
Cannot solve field access UsageKind.RUNTIME
Cannot solve field access UsageKind.API
Cannot solve field access UsageKind.RUNTIME
Cannot solve field access UsageKind.API
Cannot solve field access UsageKind.RUNTIME
Cannot solve field access UsageKind.API
Cannot solve field access UsageKind.RUNTIME
Cannot solve method call addArtifact(UsageKind.RUNTIME, Sets.union(assembly.getClassDirectories(), assembly.getResourceDirectories()), artifacts) UnsolvedSymbolException{context='Method 'union' with parameterTypes [ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Sets}'} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/internal/resolve/JvmLocalLibraryMetaDataAdapter.java
Cannot solve method call dependenciesPerUsage.put(usage, Iterables.concat(dependencies, dependencySpecs)) UnsolvedSymbolException{context='Method 'concat' with parameterTypes [ReferenceType{Iterable, typeParametersMap=TypeParametersMap{nameToValue={empty.BlockDoc=ReferenceType{org.gradle.platform.base.DependencySpec, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{Iterable, typeParametersMap=TypeParametersMap{nameToValue={empty.BlockDoc=ReferenceType{org.gradle.platform.base.DependencySpec, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/internal/resolve/JvmLocalLibraryMetaDataAdapter.java
Cannot solve field access UsageKind.API
Cannot resolve field access null
Cannot solve method call Sets.intersection(resolveDimensions, binaryVariants.getNonNullVariantAxes()) java.lang.RuntimeException: Method 'getNonNullVariantAxes' cannot be resolved in context binaryVariants.getNonNullVariantAxes() (line: 70) MethodCallExprContext{wrapped=binaryVariants.getNonNullVariantAxes()}. Parameter types: [] /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/internal/resolve/VariantsMatcher.java
Method 'getVariantAxisType' cannot be resolved in context variantsMetaData.getVariantAxisType(dimension) (line: 74) MethodCallExprContext{wrapped=variantsMetaData.getVariantAxisType(dimension)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call variantsMetaData.getValueAsType(Cast.<Class<? extends Named>>uncheckedCast(dimensionType), dimension) UnsolvedSymbolException{context='Method 'uncheckedCast' with parameterTypes [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=null, boundedType=null}}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class Cast {

    /**
     * Casts the given object to the given type, providing a better error message than the default.
     *
     * The standard {@link Class#cast(Object)} method produces unsatisfactory error messages on some platforms
     * when it fails. All this method does is provide a better, consistent, error message.
     *
     * This should be used whenever there is a chance the cast could fail. If in doubt, use this.
     *
     * @param outputType The type to cast the input to
     * @param object The object to be cast
     * @param <O> The type to be cast to
     * @param <I> The type of the object to be vast
     * @return The input object, cast to the output type
     */
    public static <O, I> O cast(Class<O> outputType, I object) {
        try {
            return outputType.cast(object);
        } catch (ClassCastException e) {
            throw new ClassCastException(String.format("Failed to cast object %s of type %s to target type %s", object, object.getClass().getName(), outputType.getName()));
        }
    }

    @SuppressWarnings("unchecked")
    public static <T> T uncheckedCast(Object object) {
        return (T) object;
    }
}}'} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/internal/resolve/VariantsMatcher.java
Cannot solve method call binaryVariants.getValueAsType(Cast.<Class<? extends Named>>uncheckedCast(dimensionType), dimension) UnsolvedSymbolException{context='Method 'uncheckedCast' with parameterTypes [ReferenceType{Class, typeParametersMap=TypeParametersMap{nameToValue={empty.?=WildcardUsage{type=null, boundedType=null}}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class Cast {

    /**
     * Casts the given object to the given type, providing a better error message than the default.
     *
     * The standard {@link Class#cast(Object)} method produces unsatisfactory error messages on some platforms
     * when it fails. All this method does is provide a better, consistent, error message.
     *
     * This should be used whenever there is a chance the cast could fail. If in doubt, use this.
     *
     * @param outputType The type to cast the input to
     * @param object The object to be cast
     * @param <O> The type to be cast to
     * @param <I> The type of the object to be vast
     * @return The input object, cast to the output type
     */
    public static <O, I> O cast(Class<O> outputType, I object) {
        try {
            return outputType.cast(object);
        } catch (ClassCastException e) {
            throw new ClassCastException(String.format("Failed to cast object %s of type %s to target type %s", object, object.getClass().getName(), outputType.getName()));
        }
    }

    @SuppressWarnings("unchecked")
    public static <T> T uncheckedCast(Object object) {
        return (T) object;
    }
}}'} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/internal/resolve/VariantsMatcher.java
Cannot solve method call Iterables.transform(selectedVariants.get(dimension), VariantValue.SPEC_FUNCTION) UnsolvedSymbolException{context='unknown', name='TreeMultimap', typeSolver=null} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/internal/resolve/VariantsMatcher.java
Cannot solve method call ImmutableSet.copyOf(Iterables.transform(selectedVariants.get(dimension), VariantValue.SPEC_FUNCTION)) java.lang.RuntimeException: Error calculating the type of parameter selectedVariants.get(dimension) of method call Iterables.transform(selectedVariants.get(dimension), VariantValue.SPEC_FUNCTION) /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/internal/resolve/VariantsMatcher.java
Method 'append' cannot be resolved in context sb.append("spec=") (line: 129) MethodCallExprContext{wrapped=sb.append("spec=")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context sb.append(", value=") (line: 130) MethodCallExprContext{wrapped=sb.append(", value=")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call predicate.isAssignableFrom(o.getClass()) java.lang.RuntimeException: Method 'getClass' cannot be resolved in context o.getClass() (line: 36) MethodCallExprContext{wrapped=o.getClass()}. Parameter types: [] /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/internal/resolve/DefaultVariantAxisCompatibilityFactory.java
Cannot solve method call ImmutableSet.copyOf(Maps.filterEntries(variantCoordinates, new Predicate<Map.Entry<String, Object>>() {

    @Override
    public boolean apply(Map.Entry<String, Object> input) {
        return input.getValue() != null;
    }
}).keySet()) UnsolvedSymbolException{context='Method 'filterEntries' with parameterTypes [ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{Predicate, typeParametersMap=TypeParametersMap{nameToValue={empty.? super ScriptBlock=ReferenceType{java.util.Map.Entry, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.Entry.K=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.Entry.V=ReferenceType{Predicate, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Maps}'} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/internal/resolve/DefaultVariantsMetaData.java
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
Cannot solve method call Character.isJavaIdentifierStart(token.charAt(0)) java.lang.RuntimeException: Method 'charAt' cannot be resolved in context token.charAt(0) (line: 111) MethodCallExprContext{wrapped=token.charAt(0)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/internal/JvmPackageName.java
Method 'substring' cannot be resolved in context token.substring(1) (line: 115) MethodCallExprContext{wrapped=token.substring(1)}. Parameter types: [PrimitiveTypeUsage{name='int'}]
Cannot solve method call ConfigureUtil.configure(configureClosure, getManifest()) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/tasks/Jar.java
Cannot solve method call ConfigureUtil.configure(configureClosure, getMetaInf()) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/tasks/Jar.java
Cannot solve method call mv.visitMethodInsn(INVOKESTATIC, internalClassName, UOE_METHOD, "()Ljava/lang/UnsupportedOperationException;", false) UnsolvedSymbolException{context='Solving INVOKESTATIC', name='INVOKESTATIC', typeSolver=null} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/tasks/api/internal/MethodStubbingApiMemberAdapter.java
Cannot solve method call mv.visitInsn(ATHROW) UnsolvedSymbolException{context='Solving ATHROW', name='ATHROW', typeSolver=null} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/tasks/api/internal/MethodStubbingApiMemberAdapter.java
Cannot solve method call mv.visitTypeInsn(NEW, "java/lang/UnsupportedOperationException") UnsolvedSymbolException{context='Solving NEW', name='NEW', typeSolver=null} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/tasks/api/internal/MethodStubbingApiMemberAdapter.java
Cannot solve method call mv.visitInsn(DUP) UnsolvedSymbolException{context='Solving DUP', name='DUP', typeSolver=null} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/tasks/api/internal/MethodStubbingApiMemberAdapter.java
Cannot solve method call mv.visitMethodInsn(INVOKESPECIAL, "java/lang/UnsupportedOperationException", "<init>", "(Ljava/lang/String;)V", false) UnsolvedSymbolException{context='Solving INVOKESPECIAL', name='INVOKESPECIAL', typeSolver=null} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/tasks/api/internal/MethodStubbingApiMemberAdapter.java
Cannot solve method call mv.visitInsn(ARETURN) UnsolvedSymbolException{context='Solving ARETURN', name='ARETURN', typeSolver=null} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/tasks/api/internal/MethodStubbingApiMemberAdapter.java
Method 'compare' cannot be resolved in context super.compare(o).compare(parameter, ((ParameterAnnotationMember) o).parameter) (line: 34) MethodCallExprContext{wrapped=super.compare(o).compare(parameter, ((ParameterAnnotationMember) o).parameter)}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}]
Method 'compare' cannot be resolved in context super.compare(o).compare(outerName == null ? "" : outerName, o.outerName == null ? "" : o.outerName) (line: 40) MethodCallExprContext{wrapped=super.compare(o).compare(outerName == null ? "" : outerName, o.outerName == null ? "" : o.outerName)}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'compare' cannot be resolved in context super.compare(o).compare(outerName == null ? "" : outerName, o.outerName == null ? "" : o.outerName) (line: 40) MethodCallExprContext{wrapped=super.compare(o).compare(outerName == null ? "" : outerName, o.outerName == null ? "" : o.outerName)}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call apiMemberAdapter.visit(classMember.getVersion(), classMember.getAccess(), classMember.getName(), classMember.getSignature(), classMember.getSuperName(), classMember.getInterfaces()) java.lang.RuntimeException: Method 'getVersion' cannot be resolved in context classMember.getVersion() (line: 66) MethodCallExprContext{wrapped=classMember.getVersion()}. Parameter types: [] /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/tasks/api/internal/ApiMemberSelector.java
Cannot solve method call visitAnnotationMembers(classMember.getAnnotations()) java.lang.RuntimeException: Method 'getAnnotations' cannot be resolved in context classMember.getAnnotations() (line: 68) MethodCallExprContext{wrapped=classMember.getAnnotations()}. Parameter types: [] /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/tasks/api/internal/ApiMemberSelector.java
Method 'getExceptions' cannot be resolved in context method.getExceptions() (line: 72) MethodCallExprContext{wrapped=method.getExceptions()}. Parameter types: []
Cannot solve method call apiMemberAdapter.visitMethod(method.getAccess(), method.getName(), method.getTypeDesc(), method.getSignature(), method.getExceptions().toArray(new String[0])) java.lang.RuntimeException: Method 'getAccess' cannot be resolved in context method.getAccess() (line: 71) MethodCallExprContext{wrapped=method.getAccess()}. Parameter types: [] /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/tasks/api/internal/ApiMemberSelector.java
Cannot solve method call visitAnnotationMembers(mv, method.getAnnotations()) java.lang.RuntimeException: Method 'getAnnotations' cannot be resolved in context method.getAnnotations() (line: 73) MethodCallExprContext{wrapped=method.getAnnotations()}. Parameter types: [] /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/tasks/api/internal/ApiMemberSelector.java
Cannot solve method call visitAnnotationMembers(mv, method.getParameterAnnotations()) java.lang.RuntimeException: Method 'getParameterAnnotations' cannot be resolved in context method.getParameterAnnotations() (line: 74) MethodCallExprContext{wrapped=method.getParameterAnnotations()}. Parameter types: [] /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/tasks/api/internal/ApiMemberSelector.java
Cannot solve method call apiMemberAdapter.visitField(field.getAccess(), field.getName(), field.getTypeDesc(), field.getSignature(), null) java.lang.RuntimeException: Method 'getAccess' cannot be resolved in context field.getAccess() (line: 79) MethodCallExprContext{wrapped=field.getAccess()}. Parameter types: [] /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/tasks/api/internal/ApiMemberSelector.java
Cannot solve method call visitAnnotationMembers(fieldVisitor, field.getAnnotations()) java.lang.RuntimeException: Method 'getAnnotations' cannot be resolved in context field.getAnnotations() (line: 80) MethodCallExprContext{wrapped=field.getAnnotations()}. Parameter types: [] /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/tasks/api/internal/ApiMemberSelector.java
Cannot solve method call apiMemberAdapter.visitInnerClass(innerClass.getName(), innerClass.getOuterName(), innerClass.getInnerName(), innerClass.getAccess()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context innerClass.getName() (line: 85) MethodCallExprContext{wrapped=innerClass.getName()}. Parameter types: [] /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/tasks/api/internal/ApiMemberSelector.java
Cannot solve method call apiMemberAdapter.visitAnnotation(annotation.getName(), annotation.isVisible()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context annotation.getName() (line: 93) MethodCallExprContext{wrapped=annotation.getName()}. Parameter types: [] /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/tasks/api/internal/ApiMemberSelector.java
Cannot solve method call mv.visitAnnotation(annotation.getName(), annotation.isVisible()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context annotation.getName() (line: 106) MethodCallExprContext{wrapped=annotation.getName()}. Parameter types: [] /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/tasks/api/internal/ApiMemberSelector.java
Cannot solve method call mv.visitParameterAnnotation(((ParameterAnnotationMember) annotation).getParameter(), annotation.getName(), annotation.isVisible()) java.lang.RuntimeException: Method 'getParameter' cannot be resolved in context ((ParameterAnnotationMember) annotation).getParameter() (line: 103) MethodCallExprContext{wrapped=((ParameterAnnotationMember) annotation).getParameter()}. Parameter types: [] /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/tasks/api/internal/ApiMemberSelector.java
Cannot solve method call fv.visitAnnotation(annotation.getName(), annotation.isVisible()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context annotation.getName() (line: 114) MethodCallExprContext{wrapped=annotation.getName()}. Parameter types: [] /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/tasks/api/internal/ApiMemberSelector.java
Cannot solve method call annotationVisitor.visitAnnotation(name, annotation.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context annotation.getName() (line: 141) MethodCallExprContext{wrapped=annotation.getName()}. Parameter types: [] /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/tasks/api/internal/ApiMemberSelector.java
Cannot solve method call annotationVisitor.visit(name, value.getValue()) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context value.getValue() (line: 131) MethodCallExprContext{wrapped=value.getValue()}. Parameter types: [] /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/tasks/api/internal/ApiMemberSelector.java
Cannot solve method call annotationVisitor.visitEnum(name, ((EnumAnnotationValue) value).getTypeDesc(), (String) value.getValue()) java.lang.RuntimeException: Method 'getTypeDesc' cannot be resolved in context ((EnumAnnotationValue) value).getTypeDesc() (line: 129) MethodCallExprContext{wrapped=((EnumAnnotationValue) value).getTypeDesc()}. Parameter types: [] /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/tasks/api/internal/ApiMemberSelector.java
Cannot solve method call isCandidateApiMember(originalClassReader.getAccess(), apiIncludesPackagePrivateMembers) java.lang.RuntimeException: Method 'getAccess' cannot be resolved in context originalClassReader.getAccess() (line: 61) MethodCallExprContext{wrapped=originalClassReader.getAccess()}. Parameter types: [] /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/tasks/api/internal/ApiClassExtractor.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call originalClassReader.accept(new ApiMemberSelector(new MethodStubbingApiMemberAdapter(apiClassWriter), apiIncludesPackagePrivateMembers), ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES) UnsolvedSymbolException{context='unknown', name='SKIP_DEBUG', typeSolver=null} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/tasks/api/internal/ApiClassExtractor.java
Method 'substring' cannot be resolved in context internalClassName.substring(0, packageSeparatorIndex) (line: 89) MethodCallExprContext{wrapped=internalClassName.substring(0, packageSeparatorIndex)}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}]
Method 'matcher' cannot be resolved in context LOCAL_CLASS_PATTERN.matcher(className) (line: 95) MethodCallExprContext{wrapped=LOCAL_CLASS_PATTERN.matcher(className)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot resolve field access null
Cannot solve method call super.compare(o).compare(exceptions, o.exceptions, Ordering.<String>natural().lexicographical()) UnsolvedSymbolException{context='Method 'natural' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Ordering}'} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/tasks/api/internal/MethodMember.java
Error calculating the type of parameter Ordering.<String>natural().lexicographical() of method call super.compare(o).compare(exceptions, o.exceptions, Ordering.<String>natural().lexicographical())
Method 'append' cannot be resolved in context methodDesc.append(Modifier.toString(getAccess())) (line: 62) MethodCallExprContext{wrapped=methodDesc.append(Modifier.toString(getAccess()))}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call methodDesc.append(Type.getReturnType(getTypeDesc()).getClassName()) UnsolvedSymbolException{context='Method 'getReturnType' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=org.objectweb.asm.Type}'} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/tasks/api/internal/MethodMember.java
Error calculating the type of parameter Type.getReturnType(getTypeDesc()).getClassName() of method call methodDesc.append(Type.getReturnType(getTypeDesc()).getClassName())
Cannot solve method call methodDesc.append(type.getClassName()) java.lang.RuntimeException: Method 'getClassName' cannot be resolved in context type.getClassName() (line: 69) MethodCallExprContext{wrapped=type.getClassName()}. Parameter types: [] /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/tasks/api/internal/MethodMember.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call String.format("%s %s %s", Modifier.toString(getAccess()), Type.getType(getTypeDesc()).getClassName(), getName()) UnsolvedSymbolException{context='Method 'getType' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=org.objectweb.asm.Type}'} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/tasks/api/internal/FieldMember.java
Cannot resolve field access null
Cannot solve method call String.format("Duplicate Java installation found:\n%s", Joiner.on("\n").join(errors)) UnsolvedSymbolException{context='Method 'on' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=Joiner}'} /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/plugins/JvmComponentPlugin.java
Empty name expression IS_JDK
Empty name expression IS_JRE
Empty name expression NO_SUCH_DIRECTORY
Empty name expression INVALID_JDK
Method 'withBinaryType' cannot be resolved in context DefaultBinaryNamingScheme.component(jvmLibrary.getName()).withBinaryType("Jar") (line: 259) MethodCallExprContext{wrapped=DefaultBinaryNamingScheme.component(jvmLibrary.getName()).withBinaryType("Jar")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'withBinaryType' cannot be resolved in context DefaultBinaryNamingScheme.component(jvmLibrary.getName()).withBinaryType("Jar") (line: 259) MethodCallExprContext{wrapped=DefaultBinaryNamingScheme.component(jvmLibrary.getName()).withBinaryType("Jar")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'dir' cannot be resolved in context apiJarTask.getInputs().dir(classDir) (line: 304) MethodCallExprContext{wrapped=apiJarTask.getInputs().dir(classDir)}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'dir' cannot be resolved in context apiJarTask.getInputs().dir(classDir) (line: 304) MethodCallExprContext{wrapped=apiJarTask.getInputs().dir(classDir)}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call binaryName.substring(0, binaryName.length() - 3) java.lang.RuntimeException: Method 'length' cannot be resolved in context binaryName.length() (line: 311) MethodCallExprContext{wrapped=binaryName.length()}. Parameter types: [] /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/plugins/JvmComponentPlugin.java
Cannot solve method call String.format("   - %s are both pointing to the same JDK installation path: %s", Joiner.on(", ").join(Iterables.transform(localJavas, new Function<LocalJava, String>() {

    @Override
    public String apply(LocalJava input) {
        return "'" + input.getName() + "'";
    }
})), path) java.lang.RuntimeException: Error calculating the type of parameter Iterables.transform(localJavas, new Function<LocalJava, String>() {

    @Override
    public String apply(LocalJava input) {
        return "'" + input.getName() + "'";
    }
}) of method call Joiner.on(", ").join(Iterables.transform(localJavas, new Function<LocalJava, String>() {

    @Override
    public String apply(LocalJava input) {
        return "'" + input.getName() + "'";
    }
})) /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/plugins/JvmComponentPlugin.java
Cannot solve method call errors.add(String.format("   - %s are both pointing to the same JDK installation path: %s", Joiner.on(", ").join(Iterables.transform(localJavas, new Function<LocalJava, String>() {

    @Override
    public String apply(LocalJava input) {
        return "'" + input.getName() + "'";
    }
})), path)) java.lang.RuntimeException: Error calculating the type of parameter Joiner.on(", ").join(Iterables.transform(localJavas, new Function<LocalJava, String>() {

    @Override
    public String apply(LocalJava input) {
        return "'" + input.getName() + "'";
    }
})) of method call String.format("   - %s are both pointing to the same JDK installation path: %s", Joiner.on(", ").join(Iterables.transform(localJavas, new Function<LocalJava, String>() {

    @Override
    public String apply(LocalJava input) {
        return "'" + input.getName() + "'";
    }
})), path) /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/plugins/JvmComponentPlugin.java
Cannot solve method call jvmBinary.setClassesDir(namingScheme.getOutputDirectory(buildDir, "classes")) java.lang.RuntimeException: Method 'getOutputDirectory' cannot be resolved in context namingScheme.getOutputDirectory(buildDir, "classes") (line: 356) MethodCallExprContext{wrapped=namingScheme.getOutputDirectory(buildDir, "classes")}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/plugins/JvmComponentPlugin.java
Cannot solve method call jvmBinary.setResourcesDir(namingScheme.getOutputDirectory(buildDir, "resources")) java.lang.RuntimeException: Method 'getOutputDirectory' cannot be resolved in context namingScheme.getOutputDirectory(buildDir, "resources") (line: 357) MethodCallExprContext{wrapped=namingScheme.getOutputDirectory(buildDir, "resources")}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-jvm/src/main/java/org/gradle/jvm/plugins/JvmComponentPlugin.java
Cannot solve method call delegate.from(mergePath) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/platform-jvm/src/main/java/org/gradle/api/java/archives/internal/CustomManifestInternalWrapper.java
Cannot solve method call delegate.from(mergePath, closure) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/platform-jvm/src/main/java/org/gradle/api/java/archives/internal/CustomManifestInternalWrapper.java
Cannot solve method call put(entry.getKey(), entry.getValue()) java.lang.RuntimeException: Method 'getKey' cannot be resolved in context entry.getKey() (line: 78) MethodCallExprContext{wrapped=entry.getKey()}. Parameter types: [] /repo/subprojects/platform-jvm/src/main/java/org/gradle/api/java/archives/internal/DefaultAttributes.java
Method 'getAttributes' cannot be resolved in context gradleManifest.getAttributes() (line: 143) MethodCallExprContext{wrapped=gradleManifest.getAttributes()}. Parameter types: []
Method 'getSections' cannot be resolved in context gradleManifest.getSections() (line: 151) MethodCallExprContext{wrapped=gradleManifest.getSections()}. Parameter types: []
Cannot solve method call from(mergePaths, null) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/platform-jvm/src/main/java/org/gradle/api/java/archives/internal/DefaultManifest.java
Cannot solve method call ConfigureUtil.configure(closure, mergeSpec) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/platform-jvm/src/main/java/org/gradle/api/java/archives/internal/DefaultManifest.java
Cannot solve method call generateJavaManifest(manifest.getEffectiveManifest()) java.lang.RuntimeException: Method 'getEffectiveManifest' cannot be resolved in context manifest.getEffectiveManifest() (line: 220) MethodCallExprContext{wrapped=manifest.getEffectiveManifest()}. Parameter types: [] /repo/subprojects/platform-jvm/src/main/java/org/gradle/api/java/archives/internal/DefaultManifest.java
Method 'toString' cannot be resolved in context buffer.toString(DEFAULT_CONTENT_CHARSET) (line: 228) MethodCallExprContext{wrapped=buffer.toString(DEFAULT_CONTENT_CHARSET)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call ConfigureUtil.configureUsing(mergeAction) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/platform-jvm/src/main/java/org/gradle/api/java/archives/internal/DefaultManifestMergeSpec.java
Cannot solve method call eachEntry(ConfigureUtil.configureUsing(mergeAction)) java.lang.RuntimeException: Error calculating the type of parameter mergeAction of method call ConfigureUtil.configureUsing(mergeAction) /repo/subprojects/platform-jvm/src/main/java/org/gradle/api/java/archives/internal/DefaultManifestMergeSpec.java
Cannot solve method call visitor.node(String.format("Could not find %s '%s'. Searched in", type.getToolName(), exeName)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/tools/ToolSearchPath.java
Cannot solve method call visitor.node(String.format("Could not find %s '%s' in system path.", type.getToolName(), exeName)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/tools/ToolSearchPath.java
Cannot solve field access LogLevel.WARN
Method 'concat' cannot be resolved in context "The source file ".concat(sourceFile.getName()).concat(" includes the header ").concat(pchHeader) (line: 153) MethodCallExprContext{wrapped="The source file ".concat(sourceFile.getName()).concat(" includes the header ").concat(pchHeader)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call String.format("Could not determine %s version: failed to execute %s %s.", getDescription(), gccBinary.getName(), Joiner.on(' ').join(allArgs)) UnsolvedSymbolException{context='Method 'on' with parameterTypes [PrimitiveTypeUsage{name='char'}]', name='ReflectionClassDeclaration{clazz=Joiner}'} /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/gcc/version/GccVersionDeterminer.java
Cannot solve field access ToolType.CPP_COMPILER
Cannot solve field access ToolType.CPP_COMPILER
Cannot solve field access ToolType.C_COMPILER
Cannot solve field access ToolType.C_COMPILER
Cannot solve field access ToolType.OBJECTIVECPP_COMPILER
Cannot solve field access ToolType.OBJECTIVECPP_COMPILER
Cannot solve field access ToolType.OBJECTIVEC_COMPILER
Cannot solve field access ToolType.OBJECTIVEC_COMPILER
Cannot solve field access ToolType.ASSEMBLER
Cannot solve field access ToolType.LINKER
Cannot solve field access ToolType.STATIC_LIB_ARCHIVER
Cannot solve method call result.unavailable(String.format("Don't know how to build for platform '%s'.", targetPlatform.getName())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/gcc/AbstractGccCompatibleToolChain.java
Cannot solve field access ToolType.C_COMPILER
Cannot solve field access ToolType.C_COMPILER
Cannot solve method call toolChain.add(instantiator.newInstance(DefaultGccCommandLineToolConfiguration.class, ToolType.C_COMPILER, "gcc")) java.lang.RuntimeException: Method 'newInstance' cannot be resolved in context instantiator.newInstance(DefaultGccCommandLineToolConfiguration.class, ToolType.C_COMPILER, "gcc") (line: 188) MethodCallExprContext{wrapped=instantiator.newInstance(DefaultGccCommandLineToolConfiguration.class, ToolType.C_COMPILER, "gcc")}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.nativeplatform.toolchain.internal.tools.DefaultGccCommandLineToolConfiguration, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{org.gradle.nativeplatform.toolchain.internal.ToolType, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/gcc/AbstractGccCompatibleToolChain.java
Cannot solve field access ToolType.CPP_COMPILER
Cannot solve method call toolChain.add(instantiator.newInstance(DefaultGccCommandLineToolConfiguration.class, ToolType.CPP_COMPILER, "g++")) java.lang.RuntimeException: Method 'newInstance' cannot be resolved in context instantiator.newInstance(DefaultGccCommandLineToolConfiguration.class, ToolType.CPP_COMPILER, "g++") (line: 189) MethodCallExprContext{wrapped=instantiator.newInstance(DefaultGccCommandLineToolConfiguration.class, ToolType.CPP_COMPILER, "g++")}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.nativeplatform.toolchain.internal.tools.DefaultGccCommandLineToolConfiguration, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{org.gradle.nativeplatform.toolchain.internal.ToolType, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/gcc/AbstractGccCompatibleToolChain.java
Cannot solve field access ToolType.LINKER
Cannot solve method call toolChain.add(instantiator.newInstance(DefaultGccCommandLineToolConfiguration.class, ToolType.LINKER, "g++")) java.lang.RuntimeException: Method 'newInstance' cannot be resolved in context instantiator.newInstance(DefaultGccCommandLineToolConfiguration.class, ToolType.LINKER, "g++") (line: 190) MethodCallExprContext{wrapped=instantiator.newInstance(DefaultGccCommandLineToolConfiguration.class, ToolType.LINKER, "g++")}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.nativeplatform.toolchain.internal.tools.DefaultGccCommandLineToolConfiguration, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{org.gradle.nativeplatform.toolchain.internal.ToolType, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/gcc/AbstractGccCompatibleToolChain.java
Cannot solve field access ToolType.STATIC_LIB_ARCHIVER
Cannot solve method call toolChain.add(instantiator.newInstance(DefaultGccCommandLineToolConfiguration.class, ToolType.STATIC_LIB_ARCHIVER, "ar")) java.lang.RuntimeException: Method 'newInstance' cannot be resolved in context instantiator.newInstance(DefaultGccCommandLineToolConfiguration.class, ToolType.STATIC_LIB_ARCHIVER, "ar") (line: 191) MethodCallExprContext{wrapped=instantiator.newInstance(DefaultGccCommandLineToolConfiguration.class, ToolType.STATIC_LIB_ARCHIVER, "ar")}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.nativeplatform.toolchain.internal.tools.DefaultGccCommandLineToolConfiguration, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{org.gradle.nativeplatform.toolchain.internal.ToolType, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/gcc/AbstractGccCompatibleToolChain.java
Cannot solve field access ToolType.OBJECTIVECPP_COMPILER
Cannot solve method call toolChain.add(instantiator.newInstance(DefaultGccCommandLineToolConfiguration.class, ToolType.OBJECTIVECPP_COMPILER, "g++")) java.lang.RuntimeException: Method 'newInstance' cannot be resolved in context instantiator.newInstance(DefaultGccCommandLineToolConfiguration.class, ToolType.OBJECTIVECPP_COMPILER, "g++") (line: 192) MethodCallExprContext{wrapped=instantiator.newInstance(DefaultGccCommandLineToolConfiguration.class, ToolType.OBJECTIVECPP_COMPILER, "g++")}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.nativeplatform.toolchain.internal.tools.DefaultGccCommandLineToolConfiguration, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{org.gradle.nativeplatform.toolchain.internal.ToolType, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/gcc/AbstractGccCompatibleToolChain.java
Cannot solve field access ToolType.OBJECTIVEC_COMPILER
Cannot solve method call toolChain.add(instantiator.newInstance(DefaultGccCommandLineToolConfiguration.class, ToolType.OBJECTIVEC_COMPILER, "gcc")) java.lang.RuntimeException: Method 'newInstance' cannot be resolved in context instantiator.newInstance(DefaultGccCommandLineToolConfiguration.class, ToolType.OBJECTIVEC_COMPILER, "gcc") (line: 193) MethodCallExprContext{wrapped=instantiator.newInstance(DefaultGccCommandLineToolConfiguration.class, ToolType.OBJECTIVEC_COMPILER, "gcc")}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.nativeplatform.toolchain.internal.tools.DefaultGccCommandLineToolConfiguration, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{org.gradle.nativeplatform.toolchain.internal.ToolType, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/gcc/AbstractGccCompatibleToolChain.java
Cannot solve field access ToolType.ASSEMBLER
Cannot solve method call toolChain.add(instantiator.newInstance(DefaultGccCommandLineToolConfiguration.class, ToolType.ASSEMBLER, "gcc")) java.lang.RuntimeException: Method 'newInstance' cannot be resolved in context instantiator.newInstance(DefaultGccCommandLineToolConfiguration.class, ToolType.ASSEMBLER, "gcc") (line: 194) MethodCallExprContext{wrapped=instantiator.newInstance(DefaultGccCommandLineToolConfiguration.class, ToolType.ASSEMBLER, "gcc")}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.nativeplatform.toolchain.internal.tools.DefaultGccCommandLineToolConfiguration, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{org.gradle.nativeplatform.toolchain.internal.ToolType, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/gcc/AbstractGccCompatibleToolChain.java
Cannot solve field access ToolType.C_COMPILER
Cannot solve field access ToolType.CPP_COMPILER
Cannot solve field access ToolType.OBJECTIVEC_COMPILER
Cannot solve field access ToolType.OBJECTIVECPP_COMPILER
Cannot solve field access ToolType.C_COMPILER
Cannot solve field access ToolType.CPP_COMPILER
Cannot solve field access ToolType.OBJECTIVEC_COMPILER
Cannot solve field access ToolType.OBJECTIVECPP_COMPILER
Cannot solve field access ToolType.ASSEMBLER
Cannot solve field access ToolType.LINKER
Cannot solve field access ToolType.STATIC_LIB_ARCHIVER
Cannot solve method call String.format("Don't know how to provide tool of type %s.", toolType.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context toolType.getSimpleName() (line: 79) MethodCallExprContext{wrapped=toolType.getSimpleName()}. Parameter types: [] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/UnavailablePlatformToolProvider.java
Method 'concat' cannot be resolved in context "#include \"".concat(header) (line: 59) MethodCallExprContext{wrapped="#include \"".concat(header)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call "Cannot determine source file extension for spec with type ".concat(specClass.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context specClass.getSimpleName() (line: 105) MethodCallExprContext{wrapped=specClass.getSimpleName()}. Parameter types: [] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/PCHUtils.java
Cannot solve method call toolExec.getEnvironment().containsKey(pathVar.toUpperCase()) java.lang.RuntimeException: Method 'toUpperCase' cannot be resolved in context pathVar.toUpperCase() (line: 68) MethodCallExprContext{wrapped=pathVar.toUpperCase()}. Parameter types: [] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/DefaultCommandLineToolInvocationWorker.java
Cannot solve method call toolExec.getEnvironment().remove(pathVar.toUpperCase()) java.lang.RuntimeException: Method 'toUpperCase' cannot be resolved in context pathVar.toUpperCase() (line: 69) MethodCallExprContext{wrapped=pathVar.toUpperCase()}. Parameter types: [] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/DefaultCommandLineToolInvocationWorker.java
Cannot solve field access ToolType.C_COMPILER
Cannot solve field access ToolType.C_COMPILER
Cannot solve method call tools.put(ToolType.C_COMPILER, instantiator.newInstance(DefaultCommandLineToolConfiguration.class, ToolType.C_COMPILER)) java.lang.RuntimeException: Method 'newInstance' cannot be resolved in context instantiator.newInstance(DefaultCommandLineToolConfiguration.class, ToolType.C_COMPILER) (line: 37) MethodCallExprContext{wrapped=instantiator.newInstance(DefaultCommandLineToolConfiguration.class, ToolType.C_COMPILER)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.nativeplatform.toolchain.internal.tools.DefaultCommandLineToolConfiguration, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{org.gradle.nativeplatform.toolchain.internal.ToolType, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/DefaultVisualCppPlatformToolChain.java
Cannot solve field access ToolType.CPP_COMPILER
Cannot solve field access ToolType.CPP_COMPILER
Cannot solve method call tools.put(ToolType.CPP_COMPILER, instantiator.newInstance(DefaultCommandLineToolConfiguration.class, ToolType.CPP_COMPILER)) java.lang.RuntimeException: Method 'newInstance' cannot be resolved in context instantiator.newInstance(DefaultCommandLineToolConfiguration.class, ToolType.CPP_COMPILER) (line: 38) MethodCallExprContext{wrapped=instantiator.newInstance(DefaultCommandLineToolConfiguration.class, ToolType.CPP_COMPILER)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.nativeplatform.toolchain.internal.tools.DefaultCommandLineToolConfiguration, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{org.gradle.nativeplatform.toolchain.internal.ToolType, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/DefaultVisualCppPlatformToolChain.java
Cannot solve field access ToolType.LINKER
Cannot solve field access ToolType.LINKER
Cannot solve method call tools.put(ToolType.LINKER, instantiator.newInstance(DefaultCommandLineToolConfiguration.class, ToolType.LINKER)) java.lang.RuntimeException: Method 'newInstance' cannot be resolved in context instantiator.newInstance(DefaultCommandLineToolConfiguration.class, ToolType.LINKER) (line: 39) MethodCallExprContext{wrapped=instantiator.newInstance(DefaultCommandLineToolConfiguration.class, ToolType.LINKER)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.nativeplatform.toolchain.internal.tools.DefaultCommandLineToolConfiguration, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{org.gradle.nativeplatform.toolchain.internal.ToolType, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/DefaultVisualCppPlatformToolChain.java
Cannot solve field access ToolType.STATIC_LIB_ARCHIVER
Cannot solve field access ToolType.STATIC_LIB_ARCHIVER
Cannot solve method call tools.put(ToolType.STATIC_LIB_ARCHIVER, instantiator.newInstance(DefaultCommandLineToolConfiguration.class, ToolType.STATIC_LIB_ARCHIVER)) java.lang.RuntimeException: Method 'newInstance' cannot be resolved in context instantiator.newInstance(DefaultCommandLineToolConfiguration.class, ToolType.STATIC_LIB_ARCHIVER) (line: 40) MethodCallExprContext{wrapped=instantiator.newInstance(DefaultCommandLineToolConfiguration.class, ToolType.STATIC_LIB_ARCHIVER)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.nativeplatform.toolchain.internal.tools.DefaultCommandLineToolConfiguration, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{org.gradle.nativeplatform.toolchain.internal.ToolType, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/DefaultVisualCppPlatformToolChain.java
Cannot solve field access ToolType.ASSEMBLER
Cannot solve field access ToolType.ASSEMBLER
Cannot solve method call tools.put(ToolType.ASSEMBLER, instantiator.newInstance(DefaultCommandLineToolConfiguration.class, ToolType.ASSEMBLER)) java.lang.RuntimeException: Method 'newInstance' cannot be resolved in context instantiator.newInstance(DefaultCommandLineToolConfiguration.class, ToolType.ASSEMBLER) (line: 41) MethodCallExprContext{wrapped=instantiator.newInstance(DefaultCommandLineToolConfiguration.class, ToolType.ASSEMBLER)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.nativeplatform.toolchain.internal.tools.DefaultCommandLineToolConfiguration, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{org.gradle.nativeplatform.toolchain.internal.ToolType, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/DefaultVisualCppPlatformToolChain.java
Cannot solve field access ToolType.WINDOW_RESOURCES_COMPILER
Cannot solve field access ToolType.WINDOW_RESOURCES_COMPILER
Cannot solve method call tools.put(ToolType.WINDOW_RESOURCES_COMPILER, instantiator.newInstance(DefaultCommandLineToolConfiguration.class, ToolType.WINDOW_RESOURCES_COMPILER)) java.lang.RuntimeException: Method 'newInstance' cannot be resolved in context instantiator.newInstance(DefaultCommandLineToolConfiguration.class, ToolType.WINDOW_RESOURCES_COMPILER) (line: 42) MethodCallExprContext{wrapped=instantiator.newInstance(DefaultCommandLineToolConfiguration.class, ToolType.WINDOW_RESOURCES_COMPILER)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.nativeplatform.toolchain.internal.tools.DefaultCommandLineToolConfiguration, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{org.gradle.nativeplatform.toolchain.internal.ToolType, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/DefaultVisualCppPlatformToolChain.java
Cannot solve field access ToolType.C_COMPILER
Cannot solve field access ToolType.CPP_COMPILER
Cannot solve field access ToolType.WINDOW_RESOURCES_COMPILER
Cannot solve field access ToolType.ASSEMBLER
Cannot solve field access ToolType.LINKER
Cannot solve field access ToolType.STATIC_LIB_ARCHIVER
Cannot resolve field access null
Cannot solve method call windowsRegistry.getSubkeys(WindowsRegistry.Key.HKEY_LOCAL_MACHINE, baseKey + REGISTRY_ROOTPATH_SDK) UnsolvedSymbolException{context='unknown', name='HKEY_LOCAL_MACHINE', typeSolver=null} /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/DefaultWindowsSdkLocator.java
Cannot resolve field access null
Cannot solve method call windowsRegistry.getStringValue(WindowsRegistry.Key.HKEY_LOCAL_MACHINE, basePath, REGISTRY_FOLDER) UnsolvedSymbolException{context='unknown', name='HKEY_LOCAL_MACHINE', typeSolver=null} /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/DefaultWindowsSdkLocator.java
Cannot resolve field access null
Cannot solve method call windowsRegistry.getStringValue(WindowsRegistry.Key.HKEY_LOCAL_MACHINE, basePath, REGISTRY_VERSION) UnsolvedSymbolException{context='unknown', name='HKEY_LOCAL_MACHINE', typeSolver=null} /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/DefaultWindowsSdkLocator.java
Cannot solve method call formatVersion(windowsRegistry.getStringValue(WindowsRegistry.Key.HKEY_LOCAL_MACHINE, basePath, REGISTRY_VERSION)) java.lang.RuntimeException: Error calculating the type of parameter WindowsRegistry.Key.HKEY_LOCAL_MACHINE of method call windowsRegistry.getStringValue(WindowsRegistry.Key.HKEY_LOCAL_MACHINE, basePath, REGISTRY_VERSION) /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/DefaultWindowsSdkLocator.java
Cannot resolve field access null
Cannot solve method call windowsRegistry.getStringValue(WindowsRegistry.Key.HKEY_LOCAL_MACHINE, basePath, REGISTRY_NAME) UnsolvedSymbolException{context='unknown', name='HKEY_LOCAL_MACHINE', typeSolver=null} /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/DefaultWindowsSdkLocator.java
Cannot resolve field access null
Cannot solve method call windowsRegistry.getStringValue(WindowsRegistry.Key.HKEY_LOCAL_MACHINE, baseKey + REGISTRY_ROOTPATH_KIT, keys[i]) UnsolvedSymbolException{context='unknown', name='HKEY_LOCAL_MACHINE', typeSolver=null} /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/DefaultWindowsSdkLocator.java
Cannot resolve field access null
Cannot solve method call args.add(escapeUserArg("/D" + macroArg)) java.lang.RuntimeException: Method 'escapeUserArg' cannot be resolved in context escapeUserArg("/D" + macroArg) (line: 59) MethodCallExprContext{wrapped=escapeUserArg("/D" + macroArg)}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/VisualCppCompilerArgsTransformer.java
Method 'getVersion' cannot be resolved in context o2.getVersion() (line: 74) MethodCallExprContext{wrapped=o2.getVersion()}. Parameter types: []
Cannot resolve field access null
Cannot solve method call windowsRegistry.getValueNames(WindowsRegistry.Key.HKEY_LOCAL_MACHINE, baseKey + REGISTRY_ROOTPATH_VC) UnsolvedSymbolException{context='unknown', name='HKEY_LOCAL_MACHINE', typeSolver=null} /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/DefaultVisualStudioLocator.java
Cannot resolve field access null
Cannot solve method call windowsRegistry.getStringValue(WindowsRegistry.Key.HKEY_LOCAL_MACHINE, baseKey + REGISTRY_ROOTPATH_VC, valueName) UnsolvedSymbolException{context='unknown', name='HKEY_LOCAL_MACHINE', typeSolver=null} /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/DefaultVisualStudioLocator.java
Cannot solve field access ArchitectureDescriptorBuilder.X86_ON_X86
Cannot solve field access ArchitectureDescriptorBuilder.AMD64_ON_X86
Cannot solve field access ArchitectureDescriptorBuilder.IA64_ON_X86
Cannot solve field access ArchitectureDescriptorBuilder.ARM_ON_X86
Cannot resolve field access null
Cannot solve field access ArchitectureDescriptorBuilder.AMD64_ON_AMD64
Cannot solve field access ArchitectureDescriptorBuilder.X86_ON_AMD64
Cannot solve field access ArchitectureDescriptorBuilder.ARM_ON_AMD64
Method 'getVersion' cannot be resolved in context visualStudio.getVersion() (line: 229) MethodCallExprContext{wrapped=visualStudio.getVersion()}. Parameter types: []
Cannot solve method call X86_ON_X86.getBinPath(basePath) com.github.javaparser.ast.body.EnumConstantDeclaration /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/DefaultVisualStudioLocator.java
Cannot solve method call AMD64_ON_AMD64.getBinPath(basePath) com.github.javaparser.ast.body.EnumConstantDeclaration /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/DefaultVisualStudioLocator.java
Cannot solve method call AMD64_ON_AMD64.getBinPath(basePath) com.github.javaparser.ast.body.EnumConstantDeclaration /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/DefaultVisualStudioLocator.java
Empty name expression DEFINE_ARMPARTITIONAVAILABLE
Cannot solve method call X86_ON_X86.getBinPath(basePath) com.github.javaparser.ast.body.EnumConstantDeclaration /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/DefaultVisualStudioLocator.java
Empty name expression DEFINE_ARMPARTITIONAVAILABLE
Cannot solve method call X86_ON_X86.getBinPath(basePath) com.github.javaparser.ast.body.EnumConstantDeclaration /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/DefaultVisualStudioLocator.java
Cannot solve method call pchArgs.add("/Yu".concat(lastHeader)) java.lang.RuntimeException: Method 'concat' cannot be resolved in context "/Yu".concat(lastHeader) (line: 53) MethodCallExprContext{wrapped="/Yu".concat(lastHeader)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/VisualCppNativeCompiler.java
Cannot solve method call result.unavailable(String.format("Don't know how to build for platform '%s'.", targetPlatform.getName())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/VisualCppToolChain.java
Cannot solve method call tool("C++ compiler", visualCpp.getCompiler(targetPlatform)) java.lang.RuntimeException: Method 'getCompiler' cannot be resolved in context visualCpp.getCompiler(targetPlatform) (line: 66) MethodCallExprContext{wrapped=visualCpp.getCompiler(targetPlatform)}. Parameter types: [ReferenceType{org.gradle.nativeplatform.platform.internal.NativePlatformInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/VisualCppPlatformToolProvider.java
Cannot solve field access ToolType.CPP_COMPILER
Cannot solve method call tool("C++ PCH compiler", visualCpp.getCompiler(targetPlatform)) java.lang.RuntimeException: Method 'getCompiler' cannot be resolved in context visualCpp.getCompiler(targetPlatform) (line: 73) MethodCallExprContext{wrapped=visualCpp.getCompiler(targetPlatform)}. Parameter types: [ReferenceType{org.gradle.nativeplatform.platform.internal.NativePlatformInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/VisualCppPlatformToolProvider.java
Cannot solve field access ToolType.CPP_COMPILER
Cannot solve method call tool("C compiler", visualCpp.getCompiler(targetPlatform)) java.lang.RuntimeException: Method 'getCompiler' cannot be resolved in context visualCpp.getCompiler(targetPlatform) (line: 80) MethodCallExprContext{wrapped=visualCpp.getCompiler(targetPlatform)}. Parameter types: [ReferenceType{org.gradle.nativeplatform.platform.internal.NativePlatformInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/VisualCppPlatformToolProvider.java
Cannot solve field access ToolType.C_COMPILER
Cannot solve method call tool("C PCH compiler", visualCpp.getCompiler(targetPlatform)) java.lang.RuntimeException: Method 'getCompiler' cannot be resolved in context visualCpp.getCompiler(targetPlatform) (line: 87) MethodCallExprContext{wrapped=visualCpp.getCompiler(targetPlatform)}. Parameter types: [ReferenceType{org.gradle.nativeplatform.platform.internal.NativePlatformInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/VisualCppPlatformToolProvider.java
Cannot solve field access ToolType.C_COMPILER
Cannot solve method call tool("Assembler", visualCpp.getAssembler(targetPlatform)) java.lang.RuntimeException: Method 'getAssembler' cannot be resolved in context visualCpp.getAssembler(targetPlatform) (line: 94) MethodCallExprContext{wrapped=visualCpp.getAssembler(targetPlatform)}. Parameter types: [ReferenceType{org.gradle.nativeplatform.platform.internal.NativePlatformInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/VisualCppPlatformToolProvider.java
Cannot solve field access ToolType.ASSEMBLER
Cannot solve method call tool("Windows resource compiler", sdk.getResourceCompiler(targetPlatform)) java.lang.RuntimeException: Method 'getResourceCompiler' cannot be resolved in context sdk.getResourceCompiler(targetPlatform) (line: 110) MethodCallExprContext{wrapped=sdk.getResourceCompiler(targetPlatform)}. Parameter types: [ReferenceType{org.gradle.nativeplatform.platform.internal.NativePlatformInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/VisualCppPlatformToolProvider.java
Cannot solve field access ToolType.WINDOW_RESOURCES_COMPILER
Cannot solve method call tool("Linker", visualCpp.getLinker(targetPlatform)) java.lang.RuntimeException: Method 'getLinker' cannot be resolved in context visualCpp.getLinker(targetPlatform) (line: 118) MethodCallExprContext{wrapped=visualCpp.getLinker(targetPlatform)}. Parameter types: [ReferenceType{org.gradle.nativeplatform.platform.internal.NativePlatformInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/VisualCppPlatformToolProvider.java
Cannot solve field access ToolType.LINKER
Cannot solve method call tool("Static library archiver", visualCpp.getArchiver(targetPlatform)) java.lang.RuntimeException: Method 'getArchiver' cannot be resolved in context visualCpp.getArchiver(targetPlatform) (line: 124) MethodCallExprContext{wrapped=visualCpp.getArchiver(targetPlatform)}. Parameter types: [ReferenceType{org.gradle.nativeplatform.platform.internal.NativePlatformInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/VisualCppPlatformToolProvider.java
Cannot solve field access ToolType.STATIC_LIB_ARCHIVER
Cannot solve method call invocationContext.addPath(visualCpp.getPath(targetPlatform)) java.lang.RuntimeException: Method 'getPath' cannot be resolved in context visualCpp.getPath(targetPlatform) (line: 136) MethodCallExprContext{wrapped=visualCpp.getPath(targetPlatform)}. Parameter types: [ReferenceType{org.gradle.nativeplatform.platform.internal.NativePlatformInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/VisualCppPlatformToolProvider.java
Cannot solve method call invocationContext.addPath(sdk.getBinDir(targetPlatform)) java.lang.RuntimeException: Method 'getBinDir' cannot be resolved in context sdk.getBinDir(targetPlatform) (line: 137) MethodCallExprContext{wrapped=sdk.getBinDir(targetPlatform)}. Parameter types: [ReferenceType{org.gradle.nativeplatform.platform.internal.NativePlatformInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/VisualCppPlatformToolProvider.java
Cannot solve method call original.include(visualCpp.getIncludePath(targetPlatform)) java.lang.RuntimeException: Method 'getIncludePath' cannot be resolved in context visualCpp.getIncludePath(targetPlatform) (line: 177) MethodCallExprContext{wrapped=visualCpp.getIncludePath(targetPlatform)}. Parameter types: [ReferenceType{org.gradle.nativeplatform.platform.internal.NativePlatformInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/VisualCppPlatformToolProvider.java
Cannot solve method call original.include(sdk.getIncludeDirs()) java.lang.RuntimeException: Method 'getIncludeDirs' cannot be resolved in context sdk.getIncludeDirs() (line: 178) MethodCallExprContext{wrapped=sdk.getIncludeDirs()}. Parameter types: [] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/VisualCppPlatformToolProvider.java
Method 'getDefinitions' cannot be resolved in context visualCpp.getDefinitions(targetPlatform) (line: 179) MethodCallExprContext{wrapped=visualCpp.getDefinitions(targetPlatform)}. Parameter types: [ReferenceType{org.gradle.nativeplatform.platform.internal.NativePlatformInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call original.libraryPath(visualCpp.getLibraryPath(targetPlatform), sdk.getLibDir(targetPlatform)) java.lang.RuntimeException: Method 'getLibraryPath' cannot be resolved in context visualCpp.getLibraryPath(targetPlatform) (line: 190) MethodCallExprContext{wrapped=visualCpp.getLibraryPath(targetPlatform)}. Parameter types: [ReferenceType{org.gradle.nativeplatform.platform.internal.NativePlatformInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/msvcpp/VisualCppPlatformToolProvider.java
Method 'replace' cannot be resolved in context original.replace("\\", "\\\\") (line: 35) MethodCallExprContext{wrapped=original.replace("\\", "\\\\")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call String.format("Don't know how to provide tool of type %s.", toolType.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context toolType.getSimpleName() (line: 69) MethodCallExprContext{wrapped=toolType.getSimpleName()}. Parameter types: [] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/AbstractPlatformToolProvider.java
Cannot solve method call visitor.node(String.format("No tool chain is available to build for platform '%s'", targetPlatform.getName())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/DefaultNativeToolChainRegistry.java
Cannot solve method call toolChainRegistry.registerFactory(VisualCpp.class, new NamedDomainObjectFactory<VisualCpp>() {

    public VisualCpp create(String name) {
        return instantiator.newInstance(VisualCppToolChain.class, name, buildOperationProcessor, operatingSystem, fileResolver, execActionFactory, visualStudioLocator, windowsSdkLocator, instantiator);
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/plugins/MicrosoftVisualCppCompilerPlugin.java
Cannot solve method call toolChainRegistry.registerFactory(Clang.class, new NamedDomainObjectFactory<Clang>() {

    public Clang create(String name) {
        return instantiator.newInstance(ClangToolChain.class, name, buildOperationProcessor, OperatingSystem.current(), fileResolver, execActionFactory, metaDataProviderFactory, instantiator);
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/plugins/ClangCompilerPlugin.java
Cannot solve method call toolChainRegistry.registerFactory(Gcc.class, new NamedDomainObjectFactory<Gcc>() {

    public Gcc create(String name) {
        return instantiator.newInstance(GccToolChain.class, instantiator, name, buildOperationProcessor, OperatingSystem.current(), fileResolver, execActionFactory, metaDataProviderFactory);
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/plugins/GccCompilerPlugin.java
Cannot solve method call resolve(getInputs().withType(DependentSourceSet.class)) java.lang.RuntimeException: Method 'withType' cannot be resolved in context getInputs().withType(DependentSourceSet.class) (line: 170) MethodCallExprContext{wrapped=getInputs().withType(DependentSourceSet.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.language.nativeplatform.DependentSourceSet, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/internal/AbstractNativeBinarySpec.java
Error calculating the type of parameter getInputs().withType(DependentSourceSet.class) of method call resolve(getInputs().withType(DependentSourceSet.class))
Method 'resolve' cannot be resolved in context resolve(Collections.singleton(sourceSet)) (line: 175) MethodCallExprContext{wrapped=resolve(Collections.singleton(sourceSet))}. Parameter types: [ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{org.gradle.language.nativeplatform.DependentSourceSet, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call resolve(getInputs().withType(DependentSourceSet.class)) java.lang.RuntimeException: Method 'withType' cannot be resolved in context getInputs().withType(DependentSourceSet.class) (line: 185) MethodCallExprContext{wrapped=getInputs().withType(DependentSourceSet.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.language.nativeplatform.DependentSourceSet, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/internal/AbstractNativeBinarySpec.java
Error calculating the type of parameter getInputs().withType(DependentSourceSet.class) of method call resolve(getInputs().withType(DependentSourceSet.class))
Cannot solve method call resolve(getInputs().withType(DependentSourceSet.class)) java.lang.RuntimeException: Method 'withType' cannot be resolved in context getInputs().withType(DependentSourceSet.class) (line: 190) MethodCallExprContext{wrapped=getInputs().withType(DependentSourceSet.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.language.nativeplatform.DependentSourceSet, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/internal/AbstractNativeBinarySpec.java
Error calculating the type of parameter getInputs().withType(DependentSourceSet.class) of method call resolve(getInputs().withType(DependentSourceSet.class))
Cannot solve method call NativeBinaries.createNativeBinaries(projectNativeComponent, projectNativeComponent.getBinaries().withType(NativeBinarySpec.class), nativeDependencyResolver, fileCollectionFactory, namingSchemeWithFlavor, platform, buildType, flavor) java.lang.RuntimeException: Method 'withType' cannot be resolved in context projectNativeComponent.getBinaries().withType(NativeBinarySpec.class) (line: 118) MethodCallExprContext{wrapped=projectNativeComponent.getBinaries().withType(NativeBinarySpec.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.nativeplatform.NativeBinarySpec, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/internal/configure/NativeComponentRules.java
Method 'withBinaryType' cannot be resolved in context namingScheme.withBinaryType("Executable") (line: 46) MethodCallExprContext{wrapped=namingScheme.withBinaryType("Executable")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call createNativeBinary(NativeExecutableBinarySpec.class, binaries, resolver, fileCollectionFactory, namingScheme.withBinaryType("Executable").withRole("executable", true), platform, buildType, flavor) java.lang.RuntimeException: Method 'withBinaryType' cannot be resolved in context namingScheme.withBinaryType("Executable") (line: 46) MethodCallExprContext{wrapped=namingScheme.withBinaryType("Executable")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/internal/configure/NativeBinaries.java
Method 'withBinaryType' cannot be resolved in context namingScheme.withBinaryType("SharedLibrary") (line: 43) MethodCallExprContext{wrapped=namingScheme.withBinaryType("SharedLibrary")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call createNativeBinary(SharedLibraryBinarySpec.class, binaries, resolver, fileCollectionFactory, namingScheme.withBinaryType("SharedLibrary").withRole("shared", false), platform, buildType, flavor) java.lang.RuntimeException: Method 'withBinaryType' cannot be resolved in context namingScheme.withBinaryType("SharedLibrary") (line: 43) MethodCallExprContext{wrapped=namingScheme.withBinaryType("SharedLibrary")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/internal/configure/NativeBinaries.java
Method 'withBinaryType' cannot be resolved in context namingScheme.withBinaryType("StaticLibrary") (line: 44) MethodCallExprContext{wrapped=namingScheme.withBinaryType("StaticLibrary")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call createNativeBinary(StaticLibraryBinarySpec.class, binaries, resolver, fileCollectionFactory, namingScheme.withBinaryType("StaticLibrary").withRole("static", false), platform, buildType, flavor) java.lang.RuntimeException: Method 'withBinaryType' cannot be resolved in context namingScheme.withBinaryType("StaticLibrary") (line: 44) MethodCallExprContext{wrapped=namingScheme.withBinaryType("StaticLibrary")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/internal/configure/NativeBinaries.java
Cannot solve field access ModelActionRole.Defaults
Cannot solve method call DirectNodeNoInputsModelAction.of(ModelReference.of(binaryPath, NativeBinarySpec.class), new SimpleModelRuleDescriptor("initialize binary " + binaryPath), new BiAction<MutableModelNode, NativeBinarySpec>() {

    @Override
    public void execute(MutableModelNode mutableModelNode, NativeBinarySpec nativeBinarySpec) {
        initialize(nativeBinarySpec, namingScheme, resolver, fileCollectionFactory, platform, buildType, flavor);
    }
}) UnsolvedSymbolException{context='Method 'of' with parameterTypes [ReferenceType{org.gradle.model.internal.core.ModelPath, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{NativeBinarySpec, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * A model reference is a speculative reference to a potential model element.
 * <p>
 * Rule subjects/inputs are defined in terms of references, as opposed to concrete identity.
 * The reference may be by type only, or by path only.
 * <p>
 * A reference doesn't include the notion of readonly vs. writable as the context of the reference implies this.
 * Having this be part of the reference would open opportunities for mismatch of that flag in the context.
 *
 * @param <T> the type of the reference.
 */
@ThreadSafe
public class ModelReference<T> {

    public static final ModelReference<Object> ANY = of(ModelType.untyped());

    @Nullable
    private final ModelPath path;

    private final ModelType<T> type;

    @Nullable
    private final ModelPath scope;

    private final ModelNode.State state;

    @Nullable
    private final String description;

    private int hashCode;

    private ModelReference(@Nullable ModelPath path, ModelType<T> type, @Nullable ModelPath scope, @Nullable ModelNode.State state, @Nullable String description) {
        this.path = path;
        this.type = Preconditions.checkNotNull(type, "type");
        this.scope = scope;
        this.description = description;
        this.state = state != null ? state : ModelNode.State.GraphClosed;
    }

    public static ModelReference<Object> any() {
        return ANY;
    }

    public static <T> ModelReference<T> of(ModelPath path, ModelType<T> type, String description) {
        return Cast.uncheckedCast(new ModelReference<T>(path, type, null, null, description));
    }

    public static <T> ModelReference<T> of(String path, ModelType<T> type, String description) {
        return of(ModelPath.path(path), type, description);
    }

    public static <T> ModelReference<T> of(ModelPath path, ModelType<T> type) {
        return Cast.uncheckedCast(new ModelReference<T>(path, type, null, null, null));
    }

    public static <T> ModelReference<T> of(ModelPath path, ModelType<T> type, ModelNode.State state) {
        return Cast.uncheckedCast(new ModelReference<T>(path, type, null, state, null));
    }

    public static <T> ModelReference<T> of(ModelPath path, Class<T> type) {
        return of(path, ModelType.of(type));
    }

    public static <T> ModelReference<T> of(String path, Class<T> type) {
        return of(ModelPath.path(path), ModelType.of(type));
    }

    public static <T> ModelReference<T> of(String path, ModelType<T> type) {
        return of(path == null ? null : ModelPath.path(path), type);
    }

    public static <T> ModelReference<T> of(Class<T> type) {
        return of((ModelPath) null, ModelType.of(type));
    }

    public static <T> ModelReference<T> of(ModelType<T> type) {
        return of((ModelPath) null, type);
    }

    public static ModelReference<Object> of(String path) {
        return of(ModelPath.path(path), ModelType.UNTYPED);
    }

    public static ModelReference<Object> of(ModelPath path) {
        return of(path, ModelType.UNTYPED);
    }

    public static ModelReference<Object> untyped(ModelPath path) {
        return untyped(path, null);
    }

    public static ModelReference<Object> untyped(ModelPath path, String description) {
        return of(path, ModelType.UNTYPED, description);
    }

    @Nullable
    public ModelPath getPath() {
        return path;
    }

    /**
     * Return the path of the scope of the node to select, or null if scope is not relevant.
     *
     * <p>A node will be selected if its path or its parent's path equals the specified path.</p>
     */
    @Nullable
    public ModelPath getScope() {
        return scope;
    }

    @Nullable
    public String getDescription() {
        return description;
    }

    public ModelType<T> getType() {
        return type;
    }

    public ModelNode.State getState() {
        return state;
    }

    public boolean isUntyped() {
        return type.equals(ModelType.UNTYPED);
    }

    public ModelReference<T> inScope(ModelPath scope) {
        if (scope.equals(this.scope)) {
            return this;
        }
        return Cast.uncheckedCast(new ModelReference<T>(path, type, scope, state, description));
    }

    public ModelReference<T> withPath(ModelPath path) {
        return Cast.uncheckedCast(new ModelReference<T>(path, type, scope, state, description));
    }

    public ModelReference<T> atState(ModelNode.State state) {
        if (state.equals(this.state)) {
            return this;
        }
        return Cast.uncheckedCast(new ModelReference<T>(path, type, scope, state, description));
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ModelReference<?> that = (ModelReference<?>) o;
        return Objects.equal(path, that.path) && Objects.equal(scope, that.scope) && type.equals(that.type) && state.equals(that.state) && Objects.equal(description, that.description);
    }

    @Override
    public int hashCode() {
        int result = hashCode;
        if (result != 0) {
            return result;
        }
        result = path == null ? 0 : path.hashCode();
        result = 31 * result + (scope == null ? 0 : scope.hashCode());
        result = 31 * result + type.hashCode();
        result = 31 * result + state.hashCode();
        result = 31 * result + (description == null ? 0 : description.hashCode());
        hashCode = result;
        return result;
    }

    @Override
    public String toString() {
        return "ModelReference{path=" + path + ", scope=" + scope + ", type=" + type + ", state=" + state + '}';
    }
}}'} /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/internal/configure/NativeBinaries.java
Cannot solve method call backingNode.applyToLink(ModelActionRole.Defaults, DirectNodeNoInputsModelAction.of(ModelReference.of(binaryPath, NativeBinarySpec.class), new SimpleModelRuleDescriptor("initialize binary " + binaryPath), new BiAction<MutableModelNode, NativeBinarySpec>() {

    @Override
    public void execute(MutableModelNode mutableModelNode, NativeBinarySpec nativeBinarySpec) {
        initialize(nativeBinarySpec, namingScheme, resolver, fileCollectionFactory, platform, buildType, flavor);
    }
})) java.lang.RuntimeException: Error calculating the type of parameter ModelReference.of(binaryPath, NativeBinarySpec.class) of method call DirectNodeNoInputsModelAction.of(ModelReference.of(binaryPath, NativeBinarySpec.class), new SimpleModelRuleDescriptor("initialize binary " + binaryPath), new BiAction<MutableModelNode, NativeBinarySpec>() {

    @Override
    public void execute(MutableModelNode mutableModelNode, NativeBinarySpec nativeBinarySpec) {
        initialize(nativeBinarySpec, namingScheme, resolver, fileCollectionFactory, platform, buildType, flavor);
    }
}) /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/internal/configure/NativeBinaries.java
Cannot solve method call getPrebuiltLibrary(repositories.withType(PrebuiltLibraries.class), library.getLibraryName()) java.lang.RuntimeException: Method 'withType' cannot be resolved in context repositories.withType(PrebuiltLibraries.class) (line: 46) MethodCallExprContext{wrapped=repositories.withType(PrebuiltLibraries.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.nativeplatform.PrebuiltLibraries, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/internal/prebuilt/PrebuiltLibraryBinaryLocator.java
Cannot solve method call String.format("%s not set for %s.", fileDescription, AbstractPrebuiltLibraryBinary.this.getDisplayName()) java.lang.RuntimeException: Method 'getDisplayName' cannot be resolved in context AbstractPrebuiltLibraryBinary.this.getDisplayName() (line: 105) MethodCallExprContext{wrapped=AbstractPrebuiltLibraryBinary.this.getDisplayName()}. Parameter types: [] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/internal/prebuilt/AbstractPrebuiltLibraryBinary.java
Cannot solve method call String.format("%s %s does not exist for %s.", fileDescription, file.getAbsolutePath(), AbstractPrebuiltLibraryBinary.this.getDisplayName()) java.lang.RuntimeException: Method 'getDisplayName' cannot be resolved in context AbstractPrebuiltLibraryBinary.this.getDisplayName() (line: 108) MethodCallExprContext{wrapped=AbstractPrebuiltLibraryBinary.this.getDisplayName()}. Parameter types: [] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/internal/prebuilt/AbstractPrebuiltLibraryBinary.java
Cannot solve method call String.format("Invalid %s: '%s'", type.getSimpleName(), unusedNames.iterator().next()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context type.getSimpleName() (line: 78) MethodCallExprContext{wrapped=type.getSimpleName()}. Parameter types: [] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/internal/AbstractTargetedNativeComponentSpec.java
Method 'candidate' cannot be resolved in context visitor.candidate("Map with mandatory 'library' and optional 'project' and 'linkage' keys") (line: 50) MethodCallExprContext{wrapped=visitor.candidate("Map with mandatory 'library' and optional 'project' and 'linkage' keys")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'withType' cannot be resolved in context components.withType(NativeLibrarySpec.class) (line: 46) MethodCallExprContext{wrapped=components.withType(NativeLibrarySpec.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.nativeplatform.NativeLibrarySpec, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call binary.getTasks().create(namingScheme.getTaskName("install"), InstallExecutable.class, new Action<InstallExecutable>() {

    @Override
    public void execute(InstallExecutable installTask) {
        installTask.setDescription("Installs a development image of " + binary.getDisplayName());
        installTask.setGroup(LifecycleBasePlugin.BUILD_GROUP);
        installTask.setToolChain(executable.getToolChain());
        installTask.setPlatform(binary.getTargetPlatform());
        installTask.setExecutable(executable.getFile());
        installTask.setDestinationDir(installation.getDirectory());
        // TODO:HH wire binary libs via executable
        installTask.lib(new BinaryLibs(binary) {

            @Override
            protected FileCollection getFiles(NativeDependencySet nativeDependencySet) {
                return nativeDependencySet.getRuntimeFiles();
            }
        });
        // TODO:HH installTask.dependsOn(executable)
        installTask.dependsOn(binary);
    }
}) java.lang.RuntimeException: Method 'getTaskName' cannot be resolved in context namingScheme.getTaskName("install") (line: 77) MethodCallExprContext{wrapped=namingScheme.getTaskName("install")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/internal/NativeComponents.java
Method 'withType' cannot be resolved in context components.withType(NativeComponentSpec.class) (line: 101) MethodCallExprContext{wrapped=components.withType(NativeComponentSpec.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.nativeplatform.NativeComponentSpec, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call modelRegistry.realize("binaries", ModelTypes.modelMap(NativeBinarySpecInternal.class)) UnsolvedSymbolException{context='Method 'modelMap' with parameterTypes [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.nativeplatform.internal.NativeBinarySpecInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class ModelTypes {

    public static <I> ModelType<ModelMap<I>> modelMap(Class<I> type) {
        return modelMap(ModelType.of(type));
    }

    public static <I> ModelType<ModelMap<I>> modelMap(ModelType<I> type) {
        return new ModelType.Builder<ModelMap<I>>() {
        }.where(new ModelType.Parameter<I>() {
        }, type).build();
    }

    public static <I> ModelType<ModelSet<I>> modelSet(ModelType<I> type) {
        return new ModelType.Builder<ModelSet<I>>() {
        }.where(new ModelType.Parameter<I>() {
        }, type).build();
    }

    public static <I> ModelType<List<I>> list(ModelType<I> type) {
        return new ModelType.Builder<List<I>>() {
        }.where(new ModelType.Parameter<I>() {
        }, type).build();
    }

    public static <I> ModelType<Set<I>> set(ModelType<I> type) {
        return new ModelType.Builder<Set<I>>() {
        }.where(new ModelType.Parameter<I>() {
        }, type).build();
    }

    public static <T> Ordering<ModelType<? extends T>> displayOrder() {
        return new Ordering<ModelType<? extends T>>() {

            @Override
            public int compare(ModelType<? extends T> left, ModelType<? extends T> right) {
                return left.getDisplayName().compareTo(right.getDisplayName());
            }
        };
    }

    /**
     * Returns the sorted, unique display names of the given types.
     */
    public static Iterable<String> getDisplayNames(Iterable<? extends ModelType<?>> types) {
        ImmutableSortedSet.Builder<String> builder = ImmutableSortedSet.naturalOrder();
        for (ModelType<?> type : types) {
            builder.add(type.getDisplayName());
        }
        return builder.build();
    }

    /**
     * Collect all types that make up the type hierarchy of the given types.
     */
    public static Set<ModelType<?>> collectHierarchy(Iterable<? extends ModelType<?>> types) {
        Queue<ModelType<?>> queue = new ArrayDeque<ModelType<?>>(Iterables.size(types) * 2);
        Iterables.addAll(queue, types);
        Set<ModelType<?>> seenTypes = Sets.newLinkedHashSet();
        ModelType<?> type;
        while ((type = queue.poll()) != null) {
            // Do not process Object's or GroovyObject's methods
            Class<?> rawClass = type.getRawClass();
            if (rawClass.equals(Object.class) || rawClass.equals(GroovyObject.class)) {
                continue;
            }
            // Do not reprocess
            if (!seenTypes.add(type)) {
                continue;
            }
            Class<?> superclass = rawClass.getSuperclass();
            if (superclass != null) {
                ModelType<?> superType = ModelType.of(superclass);
                if (!seenTypes.contains(superType)) {
                    queue.add(superType);
                }
            }
            for (Class<?> iface : rawClass.getInterfaces()) {
                ModelType<?> ifaceType = ModelType.of(iface);
                if (!seenTypes.contains(ifaceType)) {
                    queue.add(ifaceType);
                }
            }
        }
        return seenTypes;
    }
}}'} /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/internal/NativeComponents.java
Cannot solve method call modelRegistry.realize("tasks", ModelTypes.modelMap(Task.class)) UnsolvedSymbolException{context='Method 'modelMap' with parameterTypes [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.Task, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class ModelTypes {

    public static <I> ModelType<ModelMap<I>> modelMap(Class<I> type) {
        return modelMap(ModelType.of(type));
    }

    public static <I> ModelType<ModelMap<I>> modelMap(ModelType<I> type) {
        return new ModelType.Builder<ModelMap<I>>() {
        }.where(new ModelType.Parameter<I>() {
        }, type).build();
    }

    public static <I> ModelType<ModelSet<I>> modelSet(ModelType<I> type) {
        return new ModelType.Builder<ModelSet<I>>() {
        }.where(new ModelType.Parameter<I>() {
        }, type).build();
    }

    public static <I> ModelType<List<I>> list(ModelType<I> type) {
        return new ModelType.Builder<List<I>>() {
        }.where(new ModelType.Parameter<I>() {
        }, type).build();
    }

    public static <I> ModelType<Set<I>> set(ModelType<I> type) {
        return new ModelType.Builder<Set<I>>() {
        }.where(new ModelType.Parameter<I>() {
        }, type).build();
    }

    public static <T> Ordering<ModelType<? extends T>> displayOrder() {
        return new Ordering<ModelType<? extends T>>() {

            @Override
            public int compare(ModelType<? extends T> left, ModelType<? extends T> right) {
                return left.getDisplayName().compareTo(right.getDisplayName());
            }
        };
    }

    /**
     * Returns the sorted, unique display names of the given types.
     */
    public static Iterable<String> getDisplayNames(Iterable<? extends ModelType<?>> types) {
        ImmutableSortedSet.Builder<String> builder = ImmutableSortedSet.naturalOrder();
        for (ModelType<?> type : types) {
            builder.add(type.getDisplayName());
        }
        return builder.build();
    }

    /**
     * Collect all types that make up the type hierarchy of the given types.
     */
    public static Set<ModelType<?>> collectHierarchy(Iterable<? extends ModelType<?>> types) {
        Queue<ModelType<?>> queue = new ArrayDeque<ModelType<?>>(Iterables.size(types) * 2);
        Iterables.addAll(queue, types);
        Set<ModelType<?>> seenTypes = Sets.newLinkedHashSet();
        ModelType<?> type;
        while ((type = queue.poll()) != null) {
            // Do not process Object's or GroovyObject's methods
            Class<?> rawClass = type.getRawClass();
            if (rawClass.equals(Object.class) || rawClass.equals(GroovyObject.class)) {
                continue;
            }
            // Do not reprocess
            if (!seenTypes.add(type)) {
                continue;
            }
            Class<?> superclass = rawClass.getSuperclass();
            if (superclass != null) {
                ModelType<?> superType = ModelType.of(superclass);
                if (!seenTypes.contains(superType)) {
                    queue.add(superType);
                }
            }
            for (Class<?> iface : rawClass.getInterfaces()) {
                ModelType<?> ifaceType = ModelType.of(iface);
                if (!seenTypes.contains(ifaceType)) {
                    queue.add(ifaceType);
                }
            }
        }
        return seenTypes;
    }
}}'} /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/internal/NativeComponents.java
Cannot solve method call dependencies.add(projectTasks.get(dependentBinary.getNamingScheme().getTaskName(dependedOnBinaryTaskName))) com.github.javaparser.symbolsolver.logic.ConfilictingGenericTypesException: No matching between ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual) /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/internal/NativeComponents.java
Cannot solve method call dependencies.put(binary, Sets.<NativeBinarySpecInternal>newLinkedHashSet()) UnsolvedSymbolException{context='Method 'newLinkedHashSet' with parameterTypes []', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Sets}'} /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/internal/NativeDependentBinariesResolutionStrategy.java
Cannot solve method call modelRegistry.realize("components", ModelTypes.modelMap(NativeComponentSpec.class)) UnsolvedSymbolException{context='Method 'modelMap' with parameterTypes [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.nativeplatform.NativeComponentSpec, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class ModelTypes {

    public static <I> ModelType<ModelMap<I>> modelMap(Class<I> type) {
        return modelMap(ModelType.of(type));
    }

    public static <I> ModelType<ModelMap<I>> modelMap(ModelType<I> type) {
        return new ModelType.Builder<ModelMap<I>>() {
        }.where(new ModelType.Parameter<I>() {
        }, type).build();
    }

    public static <I> ModelType<ModelSet<I>> modelSet(ModelType<I> type) {
        return new ModelType.Builder<ModelSet<I>>() {
        }.where(new ModelType.Parameter<I>() {
        }, type).build();
    }

    public static <I> ModelType<List<I>> list(ModelType<I> type) {
        return new ModelType.Builder<List<I>>() {
        }.where(new ModelType.Parameter<I>() {
        }, type).build();
    }

    public static <I> ModelType<Set<I>> set(ModelType<I> type) {
        return new ModelType.Builder<Set<I>>() {
        }.where(new ModelType.Parameter<I>() {
        }, type).build();
    }

    public static <T> Ordering<ModelType<? extends T>> displayOrder() {
        return new Ordering<ModelType<? extends T>>() {

            @Override
            public int compare(ModelType<? extends T> left, ModelType<? extends T> right) {
                return left.getDisplayName().compareTo(right.getDisplayName());
            }
        };
    }

    /**
     * Returns the sorted, unique display names of the given types.
     */
    public static Iterable<String> getDisplayNames(Iterable<? extends ModelType<?>> types) {
        ImmutableSortedSet.Builder<String> builder = ImmutableSortedSet.naturalOrder();
        for (ModelType<?> type : types) {
            builder.add(type.getDisplayName());
        }
        return builder.build();
    }

    /**
     * Collect all types that make up the type hierarchy of the given types.
     */
    public static Set<ModelType<?>> collectHierarchy(Iterable<? extends ModelType<?>> types) {
        Queue<ModelType<?>> queue = new ArrayDeque<ModelType<?>>(Iterables.size(types) * 2);
        Iterables.addAll(queue, types);
        Set<ModelType<?>> seenTypes = Sets.newLinkedHashSet();
        ModelType<?> type;
        while ((type = queue.poll()) != null) {
            // Do not process Object's or GroovyObject's methods
            Class<?> rawClass = type.getRawClass();
            if (rawClass.equals(Object.class) || rawClass.equals(GroovyObject.class)) {
                continue;
            }
            // Do not reprocess
            if (!seenTypes.add(type)) {
                continue;
            }
            Class<?> superclass = rawClass.getSuperclass();
            if (superclass != null) {
                ModelType<?> superType = ModelType.of(superclass);
                if (!seenTypes.contains(superType)) {
                    queue.add(superType);
                }
            }
            for (Class<?> iface : rawClass.getInterfaces()) {
                ModelType<?> ifaceType = ModelType.of(iface);
                if (!seenTypes.contains(ifaceType)) {
                    queue.add(ifaceType);
                }
            }
        }
        return seenTypes;
    }
}}'} /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/internal/NativeDependentBinariesResolutionStrategy.java
Cannot solve method call allBinariesOf(components.withType(VariantComponentSpec.class)) java.lang.RuntimeException: Method 'withType' cannot be resolved in context components.withType(VariantComponentSpec.class) (line: 159) MethodCallExprContext{wrapped=components.withType(VariantComponentSpec.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.platform.base.VariantComponentSpec, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/internal/NativeDependentBinariesResolutionStrategy.java
Cannot solve method call modelRegistry.find("testSuites", ModelTypes.modelMap(Object.class)) UnsolvedSymbolException{context='Method 'modelMap' with parameterTypes [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=public abstract class ModelTypes {

    public static <I> ModelType<ModelMap<I>> modelMap(Class<I> type) {
        return modelMap(ModelType.of(type));
    }

    public static <I> ModelType<ModelMap<I>> modelMap(ModelType<I> type) {
        return new ModelType.Builder<ModelMap<I>>() {
        }.where(new ModelType.Parameter<I>() {
        }, type).build();
    }

    public static <I> ModelType<ModelSet<I>> modelSet(ModelType<I> type) {
        return new ModelType.Builder<ModelSet<I>>() {
        }.where(new ModelType.Parameter<I>() {
        }, type).build();
    }

    public static <I> ModelType<List<I>> list(ModelType<I> type) {
        return new ModelType.Builder<List<I>>() {
        }.where(new ModelType.Parameter<I>() {
        }, type).build();
    }

    public static <I> ModelType<Set<I>> set(ModelType<I> type) {
        return new ModelType.Builder<Set<I>>() {
        }.where(new ModelType.Parameter<I>() {
        }, type).build();
    }

    public static <T> Ordering<ModelType<? extends T>> displayOrder() {
        return new Ordering<ModelType<? extends T>>() {

            @Override
            public int compare(ModelType<? extends T> left, ModelType<? extends T> right) {
                return left.getDisplayName().compareTo(right.getDisplayName());
            }
        };
    }

    /**
     * Returns the sorted, unique display names of the given types.
     */
    public static Iterable<String> getDisplayNames(Iterable<? extends ModelType<?>> types) {
        ImmutableSortedSet.Builder<String> builder = ImmutableSortedSet.naturalOrder();
        for (ModelType<?> type : types) {
            builder.add(type.getDisplayName());
        }
        return builder.build();
    }

    /**
     * Collect all types that make up the type hierarchy of the given types.
     */
    public static Set<ModelType<?>> collectHierarchy(Iterable<? extends ModelType<?>> types) {
        Queue<ModelType<?>> queue = new ArrayDeque<ModelType<?>>(Iterables.size(types) * 2);
        Iterables.addAll(queue, types);
        Set<ModelType<?>> seenTypes = Sets.newLinkedHashSet();
        ModelType<?> type;
        while ((type = queue.poll()) != null) {
            // Do not process Object's or GroovyObject's methods
            Class<?> rawClass = type.getRawClass();
            if (rawClass.equals(Object.class) || rawClass.equals(GroovyObject.class)) {
                continue;
            }
            // Do not reprocess
            if (!seenTypes.add(type)) {
                continue;
            }
            Class<?> superclass = rawClass.getSuperclass();
            if (superclass != null) {
                ModelType<?> superType = ModelType.of(superclass);
                if (!seenTypes.contains(superType)) {
                    queue.add(superType);
                }
            }
            for (Class<?> iface : rawClass.getInterfaces()) {
                ModelType<?> ifaceType = ModelType.of(iface);
                if (!seenTypes.contains(ifaceType)) {
                    queue.add(ifaceType);
                }
            }
        }
        return seenTypes;
    }
}}'} /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/internal/NativeDependentBinariesResolutionStrategy.java
Method 'withType' cannot be resolved in context testSuites.withType(NativeComponentSpec.class) (line: 164) MethodCallExprContext{wrapped=testSuites.withType(NativeComponentSpec.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.nativeplatform.NativeComponentSpec, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call allBinariesOf(testSuites.withType(NativeComponentSpec.class).withType(VariantComponentSpec.class)) java.lang.RuntimeException: Method 'withType' cannot be resolved in context testSuites.withType(NativeComponentSpec.class) (line: 164) MethodCallExprContext{wrapped=testSuites.withType(NativeComponentSpec.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.nativeplatform.NativeComponentSpec, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/internal/NativeDependentBinariesResolutionStrategy.java
Cannot resolve field access null
Cannot solve field access StyledTextOutput.Style.Identifier
Method 'append' cannot be resolved in context toolChainPath.append(pathEntry.getAbsolutePath()) (line: 167) MethodCallExprContext{wrapped=toolChainPath.append(pathEntry.getAbsolutePath())}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot resolve field access null
Cannot solve method call Cast.uncheckedCast(toolChain.select(targetPlatform).newCompiler(spec.getClass())) java.lang.RuntimeException: Method 'newCompiler' cannot be resolved in context toolChain.select(targetPlatform).newCompiler(spec.getClass()) (line: 105) MethodCallExprContext{wrapped=toolChain.select(targetPlatform).newCompiler(spec.getClass())}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/tasks/CreateStaticLibrary.java
Cannot solve method call PCHUtils.generatePCHFile(Lists.newArrayList(header), prefixHeaderFile) UnsolvedSymbolException{context='Method 'newArrayList' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Lists}'} /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/tasks/PrefixHeaderFileGenerateTask.java
Cannot resolve field access null
Cannot solve method call Cast.uncheckedCast(toolChain.select(targetPlatform).newCompiler(spec.getClass())) java.lang.RuntimeException: Method 'newCompiler' cannot be resolved in context toolChain.select(targetPlatform).newCompiler(spec.getClass()) (line: 196) MethodCallExprContext{wrapped=toolChain.select(targetPlatform).newCompiler(spec.getClass())}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/tasks/AbstractLinkTask.java
Cannot solve method call platforms.registerFactory(NativePlatform.class, nativePlatformFactory) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/plugins/NativeComponentModelPlugin.java
Cannot solve method call platforms.registerFactory(Platform.class, nativePlatformFactory) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/plugins/NativeComponentModelPlugin.java
Method 'withType' cannot be resolved in context componentSpec.getSources().withType(DependentSourceSetInternal.class) (line: 251) MethodCallExprContext{wrapped=componentSpec.getSources().withType(DependentSourceSetInternal.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.language.nativeplatform.internal.DependentSourceSetInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'withType' cannot be resolved in context nativeComponentSpec.getSources().withType(DependentSourceSetInternal.class) (line: 267) MethodCallExprContext{wrapped=nativeComponentSpec.getSources().withType(DependentSourceSetInternal.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.language.nativeplatform.internal.DependentSourceSetInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'withType' cannot be resolved in context components.withType(SourceComponentSpec.class) (line: 266) MethodCallExprContext{wrapped=components.withType(SourceComponentSpec.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.platform.base.SourceComponentSpec, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'withType' cannot be resolved in context binaries.withType(NativeExecutableBinarySpecInternal.class) (line: 379) MethodCallExprContext{wrapped=binaries.withType(NativeExecutableBinarySpecInternal.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.nativeplatform.internal.NativeExecutableBinarySpecInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call registerFactory(PrebuiltLibraries.class, new NamedDomainObjectFactory<PrebuiltLibraries>() {

    public PrebuiltLibraries create(String name) {
        return instantiator.newInstance(DefaultPrebuiltLibraries.class, name, instantiator, sourceDirectorySetFactory, binaryFactory);
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/plugins/NativeComponentModelPlugin.java
Cannot solve method call knownArchitecture.isAlias(input.toLowerCase()) java.lang.RuntimeException: Method 'toLowerCase' cannot be resolved in context input.toLowerCase() (line: 44) MethodCallExprContext{wrapped=input.toLowerCase()}. Parameter types: [] /repo/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/platform/internal/Architectures.java
Method 'getMethod' cannot be resolved in context obj.getClass().getMethod("get") (line: 43) MethodCallExprContext{wrapped=obj.getClass().getMethod("get")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call Cast.uncheckedCast(obj.getClass().getMethod("get").invoke(obj)) java.lang.RuntimeException: Method 'getMethod' cannot be resolved in context obj.getClass().getMethod("get") (line: 43) MethodCallExprContext{wrapped=obj.getClass().getMethod("get")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-play/src/main/java/org/gradle/scala/internal/reflect/ScalaOptionInvocationWrapper.java
Cannot solve field access TwirlImports.SCALA
Cannot solve method call String.format("Cannot create Compiler for unsupported CompileSpec type '%s'", spec.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context spec.getSimpleName() (line: 78) MethodCallExprContext{wrapped=spec.getSimpleName()}. Parameter types: [] /repo/subprojects/platform-play/src/main/java/org/gradle/play/internal/toolchain/DefaultPlayToolProvider.java
Cannot solve method call String.format("Don't know how to provide tool of type %s.", toolType.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context toolType.getSimpleName() (line: 86) MethodCallExprContext{wrapped=toolType.getSimpleName()}. Parameter types: [] /repo/subprojects/platform-play/src/main/java/org/gradle/play/internal/toolchain/DefaultPlayToolProvider.java
Method 'getCause' cannot be resolved in context exception.getCause() (line: 121) MethodCallExprContext{wrapped=exception.getCause()}. Parameter types: []
Cannot solve method call visitor.node(exception.getCause().getMessage()) java.lang.RuntimeException: Method 'getCause' cannot be resolved in context exception.getCause() (line: 121) MethodCallExprContext{wrapped=exception.getCause()}. Parameter types: [] /repo/subprojects/platform-play/src/main/java/org/gradle/play/internal/toolchain/DefaultPlayToolChain.java
Empty name expression PLAY_2_2_X
Empty name expression PLAY_2_3_X
Empty name expression PLAY_2_4_X
Empty name expression PLAY_2_5_X
Cannot solve method call ScalaReflectionUtil.scalaMethod(cl, "play.twirl.compiler.TwirlCompiler", "compile", File.class, File.class, File.class, String.class, String.class, cl.loadClass(ScalaCodecMapper.getClassName()), boolean.class, boolean.class) java.lang.RuntimeException: Method 'loadClass' cannot be resolved in context cl.loadClass(ScalaCodecMapper.getClassName()) (line: 76) MethodCallExprContext{wrapped=cl.loadClass(ScalaCodecMapper.getClassName())}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-play/src/main/java/org/gradle/play/internal/twirl/TwirlCompilerAdapterV10X.java
Cannot solve field access TwirlImports.JAVA
Cannot solve field access TwirlImports.JAVA
Cannot solve method call ScalaReflectionUtil.scalaMethod(cl, "play.routes.compiler.RoutesCompiler", "compile", cl.loadClass("play.routes.compiler.RoutesCompiler$RoutesCompilerTask"), cl.loadClass("play.routes.compiler.RoutesGenerator"), File.class) java.lang.RuntimeException: Method 'loadClass' cannot be resolved in context cl.loadClass("play.routes.compiler.RoutesCompiler$RoutesCompilerTask") (line: 49) MethodCallExprContext{wrapped=cl.loadClass("play.routes.compiler.RoutesCompiler$RoutesCompilerTask")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-play/src/main/java/org/gradle/play/internal/routes/RoutesCompilerAdapterV24X.java
Cannot solve method call DirectInstantiator.instantiate(cl.loadClass("play.routes.compiler.RoutesCompiler$RoutesCompilerTask"), file, ScalaListBuffer.fromList(cl, defaultImports), isGenerateForwardsRouter(), generateReverseRoutes, namespaceReverseRouter) java.lang.RuntimeException: Method 'loadClass' cannot be resolved in context cl.loadClass("play.routes.compiler.RoutesCompiler$RoutesCompilerTask") (line: 60) MethodCallExprContext{wrapped=cl.loadClass("play.routes.compiler.RoutesCompiler$RoutesCompilerTask")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-play/src/main/java/org/gradle/play/internal/routes/RoutesCompilerAdapterV24X.java
Cannot solve method call ScalaReflectionUtil.scalaMethod(cl, "play.router.RoutesCompiler", "compile", File.class, File.class, cl.loadClass("scala.collection.Seq"), boolean.class, boolean.class) java.lang.RuntimeException: Method 'loadClass' cannot be resolved in context cl.loadClass("scala.collection.Seq") (line: 46) MethodCallExprContext{wrapped=cl.loadClass("scala.collection.Seq")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-play/src/main/java/org/gradle/play/internal/routes/RoutesCompilerAdapterV22X.java
Empty name expression PLAY_2_2_X
Empty name expression PLAY_2_3_X
Empty name expression PLAY_2_4_X
Empty name expression PLAY_2_5_X
Cannot solve method call ScalaReflectionUtil.scalaMethod(cl, "play.router.RoutesCompiler", "compile", File.class, File.class, cl.loadClass("scala.collection.Seq"), boolean.class, boolean.class, boolean.class) java.lang.RuntimeException: Method 'loadClass' cannot be resolved in context cl.loadClass("scala.collection.Seq") (line: 46) MethodCallExprContext{wrapped=cl.loadClass("scala.collection.Seq")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-play/src/main/java/org/gradle/play/internal/routes/RoutesCompilerAdapterV23X.java
Method 'candidate' cannot be resolved in context visitor.candidate("Map defining the platform versions") (line: 50) MethodCallExprContext{wrapped=visitor.candidate("Map defining the platform versions")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'candidate' cannot be resolved in context visitor.candidate("The name of a Play platform") (line: 63) MethodCallExprContext{wrapped=visitor.candidate("The name of a Play platform")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve field access PlayMajorVersion.PLAY_2_2_X
Cannot solve field access PlayMajorVersion.PLAY_2_3_X
Cannot solve field access PlayMajorVersion.PLAY_2_4_X
Cannot solve field access PlayMajorVersion.PLAY_2_5_X
Cannot solve method call String.format("Minification failed with the following errors:\n\t%s", StringUtils.join(allErrors, "\n\t")) UnsolvedSymbolException{context='Method 'join' with parameterTypes [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=org.apache.commons.lang.StringUtils}'} /repo/subprojects/platform-play/src/main/java/org/gradle/play/internal/javascript/GoogleClosureCompiler.java
Cannot resolve field access null
Cannot solve method call Cast.uncheckedCast(classLoader.loadClass(PLAY_EXCEPTION_CLASSNAME)) java.lang.RuntimeException: Method 'loadClass' cannot be resolved in context classLoader.loadClass(PLAY_EXCEPTION_CLASSNAME) (line: 68) MethodCallExprContext{wrapped=classLoader.loadClass(PLAY_EXCEPTION_CLASSNAME)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-play/src/main/java/org/gradle/play/internal/run/DefaultVersionedPlayRunAdapter.java
Cannot solve method call DirectInstantiator.instantiate(playExceptionClass, "Gradle Build Failure", failure.getMessage(), failure) java.lang.RuntimeException: Method 'getMessage' cannot be resolved in context failure.getMessage() (line: 92) MethodCallExprContext{wrapped=failure.getMessage()}. Parameter types: [] /repo/subprojects/platform-play/src/main/java/org/gradle/play/internal/run/DefaultVersionedPlayRunAdapter.java
Empty name expression PLAY_2_2_X
Empty name expression PLAY_2_4_X
Empty name expression PLAY_2_5_X
Empty name expression PLAY_2_3_X
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Method 'from' cannot be resolved in context copySpec.from(fileDetails.getFile()) (line: 157) MethodCallExprContext{wrapped=copySpec.from(fileDetails.getFile())}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'newOperation' cannot be resolved in context progressLoggerFactory.newOperation(PlayRun.class) (line: 92) MethodCallExprContext{wrapped=progressLoggerFactory.newOperation(PlayRun.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.play.tasks.PlayRun, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'get' cannot be resolved in context playToolProvider.get(PlayApplicationRunner.class) (line: 98) MethodCallExprContext{wrapped=playToolProvider.get(PlayApplicationRunner.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.play.internal.run.PlayApplicationRunner, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'newOperation' cannot be resolved in context progressLoggerFactory.newOperation(PlayRun.class) (line: 106) MethodCallExprContext{wrapped=progressLoggerFactory.newOperation(PlayRun.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.play.tasks.PlayRun, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getTargetPlatforms' cannot be resolved in context playApplication.getTargetPlatforms() (line: 138) MethodCallExprContext{wrapped=playApplication.getTargetPlatforms()}. Parameter types: []
Method 'getPlay' cannot be resolved in context configurations.getPlay() (line: 176) MethodCallExprContext{wrapped=configurations.getPlay()}. Parameter types: []
Method 'getPlay' cannot be resolved in context configurations.getPlay() (line: 177) MethodCallExprContext{wrapped=configurations.getPlay()}. Parameter types: []
Method 'getPlay' cannot be resolved in context configurations.getPlay() (line: 186) MethodCallExprContext{wrapped=configurations.getPlay()}. Parameter types: []
Cannot solve method call playBinaryInternal.setClasspath(configurations.getPlay().getAllArtifacts()) java.lang.RuntimeException: Method 'getPlay' cannot be resolved in context configurations.getPlay() (line: 186) MethodCallExprContext{wrapped=configurations.getPlay()}. Parameter types: [] /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayApplicationPlugin.java
Method 'getInputs' cannot be resolved in context playApplicationBinarySpec.getInputs() (line: 198) MethodCallExprContext{wrapped=playApplicationBinarySpec.getInputs()}. Parameter types: []
Method 'getGeneratedScala' cannot be resolved in context playApplicationBinarySpec.getGeneratedScala() (line: 197) MethodCallExprContext{wrapped=playApplicationBinarySpec.getGeneratedScala()}. Parameter types: []
Method 'getInputs' cannot be resolved in context playApplicationBinarySpec.getInputs() (line: 201) MethodCallExprContext{wrapped=playApplicationBinarySpec.getInputs()}. Parameter types: []
Method 'getGeneratedJavaScript' cannot be resolved in context playApplicationBinarySpec.getGeneratedJavaScript() (line: 200) MethodCallExprContext{wrapped=playApplicationBinarySpec.getGeneratedJavaScript()}. Parameter types: []
Method 'getTargetPlatforms' cannot be resolved in context playApplicationSpec.getTargetPlatforms() (line: 213) MethodCallExprContext{wrapped=playApplicationSpec.getTargetPlatforms()}. Parameter types: []
Cannot resolve field access null
Method 'getTargetPlatforms' cannot be resolved in context playApplicationSpec.getTargetPlatforms() (line: 217) MethodCallExprContext{wrapped=playApplicationSpec.getTargetPlatforms()}. Parameter types: []
Method 'getPlayPlatform' cannot be resolved in context configurations.getPlayPlatform() (line: 221) MethodCallExprContext{wrapped=configurations.getPlayPlatform()}. Parameter types: []
Method 'getPlayTest' cannot be resolved in context configurations.getPlayTest() (line: 222) MethodCallExprContext{wrapped=configurations.getPlayTest()}. Parameter types: []
Method 'getPlayRun' cannot be resolved in context configurations.getPlayRun() (line: 223) MethodCallExprContext{wrapped=configurations.getPlayRun()}. Parameter types: []
Method 'getPlayRun' cannot be resolved in context configurations.getPlayRun() (line: 233) MethodCallExprContext{wrapped=configurations.getPlayRun()}. Parameter types: []
Cannot solve method call scalaCompile.setClasspath(((PlayApplicationBinarySpecInternal) binary).getClasspath()) java.lang.RuntimeException: Method 'getClasspath' cannot be resolved in context ((PlayApplicationBinarySpecInternal) binary).getClasspath() (line: 242) MethodCallExprContext{wrapped=((PlayApplicationBinarySpecInternal) binary).getClasspath()}. Parameter types: [] /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayApplicationPlugin.java
Method 'withType' cannot be resolved in context tasks.withType(PlatformScalaCompile.class) (line: 239) MethodCallExprContext{wrapped=tasks.withType(PlatformScalaCompile.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.language.scala.tasks.PlatformScalaCompile, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getTasks' cannot be resolved in context binary.getTasks() (line: 249) MethodCallExprContext{wrapped=binary.getTasks()}. Parameter types: []
Cannot solve method call jar.setDescription("Assembles the application jar for the " + binary.getDisplayName() + ".") java.lang.RuntimeException: Method 'getDisplayName' cannot be resolved in context binary.getDisplayName() (line: 252) MethodCallExprContext{wrapped=binary.getDisplayName()}. Parameter types: [] /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayApplicationPlugin.java
Method 'getJarFile' cannot be resolved in context binary.getJarFile() (line: 253) MethodCallExprContext{wrapped=binary.getJarFile()}. Parameter types: []
Cannot solve method call jar.setDestinationDir(binary.getJarFile().getParentFile()) java.lang.RuntimeException: Method 'getJarFile' cannot be resolved in context binary.getJarFile() (line: 253) MethodCallExprContext{wrapped=binary.getJarFile()}. Parameter types: [] /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayApplicationPlugin.java
Method 'getJarFile' cannot be resolved in context binary.getJarFile() (line: 254) MethodCallExprContext{wrapped=binary.getJarFile()}. Parameter types: []
Cannot solve method call jar.setArchiveName(binary.getJarFile().getName()) java.lang.RuntimeException: Method 'getJarFile' cannot be resolved in context binary.getJarFile() (line: 254) MethodCallExprContext{wrapped=binary.getJarFile()}. Parameter types: [] /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayApplicationPlugin.java
Method 'getAssembly' cannot be resolved in context binary.getAssembly() (line: 255) MethodCallExprContext{wrapped=binary.getAssembly()}. Parameter types: []
Cannot solve method call jar.from(binary.getAssembly().getClassDirectories()) java.lang.RuntimeException: Method 'getAssembly' cannot be resolved in context binary.getAssembly() (line: 255) MethodCallExprContext{wrapped=binary.getAssembly()}. Parameter types: [] /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayApplicationPlugin.java
Method 'getAssembly' cannot be resolved in context binary.getAssembly() (line: 256) MethodCallExprContext{wrapped=binary.getAssembly()}. Parameter types: []
Cannot solve method call jar.from(binary.getAssembly().getResourceDirectories()) java.lang.RuntimeException: Method 'getAssembly' cannot be resolved in context binary.getAssembly() (line: 256) MethodCallExprContext{wrapped=binary.getAssembly()}. Parameter types: [] /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayApplicationPlugin.java
Cannot solve method call jar.dependsOn(binary.getAssembly()) java.lang.RuntimeException: Method 'getAssembly' cannot be resolved in context binary.getAssembly() (line: 257) MethodCallExprContext{wrapped=binary.getAssembly()}. Parameter types: [] /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayApplicationPlugin.java
Method 'getTasks' cannot be resolved in context binary.getTasks() (line: 261) MethodCallExprContext{wrapped=binary.getTasks()}. Parameter types: []
Cannot solve method call jar.setDescription("Assembles the assets jar for the " + binary.getDisplayName() + ".") java.lang.RuntimeException: Method 'getDisplayName' cannot be resolved in context binary.getDisplayName() (line: 264) MethodCallExprContext{wrapped=binary.getDisplayName()}. Parameter types: [] /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayApplicationPlugin.java
Method 'getAssetsJarFile' cannot be resolved in context binary.getAssetsJarFile() (line: 265) MethodCallExprContext{wrapped=binary.getAssetsJarFile()}. Parameter types: []
Cannot solve method call jar.setDestinationDir(binary.getAssetsJarFile().getParentFile()) java.lang.RuntimeException: Method 'getAssetsJarFile' cannot be resolved in context binary.getAssetsJarFile() (line: 265) MethodCallExprContext{wrapped=binary.getAssetsJarFile()}. Parameter types: [] /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayApplicationPlugin.java
Method 'getAssetsJarFile' cannot be resolved in context binary.getAssetsJarFile() (line: 266) MethodCallExprContext{wrapped=binary.getAssetsJarFile()}. Parameter types: []
Cannot solve method call jar.setArchiveName(binary.getAssetsJarFile().getName()) java.lang.RuntimeException: Method 'getAssetsJarFile' cannot be resolved in context binary.getAssetsJarFile() (line: 266) MethodCallExprContext{wrapped=binary.getAssetsJarFile()}. Parameter types: [] /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayApplicationPlugin.java
Method 'getAssets' cannot be resolved in context binary.getAssets() (line: 269) MethodCallExprContext{wrapped=binary.getAssets()}. Parameter types: []
Cannot solve method call newSpec.from(binary.getAssets().getAssetDirs()) java.lang.RuntimeException: Method 'getAssets' cannot be resolved in context binary.getAssets() (line: 269) MethodCallExprContext{wrapped=binary.getAssets()}. Parameter types: [] /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayApplicationPlugin.java
Cannot solve method call jar.dependsOn(binary.getAssets()) java.lang.RuntimeException: Method 'getAssets' cannot be resolved in context binary.getAssets() (line: 271) MethodCallExprContext{wrapped=binary.getAssets()}. Parameter types: [] /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayApplicationPlugin.java
Method 'getTasks' cannot be resolved in context binary.getTasks() (line: 280) MethodCallExprContext{wrapped=binary.getTasks()}. Parameter types: []
Cannot solve method call playToolChain.select(binary.getTargetPlatform()) java.lang.RuntimeException: Method 'getTargetPlatform' cannot be resolved in context binary.getTargetPlatform() (line: 287) MethodCallExprContext{wrapped=binary.getTargetPlatform()}. Parameter types: [] /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayApplicationPlugin.java
Cannot solve method call playRun.setPlayToolProvider(playToolChain.select(binary.getTargetPlatform())) java.lang.RuntimeException: Error calculating the type of parameter binary.getTargetPlatform() of method call playToolChain.select(binary.getTargetPlatform()) /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayApplicationPlugin.java
Cannot solve method call playRun.setApplicationJar(binary.getJarFile()) java.lang.RuntimeException: Method 'getJarFile' cannot be resolved in context binary.getJarFile() (line: 288) MethodCallExprContext{wrapped=binary.getJarFile()}. Parameter types: [] /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayApplicationPlugin.java
Cannot solve method call playRun.setAssetsJar(binary.getAssetsJarFile()) java.lang.RuntimeException: Method 'getAssetsJarFile' cannot be resolved in context binary.getAssetsJarFile() (line: 289) MethodCallExprContext{wrapped=binary.getAssetsJarFile()}. Parameter types: [] /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayApplicationPlugin.java
Method 'getAssets' cannot be resolved in context binary.getAssets() (line: 290) MethodCallExprContext{wrapped=binary.getAssets()}. Parameter types: []
Cannot solve method call playRun.setAssetsDirs(binary.getAssets().getAssetDirs()) java.lang.RuntimeException: Method 'getAssets' cannot be resolved in context binary.getAssets() (line: 290) MethodCallExprContext{wrapped=binary.getAssets()}. Parameter types: [] /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayApplicationPlugin.java
Method 'getPlayRun' cannot be resolved in context configurations.getPlayRun() (line: 291) MethodCallExprContext{wrapped=configurations.getPlayRun()}. Parameter types: []
Cannot solve method call playRun.setRuntimeClasspath(configurations.getPlayRun().getNonChangingArtifacts()) java.lang.RuntimeException: Method 'getPlayRun' cannot be resolved in context configurations.getPlayRun() (line: 291) MethodCallExprContext{wrapped=configurations.getPlayRun()}. Parameter types: [] /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayApplicationPlugin.java
Method 'getPlayRun' cannot be resolved in context configurations.getPlayRun() (line: 292) MethodCallExprContext{wrapped=configurations.getPlayRun()}. Parameter types: []
Cannot solve method call playRun.setChangingClasspath(configurations.getPlayRun().getChangingArtifacts()) java.lang.RuntimeException: Method 'getPlayRun' cannot be resolved in context configurations.getPlayRun() (line: 292) MethodCallExprContext{wrapped=configurations.getPlayRun()}. Parameter types: [] /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayApplicationPlugin.java
Cannot solve method call playRun.dependsOn(binary.getBuildTask()) java.lang.RuntimeException: Method 'getBuildTask' cannot be resolved in context binary.getBuildTask() (line: 293) MethodCallExprContext{wrapped=binary.getBuildTask()}. Parameter types: [] /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayApplicationPlugin.java
Cannot solve method call configurations.getPlay().addDependency(((PlayPlatformInternal) targetPlatform).getDependencyNotation("play-java")) java.lang.RuntimeException: Method 'getDependencyNotation' cannot be resolved in context ((PlayPlatformInternal) targetPlatform).getDependencyNotation("play-java") (line: 86) MethodCallExprContext{wrapped=((PlayPlatformInternal) targetPlatform).getDependencyNotation("play-java")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayTwirlPlugin.java
Method 'withType' cannot be resolved in context playApplicationSpec.getSources().withType(TwirlSourceSet.class) (line: 98) MethodCallExprContext{wrapped=playApplicationSpec.getSources().withType(TwirlSourceSet.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.language.twirl.TwirlSourceSet, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve field access TwirlImports.JAVA
Cannot solve method call CollectionUtils.any(playApplicationSpec.getSources().withType(TwirlSourceSet.class).values(), new Spec<TwirlSourceSet>() {

    @Override
    public boolean isSatisfiedBy(TwirlSourceSet twirlSourceSet) {
        return twirlSourceSet.getDefaultImports() == TwirlImports.JAVA;
    }
}) java.lang.RuntimeException: Method 'withType' cannot be resolved in context playApplicationSpec.getSources().withType(TwirlSourceSet.class) (line: 98) MethodCallExprContext{wrapped=playApplicationSpec.getSources().withType(TwirlSourceSet.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.language.twirl.TwirlSourceSet, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayTwirlPlugin.java
Cannot solve method call jar.dependsOn(binary.getTasks().withType(Jar.class)) java.lang.RuntimeException: Method 'withType' cannot be resolved in context binary.getTasks().withType(Jar.class) (line: 121) MethodCallExprContext{wrapped=binary.getTasks().withType(Jar.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.jvm.tasks.Jar, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayDistributionPlugin.java
Cannot solve method call jar.from(jar.getProject().zipTree(binary.getJarFile())) java.lang.RuntimeException: Method 'zipTree' cannot be resolved in context jar.getProject().zipTree(binary.getJarFile()) (line: 122) MethodCallExprContext{wrapped=jar.getProject().zipTree(binary.getJarFile())}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayDistributionPlugin.java
Method 'getPlayRun' cannot be resolved in context configurations.getPlayRun() (line: 151) MethodCallExprContext{wrapped=configurations.getPlayRun()}. Parameter types: []
Cannot solve method call libSpec.from(configurations.getPlayRun().getAllArtifacts()) java.lang.RuntimeException: Method 'getPlayRun' cannot be resolved in context configurations.getPlayRun() (line: 151) MethodCallExprContext{wrapped=configurations.getPlayRun()}. Parameter types: [] /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayDistributionPlugin.java
Method 'from' cannot be resolved in context confSpec.from("conf") (line: 159) MethodCallExprContext{wrapped=confSpec.from("conf")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call Iterables.concat(playConfiguration.getAllArtifacts(), Collections.singleton(assetsJarFile)) java.lang.RuntimeException: Method 'getAllArtifacts' cannot be resolved in context playConfiguration.getAllArtifacts() (line: 248) MethodCallExprContext{wrapped=playConfiguration.getAllArtifacts()}. Parameter types: [] /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayDistributionPlugin.java
Cannot solve method call Iterables.transform(Iterables.concat(playConfiguration.getAllArtifacts(), Collections.singleton(assetsJarFile)), new PrefixArtifactFileNames(playConfiguration)) java.lang.RuntimeException: Error calculating the type of parameter playConfiguration.getAllArtifacts() of method call Iterables.concat(playConfiguration.getAllArtifacts(), Collections.singleton(assetsJarFile)) /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayDistributionPlugin.java
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
Method 'getConfiguration' cannot be resolved in context configuration.getConfiguration() (line: 309) MethodCallExprContext{wrapped=configuration.getConfiguration()}. Parameter types: []
Method 'getConfiguration' cannot be resolved in context configuration.getConfiguration() (line: 309) MethodCallExprContext{wrapped=configuration.getConfiguration()}. Parameter types: []
Method 'replaceAll' cannot be resolved in context projectPath.replaceAll(":", ".") (line: 340) MethodCallExprContext{wrapped=projectPath.replaceAll(":", ".")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call new SimpleFileCollection(testSourceDir).getAsFileTree().matching(new PatternSet().include("**/*.scala", "**/*.java")) java.lang.RuntimeException: Method 'include' cannot be resolved in context new PatternSet().include("**/*.scala", "**/*.java") (line: 57) MethodCallExprContext{wrapped=new PatternSet().include("**/*.scala", "**/*.java")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayTestPlugin.java
Cannot solve method call test.setDescription("Runs " + WordUtils.uncapitalize(binary.getDisplayName() + ".")) UnsolvedSymbolException{context='Method 'uncapitalize' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=org.apache.commons.lang.WordUtils}'} /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayTestPlugin.java
Method 'getReports' cannot be resolved in context test.getReports() (line: 88) MethodCallExprContext{wrapped=test.getReports()}. Parameter types: []
Method 'getReports' cannot be resolved in context test.getReports() (line: 88) MethodCallExprContext{wrapped=test.getReports()}. Parameter types: []
Method 'getReports' cannot be resolved in context test.getReports() (line: 89) MethodCallExprContext{wrapped=test.getReports()}. Parameter types: []
Method 'getReports' cannot be resolved in context test.getReports() (line: 89) MethodCallExprContext{wrapped=test.getReports()}. Parameter types: []
Cannot solve method call binary.getTasks().add(tasks.get(testTaskName)) com.github.javaparser.symbolsolver.logic.ConfilictingGenericTypesException: No matching between ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual) /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayTestPlugin.java
Cannot solve method call checkTask.dependsOn(binary.getTasks().withType(Test.class)) java.lang.RuntimeException: Method 'withType' cannot be resolved in context binary.getTasks().withType(Test.class) (line: 114) MethodCallExprContext{wrapped=binary.getTasks().withType(Test.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{Test, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/platform-play/src/main/java/org/gradle/play/plugins/PlayTestPlugin.java
Method 'snapshot' cannot be resolved in context classPathSnapshotter.snapshot(new DefaultClassPath(getPluginClasspath())) (line: 98) MethodCallExprContext{wrapped=classPathSnapshotter.snapshot(new DefaultClassPath(getPluginClasspath()))}. Parameter types: [ReferenceType{org.gradle.internal.classpath.DefaultClassPath, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'snapshot' cannot be resolved in context classPathSnapshotter.snapshot(new DefaultClassPath(getPluginClasspath())) (line: 98) MethodCallExprContext{wrapped=classPathSnapshotter.snapshot(new DefaultClassPath(getPluginClasspath()))}. Parameter types: [ReferenceType{org.gradle.internal.classpath.DefaultClassPath, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot resolve field access null
Cannot solve method call reader.accept(new TaskNameCollectorVisitor(classNames), ClassReader.SKIP_CODE) UnsolvedSymbolException{context='unknown', name='SKIP_CODE', typeSolver=null} /repo/subprojects/plugin-development/src/main/java/org/gradle/plugin/devel/tasks/ValidateTaskProperties.java
Cannot solve method call Modifier.isPublic(clazz.getModifiers()) java.lang.RuntimeException: Method 'getModifiers' cannot be resolved in context clazz.getModifiers() (line: 176) MethodCallExprContext{wrapped=clazz.getModifiers()}. Parameter types: [] /repo/subprojects/plugin-development/src/main/java/org/gradle/plugin/devel/tasks/ValidateTaskProperties.java
Cannot solve method call Modifier.isAbstract(clazz.getModifiers()) java.lang.RuntimeException: Method 'getModifiers' cannot be resolved in context clazz.getModifiers() (line: 179) MethodCallExprContext{wrapped=clazz.getModifiers()}. Parameter types: [] /repo/subprojects/plugin-development/src/main/java/org/gradle/plugin/devel/tasks/ValidateTaskProperties.java
Method 'create' cannot be resolved in context getServices().get(DirectoryFileTreeFactory.class).create(getClassesDir()) (line: 147) MethodCallExprContext{wrapped=getServices().get(DirectoryFileTreeFactory.class).create(getClassesDir())}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot resolve field access null
Cannot solve method call taskValidationProblems.values().contains(Boolean.TRUE) UnsolvedSymbolException{context='unknown', name='TRUE', typeSolver=null} /repo/subprojects/plugin-development/src/main/java/org/gradle/plugin/devel/tasks/ValidateTaskProperties.java
Cannot solve method call communicateResult(problemMessages, taskValidationProblems.values().contains(Boolean.TRUE)) java.lang.RuntimeException: Error calculating the type of parameter Boolean.TRUE of method call taskValidationProblems.values().contains(Boolean.TRUE) /repo/subprojects/plugin-development/src/main/java/org/gradle/plugin/devel/tasks/ValidateTaskProperties.java
Error calculating the type of parameter Charsets.UTF_8 of method call Files.asCharSink(outputFile, Charsets.UTF_8)
Cannot solve method call String.format("Task property validation failed. See %s for more information on how to annotate task properties.", getDocumentationRegistry().getDocumentationFor("more_about_tasks", "sec:task_input_output_annotations")) java.lang.RuntimeException: Method 'getDocumentationFor' cannot be resolved in context getDocumentationRegistry().getDocumentationFor("more_about_tasks", "sec:task_input_output_annotations") (line: 217) MethodCallExprContext{wrapped=getDocumentationRegistry().getDocumentationFor("more_about_tasks", "sec:task_input_output_annotations")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/plugin-development/src/main/java/org/gradle/plugin/devel/tasks/ValidateTaskProperties.java
Cannot solve method call getLogger().warn("Task property validation finished with errors. See {} for more information on how to annotate task properties.{}", getDocumentationRegistry().getDocumentationFor("more_about_tasks", "sec:task_input_output_annotations"), toMessageList(problemMessages)) java.lang.RuntimeException: Method 'getDocumentationFor' cannot be resolved in context getDocumentationRegistry().getDocumentationFor("more_about_tasks", "sec:task_input_output_annotations") (line: 215) MethodCallExprContext{wrapped=getDocumentationRegistry().getDocumentationFor("more_about_tasks", "sec:task_input_output_annotations")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/plugin-development/src/main/java/org/gradle/plugin/devel/tasks/ValidateTaskProperties.java
Cannot resolve field access null
expected either zero type arguments or has many as defined in the declaration (0). Found 1
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call builder.append(String.format("%n  - %s", problemMessage)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/plugin-development/src/main/java/org/gradle/plugin/devel/tasks/ValidateTaskProperties.java
Cannot solve field access PathSensitivity.RELATIVE
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call classNames.add(name.replace('/', '.')) java.lang.RuntimeException: Method 'replace' cannot be resolved in context name.replace('/', '.') (line: 358) MethodCallExprContext{wrapped=name.replace('/', '.')}. Parameter types: [PrimitiveTypeUsage{name='char'}, PrimitiveTypeUsage{name='char'}] /repo/subprojects/plugin-development/src/main/java/org/gradle/plugin/devel/tasks/ValidateTaskProperties.java
Cannot solve method call root.appendChild(document.createElement("dependencies")) java.lang.RuntimeException: Method 'createElement' cannot be resolved in context document.createElement("dependencies") (line: 80) MethodCallExprContext{wrapped=document.createElement("dependencies")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/plugin-development/src/main/java/org/gradle/plugin/devel/plugins/MavenPluginPublishingRules.java
Cannot solve method call dependencies.appendChild(document.createElement("dependency")) java.lang.RuntimeException: Method 'createElement' cannot be resolved in context document.createElement("dependency") (line: 81) MethodCallExprContext{wrapped=document.createElement("dependency")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/plugin-development/src/main/java/org/gradle/plugin/devel/plugins/MavenPluginPublishingRules.java
Cannot solve method call dependency.appendChild(document.createElement("groupId")) java.lang.RuntimeException: Method 'createElement' cannot be resolved in context document.createElement("groupId") (line: 82) MethodCallExprContext{wrapped=document.createElement("groupId")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/plugin-development/src/main/java/org/gradle/plugin/devel/plugins/MavenPluginPublishingRules.java
Cannot solve method call dependency.appendChild(document.createElement("artifactId")) java.lang.RuntimeException: Method 'createElement' cannot be resolved in context document.createElement("artifactId") (line: 84) MethodCallExprContext{wrapped=document.createElement("artifactId")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/plugin-development/src/main/java/org/gradle/plugin/devel/plugins/MavenPluginPublishingRules.java
Cannot solve method call dependency.appendChild(document.createElement("version")) java.lang.RuntimeException: Method 'createElement' cannot be resolved in context document.createElement("version") (line: 86) MethodCallExprContext{wrapped=document.createElement("version")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/plugin-development/src/main/java/org/gradle/plugin/devel/plugins/MavenPluginPublishingRules.java
Cannot solve method call conventionMapping.map("pluginClasspath", new Callable<Object>() {

    public Object call() throws Exception {
        FileCollection gradleApi = gradlePluginConfiguration.getIncoming().getFiles();
        return extension.getPluginSourceSet().getRuntimeClasspath().minus(gradleApi);
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/plugin-development/src/main/java/org/gradle/plugin/devel/plugins/JavaGradlePluginPlugin.java
Cannot solve method call conventionMapping.map("outputDirectory", new Callable<Object>() {

    public Object call() throws Exception {
        return new File(project.getBuildDir(), pluginUnderTestMetadataTask.getName());
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/plugin-development/src/main/java/org/gradle/plugin/devel/plugins/JavaGradlePluginPlugin.java
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 220) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 220) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call LOGGER.warn(String.format(BAD_IMPL_CLASS_WARNING_MESSAGE, task.getPath(), pluginFileName, pluginImplementation)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/plugin-development/src/main/java/org/gradle/plugin/devel/plugins/JavaGradlePluginPlugin.java
Cannot solve method call LOGGER.warn(String.format(INVALID_DESCRIPTOR_WARNING_MESSAGE, task.getPath(), pluginFileName)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/plugin-development/src/main/java/org/gradle/plugin/devel/plugins/JavaGradlePluginPlugin.java
Cannot solve method call LOGGER.warn(String.format(DECLARED_PLUGIN_MISSING_MESSAGE, task.getPath(), declaration.getName(), declaration.getId())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/plugin-development/src/main/java/org/gradle/plugin/devel/plugins/JavaGradlePluginPlugin.java
Cannot solve method call LOGGER.warn(String.format(NO_DESCRIPTOR_WARNING_MESSAGE, task.getPath())) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/plugin-development/src/main/java/org/gradle/plugin/devel/plugins/JavaGradlePluginPlugin.java
Cannot solve method call classes.contains(fqClass.replaceAll("\\.", "/") + ".class") java.lang.RuntimeException: Method 'replaceAll' cannot be resolved in context fqClass.replaceAll("\\.", "/") (line: 275) MethodCallExprContext{wrapped=fqClass.replaceAll("\\.", "/")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/plugin-development/src/main/java/org/gradle/plugin/devel/plugins/JavaGradlePluginPlugin.java
Cannot solve method call dependencies.add(runtimeConfigurationName, project.files(pluginClasspathTask)) java.lang.RuntimeException: Method 'files' cannot be resolved in context project.files(pluginClasspathTask) (line: 341) MethodCallExprContext{wrapped=project.files(pluginClasspathTask)}. Parameter types: [ReferenceType{org.gradle.plugin.devel.tasks.PluginUnderTestMetadata, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/plugin-development/src/main/java/org/gradle/plugin/devel/plugins/JavaGradlePluginPlugin.java
Method 'getElementsByTagName' cannot be resolved in context root.getElementsByTagName("dependencies") (line: 85) MethodCallExprContext{wrapped=root.getElementsByTagName("dependencies")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call dependencies.appendChild(document.createElement("dependency")) java.lang.RuntimeException: Method 'createElement' cannot be resolved in context document.createElement("dependency") (line: 86) MethodCallExprContext{wrapped=document.createElement("dependency")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/plugin-development/src/main/java/org/gradle/plugin/devel/plugins/IvyPluginPublishingRules.java
Method 'getAttributes' cannot be resolved in context dependency.getAttributes() (line: 89) MethodCallExprContext{wrapped=dependency.getAttributes()}. Parameter types: []
Method 'getAttributes' cannot be resolved in context dependency.getAttributes() (line: 92) MethodCallExprContext{wrapped=dependency.getAttributes()}. Parameter types: []
Method 'getAttributes' cannot be resolved in context dependency.getAttributes() (line: 95) MethodCallExprContext{wrapped=dependency.getAttributes()}. Parameter types: []
Method 'getRegisteredSchemes' cannot be resolved in context authenticationSchemeRegistry.getRegisteredSchemes() (line: 85) MethodCallExprContext{wrapped=authenticationSchemeRegistry.getRegisteredSchemes()}. Parameter types: []
Cannot solve method call classLoaderScope.export(pluginImplementation.asClass().getClassLoader()) java.lang.RuntimeException: Method 'getClassLoader' cannot be resolved in context pluginImplementation.asClass().getClassLoader() (line: 198) MethodCallExprContext{wrapped=pluginImplementation.asClass().getClassLoader()}. Parameter types: [] /repo/subprojects/plugin-use/src/main/java/org/gradle/plugin/use/internal/DefaultPluginRequestApplicator.java
Cannot resolve field access null
Cannot solve field access FileLockManager.LockMode.None
Method 'withDisplayName' cannot be resolved in context cacheRepository.cache(CACHE_NAME).withDisplayName("Plugin Resolution Cache") (line: 82) MethodCallExprContext{wrapped=cacheRepository.cache(CACHE_NAME).withDisplayName("Plugin Resolution Cache")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'withDisplayName' cannot be resolved in context cacheRepository.cache(CACHE_NAME).withDisplayName("Plugin Resolution Cache") (line: 82) MethodCallExprContext{wrapped=cacheRepository.cache(CACHE_NAME).withDisplayName("Plugin Resolution Cache")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call result.notFound(getDescription(), String.format("plugin is not in '%s' namespace", DefaultPluginManager.CORE_PLUGIN_NAMESPACE)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/plugin-use/src/main/java/org/gradle/plugin/use/resolve/internal/CorePluginResolver.java
Cannot solve method call String.format("not a core plugin, please see %s for available core plugins", documentationRegistry.getDocumentationFor("standard_plugins")) java.lang.RuntimeException: Method 'getDocumentationFor' cannot be resolved in context documentationRegistry.getDocumentationFor("standard_plugins") (line: 43) MethodCallExprContext{wrapped=documentationRegistry.getDocumentationFor("standard_plugins")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/plugin-use/src/main/java/org/gradle/plugin/use/resolve/internal/CorePluginResolver.java
Cannot solve method call result.notFound(getDescription(), String.format("not a core plugin, please see %s for available core plugins", documentationRegistry.getDocumentationFor("standard_plugins"))) java.lang.RuntimeException: Error calculating the type of parameter documentationRegistry.getDocumentationFor("standard_plugins") of method call String.format("not a core plugin, please see %s for available core plugins", documentationRegistry.getDocumentationFor("standard_plugins")) /repo/subprojects/plugin-use/src/main/java/org/gradle/plugin/use/resolve/internal/CorePluginResolver.java
Cannot solve method call result.notFound(name, String.format("Could not resolve plugin artifact '%s'", getMarkerCoordinates(pluginRequest))) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/plugin-use/src/main/java/org/gradle/plugin/use/resolve/internal/ArtifactRepositoryPluginResolver.java
Cannot solve method call DefaultPotentialPluginWithId.of(NOOP_PLUGIN_ID, pluginRegistry.inspect(NoopPlugin.class)) java.lang.RuntimeException: Method 'inspect' cannot be resolved in context pluginRegistry.inspect(NoopPlugin.class) (line: 38) MethodCallExprContext{wrapped=pluginRegistry.inspect(NoopPlugin.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.plugin.use.resolve.internal.NoopPluginResolver.NoopPlugin, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/plugin-use/src/main/java/org/gradle/plugin/use/resolve/internal/NoopPluginResolver.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call String.format("Plugin resolution service returned HTTP %d with message '%s' (url: %s)", response.getStatusCode(), errorResponse.message, response.getUrl()) java.lang.RuntimeException: Method 'getStatusCode' cannot be resolved in context response.getStatusCode() (line: 90) MethodCallExprContext{wrapped=response.getStatusCode()}. Parameter types: [] /repo/subprojects/plugin-use/src/main/java/org/gradle/plugin/use/resolve/service/internal/PluginResolutionServiceResolver.java
Cannot resolve field access null
Cannot solve method call result.notFound(getDescription(), errorResponse.message) UnsolvedSymbolException{context='unknown', name='message', typeSolver=null} /repo/subprojects/plugin-use/src/main/java/org/gradle/plugin/use/resolve/service/internal/PluginResolutionServiceResolver.java
Cannot resolve field access null
Cannot solve method call PluginId.of(metadata.id) UnsolvedSymbolException{context='unknown', name='id', typeSolver=null} /repo/subprojects/plugin-use/src/main/java/org/gradle/plugin/use/resolve/service/internal/PluginResolutionServiceResolver.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call context.addLegacy(pluginId, metadata.implementation.get("repo"), metadata.implementation.get("gav")) UnsolvedSymbolException{context='unknown', name='implementation', typeSolver=null} /repo/subprojects/plugin-use/src/main/java/org/gradle/plugin/use/resolve/service/internal/PluginResolutionServiceResolver.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call resolution.getDependencyHandler().create(metadata.implementation.get("gav")) UnsolvedSymbolException{context='unknown', name='implementation', typeSolver=null} /repo/subprojects/plugin-use/src/main/java/org/gradle/plugin/use/resolve/service/internal/PluginResolutionServiceResolver.java
Method 'createChild' cannot be resolved in context parentScope.createChild("injected-plugin") (line: 46) MethodCallExprContext{wrapped=parentScope.createChild("injected-plugin")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'createChild' cannot be resolved in context parentScope.createChild("injected-plugin") (line: 46) MethodCallExprContext{wrapped=parentScope.createChild("injected-plugin")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call String.format("%s", PATH_SEGMENT_ESCAPER.escape(GradleVersion.current().getVersion())) java.lang.RuntimeException: Method 'escape' cannot be resolved in context PATH_SEGMENT_ESCAPER.escape(GradleVersion.current().getVersion()) (line: 43) MethodCallExprContext{wrapped=PATH_SEGMENT_ESCAPER.escape(GradleVersion.current().getVersion())}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/plugin-use/src/main/java/org/gradle/plugin/use/resolve/service/internal/HttpPluginResolutionServiceClient.java
Cannot solve method call toRequestUrl(portalUrl, String.format(PLUGIN_USE_REQUEST_URL, escapedId, escapedPluginVersion)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/plugin-use/src/main/java/org/gradle/plugin/use/resolve/service/internal/HttpPluginResolutionServiceClient.java
Cannot solve method call validate(requestUrl, new Gson().fromJson(reader, ErrorResponse.class)) java.lang.RuntimeException: Method 'fromJson' cannot be resolved in context new Gson().fromJson(reader, ErrorResponse.class) (line: 103) MethodCallExprContext{wrapped=new Gson().fromJson(reader, ErrorResponse.class)}. Parameter types: [ReferenceType{java.io.Reader, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{ErrorResponse, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/plugin-use/src/main/java/org/gradle/plugin/use/resolve/service/internal/HttpPluginResolutionServiceClient.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call String.format("invalid plugin metadata - unsupported implementation type '%s'", pluginUseMetaData.implementationType) UnsolvedSymbolException{context='unknown', name='implementationType', typeSolver=null} /repo/subprojects/plugin-use/src/main/java/org/gradle/plugin/use/resolve/service/internal/HttpPluginResolutionServiceClient.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call PersistentIndexedCacheParameters.of(PLUGIN_USE_METADATA_CACHE_NAME, new PluginRequestKey.Serializer(), ResponseSerializer.of(new PluginUseMetaData.Serializer())) UnsolvedSymbolException{context='Method 'of' with parameterTypes [ReferenceType{org.gradle.plugin.use.resolve.service.internal.PluginUseMetaData.Serializer, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=private static class ResponseSerializer<T> implements Serializer<Response<T>> {

    private final Serializer<T> payloadSerializer;

    private static <T> ResponseSerializer<T> of(Serializer<T> payloadSerializer) {
        return new ResponseSerializer<T>(payloadSerializer);
    }

    private ResponseSerializer(Serializer<T> payloadSerializer) {
        this.payloadSerializer = payloadSerializer;
    }

    public Response<T> read(Decoder decoder) throws Exception {
        return new SuccessResponse<T>(payloadSerializer.read(decoder), decoder.readSmallInt(), decoder.readString(), decoder.readNullableString());
    }

    public void write(Encoder encoder, Response<T> value) throws Exception {
        T response = value.getResponse();
        payloadSerializer.write(encoder, response);
        encoder.writeSmallInt(value.getStatusCode());
        encoder.writeString(value.getUrl());
        encoder.writeNullableString(value.getClientStatusChecksum());
    }
}}'} /repo/subprojects/plugin-use/src/main/java/org/gradle/plugin/use/resolve/service/internal/PersistentCachingPluginResolutionServiceClient.java
Cannot solve method call persistentCache.createCache(PersistentIndexedCacheParameters.of(PLUGIN_USE_METADATA_CACHE_NAME, new PluginRequestKey.Serializer(), ResponseSerializer.of(new PluginUseMetaData.Serializer()))) java.lang.RuntimeException: Error calculating the type of parameter ResponseSerializer.of(new PluginUseMetaData.Serializer()) of method call PersistentIndexedCacheParameters.of(PLUGIN_USE_METADATA_CACHE_NAME, new PluginRequestKey.Serializer(), ResponseSerializer.of(new PluginUseMetaData.Serializer())) /repo/subprojects/plugin-use/src/main/java/org/gradle/plugin/use/resolve/service/internal/PersistentCachingPluginResolutionServiceClient.java
Cannot solve method call PersistentIndexedCacheParameters.of(CLIENT_STATUS_CACHE_NAME, new ClientStatusKey.Serializer(), ResponseSerializer.of(new ClientStatus.Serializer())) UnsolvedSymbolException{context='Method 'of' with parameterTypes [ReferenceType{org.gradle.plugin.use.resolve.service.internal.ClientStatus.Serializer, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=private static class ResponseSerializer<T> implements Serializer<Response<T>> {

    private final Serializer<T> payloadSerializer;

    private static <T> ResponseSerializer<T> of(Serializer<T> payloadSerializer) {
        return new ResponseSerializer<T>(payloadSerializer);
    }

    private ResponseSerializer(Serializer<T> payloadSerializer) {
        this.payloadSerializer = payloadSerializer;
    }

    public Response<T> read(Decoder decoder) throws Exception {
        return new SuccessResponse<T>(payloadSerializer.read(decoder), decoder.readSmallInt(), decoder.readString(), decoder.readNullableString());
    }

    public void write(Encoder encoder, Response<T> value) throws Exception {
        T response = value.getResponse();
        payloadSerializer.write(encoder, response);
        encoder.writeSmallInt(value.getStatusCode());
        encoder.writeString(value.getUrl());
        encoder.writeNullableString(value.getClientStatusChecksum());
    }
}}'} /repo/subprojects/plugin-use/src/main/java/org/gradle/plugin/use/resolve/service/internal/PersistentCachingPluginResolutionServiceClient.java
Cannot solve method call persistentCache.createCache(PersistentIndexedCacheParameters.of(CLIENT_STATUS_CACHE_NAME, new ClientStatusKey.Serializer(), ResponseSerializer.of(new ClientStatus.Serializer()))) java.lang.RuntimeException: Error calculating the type of parameter ResponseSerializer.of(new ClientStatus.Serializer()) of method call PersistentIndexedCacheParameters.of(CLIENT_STATUS_CACHE_NAME, new ClientStatusKey.Serializer(), ResponseSerializer.of(new ClientStatus.Serializer())) /repo/subprojects/plugin-use/src/main/java/org/gradle/plugin/use/resolve/service/internal/PersistentCachingPluginResolutionServiceClient.java
Cannot solve method call ((IConventionAware) dist).getConventionMapping().map("baseName", new Callable<Object>() {

    @Override
    public Object call() throws Exception {
        return dist.getName().equals(MAIN_DISTRIBUTION_NAME) ? project.getName() : String.format("%s-%s", project.getName(), dist.getName());
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/plugins/src/main/java/org/gradle/api/distribution/plugins/DistributionPlugin.java
Cannot solve method call archiveTask.getConventionMapping().map("baseName", new Callable<Object>() {

    @Override
    public Object call() throws Exception {
        if (distribution.getBaseName() == null || distribution.getBaseName().equals("")) {
            throw new GradleException("Distribution baseName must not be null or empty! Check your configuration of the distribution plugin.");
        }
        return distribution.getBaseName();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/plugins/src/main/java/org/gradle/api/distribution/plugins/DistributionPlugin.java
Method 'getByType' cannot be resolved in context project.getExtensions().getByType(DefaultArtifactPublicationSet.class) (line: 126) MethodCallExprContext{wrapped=project.getExtensions().getByType(DefaultArtifactPublicationSet.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.internal.plugins.DefaultArtifactPublicationSet, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call sourceSet.setClasses(instantiator.newInstance(DefaultSourceSetOutput.class, sourceSet.getDisplayName(), fileResolver, taskResolver)) java.lang.RuntimeException: Method 'newInstance' cannot be resolved in context instantiator.newInstance(DefaultSourceSetOutput.class, sourceSet.getDisplayName(), fileResolver, taskResolver) (line: 47) MethodCallExprContext{wrapped=instantiator.newInstance(DefaultSourceSetOutput.class, sourceSet.getDisplayName(), fileResolver, taskResolver)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.internal.tasks.DefaultSourceSetOutput, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.api.internal.file.FileResolver, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.api.internal.tasks.TaskResolver, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/plugins/src/main/java/org/gradle/api/internal/tasks/DefaultSourceSetContainer.java
Cannot solve field access ScriptBindingParameter.APP_NAME
Cannot solve field access ScriptBindingParameter.OPTS_ENV_VAR
Cannot solve field access ScriptBindingParameter.EXIT_ENV_VAR
Cannot solve field access ScriptBindingParameter.MAIN_CLASSNAME
Cannot solve field access ScriptBindingParameter.DEFAULT_JVM_OPTS
Cannot solve method call binding.put(ScriptBindingParameter.DEFAULT_JVM_OPTS.getKey(), createJoinedDefaultJvmOpts(details.getDefaultJvmOpts())) java.lang.RuntimeException: Method 'createJoinedDefaultJvmOpts' cannot be resolved in context createJoinedDefaultJvmOpts(details.getDefaultJvmOpts()) (line: 57) MethodCallExprContext{wrapped=createJoinedDefaultJvmOpts(details.getDefaultJvmOpts())}. Parameter types: [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/plugins/src/main/java/org/gradle/api/internal/plugins/StartScriptTemplateBindingFactory.java
Cannot solve field access ScriptBindingParameter.APP_NAME_SYS_PROP
Cannot solve field access ScriptBindingParameter.APP_HOME_REL_PATH
Cannot solve field access ScriptBindingParameter.CLASSPATH
Cannot solve method call binding.put(ScriptBindingParameter.CLASSPATH.getKey(), createJoinedClasspath(details.getClasspath())) java.lang.RuntimeException: Method 'createJoinedClasspath' cannot be resolved in context createJoinedClasspath(details.getClasspath()) (line: 60) MethodCallExprContext{wrapped=createJoinedClasspath(details.getClasspath())}. Parameter types: [ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/plugins/src/main/java/org/gradle/api/internal/plugins/StartScriptTemplateBindingFactory.java
Cannot solve method call upload.getConventionMapping().map("descriptorDestination", new Callable<File>() {

    public File call() throws Exception {
        return new File(project.getBuildDir(), "ivy.xml");
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/plugins/src/main/java/org/gradle/api/internal/plugins/UploadRule.java
Cannot solve method call taskName.substring(PREFIX.length()) java.lang.RuntimeException: Method 'length' cannot be resolved in context PREFIX.length() (line: 43) MethodCallExprContext{wrapped=PREFIX.length()}. Parameter types: [] /repo/subprojects/plugins/src/main/java/org/gradle/api/internal/plugins/BuildConfigurationRule.java
Cannot solve method call StringUtils.uncapitalize(taskName.substring(PREFIX.length())) java.lang.RuntimeException: Error calculating the type of parameter PREFIX.length() of method call taskName.substring(PREFIX.length()) /repo/subprojects/plugins/src/main/java/org/gradle/api/internal/plugins/BuildConfigurationRule.java
Cannot solve method call Cast.cast(FileCollectionInternal.class, project.files(groovyJar.getFile())) java.lang.RuntimeException: Method 'files' cannot be resolved in context project.files(groovyJar.getFile()) (line: 91) MethodCallExprContext{wrapped=project.files(groovyJar.getFile())}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/plugins/src/main/java/org/gradle/api/tasks/GroovyRuntime.java
Cannot solve method call dependencies.add(project.getDependencies().create(notation)) com.github.javaparser.symbolsolver.logic.ConfilictingGenericTypesException: No matching between ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual) /repo/subprojects/plugins/src/main/java/org/gradle/api/tasks/GroovyRuntime.java
Cannot solve method call project.getDependencies().create(notation.replace(":groovy:", ":groovy-ant:")) java.lang.RuntimeException: Method 'replace' cannot be resolved in context notation.replace(":groovy:", ":groovy-ant:") (line: 104) MethodCallExprContext{wrapped=notation.replace(":groovy:", ":groovy-ant:")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/plugins/src/main/java/org/gradle/api/tasks/GroovyRuntime.java
Cannot solve method call dependencies.add(project.getDependencies().create(notation.replace(":groovy:", ":groovy-ant:"))) java.lang.RuntimeException: Error calculating the type of parameter notation.replace(":groovy:", ":groovy-ant:") of method call project.getDependencies().create(notation.replace(":groovy:", ":groovy-ant:")) /repo/subprojects/plugins/src/main/java/org/gradle/api/tasks/GroovyRuntime.java
Cannot solve method call project.getConfigurations().detachedConfiguration(dependencies.toArray(new Dependency[0])) java.lang.RuntimeException: org.gradle.api.artifacts.Dependency[] T[] /repo/subprojects/plugins/src/main/java/org/gradle/api/tasks/GroovyRuntime.java
Method 'getRootSpec' cannot be resolved in context getRootSpec() (line: 68) MethodCallExprContext{wrapped=getRootSpec()}. Parameter types: []
Error calculating the type of parameter getMainSpec() of method call getRootSpec().addChildBeforeSpec(getMainSpec())
Method 'getProject' cannot be resolved in context getProject() (line: 142) MethodCallExprContext{wrapped=getProject()}. Parameter types: []
Method 'getProject' cannot be resolved in context getProject() (line: 152) MethodCallExprContext{wrapped=getProject()}. Parameter types: []
Cannot solve field access PathSensitivity.NONE
Cannot solve method call super.manifest(configureClosure) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/plugins/src/main/java/org/gradle/api/tasks/bundling/Jar.java
Cannot solve method call collect(getRepositories(), Transformers.cast(PublicationAwareRepository.class)) UnsolvedSymbolException{context='Method 'cast' with parameterTypes [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.internal.artifacts.repositories.PublicationAwareRepository, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * Utility transformers.
 */
public abstract class Transformers {

    /**
     * Creates a transformer that simply type casts the input to the given output type.
     *
     * @param outputType The type to cast the input to
     * @param <O> The type of the transformed object
     * @param <I> The type of the object to be transformed
     * @return A transformer that simply type casts the input to the given output type.
     */
    public static <O, I> Transformer<O, I> cast(Class<O> outputType) {
        return new CastingTransformer<O, I>(outputType);
    }

    // just returns the original object
    public static <T> Transformer<T, T> noOpTransformer() {
        return new Transformer<T, T>() {

            public T transform(T original) {
                return original;
            }
        };
    }

    private static class CastingTransformer<O, I> implements Transformer<O, I> {

        final Class<O> outputType;

        public CastingTransformer(Class<O> outputType) {
            this.outputType = outputType;
        }

        public O transform(I input) {
            return Cast.cast(outputType, input);
        }
    }

    public static <T> Transformer<String, T> asString() {
        return new ToStringTransformer<T>();
    }

    private static class ToStringTransformer<T> implements Transformer<String, T> {

        public String transform(T original) {
            return original == null ? null : original.toString();
        }
    }

    /**
     * Returns a transformer that names {@link Named} objects.
     *
     * Nulls are returned as null.
     *
     * @return The naming transformer.
     */
    public static Transformer<String, Named> name() {
        return name(Named.Namer.INSTANCE);
    }

    /**
     * Returns a transformer that names objects with the given {@link Namer}
     *
     * @param namer The namer to name the objects with
     * @param <T> The type of objects to be named
     * @return The naming transformer.
     */
    public static <T> Transformer<String, T> name(Namer<? super T> namer) {
        return new ToNameTransformer<T>(namer);
    }

    private static class ToNameTransformer<T> implements Transformer<String, T> {

        private final Namer<? super T> namer;

        public ToNameTransformer(Namer<? super T> namer) {
            this.namer = namer;
        }

        public String transform(T thing) {
            return thing == null ? null : namer.determineName(thing);
        }
    }

    /**
     * Transforms strings which may have spaces and which may have already been escaped with
     * quotes into safe command-line arguments.
     */
    public static Transformer<String, String> asSafeCommandLineArgument() {
        return new CommandLineArgumentTransformer();
    }

    private static class CommandLineArgumentTransformer implements Transformer<String, String> {

        private static final Pattern SINGLE_QUOTED = Pattern.compile("^'.*'$");

        private static final Pattern DOUBLE_QUOTED = Pattern.compile("^\".*\"$");

        private static final Pattern A_SINGLE_QUOTE = Pattern.compile("'");

        @Override
        public String transform(String input) {
            if (SINGLE_QUOTED.matcher(input).matches() || DOUBLE_QUOTED.matcher(input).matches() || !input.contains(" ")) {
                return input;
            } else {
                return wrapWithSingleQuotes(input);
            }
        }

        private String wrapWithSingleQuotes(String input) {
            return String.format("'%1$s'", escapeSingleQuotes(input));
        }

        private String escapeSingleQuotes(String input) {
            return A_SINGLE_QUOTE.matcher(input).replaceAll("\\\\'");
        }
    }

    /**
     * A getClass() transformer.
     *
     * @param <T> The type of the object
     * @return A getClass() transformer.
     */
    public static <T> Transformer<Class<T>, T> type() {
        return new Transformer<Class<T>, T>() {

            public Class<T> transform(T original) {
                @SuppressWarnings("unchecked") Class<T> aClass = (Class<T>) original.getClass();
                return aClass;
            }
        };
    }

    public static <R> Transformer<R, Object> toTransformer(final Factory<R> factory) {
        return new Transformer<R, Object>() {

            public R transform(Object original) {
                return factory.create();
            }
        };
    }

    public static <R, I> Transformer<R, I> toTransformer(final Action<? super I> action) {
        return new Transformer<R, I>() {

            public R transform(I original) {
                action.execute(original);
                return null;
            }
        };
    }

    /**
     * Converts a URL to a URI
     */
    public static Transformer<URL, URI> toURL() {
        return new Transformer<URL, URI>() {

            public URL transform(URI original) {
                try {
                    return original.toURL();
                } catch (MalformedURLException e) {
                    throw UncheckedException.throwAsUncheckedException(e);
                }
            }
        };
    }

    /**
     * Always returns the given argument.
     */
    public static <T, I> Transformer<T, I> constant(final T t) {
        return new Transformer<T, I>() {

            public T transform(I original) {
                return t;
            }
        };
    }
}}'} /repo/subprojects/plugins/src/main/java/org/gradle/api/tasks/Upload.java
Method 'getFileResolver' cannot be resolved in context project.getServices().get(FileLookup.class).getFileResolver(curProjectBuildDir) (line: 60) MethodCallExprContext{wrapped=project.getServices().get(FileLookup.class).getFileResolver(curProjectBuildDir)}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getFileResolver' cannot be resolved in context project.getServices().get(FileLookup.class).getFileResolver(curProjectBuildDir) (line: 76) MethodCallExprContext{wrapped=project.getServices().get(FileLookup.class).getFileResolver(curProjectBuildDir)}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call childSpec.from(project.file("src/dist")) java.lang.RuntimeException: Method 'file' cannot be resolved in context project.file("src/dist") (line: 48) MethodCallExprContext{wrapped=project.file("src/dist")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/JavaLibraryDistributionPlugin.java
Cannot solve method call libSpec.from(project.getConfigurations().getByName("runtime")) java.lang.RuntimeException: Method 'getByName' cannot be resolved in context project.getConfigurations().getByName("runtime") (line: 52) MethodCallExprContext{wrapped=project.getConfigurations().getByName("runtime")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/JavaLibraryDistributionPlugin.java
Cannot solve method call compile.getConventionMapping().map("groovyClasspath", new Callable<Object>() {

    public Object call() throws Exception {
        return groovyRuntime.inferGroovyClasspath(compile.getClasspath());
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/GroovyBasePlugin.java
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 89) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 89) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getExternalModule' cannot be resolved in context moduleRegistry.getExternalModule("jansi") (line: 122) MethodCallExprContext{wrapped=moduleRegistry.getExternalModule("jansi")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getExternalModule' cannot be resolved in context moduleRegistry.getExternalModule("jansi") (line: 122) MethodCallExprContext{wrapped=moduleRegistry.getExternalModule("jansi")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call project.files(moduleRegistry.getExternalModule("jansi").getImplementationClasspath().getAsFiles()) java.lang.RuntimeException: Method 'getExternalModule' cannot be resolved in context moduleRegistry.getExternalModule("jansi") (line: 122) MethodCallExprContext{wrapped=moduleRegistry.getExternalModule("jansi")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/GroovyBasePlugin.java
Cannot solve method call groovydoc.getConventionMapping().map("groovyClasspath", new Callable<Object>() {

    public Object call() throws Exception {
        FileCollection groovyClasspath = groovyRuntime.inferGroovyClasspath(groovydoc.getClasspath());
        // Jansi is required to log errors when generating Groovydoc
        ConfigurableFileCollection jansi = project.files(moduleRegistry.getExternalModule("jansi").getImplementationClasspath().getAsFiles());
        return groovyClasspath.plus(jansi);
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/GroovyBasePlugin.java
Method 'java' cannot be resolved in context java(project.getConvention()) (line: 128) MethodCallExprContext{wrapped=java(project.getConvention())}. Parameter types: [ReferenceType{Convention, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call groovydoc.getConventionMapping().map("destinationDir", new Callable<Object>() {

    public Object call() throws Exception {
        return new File(java(project.getConvention()).getDocsDir(), "groovydoc");
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/GroovyBasePlugin.java
Method 'getByType' cannot be resolved in context project.getExtensions().getByType(ReportingExtension.class) (line: 133) MethodCallExprContext{wrapped=project.getExtensions().getByType(ReportingExtension.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.reporting.ReportingExtension, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call groovydoc.getConventionMapping().map("docTitle", new Callable<Object>() {

    public Object call() throws Exception {
        return project.getExtensions().getByType(ReportingExtension.class).getApiDocTitle();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/GroovyBasePlugin.java
Method 'getByType' cannot be resolved in context project.getExtensions().getByType(ReportingExtension.class) (line: 138) MethodCallExprContext{wrapped=project.getExtensions().getByType(ReportingExtension.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.reporting.ReportingExtension, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call groovydoc.getConventionMapping().map("windowTitle", new Callable<Object>() {

    public Object call() throws Exception {
        return project.getExtensions().getByType(ReportingExtension.class).getApiDocTitle();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/GroovyBasePlugin.java
Method 'getPlugins' cannot be resolved in context project.getConvention().getPlugins() (line: 68) MethodCallExprContext{wrapped=project.getConvention().getPlugins()}. Parameter types: []
Cannot solve method call taskConventionMapping.map("destinationDir", destinationDir) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/BasePlugin.java
Cannot solve method call taskConventionMapping.map("version", new Callable<String>() {

    public String call() throws Exception {
        return project.getVersion() == Project.DEFAULT_VERSION ? null : project.getVersion().toString();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/BasePlugin.java
Cannot solve method call taskConventionMapping.map("baseName", new Callable<String>() {

    public String call() throws Exception {
        return pluginConvention.getArchivesBaseName();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/BasePlugin.java
Method 'withType' cannot be resolved in context project.getTasks().withType(Upload.class) (line: 125) MethodCallExprContext{wrapped=project.getTasks().withType(Upload.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.tasks.Upload, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'withType' cannot be resolved in context uploadArchives.getRepositories().withType(IvyArtifactRepository.class) (line: 130) MethodCallExprContext{wrapped=uploadArchives.getRepositories().withType(IvyArtifactRepository.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.artifacts.repositories.IvyArtifactRepository, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call ((IConventionAware) distribution).getConventionMapping().map("baseName", new Callable<Object>() {

    @Override
    public Object call() throws Exception {
        return pluginConvention.getApplicationName();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/ApplicationPlugin.java
Method 'getPlugins' cannot be resolved in context project.getConvention().getPlugins() (line: 111) MethodCallExprContext{wrapped=project.getConvention().getPlugins()}. Parameter types: []
Cannot solve method call run.getConventionMapping().map("main", new Callable<Object>() {

    @Override
    public Object call() throws Exception {
        return pluginConvention.getMainClassName();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/ApplicationPlugin.java
Cannot solve method call run.getConventionMapping().map("jvmArgs", new Callable<Object>() {

    @Override
    public Object call() throws Exception {
        return pluginConvention.getApplicationDefaultJvmArgs();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/ApplicationPlugin.java
Cannot solve method call project.getTasks().getAt(JavaPlugin.JAR_TASK_NAME).getOutputs().getFiles().plus(project.getConfigurations().getByName("runtime")) java.lang.RuntimeException: Method 'getByName' cannot be resolved in context project.getConfigurations().getByName("runtime") (line: 139) MethodCallExprContext{wrapped=project.getConfigurations().getByName("runtime")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/ApplicationPlugin.java
Cannot solve method call startScripts.setClasspath(project.getTasks().getAt(JavaPlugin.JAR_TASK_NAME).getOutputs().getFiles().plus(project.getConfigurations().getByName("runtime"))) java.lang.RuntimeException: Error calculating the type of parameter project.getConfigurations().getByName("runtime") of method call project.getTasks().getAt(JavaPlugin.JAR_TASK_NAME).getOutputs().getFiles().plus(project.getConfigurations().getByName("runtime")) /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/ApplicationPlugin.java
Method 'getConventionMapping' cannot be resolved in context startScripts.getConventionMapping() (line: 141) MethodCallExprContext{wrapped=startScripts.getConventionMapping()}. Parameter types: []
Method 'getConventionMapping' cannot be resolved in context startScripts.getConventionMapping() (line: 148) MethodCallExprContext{wrapped=startScripts.getConventionMapping()}. Parameter types: []
Method 'getConventionMapping' cannot be resolved in context startScripts.getConventionMapping() (line: 155) MethodCallExprContext{wrapped=startScripts.getConventionMapping()}. Parameter types: []
Method 'getConventionMapping' cannot be resolved in context startScripts.getConventionMapping() (line: 162) MethodCallExprContext{wrapped=startScripts.getConventionMapping()}. Parameter types: []
Cannot solve method call libChildSpec.from(project.getConfigurations().getByName("runtime")) java.lang.RuntimeException: Method 'getByName' cannot be resolved in context project.getConfigurations().getByName("runtime") (line: 177) MethodCallExprContext{wrapped=project.getConfigurations().getByName("runtime")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/ApplicationPlugin.java
Cannot solve method call childSpec.from(project.file("src/dist")) java.lang.RuntimeException: Method 'file' cannot be resolved in context project.file("src/dist") (line: 185) MethodCallExprContext{wrapped=project.file("src/dist")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/ApplicationPlugin.java
Method 'getPlugins' cannot be resolved in context project.getConvention().getPlugins() (line: 47) MethodCallExprContext{wrapped=project.getConvention().getPlugins()}. Parameter types: []
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 58) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 58) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 58) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 64) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 64) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 64) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getByType' cannot be resolved in context project.getExtensions().getByType(DefaultArtifactPublicationSet.class) (line: 78) MethodCallExprContext{wrapped=project.getExtensions().getByType(DefaultArtifactPublicationSet.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.internal.plugins.DefaultArtifactPublicationSet, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getPlugins' cannot be resolved in context project.getConvention().getPlugins() (line: 103) MethodCallExprContext{wrapped=project.getConvention().getPlugins()}. Parameter types: []
Cannot solve method call ModelRegistrations.bridgedInstance(ModelReference.of("bridgedBinaries", BridgedBinaries.class), binaries) UnsolvedSymbolException{context='Method 'of' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaBasePlugin.BridgedBinaries, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * A model reference is a speculative reference to a potential model element.
 * <p>
 * Rule subjects/inputs are defined in terms of references, as opposed to concrete identity.
 * The reference may be by type only, or by path only.
 * <p>
 * A reference doesn't include the notion of readonly vs. writable as the context of the reference implies this.
 * Having this be part of the reference would open opportunities for mismatch of that flag in the context.
 *
 * @param <T> the type of the reference.
 */
@ThreadSafe
public class ModelReference<T> {

    public static final ModelReference<Object> ANY = of(ModelType.untyped());

    @Nullable
    private final ModelPath path;

    private final ModelType<T> type;

    @Nullable
    private final ModelPath scope;

    private final ModelNode.State state;

    @Nullable
    private final String description;

    private int hashCode;

    private ModelReference(@Nullable ModelPath path, ModelType<T> type, @Nullable ModelPath scope, @Nullable ModelNode.State state, @Nullable String description) {
        this.path = path;
        this.type = Preconditions.checkNotNull(type, "type");
        this.scope = scope;
        this.description = description;
        this.state = state != null ? state : ModelNode.State.GraphClosed;
    }

    public static ModelReference<Object> any() {
        return ANY;
    }

    public static <T> ModelReference<T> of(ModelPath path, ModelType<T> type, String description) {
        return Cast.uncheckedCast(new ModelReference<T>(path, type, null, null, description));
    }

    public static <T> ModelReference<T> of(String path, ModelType<T> type, String description) {
        return of(ModelPath.path(path), type, description);
    }

    public static <T> ModelReference<T> of(ModelPath path, ModelType<T> type) {
        return Cast.uncheckedCast(new ModelReference<T>(path, type, null, null, null));
    }

    public static <T> ModelReference<T> of(ModelPath path, ModelType<T> type, ModelNode.State state) {
        return Cast.uncheckedCast(new ModelReference<T>(path, type, null, state, null));
    }

    public static <T> ModelReference<T> of(ModelPath path, Class<T> type) {
        return of(path, ModelType.of(type));
    }

    public static <T> ModelReference<T> of(String path, Class<T> type) {
        return of(ModelPath.path(path), ModelType.of(type));
    }

    public static <T> ModelReference<T> of(String path, ModelType<T> type) {
        return of(path == null ? null : ModelPath.path(path), type);
    }

    public static <T> ModelReference<T> of(Class<T> type) {
        return of((ModelPath) null, ModelType.of(type));
    }

    public static <T> ModelReference<T> of(ModelType<T> type) {
        return of((ModelPath) null, type);
    }

    public static ModelReference<Object> of(String path) {
        return of(ModelPath.path(path), ModelType.UNTYPED);
    }

    public static ModelReference<Object> of(ModelPath path) {
        return of(path, ModelType.UNTYPED);
    }

    public static ModelReference<Object> untyped(ModelPath path) {
        return untyped(path, null);
    }

    public static ModelReference<Object> untyped(ModelPath path, String description) {
        return of(path, ModelType.UNTYPED, description);
    }

    @Nullable
    public ModelPath getPath() {
        return path;
    }

    /**
     * Return the path of the scope of the node to select, or null if scope is not relevant.
     *
     * <p>A node will be selected if its path or its parent's path equals the specified path.</p>
     */
    @Nullable
    public ModelPath getScope() {
        return scope;
    }

    @Nullable
    public String getDescription() {
        return description;
    }

    public ModelType<T> getType() {
        return type;
    }

    public ModelNode.State getState() {
        return state;
    }

    public boolean isUntyped() {
        return type.equals(ModelType.UNTYPED);
    }

    public ModelReference<T> inScope(ModelPath scope) {
        if (scope.equals(this.scope)) {
            return this;
        }
        return Cast.uncheckedCast(new ModelReference<T>(path, type, scope, state, description));
    }

    public ModelReference<T> withPath(ModelPath path) {
        return Cast.uncheckedCast(new ModelReference<T>(path, type, scope, state, description));
    }

    public ModelReference<T> atState(ModelNode.State state) {
        if (state.equals(this.state)) {
            return this;
        }
        return Cast.uncheckedCast(new ModelReference<T>(path, type, scope, state, description));
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ModelReference<?> that = (ModelReference<?>) o;
        return Objects.equal(path, that.path) && Objects.equal(scope, that.scope) && type.equals(that.type) && state.equals(that.state) && Objects.equal(description, that.description);
    }

    @Override
    public int hashCode() {
        int result = hashCode;
        if (result != 0) {
            return result;
        }
        result = path == null ? 0 : path.hashCode();
        result = 31 * result + (scope == null ? 0 : scope.hashCode());
        result = 31 * result + type.hashCode();
        result = 31 * result + state.hashCode();
        result = 31 * result + (description == null ? 0 : description.hashCode());
        hashCode = result;
        return result;
    }

    @Override
    public String toString() {
        return "ModelReference{path=" + path + ", scope=" + scope + ", type=" + type + ", state=" + state + '}';
    }
}}'} /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/JavaBasePlugin.java
Error calculating the type of parameter ModelReference.of("bridgedBinaries", BridgedBinaries.class) of method call ModelRegistrations.bridgedInstance(ModelReference.of("bridgedBinaries", BridgedBinaries.class), binaries)
Error calculating the type of parameter ModelReference.of("bridgedBinaries", BridgedBinaries.class) of method call ModelRegistrations.bridgedInstance(ModelReference.of("bridgedBinaries", BridgedBinaries.class), binaries)
Error calculating the type of parameter ModelReference.of("bridgedBinaries", BridgedBinaries.class) of method call ModelRegistrations.bridgedInstance(ModelReference.of("bridgedBinaries", BridgedBinaries.class), binaries)
Cannot solve method call modelRegistry.register(ModelRegistrations.bridgedInstance(ModelReference.of("bridgedBinaries", BridgedBinaries.class), binaries).descriptor("JavaBasePlugin.apply()").hidden(true).build()) java.lang.RuntimeException: Error calculating the type of parameter ModelReference.of("bridgedBinaries", BridgedBinaries.class) of method call ModelRegistrations.bridgedInstance(ModelReference.of("bridgedBinaries", BridgedBinaries.class), binaries) /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/JavaBasePlugin.java
Cannot solve method call instantiator.newInstance(DefaultJavaSourceSet.class, binaryId.child("java"), sourceSet.getJava(), compileClasspath) java.lang.RuntimeException: Method 'child' cannot be resolved in context binaryId.child("java") (line: 139) MethodCallExprContext{wrapped=binaryId.child("java")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/JavaBasePlugin.java
Cannot solve method call instantiator.newInstance(DefaultJvmResourceSet.class, binaryId.child("resources"), sourceSet.getResources()) java.lang.RuntimeException: Method 'child' cannot be resolved in context binaryId.child("resources") (line: 140) MethodCallExprContext{wrapped=binaryId.child("resources")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/JavaBasePlugin.java
Cannot solve method call conventionMapping.map("classpath", new Callable<Object>() {

    public Object call() throws Exception {
        return sourceSet.getCompileClasspath();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/JavaBasePlugin.java
Cannot solve method call conventionMapping.map("destinationDir", new Callable<Object>() {

    public Object call() throws Exception {
        return sourceSet.getOutput().getClassesDir();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/JavaBasePlugin.java
Cannot solve method call new DslObject(resourcesTask).getConventionMapping().map("destinationDir", new Callable<File>() {

    public File call() throws Exception {
        return sourceSet.getOutput().getResourcesDir();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/JavaBasePlugin.java
Cannot solve method call outputConventionMapping.map("classesDir", new Callable<Object>() {

    public Object call() throws Exception {
        String classesDirName = "classes/" + sourceSet.getName();
        return new File(project.getBuildDir(), classesDirName);
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/JavaBasePlugin.java
Cannot solve method call outputConventionMapping.map("resourcesDir", new Callable<Object>() {

    public Object call() throws Exception {
        String classesDirName = "resources/" + sourceSet.getName();
        return new File(project.getBuildDir(), classesDirName);
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/JavaBasePlugin.java
Cannot solve method call conventionMapping.map("classpath", new Callable<Object>() {

    public Object call() throws Exception {
        return sourceSet.getCompileClasspath();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/JavaBasePlugin.java
Cannot solve method call conventionMapping.map("destinationDir", new Callable<Object>() {

    public Object call() throws Exception {
        return sourceSet.getOutput().getClassesDir();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/JavaBasePlugin.java
Cannot solve method call conventionMapping.map("sourceCompatibility", new Callable<Object>() {

    public Object call() throws Exception {
        return javaConvention.getSourceCompatibility().toString();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/JavaBasePlugin.java
Cannot solve method call conventionMapping.map("targetCompatibility", new Callable<Object>() {

    public Object call() throws Exception {
        return javaConvention.getTargetCompatibility().toString();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/JavaBasePlugin.java
Cannot solve method call conventionMapping.map("dependencyCacheDir", new Callable<Object>() {

    public Object call() throws Exception {
        return javaConvention.getDependencyCacheDir();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/JavaBasePlugin.java
Cannot solve method call javadoc.getConventionMapping().map("destinationDir", new Callable<Object>() {

    public Object call() throws Exception {
        return new File(convention.getDocsDir(), "javadoc");
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/JavaBasePlugin.java
Method 'getByType' cannot be resolved in context project.getExtensions().getByType(ReportingExtension.class) (line: 298) MethodCallExprContext{wrapped=project.getExtensions().getByType(ReportingExtension.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.reporting.ReportingExtension, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call javadoc.getConventionMapping().map("title", new Callable<Object>() {

    public Object call() throws Exception {
        return project.getExtensions().getByType(ReportingExtension.class).getApiDocTitle();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/JavaBasePlugin.java
Method 'getInputs' cannot be resolved in context test.getInputs() (line: 355) MethodCallExprContext{wrapped=test.getInputs()}. Parameter types: []
Error calculating the type of parameter test.getCandidateClassFiles() of method call test.getInputs().files(test.getCandidateClassFiles())
Error calculating the type of parameter test.getCandidateClassFiles() of method call test.getInputs().files(test.getCandidateClassFiles())
Method 'getLogger' cannot be resolved in context test.getLogger() (line: 360) MethodCallExprContext{wrapped=test.getLogger()}. Parameter types: []
Method 'getReports' cannot be resolved in context test.getReports() (line: 377) MethodCallExprContext{wrapped=test.getReports()}. Parameter types: []
Method 'getReports' cannot be resolved in context test.getReports() (line: 378) MethodCallExprContext{wrapped=test.getReports()}. Parameter types: []
Cannot solve method call xmlReport.getConventionMapping().map("destination", new Callable<Object>() {

    public Object call() throws Exception {
        return new File(convention.getTestResultsDir(), test.getName());
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/JavaBasePlugin.java
Cannot solve method call htmlReport.getConventionMapping().map("destination", new Callable<Object>() {

    public Object call() throws Exception {
        return new File(convention.getTestReportDir(), test.getName());
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/JavaBasePlugin.java
Method 'getConventionMapping' cannot be resolved in context test.getConventionMapping() (line: 390) MethodCallExprContext{wrapped=test.getConventionMapping()}. Parameter types: []
Cannot solve method call test.setCompileClasspath(project.files(main.getOutput(), project.getConfigurations().getByName(TEST_COMPILE_CLASSPATH_CONFIGURATION_NAME))) java.lang.RuntimeException: Method 'files' cannot be resolved in context project.files(main.getOutput(), project.getConfigurations().getByName(TEST_COMPILE_CLASSPATH_CONFIGURATION_NAME)) (line: 86) MethodCallExprContext{wrapped=project.files(main.getOutput(), project.getConfigurations().getByName(TEST_COMPILE_CLASSPATH_CONFIGURATION_NAME))}. Parameter types: [ReferenceType{org.gradle.api.tasks.SourceSetOutput, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.api.artifacts.Configuration, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/JavaPlugin.java
Cannot solve method call test.setRuntimeClasspath(project.files(test.getOutput(), main.getOutput(), project.getConfigurations().getByName(TEST_RUNTIME_CONFIGURATION_NAME))) java.lang.RuntimeException: Method 'files' cannot be resolved in context project.files(test.getOutput(), main.getOutput(), project.getConfigurations().getByName(TEST_RUNTIME_CONFIGURATION_NAME)) (line: 87) MethodCallExprContext{wrapped=project.files(test.getOutput(), main.getOutput(), project.getConfigurations().getByName(TEST_RUNTIME_CONFIGURATION_NAME))}. Parameter types: [ReferenceType{org.gradle.api.tasks.SourceSetOutput, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.api.tasks.SourceSetOutput, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{org.gradle.api.artifacts.Configuration, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/plugins/src/main/java/org/gradle/api/plugins/JavaPlugin.java
Method 'getByType' cannot be resolved in context project.getExtensions().getByType(DefaultArtifactPublicationSet.class) (line: 112) MethodCallExprContext{wrapped=project.getExtensions().getByType(DefaultArtifactPublicationSet.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.internal.plugins.DefaultArtifactPublicationSet, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getConventionMapping' cannot be resolved in context test.getConventionMapping() (line: 126) MethodCallExprContext{wrapped=test.getConventionMapping()}. Parameter types: []
Method 'getConventionMapping' cannot be resolved in context test.getConventionMapping() (line: 131) MethodCallExprContext{wrapped=test.getConventionMapping()}. Parameter types: []
Method 'getFileResolver' cannot be resolved in context project.getServices().get(FileLookup.class).getFileResolver(project.getBuildDir()) (line: 93) MethodCallExprContext{wrapped=project.getServices().get(FileLookup.class).getFileResolver(project.getBuildDir())}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getFileResolver' cannot be resolved in context project.getServices().get(FileLookup.class).getFileResolver(project.getBuildDir()) (line: 100) MethodCallExprContext{wrapped=project.getServices().get(FileLookup.class).getFileResolver(project.getBuildDir())}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getFileResolver' cannot be resolved in context project.getServices().get(FileLookup.class).getFileResolver(project.getBuildDir()) (line: 107) MethodCallExprContext{wrapped=project.getServices().get(FileLookup.class).getFileResolver(project.getBuildDir())}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getFileResolver' cannot be resolved in context project.getServices().get(FileLookup.class).getFileResolver(getReportsDir()) (line: 114) MethodCallExprContext{wrapped=project.getServices().get(FileLookup.class).getFileResolver(getReportsDir())}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getByType' cannot be resolved in context project.getExtensions().getByType(ReportingExtension.class) (line: 118) MethodCallExprContext{wrapped=project.getExtensions().getByType(ReportingExtension.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.reporting.ReportingExtension, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call failure(String.format("%s cannot be empty.", name)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/publish/src/main/java/org/gradle/api/publish/internal/PublicationFieldValidator.java
Cannot solve method call failure(String.format("%s cannot contain ISO control character '\\u%04x'.", name, unicodeChar)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, PrimitiveTypeUsage{name='int'}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/publish/src/main/java/org/gradle/api/publish/internal/PublicationFieldValidator.java
Cannot solve method call failure(String.format("%s cannot contain '%c'.", name, (char) unicodeChar)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, PrimitiveTypeUsage{name='char'}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/publish/src/main/java/org/gradle/api/publish/internal/PublicationFieldValidator.java
Cannot solve method call failure(String.format("%s cannot be an empty string. Use null instead.", name)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/publish/src/main/java/org/gradle/api/publish/internal/PublicationFieldValidator.java
Method 'withType' cannot be resolved in context publishing.getPublications().withType(PublicationInternal.class) (line: 39) MethodCallExprContext{wrapped=publishing.getPublications().withType(PublicationInternal.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.publish.internal.PublicationInternal, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot resolve field access null
Method 'getFileResolver' cannot be resolved in context ReportingExtension.this.project.getServices().get(FileLookup.class).getFileResolver(ReportingExtension.this.project.getBuildDir()) (line: 59) MethodCallExprContext{wrapped=ReportingExtension.this.project.getServices().get(FileLookup.class).getFileResolver(ReportingExtension.this.project.getBuildDir())}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getFileResolver' cannot be resolved in context this.project.getServices().get(FileLookup.class).getFileResolver(getBaseDir()) (line: 97) MethodCallExprContext{wrapped=this.project.getServices().get(FileLookup.class).getFileResolver(getBaseDir())}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot resolve field access null
Method 'meta' cannot be resolved in context meta() (line: 62) MethodCallExprContext{wrapped=meta()}. Parameter types: []
Method 'meta' cannot be resolved in context meta() (line: 62) MethodCallExprContext{wrapped=meta()}. Parameter types: []
Method 'meta' cannot be resolved in context meta() (line: 63) MethodCallExprContext{wrapped=meta()}. Parameter types: []
Method 'meta' cannot be resolved in context meta() (line: 63) MethodCallExprContext{wrapped=meta()}. Parameter types: []
Method 'link' cannot be resolved in context link() (line: 64) MethodCallExprContext{wrapped=link()}. Parameter types: []
Method 'link' cannot be resolved in context link() (line: 64) MethodCallExprContext{wrapped=link()}. Parameter types: []
Method 'link' cannot be resolved in context link() (line: 64) MethodCallExprContext{wrapped=link()}. Parameter types: []
Method 'link' cannot be resolved in context link() (line: 64) MethodCallExprContext{wrapped=link()}. Parameter types: []
Method 'link' cannot be resolved in context link() (line: 65) MethodCallExprContext{wrapped=link()}. Parameter types: []
Method 'link' cannot be resolved in context link() (line: 65) MethodCallExprContext{wrapped=link()}. Parameter types: []
Method 'link' cannot be resolved in context link() (line: 65) MethodCallExprContext{wrapped=link()}. Parameter types: []
Method 'link' cannot be resolved in context link() (line: 65) MethodCallExprContext{wrapped=link()}. Parameter types: []
Method 'title' cannot be resolved in context title() (line: 66) MethodCallExprContext{wrapped=title()}. Parameter types: []
Method 'title' cannot be resolved in context title() (line: 66) MethodCallExprContext{wrapped=title()}. Parameter types: []
Method 'div' cannot be resolved in context div() (line: 69) MethodCallExprContext{wrapped=div()}. Parameter types: []
Method 'h1' cannot be resolved in context h1() (line: 84) MethodCallExprContext{wrapped=h1()}. Parameter types: []
Method 'h1' cannot be resolved in context h1() (line: 84) MethodCallExprContext{wrapped=h1()}. Parameter types: []
Method 'h1' cannot be resolved in context h1() (line: 71) MethodCallExprContext{wrapped=h1()}. Parameter types: []
Method 'h1' cannot be resolved in context h1() (line: 71) MethodCallExprContext{wrapped=h1()}. Parameter types: []
Method 'span' cannot be resolved in context span() (line: 78) MethodCallExprContext{wrapped=span()}. Parameter types: []
Method 'span' cannot be resolved in context span() (line: 78) MethodCallExprContext{wrapped=span()}. Parameter types: []
Method 'a' cannot be resolved in context a() (line: 76) MethodCallExprContext{wrapped=a()}. Parameter types: []
Method 'a' cannot be resolved in context a() (line: 76) MethodCallExprContext{wrapped=a()}. Parameter types: []
Method 'div' cannot be resolved in context div() (line: 86) MethodCallExprContext{wrapped=div()}. Parameter types: []
Method 'a' cannot be resolved in context a() (line: 89) MethodCallExprContext{wrapped=a()}. Parameter types: []
Method 'a' cannot be resolved in context a() (line: 89) MethodCallExprContext{wrapped=a()}. Parameter types: []
Method 'a' cannot be resolved in context a() (line: 89) MethodCallExprContext{wrapped=a()}. Parameter types: []
Cannot resolve field access null
Cannot solve field access Report.OutputType.DIRECTORY
TypeVariable {org.gradle.api.reporting.internal.DefaultReportContainer.T} is not a Reference Type
Cannot solve method call uniqueIndex(filter(getEnabled(), IS_DIRECTORY_OUTPUT_TYPE), REPORT_NAME) java.lang.RuntimeException: Method 'filter' cannot be resolved in context filter(getEnabled(), IS_DIRECTORY_OUTPUT_TYPE) (line: 117) MethodCallExprContext{wrapped=filter(getEnabled(), IS_DIRECTORY_OUTPUT_TYPE)}. Parameter types: [ReferenceType{org.gradle.api.NamedDomainObjectSet, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.api.NamedDomainObjectSet.T=TypeVariable {org.gradle.api.reporting.internal.DefaultReportContainer.T}}}}, ReferenceType{Predicate, typeParametersMap=TypeParametersMap{nameToValue={empty.? super ScriptBlock=ReferenceType{org.gradle.api.reporting.Report, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/reporting/src/main/java/org/gradle/api/reporting/internal/DefaultReportContainer.java
Cannot solve method call transformValues(uniqueIndex(filter(getEnabled(), IS_DIRECTORY_OUTPUT_TYPE), REPORT_NAME), TO_FILE) java.lang.RuntimeException: Error calculating the type of parameter filter(getEnabled(), IS_DIRECTORY_OUTPUT_TYPE) of method call uniqueIndex(filter(getEnabled(), IS_DIRECTORY_OUTPUT_TYPE), REPORT_NAME) /repo/subprojects/reporting/src/main/java/org/gradle/api/reporting/internal/DefaultReportContainer.java
Cannot solve method call filter(getEnabled(), not(IS_DIRECTORY_OUTPUT_TYPE)) java.lang.RuntimeException: Method 'not' cannot be resolved in context not(IS_DIRECTORY_OUTPUT_TYPE) (line: 122) MethodCallExprContext{wrapped=not(IS_DIRECTORY_OUTPUT_TYPE)}. Parameter types: [ReferenceType{Predicate, typeParametersMap=TypeParametersMap{nameToValue={empty.? super ScriptBlock=ReferenceType{org.gradle.api.reporting.Report, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}] /repo/subprojects/reporting/src/main/java/org/gradle/api/reporting/internal/DefaultReportContainer.java
Cannot solve method call uniqueIndex(filter(getEnabled(), not(IS_DIRECTORY_OUTPUT_TYPE)), REPORT_NAME) java.lang.RuntimeException: Error calculating the type of parameter not(IS_DIRECTORY_OUTPUT_TYPE) of method call filter(getEnabled(), not(IS_DIRECTORY_OUTPUT_TYPE)) /repo/subprojects/reporting/src/main/java/org/gradle/api/reporting/internal/DefaultReportContainer.java
Cannot solve method call transformValues(uniqueIndex(filter(getEnabled(), not(IS_DIRECTORY_OUTPUT_TYPE)), REPORT_NAME), TO_FILE) java.lang.RuntimeException: Error calculating the type of parameter filter(getEnabled(), not(IS_DIRECTORY_OUTPUT_TYPE)) of method call uniqueIndex(filter(getEnabled(), not(IS_DIRECTORY_OUTPUT_TYPE)), REPORT_NAME) /repo/subprojects/reporting/src/main/java/org/gradle/api/reporting/internal/DefaultReportContainer.java
Cannot solve method call Sets.newTreeSet(Iterables.transform(getEnabled(), REPORT_NAME)) UnsolvedSymbolException{context='Method 'transform' with parameterTypes [ReferenceType{org.gradle.api.NamedDomainObjectSet, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.api.NamedDomainObjectSet.T=TypeVariable {org.gradle.api.reporting.internal.DefaultReportContainer.T}}}}, ReferenceType{Function, typeParametersMap=TypeParametersMap{nameToValue={empty.Equivalence.Wrapper<Method>=ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, empty.Method=ReferenceType{org.gradle.api.reporting.Report, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/reporting/src/main/java/org/gradle/api/reporting/internal/DefaultReportContainer.java
Cannot resolve field access null
Method 'getByType' cannot be resolved in context project.getExtensions().getByType(ReportingExtension.class) (line: 49) MethodCallExprContext{wrapped=project.getExtensions().getByType(ReportingExtension.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.reporting.ReportingExtension, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call htmlReportConventionMapping.map("destination", new Callable<Object>() {

    public Object call() throws Exception {
        return project.getExtensions().getByType(ReportingExtension.class).file("buildDashboard");
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/reporting/src/main/java/org/gradle/api/reporting/plugins/BuildDashboardPlugin.java
Cannot solve method call setContentType(contentType.toString()) UnsolvedSymbolException{context='unknown', name='ContentType', typeSolver=null} /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/RepeatableInputStreamEntity.java
Method 'getRequestLine' cannot be resolved in context request.getRequestLine() (line: 46) MethodCallExprContext{wrapped=request.getRequestLine()}. Parameter types: []
Cannot resolve field access null
Cannot solve method call method.equalsIgnoreCase(HttpHead.METHOD_NAME) UnsolvedSymbolException{context='unknown', name='METHOD_NAME', typeSolver=null} /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/AlwaysRedirectRedirectStrategy.java
Cannot resolve field access null
Cannot solve method call method.equalsIgnoreCase(HttpPost.METHOD_NAME) UnsolvedSymbolException{context='unknown', name='METHOD_NAME', typeSolver=null} /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/AlwaysRedirectRedirectStrategy.java
Cannot resolve field access null
Cannot solve method call method.equalsIgnoreCase(HttpPut.METHOD_NAME) UnsolvedSymbolException{context='unknown', name='METHOD_NAME', typeSolver=null} /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/AlwaysRedirectRedirectStrategy.java
Cannot resolve field access null
Cannot solve method call method.equalsIgnoreCase(HttpDelete.METHOD_NAME) UnsolvedSymbolException{context='unknown', name='METHOD_NAME', typeSolver=null} /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/AlwaysRedirectRedirectStrategy.java
Cannot resolve field access null
Cannot solve method call method.equalsIgnoreCase(HttpTrace.METHOD_NAME) UnsolvedSymbolException{context='unknown', name='METHOD_NAME', typeSolver=null} /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/AlwaysRedirectRedirectStrategy.java
Cannot resolve field access null
Cannot solve method call method.equalsIgnoreCase(HttpOptions.METHOD_NAME) UnsolvedSymbolException{context='unknown', name='METHOD_NAME', typeSolver=null} /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/AlwaysRedirectRedirectStrategy.java
Cannot resolve field access null
Cannot solve method call method.equalsIgnoreCase(HttpPatch.METHOD_NAME) UnsolvedSymbolException{context='unknown', name='METHOD_NAME', typeSolver=null} /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/AlwaysRedirectRedirectStrategy.java
Cannot solve method call redirect.setEntity(((HttpEntityEnclosingRequest) original).getEntity()) UnsolvedSymbolException{context='unknown', name='HttpEntityEnclosingRequest', typeSolver=null} /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/AlwaysRedirectRedirectStrategy.java
Method 'getStatusLine' cannot be resolved in context response.getStatusLine() (line: 46) MethodCallExprContext{wrapped=response.getStatusLine()}. Parameter types: []
Method 'getStatusLine' cannot be resolved in context response.getStatusLine() (line: 46) MethodCallExprContext{wrapped=response.getStatusLine()}. Parameter types: []
Cannot solve method call String.format("Could not PUT '%s'. Received status code %s from server: %s", destination, response.getStatusLine().getStatusCode(), response.getStatusLine().getReasonPhrase()) java.lang.RuntimeException: Method 'getStatusLine' cannot be resolved in context response.getStatusLine() (line: 46) MethodCallExprContext{wrapped=response.getStatusLine()}. Parameter types: [] /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/HttpResourceUploader.java
Cannot resolve field access null
Method 'getStatusLine' cannot be resolved in context response.getStatusLine() (line: 68) MethodCallExprContext{wrapped=response.getStatusLine()}. Parameter types: []
Error calculating the type of parameter responseHeader.getValue() of method call DateUtils.parseDate(responseHeader.getValue())
Cannot solve method call response.getFirstHeader(HttpHeaders.CONTENT_LENGTH) UnsolvedSymbolException{context='unknown', name='CONTENT_LENGTH', typeSolver=null} /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/HttpResponseResource.java
Cannot solve method call response.getFirstHeader(HttpHeaders.CONTENT_TYPE) UnsolvedSymbolException{context='unknown', name='CONTENT_TYPE', typeSolver=null} /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/HttpResponseResource.java
Method 'getStatusLine' cannot be resolved in context response.getStatusLine() (line: 123) MethodCallExprContext{wrapped=response.getStatusLine()}. Parameter types: []
Cannot solve method call String.format("Response %d: %s has no content!", getStatusCode(), response.getStatusLine().getReasonPhrase()) java.lang.RuntimeException: Method 'getStatusLine' cannot be resolved in context response.getStatusLine() (line: 123) MethodCallExprContext{wrapped=response.getStatusLine()}. Parameter types: [] /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/HttpResponseResource.java
Cannot solve method call response.getFirstHeader(HttpHeaders.ETAG) UnsolvedSymbolException{context='unknown', name='ETAG', typeSolver=null} /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/HttpResponseResource.java
Cannot solve method call etag.substring(6, etag.length() - 2) java.lang.RuntimeException: Method 'length' cannot be resolved in context etag.length() (line: 147) MethodCallExprContext{wrapped=etag.length()}. Parameter types: [] /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/HttpResponseResource.java
Cannot solve method call LOGGER.warn("Invalid value for java system property '{}': {}. Default port '{}' will be used.", key, System.getProperty(key), defaultPort) UnsolvedSymbolException{context='Method 'getProperty' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=java.lang.System}'} /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/JavaSystemPropertiesProxySettings.java
Cannot solve method call Pattern.quote(nonProxyHost.substring(1)) java.lang.RuntimeException: Method 'substring' cannot be resolved in context nonProxyHost.substring(1) (line: 85) MethodCallExprContext{wrapped=nonProxyHost.substring(1)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/JavaSystemPropertiesProxySettings.java
Cannot solve method call Pattern.compile(".*" + Pattern.quote(nonProxyHost.substring(1))) java.lang.RuntimeException: Error calculating the type of parameter nonProxyHost.substring(1) of method call Pattern.quote(nonProxyHost.substring(1)) /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/JavaSystemPropertiesProxySettings.java
Cannot solve method call nonProxyHost.substring(0, nonProxyHost.length() - 1) java.lang.RuntimeException: Method 'length' cannot be resolved in context nonProxyHost.length() (line: 88) MethodCallExprContext{wrapped=nonProxyHost.length()}. Parameter types: [] /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/JavaSystemPropertiesProxySettings.java
Cannot solve method call Pattern.quote(nonProxyHost.substring(0, nonProxyHost.length() - 1)) java.lang.RuntimeException: Error calculating the type of parameter nonProxyHost.length() - 1 of method call nonProxyHost.substring(0, nonProxyHost.length() - 1) /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/JavaSystemPropertiesProxySettings.java
Cannot solve method call Pattern.compile(Pattern.quote(nonProxyHost.substring(0, nonProxyHost.length() - 1)) + ".*") java.lang.RuntimeException: Error calculating the type of parameter nonProxyHost.substring(0, nonProxyHost.length() - 1) of method call Pattern.quote(nonProxyHost.substring(0, nonProxyHost.length() - 1)) /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/JavaSystemPropertiesProxySettings.java
Cannot solve method call Pattern.compile(Pattern.quote(nonProxyHost)) UnsolvedSymbolException{context='Method 'quote' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=java.util.regex.Pattern}'} /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/JavaSystemPropertiesProxySettings.java
Method 'matcher' cannot be resolved in context nonProxyHost.matcher(host) (line: 106) MethodCallExprContext{wrapped=nonProxyHost.matcher(host)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getMetaData' cannot be resolved in context response.getMetaData() (line: 43) MethodCallExprContext{wrapped=response.getMetaData()}. Parameter types: []
Cannot solve method call parsedURI.getPath().substring(prefixPath.length(), parsedURI.getPath().length()) java.lang.RuntimeException: Method 'length' cannot be resolved in context prefixPath.length() (line: 91) MethodCallExprContext{wrapped=prefixPath.length()}. Parameter types: [] /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/ApacheDirectoryListingParser.java
Method 'split' cannot be resolved in context childPathPart.split("/") (line: 95) MethodCallExprContext{wrapped=childPathPart.split("/")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call uris.add(path.substring(pos + 1)) java.lang.RuntimeException: Method 'substring' cannot be resolved in context path.substring(pos + 1) (line: 111) MethodCallExprContext{wrapped=path.substring(pos + 1)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/ApacheDirectoryListingParser.java
Cannot solve method call uris.add(path.substring(start + 1, pos)) java.lang.RuntimeException: Method 'substring' cannot be resolved in context path.substring(start + 1, pos) (line: 108) MethodCallExprContext{wrapped=path.substring(start + 1, pos)}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}] /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/ApacheDirectoryListingParser.java
Cannot solve method call uris.add(path.substring(0, pos)) java.lang.RuntimeException: Method 'substring' cannot be resolved in context path.substring(0, pos) (line: 106) MethodCallExprContext{wrapped=path.substring(0, pos)}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}] /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/ApacheDirectoryListingParser.java
Cannot solve method call uris.add(baseURI.resolve(href)) java.lang.RuntimeException: Method 'resolve' cannot be resolved in context baseURI.resolve(href) (line: 121) MethodCallExprContext{wrapped=baseURI.resolve(href)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/ApacheDirectoryListingParser.java
Cannot solve method call request.addHeader(HttpHeaders.CACHE_CONTROL, "max-age=0") UnsolvedSymbolException{context='unknown', name='CACHE_CONTROL', typeSolver=null} /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/HttpClientHelper.java
Cannot solve method call String.format("Could not %s '%s'.", method, request.getURI()) java.lang.RuntimeException: Method 'getURI' cannot be resolved in context request.getURI() (line: 82) MethodCallExprContext{wrapped=request.getURI()}. Parameter types: [] /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/HttpClientHelper.java
Method 'getStatusLine' cannot be resolved in context response.getStatusLine() (line: 100) MethodCallExprContext{wrapped=response.getStatusLine()}. Parameter types: []
Method 'getStatusLine' cannot be resolved in context response.getStatusLine() (line: 105) MethodCallExprContext{wrapped=response.getStatusLine()}. Parameter types: []
Cannot solve method call httpContext.removeAttribute(HttpClientContext.REDIRECT_LOCATIONS) UnsolvedSymbolException{context='unknown', name='REDIRECT_LOCATIONS', typeSolver=null} /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/HttpClientHelper.java
Cannot solve method call LOGGER.debug("Performing HTTP {}: {}", request.getMethod(), request.getURI()) java.lang.RuntimeException: Method 'getMethod' cannot be resolved in context request.getMethod() (line: 112) MethodCallExprContext{wrapped=request.getMethod()}. Parameter types: [] /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/HttpClientHelper.java
Cannot solve method call LOGGER.info("Failed to get resource: {}. [HTTP {}: {}]", method, response.getStatusLine(), source) java.lang.RuntimeException: Method 'getStatusLine' cannot be resolved in context response.getStatusLine() (line: 122) MethodCallExprContext{wrapped=response.getStatusLine()}. Parameter types: [] /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/HttpClientHelper.java
Method 'getStatusLine' cannot be resolved in context response.getStatusLine() (line: 124) MethodCallExprContext{wrapped=response.getStatusLine()}. Parameter types: []
Method 'getStatusLine' cannot be resolved in context response.getStatusLine() (line: 124) MethodCallExprContext{wrapped=response.getStatusLine()}. Parameter types: []
Cannot solve method call String.format("Could not %s '%s'. Received status code %s from server: %s", method, source, response.getStatusLine().getStatusCode(), response.getStatusLine().getReasonPhrase()) java.lang.RuntimeException: Method 'getStatusLine' cannot be resolved in context response.getStatusLine() (line: 124) MethodCallExprContext{wrapped=response.getStatusLine()}. Parameter types: [] /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/HttpClientHelper.java
Cannot solve method call configureSslSocketConnectionFactory(builder, httpSettings.getSslContextFactory()) java.lang.RuntimeException: Method 'getSslContextFactory' cannot be resolved in context httpSettings.getSslContextFactory() (line: 69) MethodCallExprContext{wrapped=httpSettings.getSslContextFactory()}. Parameter types: [] /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/HttpClientConfigurer.java
Cannot solve method call configureCredentials(builder, credentialsProvider, httpSettings.getAuthenticationSettings()) java.lang.RuntimeException: Method 'getAuthenticationSettings' cannot be resolved in context httpSettings.getAuthenticationSettings() (line: 71) MethodCallExprContext{wrapped=httpSettings.getAuthenticationSettings()}. Parameter types: [] /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/HttpClientConfigurer.java
Error calculating the type of parameter AuthSchemes.BASIC of method call RegistryBuilder.<AuthSchemeProvider>create().register(AuthSchemes.BASIC, new BasicSchemeFactory())
Error calculating the type of parameter AuthSchemes.DIGEST of method call RegistryBuilder.<AuthSchemeProvider>create().register(AuthSchemes.BASIC, new BasicSchemeFactory()).register(AuthSchemes.DIGEST, new DigestSchemeFactory())
Error calculating the type of parameter AuthSchemes.NTLM of method call RegistryBuilder.<AuthSchemeProvider>create().register(AuthSchemes.BASIC, new BasicSchemeFactory()).register(AuthSchemes.DIGEST, new DigestSchemeFactory()).register(AuthSchemes.NTLM, new NTLMSchemeFactory())
Error calculating the type of parameter AuthSchemes.SPNEGO of method call RegistryBuilder.<AuthSchemeProvider>create().register(AuthSchemes.BASIC, new BasicSchemeFactory()).register(AuthSchemes.DIGEST, new DigestSchemeFactory()).register(AuthSchemes.NTLM, new NTLMSchemeFactory()).register(AuthSchemes.SPNEGO, new SPNegoSchemeFactory())
Error calculating the type of parameter AuthSchemes.KERBEROS of method call RegistryBuilder.<AuthSchemeProvider>create().register(AuthSchemes.BASIC, new BasicSchemeFactory()).register(AuthSchemes.DIGEST, new DigestSchemeFactory()).register(AuthSchemes.NTLM, new NTLMSchemeFactory()).register(AuthSchemes.SPNEGO, new SPNegoSchemeFactory()).register(AuthSchemes.KERBEROS, new KerberosSchemeFactory())
Cannot solve method call builder.setDefaultAuthSchemeRegistry(RegistryBuilder.<AuthSchemeProvider>create().register(AuthSchemes.BASIC, new BasicSchemeFactory()).register(AuthSchemes.DIGEST, new DigestSchemeFactory()).register(AuthSchemes.NTLM, new NTLMSchemeFactory()).register(AuthSchemes.SPNEGO, new SPNegoSchemeFactory()).register(AuthSchemes.KERBEROS, new KerberosSchemeFactory()).build()) java.lang.RuntimeException: Error calculating the type of parameter AuthSchemes.KERBEROS of method call RegistryBuilder.<AuthSchemeProvider>create().register(AuthSchemes.BASIC, new BasicSchemeFactory()).register(AuthSchemes.DIGEST, new DigestSchemeFactory()).register(AuthSchemes.NTLM, new NTLMSchemeFactory()).register(AuthSchemes.SPNEGO, new SPNegoSchemeFactory()).register(AuthSchemes.KERBEROS, new KerberosSchemeFactory()) /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/HttpClientConfigurer.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call useCredentials(credentialsProvider, AuthScope.ANY_HOST, AuthScope.ANY_PORT, authentications) UnsolvedSymbolException{context='unknown', name='ANY_HOST', typeSolver=null} /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/HttpClientConfigurer.java
Method 'getProxySettings' cannot be resolved in context httpSettings.getProxySettings() (line: 102) MethodCallExprContext{wrapped=httpSettings.getProxySettings()}. Parameter types: []
Method 'getSecureProxySettings' cannot be resolved in context httpSettings.getSecureProxySettings() (line: 103) MethodCallExprContext{wrapped=httpSettings.getSecureProxySettings()}. Parameter types: []
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call useCredentials(credentialsProvider, proxy.host, proxy.port, Collections.singleton(new AllSchemesAuthentication(proxy.credentials))) UnsolvedSymbolException{context='unknown', name='host', typeSolver=null} /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/HttpClientConfigurer.java
Cannot resolve field access null
Cannot solve method call LOGGER.debug("Using {} and {} for authenticating against '{}:{}' using {}", credentials, ntlmCredentials, host, port, AuthSchemes.NTLM) UnsolvedSymbolException{context='unknown', name='NTLM', typeSolver=null} /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/HttpClientConfigurer.java
Cannot resolve field access null
Cannot solve method call builder.setUserAgent(UriTextResource.getUserAgentString()) UnsolvedSymbolException{context='Method 'getUserAgentString' with parameterTypes []', name='ReflectionClassDeclaration{clazz=UriTextResource}'} /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/HttpClientConfigurer.java
Cannot resolve field access null
Cannot solve method call context.getAttribute(HttpClientContext.TARGET_AUTH_STATE) UnsolvedSymbolException{context='unknown', name='TARGET_AUTH_STATE', typeSolver=null} /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/HttpClientConfigurer.java
Method 'getRequestLine' cannot be resolved in context request.getRequestLine() (line: 188) MethodCallExprContext{wrapped=request.getRequestLine()}. Parameter types: []
Cannot resolve field access null
Cannot solve method call requestMethod.equals(HttpPut.METHOD_NAME) UnsolvedSymbolException{context='unknown', name='METHOD_NAME', typeSolver=null} /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/HttpClientConfigurer.java
Cannot resolve field access null
Cannot solve method call requestMethod.equals(HttpPost.METHOD_NAME) UnsolvedSymbolException{context='unknown', name='METHOD_NAME', typeSolver=null} /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/HttpClientConfigurer.java
Cannot solve method call context.getAttribute(HttpClientContext.CREDS_PROVIDER) UnsolvedSymbolException{context='unknown', name='CREDS_PROVIDER', typeSolver=null} /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/HttpClientConfigurer.java
Cannot solve method call context.getAttribute(HttpCoreContext.HTTP_TARGET_HOST) UnsolvedSymbolException{context='unknown', name='HTTP_TARGET_HOST', typeSolver=null} /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/HttpClientConfigurer.java
Cannot solve method call currentProperties.put(prop, System.getProperty(prop)) UnsolvedSymbolException{context='Method 'getProperty' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=java.lang.System}'} /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/DefaultSslContextFactory.java
Cannot solve method call trustStore.load(instream, trustStorePassword != null ? trustStorePassword.toCharArray() : null) java.lang.RuntimeException: Method 'toCharArray' cannot be resolved in context trustStorePassword.toCharArray() (line: 122) MethodCallExprContext{wrapped=trustStorePassword.toCharArray()}. Parameter types: [] /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/DefaultSslContextFactory.java
Cannot solve method call trustStore.load(instream, trustStorePassword != null ? trustStorePassword.toCharArray() : null) java.lang.RuntimeException: Method 'toCharArray' cannot be resolved in context trustStorePassword.toCharArray() (line: 103) MethodCallExprContext{wrapped=trustStorePassword.toCharArray()}. Parameter types: [] /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/DefaultSslContextFactory.java
Cannot solve method call keyStore.load(instream, keyStorePassword != null ? keyStorePassword.toCharArray() : EMPTY_PASSWORD) java.lang.RuntimeException: Method 'toCharArray' cannot be resolved in context keyStorePassword.toCharArray() (line: 159) MethodCallExprContext{wrapped=keyStorePassword.toCharArray()}. Parameter types: [] /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/DefaultSslContextFactory.java
Cannot solve method call kmFactory.init(keyStore, keyStorePassword != null ? keyStorePassword.toCharArray() : EMPTY_PASSWORD) java.lang.RuntimeException: Method 'toCharArray' cannot be resolved in context keyStorePassword.toCharArray() (line: 163) MethodCallExprContext{wrapped=keyStorePassword.toCharArray()}. Parameter types: [] /repo/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/DefaultSslContextFactory.java
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
expected either zero type arguments or has many as defined in the declaration (0). Found 2
Cannot resolve field access null
Cannot solve field access FileCollection.AntType.MatchingTask
Cannot solve method call antBuilder.withClasspath(scalaClasspath).execute(new Closure<Object>(this) {

    @SuppressWarnings("unused")
    public Object doCall(final AntBuilderDelegate ant) {
        ant.invokeMethod("taskdef", Collections.singletonMap("resource", "scala/tools/ant/antlib.xml"));
        ImmutableMap.Builder<String, Object> optionsBuilder = ImmutableMap.builder();
        optionsBuilder.put("destDir", targetDir);
        optionsBuilder.putAll(docOptions.optionMap());
        ImmutableMap<String, Object> options = optionsBuilder.build();
        return ant.invokeMethod("scaladoc", new Object[] { options, new Closure<Void>(this) {

            public void doCall() {
                source.addToAntBuilder(ant, "src", FileCollection.AntType.MatchingTask);
                for (File file : bootclasspathFiles) {
                    ant.invokeMethod("bootclasspath", Collections.singletonMap("location", file));
                }
                for (File dir : extensionDirs) {
                    ant.invokeMethod("extdirs", Collections.singletonMap("location", dir));
                }
                for (File file : classpathFiles) {
                    ant.invokeMethod("classpath", Collections.singletonMap("location", file));
                }
            }
        } });
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/scala/src/main/java/org/gradle/api/internal/tasks/scala/AntScalaDoc.java
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 84) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 84) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call compile.getConventionMapping().map("scalaClasspath", new Callable<FileCollection>() {

    @Override
    public FileCollection call() throws Exception {
        return scalaRuntime.inferScalaClasspath(compile.getClasspath());
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/scala/src/main/java/org/gradle/api/plugins/scala/ScalaBasePlugin.java
Cannot solve method call compile.getConventionMapping().map("zincClasspath", new Callable<Configuration>() {

    @Override
    public Configuration call() throws Exception {
        Configuration config = project.getConfigurations().getAt(ZINC_CONFIGURATION_NAME);
        if (config.getDependencies().isEmpty()) {
            project.getDependencies().add("zinc", "com.typesafe.zinc:zinc:" + DefaultScalaToolProvider.DEFAULT_ZINC_VERSION);
        }
        return config;
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/scala/src/main/java/org/gradle/api/plugins/scala/ScalaBasePlugin.java
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 174) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call scalaDoc.getConventionMapping().map("destinationDir", new Callable<File>() {

    @Override
    public File call() throws Exception {
        File docsDir = project.getConvention().getPlugin(JavaPluginConvention.class).getDocsDir();
        return project.file(docsDir.getPath() + "/scaladoc");
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/scala/src/main/java/org/gradle/api/plugins/scala/ScalaBasePlugin.java
Method 'getByType' cannot be resolved in context project.getExtensions().getByType(ReportingExtension.class) (line: 181) MethodCallExprContext{wrapped=project.getExtensions().getByType(ReportingExtension.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.reporting.ReportingExtension, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call scalaDoc.getConventionMapping().map("title", new Callable<String>() {

    @Override
    public String call() throws Exception {
        return project.getExtensions().getByType(ReportingExtension.class).getApiDocTitle();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/scala/src/main/java/org/gradle/api/plugins/scala/ScalaBasePlugin.java
Cannot solve method call scalaDoc.getConventionMapping().map("scalaClasspath", new Callable<FileCollection>() {

    @Override
    public FileCollection call() throws Exception {
        return scalaRuntime.inferScalaClasspath(scalaDoc.getClasspath());
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/scala/src/main/java/org/gradle/api/plugins/scala/ScalaBasePlugin.java
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 53) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Method 'getPlugin' cannot be resolved in context project.getConvention().getPlugin(JavaPluginConvention.class) (line: 53) MethodCallExprContext{wrapped=project.getConvention().getPlugin(JavaPluginConvention.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.api.plugins.JavaPluginConvention, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve method call scalaDoc.getConventionMapping().map("classpath", new Callable<FileCollection>() {

    @Override
    public FileCollection call() throws Exception {
        ConfigurableFileCollection files = project.files();
        files.from(main.getOutput());
        files.from(main.getCompileClasspath());
        return files;
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/scala/src/main/java/org/gradle/api/plugins/scala/ScalaPlugin.java
Cannot solve method call scalaDoc.setSource(InvokerHelper.invokeMethod(main, "getScala", null)) UnsolvedSymbolException{context='Solving InvokerHelper', name='InvokerHelper', typeSolver=null} /repo/subprojects/scala/src/main/java/org/gradle/api/plugins/scala/ScalaPlugin.java
Cannot solve method call conventionMapping.map("signatory", new Callable<Signatory>() {

    public Signatory call() {
        return getSignatory();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/signing/src/main/java/org/gradle/plugins/signing/SigningExtension.java
Cannot solve method call conventionMapping.map("signatureType", new Callable<SignatureType>() {

    public SignatureType call() {
        return getSignatureType();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/signing/src/main/java/org/gradle/plugins/signing/SigningExtension.java
Cannot solve method call conventionMapping.map("required", new Callable<Boolean>() {

    public Boolean call() {
        return isRequired();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/signing/src/main/java/org/gradle/plugins/signing/SigningExtension.java
Cannot resolve field access null
Cannot solve method call result.add(createSignTaskFor(taskToSign.getName(), new Action<Sign>() {

    public void execute(Sign task) {
        task.sign(taskToSign);
    }
})) com.github.javaparser.symbolsolver.logic.ConfilictingGenericTypesException: No matching between ReferenceType{CharSequence, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual) /repo/subprojects/signing/src/main/java/org/gradle/plugins/signing/SigningExtension.java
Cannot resolve field access null
Cannot solve method call result.add(createSignTaskFor(configurationToSign.getName(), new Action<Sign>() {

    public void execute(Sign task) {
        task.sign(configurationToSign);
    }
})) com.github.javaparser.symbolsolver.logic.ConfilictingGenericTypesException: No matching between ReferenceType{CharSequence, typeParametersMap=TypeParametersMap{nameToValue={}}} (formal) and ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}} (actual) /repo/subprojects/signing/src/main/java/org/gradle/plugins/signing/SigningExtension.java
Cannot solve method call project.getTasks().create("sign" + capitalize(name), Sign.class, taskConfiguration) java.lang.RuntimeException: Method 'capitalize' cannot be resolved in context capitalize(name) (line: 290) MethodCallExprContext{wrapped=capitalize(name)}. Parameter types: [ReferenceType{CharSequence, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/signing/src/main/java/org/gradle/plugins/signing/SigningExtension.java
Cannot solve name expression keyIdUpped
Method 'length' cannot be resolved in context keyIdUpped.length() (line: 97) MethodCallExprContext{wrapped=keyIdUpped.length()}. Parameter types: []
Cannot solve name expression keyId
Cannot solve name expression keyIdUpped
Method 'length' cannot be resolved in context keyIdUpped.length() (line: 97) MethodCallExprContext{wrapped=keyIdUpped.length()}. Parameter types: []
Cannot solve name expression keyId
Method 'length' cannot be resolved in context keyIdUpped.length() (line: 97) MethodCallExprContext{wrapped=keyIdUpped.length()}. Parameter types: []
Cannot solve name expression keyId
Cannot solve name expression keyIdUpped
Cannot solve name expression keyId
Cannot solve method call signatoryFor(name, asType(args, Object[].class)) java.lang.RuntimeException: Method 'asType' cannot be resolved in context asType(args, Object[].class) (line: 42) MethodCallExprContext{wrapped=asType(args, Object[].class)}. Parameter types: [ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ResolvedArrayType{ReferenceType{Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}] /repo/subprojects/signing/src/main/java/org/gradle/plugins/signing/signatory/pgp/Dsl.java
Cannot resolve field access null
Cannot solve method call uncheckedCast(keyRings.getKeyRings()) java.lang.RuntimeException: Method 'getKeyRings' cannot be resolved in context keyRings.getKeyRings() (line: 142) MethodCallExprContext{wrapped=keyRings.getKeyRings()}. Parameter types: [] /repo/subprojects/signing/src/main/java/org/gradle/plugins/signing/signatory/pgp/PgpSignatoryFactory.java
Cannot solve method call uncheckedCast(keyRing.getSecretKeys()) UnsolvedSymbolException{context='unknown', name='PGPSecretKeyRing', typeSolver=null} /repo/subprojects/signing/src/main/java/org/gradle/plugins/signing/signatory/pgp/PgpSignatoryFactory.java
Method 'getPublicKey' cannot be resolved in context secretKey.getPublicKey() (line: 105) MethodCallExprContext{wrapped=secretKey.getPublicKey()}. Parameter types: []
Cannot resolve field access null
Cannot solve method call generator.init(PGPSignature.BINARY_DOCUMENT, privateKey) UnsolvedSymbolException{context='unknown', name='BINARY_DOCUMENT', typeSolver=null} /repo/subprojects/signing/src/main/java/org/gradle/plugins/signing/signatory/pgp/PgpSignatory.java
Cannot solve method call new BcPBESecretKeyDecryptorBuilder(new BcPGPDigestCalculatorProvider()).build(password.toCharArray()) java.lang.RuntimeException: Method 'toCharArray' cannot be resolved in context password.toCharArray() (line: 115) MethodCallExprContext{wrapped=password.toCharArray()}. Parameter types: [] /repo/subprojects/signing/src/main/java/org/gradle/plugins/signing/signatory/pgp/PgpSignatory.java
Cannot solve method call secretKey.extractPrivateKey(decryptor) UnsolvedSymbolException{context='unknown', name='PBESecretKeyDecryptor', typeSolver=null} /repo/subprojects/signing/src/main/java/org/gradle/plugins/signing/signatory/pgp/PgpSignatory.java
Cannot solve method call withResource(newOutputStream(signatureFile), new Action<BufferedOutputStream>() {

    @Override
    public void execute(BufferedOutputStream signatureFileStream) {
        sign(signatory, toSignStream, signatureFileStream);
    }
}) java.lang.RuntimeException: Method 'newOutputStream' cannot be resolved in context newOutputStream(signatureFile) (line: 46) MethodCallExprContext{wrapped=newOutputStream(signatureFile)}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/signing/src/main/java/org/gradle/plugins/signing/type/AbstractSignatureType.java
Cannot solve method call withResource(newInputStream(toSign), new Action<InputStream>() {

    @Override
    public void execute(final InputStream toSignStream) {
        try {
            withResource(newOutputStream(signatureFile), new Action<BufferedOutputStream>() {

                @Override
                public void execute(BufferedOutputStream signatureFileStream) {
                    sign(signatory, toSignStream, signatureFileStream);
                }
            });
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }
}) java.lang.RuntimeException: Method 'newInputStream' cannot be resolved in context newInputStream(toSign) (line: 42) MethodCallExprContext{wrapped=newInputStream(toSign)}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/signing/src/main/java/org/gradle/plugins/signing/type/AbstractSignatureType.java
Method 'matcher' cannot be resolved in context JAVA_PARTS.matcher(signature.getName()) (line: 117) MethodCallExprContext{wrapped=JAVA_PARTS.matcher(signature.getName())}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call Character.isJavaIdentifierStart(name.codePointAt(0)) java.lang.RuntimeException: Method 'codePointAt' cannot be resolved in context name.codePointAt(0) (line: 118) MethodCallExprContext{wrapped=name.codePointAt(0)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/signing/src/main/java/org/gradle/plugins/signing/Sign.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call signatures.remove(Iterables.find(signatures, new Predicate<Signature>() {

    @Override
    public boolean apply(Signature input) {
        return input.getToSignArtifact().equals(publishArtifact);
    }
})) UnsolvedSymbolException{context='Method 'find' with parameterTypes [ReferenceType{org.gradle.api.internal.DefaultDomainObjectSet, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.api.internal.DefaultDomainObjectSet.T=ReferenceType{org.gradle.plugins.signing.Signature, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{Predicate, typeParametersMap=TypeParametersMap{nameToValue={empty.? super ScriptBlock=ReferenceType{org.gradle.plugins.signing.Signature, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/signing/src/main/java/org/gradle/plugins/signing/Sign.java
Cannot solve method call Iterables.filter(getInputFiles(), Predicates.notNull()) UnsolvedSymbolException{context='Method 'notNull' with parameterTypes []', name='ReflectionClassDeclaration{clazz=com.google.common.base.Predicates}'} /repo/subprojects/signing/src/main/java/org/gradle/plugins/signing/Sign.java
Cannot solve method call Lists.newLinkedList(Iterables.filter(getInputFiles(), Predicates.notNull())) java.lang.RuntimeException: Error calculating the type of parameter Predicates.notNull() of method call Iterables.filter(getInputFiles(), Predicates.notNull()) /repo/subprojects/signing/src/main/java/org/gradle/plugins/signing/Sign.java
Cannot solve method call getFileCollectionFactory().fixed("Task \'" + getPath() + "\' files to sign", Lists.newLinkedList(Iterables.filter(getInputFiles(), Predicates.notNull()))) java.lang.RuntimeException: Error calculating the type of parameter Iterables.filter(getInputFiles(), Predicates.notNull()) of method call Lists.newLinkedList(Iterables.filter(getInputFiles(), Predicates.notNull())) /repo/subprojects/signing/src/main/java/org/gradle/plugins/signing/Sign.java
Cannot solve method call Iterables.filter(Iterables.transform(signatures, SIGNATURE_FILE_FUNCTION), Predicates.notNull()) UnsolvedSymbolException{context='Method 'transform' with parameterTypes [ReferenceType{org.gradle.api.internal.DefaultDomainObjectSet, typeParametersMap=TypeParametersMap{nameToValue={org.gradle.api.internal.DefaultDomainObjectSet.T=ReferenceType{org.gradle.plugins.signing.Signature, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, ReferenceType{Function, typeParametersMap=TypeParametersMap{nameToValue={empty.Equivalence.Wrapper<Method>=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}, empty.Method=ReferenceType{org.gradle.plugins.signing.Signature, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.Iterables}'} /repo/subprojects/signing/src/main/java/org/gradle/plugins/signing/Sign.java
Cannot solve method call Lists.newLinkedList(Iterables.filter(Iterables.transform(signatures, SIGNATURE_FILE_FUNCTION), Predicates.notNull())) java.lang.RuntimeException: Error calculating the type of parameter Iterables.transform(signatures, SIGNATURE_FILE_FUNCTION) of method call Iterables.filter(Iterables.transform(signatures, SIGNATURE_FILE_FUNCTION), Predicates.notNull()) /repo/subprojects/signing/src/main/java/org/gradle/plugins/signing/Sign.java
Cannot solve method call getFileCollectionFactory().fixed("Task \'" + getPath() + "\' signature files", Lists.newLinkedList(Iterables.filter(Iterables.transform(signatures, SIGNATURE_FILE_FUNCTION), Predicates.notNull()))) java.lang.RuntimeException: Error calculating the type of parameter Iterables.filter(Iterables.transform(signatures, SIGNATURE_FILE_FUNCTION), Predicates.notNull()) of method call Lists.newLinkedList(Iterables.filter(Iterables.transform(signatures, SIGNATURE_FILE_FUNCTION), Predicates.notNull())) /repo/subprojects/signing/src/main/java/org/gradle/plugins/signing/Sign.java
Cannot solve method call init(returning(toSign), null, signatureSpec) java.lang.RuntimeException: Method 'returning' cannot be resolved in context returning(toSign) (line: 129) MethodCallExprContext{wrapped=returning(toSign)}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/signing/src/main/java/org/gradle/plugins/signing/Signature.java
Cannot solve method call init(returning(toSign), returning(classifier), signatureSpec) java.lang.RuntimeException: Method 'returning' cannot be resolved in context returning(toSign) (line: 142) MethodCallExprContext{wrapped=returning(toSign)}. Parameter types: [ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/signing/src/main/java/org/gradle/plugins/signing/Signature.java
Cannot solve method call LOGGER.debug("Response for GET {}: {}", uri, response.getStatusLine()) java.lang.RuntimeException: Method 'getStatusLine' cannot be resolved in context response.getStatusLine() (line: 58) MethodCallExprContext{wrapped=response.getStatusLine()}. Parameter types: [] /repo/subprojects/task-cache-http/src/main/java/org/gradle/cache/tasks/http/HttpTaskOutputCache.java
Method 'getStatusLine' cannot be resolved in context response.getStatusLine() (line: 61) MethodCallExprContext{wrapped=response.getStatusLine()}. Parameter types: []
Method 'getEntity' cannot be resolved in context response.getEntity() (line: 63) MethodCallExprContext{wrapped=response.getEntity()}. Parameter types: []
Cannot solve method call reader.readFrom(response.getEntity().getContent()) java.lang.RuntimeException: Method 'getEntity' cannot be resolved in context response.getEntity() (line: 63) MethodCallExprContext{wrapped=response.getEntity()}. Parameter types: [] /repo/subprojects/task-cache-http/src/main/java/org/gradle/cache/tasks/http/HttpTaskOutputCache.java
Cannot solve method call LOGGER.debug("Response for PUT {}: {}", uri, response.getStatusLine()) java.lang.RuntimeException: Method 'getStatusLine' cannot be resolved in context response.getStatusLine() (line: 110) MethodCallExprContext{wrapped=response.getStatusLine()}. Parameter types: [] /repo/subprojects/task-cache-http/src/main/java/org/gradle/cache/tasks/http/HttpTaskOutputCache.java
Cannot solve method call runningTasks.get(descriptor.getOwnerBuildOperationId()) java.lang.RuntimeException: Method 'getOwnerBuildOperationId' cannot be resolved in context descriptor.getOwnerBuildOperationId() (line: 103) MethodCallExprContext{wrapped=descriptor.getOwnerBuildOperationId()}. Parameter types: [] /repo/subprojects/tooling-api-builders/src/main/java/org/gradle/tooling/internal/provider/runner/ClientForwardingTestListener.java
Cannot solve name expression SUCCESS
Cannot solve name expression result
Cannot solve name expression result
Cannot solve name expression SKIPPED
Cannot solve name expression result
Cannot solve name expression result
Cannot solve name expression FAILURE
Cannot solve name expression result
Cannot solve name expression result
Cannot solve name expression result
Cannot solve method call convertExceptions(result.getExceptions()) UnsolvedSymbolException{context='unknown', name='TestResult.ResultType', typeSolver=null} /repo/subprojects/tooling-api-builders/src/main/java/org/gradle/tooling/internal/provider/runner/ClientForwardingTestListener.java
Cannot solve name expression resultType
Method 'append' cannot be resolved in context new StringBuilder("Test failed.\n").append(INDENT) (line: 69) MethodCallExprContext{wrapped=new StringBuilder("Test failed.\n").append(INDENT)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context failedTestsMessage.append("\n") (line: 72) MethodCallExprContext{wrapped=failedTestsMessage.append("\n")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Error calculating the type of parameter Strings.repeat(INDENT, 2) of method call failedTestsMessage.append("\n").append(Strings.repeat(INDENT, 2))
Method 'append' cannot be resolved in context requestDetails.append("\n") (line: 81) MethodCallExprContext{wrapped=requestDetails.append("\n")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Error calculating the type of parameter Strings.repeat(INDENT, 2) of method call requestDetails.append("\n").append(Strings.repeat(INDENT, 2))
Method 'append' cannot be resolved in context requestDetails.append(" (Task: '") (line: 82) MethodCallExprContext{wrapped=requestDetails.append(" (Task: '")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context requestDetails.append(" (Task: '") (line: 82) MethodCallExprContext{wrapped=requestDetails.append(" (Task: '")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context requestDetails.append("\n") (line: 92) MethodCallExprContext{wrapped=requestDetails.append("\n")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Error calculating the type of parameter Strings.repeat(INDENT, 2) of method call requestDetails.append("\n").append(Strings.repeat(INDENT, 2))
Error calculating the type of parameter Strings.repeat(INDENT, 2) of method call requestDetails.append("\n").append(Strings.repeat(INDENT, 2))
Error calculating the type of parameter Strings.repeat(INDENT, 2) of method call requestDetails.append("\n").append(Strings.repeat(INDENT, 2))
Error calculating the type of parameter Strings.repeat(INDENT, 2) of method call requestDetails.append("\n").append(Strings.repeat(INDENT, 2))
Error calculating the type of parameter Strings.repeat(INDENT, 2) of method call requestDetails.append("\n").append(Strings.repeat(INDENT, 2))
Method 'append' cannot be resolved in context requestDetails.append("\n") (line: 90) MethodCallExprContext{wrapped=requestDetails.append("\n")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Error calculating the type of parameter Strings.repeat(INDENT, 2) of method call requestDetails.append("\n").append(Strings.repeat(INDENT, 2))
Error calculating the type of parameter Strings.repeat(INDENT, 2) of method call requestDetails.append("\n").append(Strings.repeat(INDENT, 2))
Cannot solve method call runningTasks.get(descriptor.getOwnerBuildOperationId()) java.lang.RuntimeException: Method 'getOwnerBuildOperationId' cannot be resolved in context descriptor.getOwnerBuildOperationId() (line: 118) MethodCallExprContext{wrapped=descriptor.getOwnerBuildOperationId()}. Parameter types: [] /repo/subprojects/tooling-api-builders/src/main/java/org/gradle/tooling/internal/provider/runner/TestExecutionResultEvaluator.java
Method 'append' cannot be resolved in context new StringBuilder("Test ").append(className) (line: 147) MethodCallExprContext{wrapped=new StringBuilder("Test ").append(className)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context new StringBuilder("Test ").append(className) (line: 147) MethodCallExprContext{wrapped=new StringBuilder("Test ").append(className)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context new StringBuilder("Test ").append(className) (line: 147) MethodCallExprContext{wrapped=new StringBuilder("Test ").append(className)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context new StringBuilder("Test ").append(className) (line: 147) MethodCallExprContext{wrapped=new StringBuilder("Test ").append(className)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context new StringBuilder("Test ").append(className) (line: 147) MethodCallExprContext{wrapped=new StringBuilder("Test ").append(className)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getFilter' cannot be resolved in context task.getFilter() (line: 58) MethodCallExprContext{wrapped=task.getFilter()}. Parameter types: []
Method 'getOutputs' cannot be resolved in context task.getOutputs() (line: 59) MethodCallExprContext{wrapped=task.getOutputs()}. Parameter types: []
Method 'getFilter' cannot be resolved in context testTask.getFilter() (line: 90) MethodCallExprContext{wrapped=testTask.getFilter()}. Parameter types: []
Method 'getFilter' cannot be resolved in context testTask.getFilter() (line: 88) MethodCallExprContext{wrapped=testTask.getFilter()}. Parameter types: []
Cannot solve method call Arrays.asList(failure.getStackTrace()) java.lang.RuntimeException: Method 'getStackTrace' cannot be resolved in context failure.getStackTrace() (line: 56) MethodCallExprContext{wrapped=failure.getStackTrace()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/BlockingResultHandler.java
Cannot solve method call adjusted.addAll(Arrays.asList(failure.getStackTrace())) java.lang.RuntimeException: Error calculating the type of parameter failure.getStackTrace() of method call Arrays.asList(failure.getStackTrace()) /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/BlockingResultHandler.java
Cannot solve method call Arrays.asList(Thread.currentThread().getStackTrace()) UnsolvedSymbolException{context='Method 'currentThread' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Thread}'} /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/BlockingResultHandler.java
Cannot solve method call failure.setStackTrace(adjusted.toArray(new StackTraceElement[0])) java.lang.RuntimeException: StackTraceElement[] T[] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/BlockingResultHandler.java
Cannot solve method call String.format("Cannot fetch a model of type '%s' as this type is not an interface.", modelType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context modelType.getName() (line: 59) MethodCallExprContext{wrapped=modelType.getName()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/DefaultProjectConnection.java
Method 'inverse' cannot be resolved in context MODEL_TO_PROTOCOL_MAP.inverse() (line: 110) MethodCallExprContext{wrapped=MODEL_TO_PROTOCOL_MAP.inverse()}. Parameter types: []
Method 'inverse' cannot be resolved in context MODEL_NAME_MAP.inverse() (line: 119) MethodCallExprContext{wrapped=MODEL_NAME_MAP.inverse()}. Parameter types: []
Cannot solve method call JavaVersion.valueOf(ideaProject.getLanguageLevel().getLevel().replaceFirst("JDK", "VERSION")) java.lang.RuntimeException: Method 'replaceFirst' cannot be resolved in context ideaProject.getLanguageLevel().getLevel().replaceFirst("JDK", "VERSION") (line: 43) MethodCallExprContext{wrapped=ideaProject.getLanguageLevel().getLevel().replaceFirst("JDK", "VERSION")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/converters/IdeaProjectJavaLanguageSettingsMixin.java
Method 'substring' cannot be resolved in context taskName1.substring(0, colon1) (line: 37) MethodCallExprContext{wrapped=taskName1.substring(0, colon1)}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}]
Cannot solve method call compareSegments(taskName1.substring(colon1 + 1), taskName2.substring(colon2 + 1)) java.lang.RuntimeException: Method 'substring' cannot be resolved in context taskName1.substring(colon1 + 1) (line: 42) MethodCallExprContext{wrapped=taskName1.substring(colon1 + 1)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/converters/TaskNameComparator.java
Cannot solve method call targetGradleVersion.getBaseVersion().compareTo(GradleVersion.version("2.11")) UnsolvedSymbolException{context='Method 'version' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=public class GradleVersion implements Comparable<GradleVersion> {

    public static final String URL = "http://www.gradle.org";

    private static final Pattern VERSION_PATTERN = Pattern.compile("((\\d+)(\\.\\d+)+)(-(\\p{Alpha}+)-(\\d+[a-z]?))?(-(SNAPSHOT|\\d{14}([-+]\\d{4})?))?");

    private static final int STAGE_MILESTONE = 0;

    private final String version;

    private final int majorPart;

    private final String buildTime;

    private final String commitId;

    private final Long snapshot;

    private final String versionPart;

    private final Stage stage;

    private static final GradleVersion CURRENT;

    public static final String RESOURCE_NAME = "/org/gradle/build-receipt.properties";

    static {
        URL resource = GradleVersion.class.getResource(RESOURCE_NAME);
        if (resource == null) {
            throw new GradleException(format("Resource '%s' not found.", RESOURCE_NAME));
        }
        InputStream inputStream = null;
        try {
            URLConnection connection = resource.openConnection();
            connection.setUseCaches(false);
            inputStream = connection.getInputStream();
            Properties properties = new Properties();
            properties.load(inputStream);
            String version = properties.get("versionNumber").toString();
            String buildTimestamp = properties.get("buildTimestamp").toString();
            String commitId = properties.get("commitId").toString();
            Date buildTime;
            if ("unknown".equals(buildTimestamp)) {
                buildTime = null;
            } else {
                buildTime = new SimpleDateFormat("yyyyMMddHHmmssZ").parse(buildTimestamp);
            }
            CURRENT = new GradleVersion(version, buildTime, commitId);
        } catch (Exception e) {
            throw new GradleException(format("Could not load version details from resource '%s'.", resource), e);
        } finally {
            if (inputStream != null) {
                uncheckedClose(inputStream);
            }
        }
    }

    public static GradleVersion current() {
        return CURRENT;
    }

    /**
     * Parses the given string into a GradleVersion.
     *
     * @throws IllegalArgumentException On unrecognized version string.
     */
    public static GradleVersion version(String version) throws IllegalArgumentException {
        return new GradleVersion(version, null, null);
    }

    private GradleVersion(String version, Date buildTime, String commitId) {
        this.version = version;
        this.commitId = commitId;
        this.buildTime = buildTime == null ? null : formatBuildTime(buildTime);
        Matcher matcher = VERSION_PATTERN.matcher(version);
        if (!matcher.matches()) {
            throw new IllegalArgumentException(format("'%s' is not a valid Gradle version string (examples: '1.0', '1.0-rc-1')", version));
        }
        versionPart = matcher.group(1);
        majorPart = Integer.parseInt(matcher.group(2), 10);
        if (matcher.group(4) != null) {
            int stageNumber;
            if (matcher.group(5).equals("milestone")) {
                stageNumber = STAGE_MILESTONE;
            } else if (matcher.group(5).equals("preview")) {
                stageNumber = 2;
            } else if (matcher.group(5).equals("rc")) {
                stageNumber = 3;
            } else {
                stageNumber = 1;
            }
            String stageString = matcher.group(6);
            stage = new Stage(stageNumber, stageString);
        } else {
            stage = null;
        }
        if ("snapshot".equals(matcher.group(5))) {
            snapshot = 0L;
        } else if (matcher.group(8) == null) {
            snapshot = null;
        } else if ("SNAPSHOT".equals(matcher.group(8))) {
            snapshot = 0L;
        } else {
            try {
                if (matcher.group(9) != null) {
                    snapshot = new SimpleDateFormat("yyyyMMddHHmmssZ").parse(matcher.group(8)).getTime();
                } else {
                    SimpleDateFormat format = new SimpleDateFormat("yyyyMMddHHmmss");
                    format.setTimeZone(TimeZone.getTimeZone("UTC"));
                    snapshot = format.parse(matcher.group(8)).getTime();
                }
            } catch (ParseException e) {
                throw UncheckedException.throwAsUncheckedException(e);
            }
        }
    }

    private String formatBuildTime(Date buildTime) {
        DateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss z");
        format.setTimeZone(TimeZone.getTimeZone("UTC"));
        return format.format(buildTime);
    }

    @Override
    public String toString() {
        return "Gradle " + version;
    }

    public String getVersion() {
        return version;
    }

    public String getBuildTime() {
        return buildTime;
    }

    public String getRevision() {
        return commitId;
    }

    public boolean isSnapshot() {
        return snapshot != null;
    }

    /**
     * The base version of this version. For pre-release versions, this is the target version.
     *
     * For example, the version base of '1.2-rc-1' is '1.2'.
     *
     * @return The version base
     */
    public GradleVersion getBaseVersion() {
        if (stage == null && snapshot == null) {
            return this;
        }
        return version(versionPart);
    }

    public GradleVersion getNextMajor() {
        if (stage != null && stage.stage == STAGE_MILESTONE) {
            return version(majorPart + ".0");
        }
        return version((majorPart + 1) + ".0");
    }

    public int compareTo(GradleVersion gradleVersion) {
        String[] majorVersionParts = versionPart.split("\\.");
        String[] otherMajorVersionParts = gradleVersion.versionPart.split("\\.");
        for (int i = 0; i < majorVersionParts.length && i < otherMajorVersionParts.length; i++) {
            int part = Integer.parseInt(majorVersionParts[i]);
            int otherPart = Integer.parseInt(otherMajorVersionParts[i]);
            if (part > otherPart) {
                return 1;
            }
            if (otherPart > part) {
                return -1;
            }
        }
        if (majorVersionParts.length > otherMajorVersionParts.length) {
            return 1;
        }
        if (majorVersionParts.length < otherMajorVersionParts.length) {
            return -1;
        }
        if (stage != null && gradleVersion.stage != null) {
            int diff = stage.compareTo(gradleVersion.stage);
            if (diff != 0) {
                return diff;
            }
        }
        if (stage == null && gradleVersion.stage != null) {
            return 1;
        }
        if (stage != null && gradleVersion.stage == null) {
            return -1;
        }
        if (snapshot != null && gradleVersion.snapshot != null) {
            return snapshot.compareTo(gradleVersion.snapshot);
        }
        if (snapshot == null && gradleVersion.snapshot != null) {
            return 1;
        }
        if (snapshot != null && gradleVersion.snapshot == null) {
            return -1;
        }
        return 0;
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) {
            return true;
        }
        if (o == null || o.getClass() != getClass()) {
            return false;
        }
        GradleVersion other = (GradleVersion) o;
        return version.equals(other.version);
    }

    @Override
    public int hashCode() {
        return version.hashCode();
    }

    public boolean isValid() {
        return versionPart != null;
    }

    static final class Stage implements Comparable<Stage> {

        final int stage;

        final int number;

        final Character patchNo;

        Stage(int stage, String number) {
            this.stage = stage;
            Matcher m = Pattern.compile("(\\d+)([a-z])?").matcher(number);
            try {
                m.matches();
                this.number = Integer.parseInt(m.group(1));
            } catch (Exception e) {
                throw new RuntimeException("Invalid stage small number: " + number, e);
            }
            if (m.groupCount() == 2 && m.group(2) != null) {
                this.patchNo = m.group(2).charAt(0);
            } else {
                this.patchNo = '_';
            }
        }

        public int compareTo(Stage other) {
            if (stage > other.stage) {
                return 1;
            }
            if (stage < other.stage) {
                return -1;
            }
            if (number > other.number) {
                return 1;
            }
            if (number < other.number) {
                return -1;
            }
            if (patchNo > other.patchNo) {
                return 1;
            }
            if (patchNo < other.patchNo) {
                return -1;
            }
            return 0;
        }
    }
}}'} /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/converters/IdeaModelCompatibilityMapping.java
Cannot solve method call targetGradleVersion.getBaseVersion().compareTo(GradleVersion.version("3.1")) UnsolvedSymbolException{context='Method 'version' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=public class GradleVersion implements Comparable<GradleVersion> {

    public static final String URL = "http://www.gradle.org";

    private static final Pattern VERSION_PATTERN = Pattern.compile("((\\d+)(\\.\\d+)+)(-(\\p{Alpha}+)-(\\d+[a-z]?))?(-(SNAPSHOT|\\d{14}([-+]\\d{4})?))?");

    private static final int STAGE_MILESTONE = 0;

    private final String version;

    private final int majorPart;

    private final String buildTime;

    private final String commitId;

    private final Long snapshot;

    private final String versionPart;

    private final Stage stage;

    private static final GradleVersion CURRENT;

    public static final String RESOURCE_NAME = "/org/gradle/build-receipt.properties";

    static {
        URL resource = GradleVersion.class.getResource(RESOURCE_NAME);
        if (resource == null) {
            throw new GradleException(format("Resource '%s' not found.", RESOURCE_NAME));
        }
        InputStream inputStream = null;
        try {
            URLConnection connection = resource.openConnection();
            connection.setUseCaches(false);
            inputStream = connection.getInputStream();
            Properties properties = new Properties();
            properties.load(inputStream);
            String version = properties.get("versionNumber").toString();
            String buildTimestamp = properties.get("buildTimestamp").toString();
            String commitId = properties.get("commitId").toString();
            Date buildTime;
            if ("unknown".equals(buildTimestamp)) {
                buildTime = null;
            } else {
                buildTime = new SimpleDateFormat("yyyyMMddHHmmssZ").parse(buildTimestamp);
            }
            CURRENT = new GradleVersion(version, buildTime, commitId);
        } catch (Exception e) {
            throw new GradleException(format("Could not load version details from resource '%s'.", resource), e);
        } finally {
            if (inputStream != null) {
                uncheckedClose(inputStream);
            }
        }
    }

    public static GradleVersion current() {
        return CURRENT;
    }

    /**
     * Parses the given string into a GradleVersion.
     *
     * @throws IllegalArgumentException On unrecognized version string.
     */
    public static GradleVersion version(String version) throws IllegalArgumentException {
        return new GradleVersion(version, null, null);
    }

    private GradleVersion(String version, Date buildTime, String commitId) {
        this.version = version;
        this.commitId = commitId;
        this.buildTime = buildTime == null ? null : formatBuildTime(buildTime);
        Matcher matcher = VERSION_PATTERN.matcher(version);
        if (!matcher.matches()) {
            throw new IllegalArgumentException(format("'%s' is not a valid Gradle version string (examples: '1.0', '1.0-rc-1')", version));
        }
        versionPart = matcher.group(1);
        majorPart = Integer.parseInt(matcher.group(2), 10);
        if (matcher.group(4) != null) {
            int stageNumber;
            if (matcher.group(5).equals("milestone")) {
                stageNumber = STAGE_MILESTONE;
            } else if (matcher.group(5).equals("preview")) {
                stageNumber = 2;
            } else if (matcher.group(5).equals("rc")) {
                stageNumber = 3;
            } else {
                stageNumber = 1;
            }
            String stageString = matcher.group(6);
            stage = new Stage(stageNumber, stageString);
        } else {
            stage = null;
        }
        if ("snapshot".equals(matcher.group(5))) {
            snapshot = 0L;
        } else if (matcher.group(8) == null) {
            snapshot = null;
        } else if ("SNAPSHOT".equals(matcher.group(8))) {
            snapshot = 0L;
        } else {
            try {
                if (matcher.group(9) != null) {
                    snapshot = new SimpleDateFormat("yyyyMMddHHmmssZ").parse(matcher.group(8)).getTime();
                } else {
                    SimpleDateFormat format = new SimpleDateFormat("yyyyMMddHHmmss");
                    format.setTimeZone(TimeZone.getTimeZone("UTC"));
                    snapshot = format.parse(matcher.group(8)).getTime();
                }
            } catch (ParseException e) {
                throw UncheckedException.throwAsUncheckedException(e);
            }
        }
    }

    private String formatBuildTime(Date buildTime) {
        DateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss z");
        format.setTimeZone(TimeZone.getTimeZone("UTC"));
        return format.format(buildTime);
    }

    @Override
    public String toString() {
        return "Gradle " + version;
    }

    public String getVersion() {
        return version;
    }

    public String getBuildTime() {
        return buildTime;
    }

    public String getRevision() {
        return commitId;
    }

    public boolean isSnapshot() {
        return snapshot != null;
    }

    /**
     * The base version of this version. For pre-release versions, this is the target version.
     *
     * For example, the version base of '1.2-rc-1' is '1.2'.
     *
     * @return The version base
     */
    public GradleVersion getBaseVersion() {
        if (stage == null && snapshot == null) {
            return this;
        }
        return version(versionPart);
    }

    public GradleVersion getNextMajor() {
        if (stage != null && stage.stage == STAGE_MILESTONE) {
            return version(majorPart + ".0");
        }
        return version((majorPart + 1) + ".0");
    }

    public int compareTo(GradleVersion gradleVersion) {
        String[] majorVersionParts = versionPart.split("\\.");
        String[] otherMajorVersionParts = gradleVersion.versionPart.split("\\.");
        for (int i = 0; i < majorVersionParts.length && i < otherMajorVersionParts.length; i++) {
            int part = Integer.parseInt(majorVersionParts[i]);
            int otherPart = Integer.parseInt(otherMajorVersionParts[i]);
            if (part > otherPart) {
                return 1;
            }
            if (otherPart > part) {
                return -1;
            }
        }
        if (majorVersionParts.length > otherMajorVersionParts.length) {
            return 1;
        }
        if (majorVersionParts.length < otherMajorVersionParts.length) {
            return -1;
        }
        if (stage != null && gradleVersion.stage != null) {
            int diff = stage.compareTo(gradleVersion.stage);
            if (diff != 0) {
                return diff;
            }
        }
        if (stage == null && gradleVersion.stage != null) {
            return 1;
        }
        if (stage != null && gradleVersion.stage == null) {
            return -1;
        }
        if (snapshot != null && gradleVersion.snapshot != null) {
            return snapshot.compareTo(gradleVersion.snapshot);
        }
        if (snapshot == null && gradleVersion.snapshot != null) {
            return 1;
        }
        if (snapshot != null && gradleVersion.snapshot == null) {
            return -1;
        }
        return 0;
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) {
            return true;
        }
        if (o == null || o.getClass() != getClass()) {
            return false;
        }
        GradleVersion other = (GradleVersion) o;
        return version.equals(other.version);
    }

    @Override
    public int hashCode() {
        return version.hashCode();
    }

    public boolean isValid() {
        return versionPart != null;
    }

    static final class Stage implements Comparable<Stage> {

        final int stage;

        final int number;

        final Character patchNo;

        Stage(int stage, String number) {
            this.stage = stage;
            Matcher m = Pattern.compile("(\\d+)([a-z])?").matcher(number);
            try {
                m.matches();
                this.number = Integer.parseInt(m.group(1));
            } catch (Exception e) {
                throw new RuntimeException("Invalid stage small number: " + number, e);
            }
            if (m.groupCount() == 2 && m.group(2) != null) {
                this.patchNo = m.group(2).charAt(0);
            } else {
                this.patchNo = '_';
            }
        }

        public int compareTo(Stage other) {
            if (stage > other.stage) {
                return 1;
            }
            if (stage < other.stage) {
                return -1;
            }
            if (number > other.number) {
                return 1;
            }
            if (number < other.number) {
                return -1;
            }
            if (patchNo > other.patchNo) {
                return 1;
            }
            if (patchNo < other.patchNo) {
                return -1;
            }
            return 0;
        }
    }
}}'} /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/converters/IdeaModelCompatibilityMapping.java
Cannot solve method call configuredTargetTypes.containsKey(i.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context i.getName() (line: 40) MethodCallExprContext{wrapped=i.getName()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/converters/ConsumerTargetTypeProvider.java
Cannot solve method call configuredTargetTypes.get(i.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context i.getName() (line: 41) MethodCallExprContext{wrapped=i.getName()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/converters/ConsumerTargetTypeProvider.java
Error calculating the type of parameter i.getName() of method call configuredTargetTypes.get(i.getName())
Cannot solve method call selectorTasks.addAll(aggregatedTasks.get(selectorName)) java.lang.RuntimeException: Method 'get' cannot be resolved in context aggregatedTasks.get(selectorName) (line: 53) MethodCallExprContext{wrapped=aggregatedTasks.get(selectorName)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/converters/BuildInvocationsConverter.java
Cannot solve method call new ConsumerProvidedTaskSelector().setName(selectorName).setTaskNames(selectorTasks).setDescription(project.getParent() != null ? String.format("%s:%s task selector", project.getPath(), selectorName) : String.format("%s task selector", selectorName)) UnsolvedSymbolException{context='Method 'format' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=String}'} /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/converters/BuildInvocationsConverter.java
Error calculating the type of parameter project.getParent() != null ? String.format("%s:%s task selector", project.getPath(), selectorName) : String.format("%s task selector", selectorName) of method call new ConsumerProvidedTaskSelector().setName(selectorName).setTaskNames(selectorTasks).setDescription(project.getParent() != null ? String.format("%s:%s task selector", project.getPath(), selectorName) : String.format("%s task selector", selectorName))
Cannot solve method call selectors.add(new ConsumerProvidedTaskSelector().setName(selectorName).setTaskNames(selectorTasks).setDescription(project.getParent() != null ? String.format("%s:%s task selector", project.getPath(), selectorName) : String.format("%s task selector", selectorName)).setDisplayName(String.format("%s in %s and subprojects.", selectorName, project.getName()))) java.lang.RuntimeException: Error calculating the type of parameter String.format("%s in %s and subprojects.", selectorName, project.getName()) of method call new ConsumerProvidedTaskSelector().setName(selectorName).setTaskNames(selectorTasks).setDescription(project.getParent() != null ? String.format("%s:%s task selector", project.getPath(), selectorName) : String.format("%s task selector", selectorName)).setDisplayName(String.format("%s in %s and subprojects.", selectorName, project.getName())) /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/converters/BuildInvocationsConverter.java
Method 'getFactory' cannot be resolved in context singletonRegistry.getFactory(DefaultGradleConnector.class) (line: 36) MethodCallExprContext{wrapped=singletonRegistry.getFactory(DefaultGradleConnector.class)}. Parameter types: [ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=ReferenceType{org.gradle.tooling.internal.consumer.DefaultGradleConnector, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}]
Cannot solve field access JavaVersion.VERSION_1_7
Cannot resolve field access null
Method 'iterator' cannot be resolved in context arguments.iterator() (line: 59) MethodCallExprContext{wrapped=arguments.iterator()}. Parameter types: []
Cannot solve method call addProgressListener(listener, ImmutableSet.copyOf(operationTypes)) UnsolvedSymbolException{context='Method 'copyOf' with parameterTypes [ResolvedArrayType{ReferenceType{org.gradle.tooling.events.OperationType, typeParametersMap=TypeParametersMap{nameToValue={}}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.collect.ImmutableSet}'} /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/AbstractLongRunningOperation.java
Cannot solve field access OperationType.TEST
Cannot solve field access OperationType.TASK
Cannot solve field access OperationType.GENERIC
Cannot solve method call operationParamsBuilder.setCancellationToken(Preconditions.checkNotNull(cancellationToken)) UnsolvedSymbolException{context='Method 'checkNotNull' with parameterTypes [ReferenceType{org.gradle.tooling.CancellationToken, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=com.google.common.base.Preconditions}'} /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/AbstractLongRunningOperation.java
Cannot solve method call toTestDescriptor(event.getDescriptor()) java.lang.RuntimeException: Method 'getDescriptor' cannot be resolved in context event.getDescriptor() (line: 143) MethodCallExprContext{wrapped=event.getDescriptor()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/parameters/BuildProgressListenerAdapter.java
Cannot solve method call addDescriptor(event.getDescriptor(), toTestDescriptor(event.getDescriptor())) java.lang.RuntimeException: Method 'getDescriptor' cannot be resolved in context event.getDescriptor() (line: 143) MethodCallExprContext{wrapped=event.getDescriptor()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/parameters/BuildProgressListenerAdapter.java
Cannot solve method call addDescriptor(event.getDescriptor(), toTaskDescriptor((InternalTaskDescriptor) event.getDescriptor())) java.lang.RuntimeException: Method 'getDescriptor' cannot be resolved in context event.getDescriptor() (line: 148) MethodCallExprContext{wrapped=event.getDescriptor()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/parameters/BuildProgressListenerAdapter.java
Cannot solve method call toDescriptor(event.getDescriptor()) java.lang.RuntimeException: Method 'getDescriptor' cannot be resolved in context event.getDescriptor() (line: 153) MethodCallExprContext{wrapped=event.getDescriptor()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/parameters/BuildProgressListenerAdapter.java
Cannot solve method call addDescriptor(event.getDescriptor(), toDescriptor(event.getDescriptor())) java.lang.RuntimeException: Method 'getDescriptor' cannot be resolved in context event.getDescriptor() (line: 153) MethodCallExprContext{wrapped=event.getDescriptor()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/parameters/BuildProgressListenerAdapter.java
Cannot solve method call removeDescriptor(TestOperationDescriptor.class, event.getDescriptor()) java.lang.RuntimeException: Method 'getDescriptor' cannot be resolved in context event.getDescriptor() (line: 158) MethodCallExprContext{wrapped=event.getDescriptor()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/parameters/BuildProgressListenerAdapter.java
Cannot solve method call toTestResult(event.getResult()) java.lang.RuntimeException: Method 'getResult' cannot be resolved in context event.getResult() (line: 159) MethodCallExprContext{wrapped=event.getResult()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/parameters/BuildProgressListenerAdapter.java
Cannot solve method call removeDescriptor(TaskOperationDescriptor.class, event.getDescriptor()) java.lang.RuntimeException: Method 'getDescriptor' cannot be resolved in context event.getDescriptor() (line: 163) MethodCallExprContext{wrapped=event.getDescriptor()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/parameters/BuildProgressListenerAdapter.java
Cannot solve method call removeDescriptor(OperationDescriptor.class, event.getDescriptor()) java.lang.RuntimeException: Method 'getDescriptor' cannot be resolved in context event.getDescriptor() (line: 168) MethodCallExprContext{wrapped=event.getDescriptor()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/parameters/BuildProgressListenerAdapter.java
Cannot solve method call toResult(event.getResult()) java.lang.RuntimeException: Method 'getResult' cannot be resolved in context event.getResult() (line: 169) MethodCallExprContext{wrapped=event.getResult()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/parameters/BuildProgressListenerAdapter.java
Cannot solve method call this.descriptorCache.get(descriptor.getId()) java.lang.RuntimeException: Method 'getId' cannot be resolved in context descriptor.getId() (line: 173) MethodCallExprContext{wrapped=descriptor.getId()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/parameters/BuildProgressListenerAdapter.java
Cannot solve method call descriptorCache.put(descriptor.getId(), clientDescriptor) java.lang.RuntimeException: Method 'getId' cannot be resolved in context descriptor.getId() (line: 177) MethodCallExprContext{wrapped=descriptor.getId()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/parameters/BuildProgressListenerAdapter.java
Cannot solve method call this.descriptorCache.remove(descriptor.getId()) java.lang.RuntimeException: Method 'getId' cannot be resolved in context descriptor.getId() (line: 182) MethodCallExprContext{wrapped=descriptor.getId()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/parameters/BuildProgressListenerAdapter.java
Cannot solve method call String.format("Unexpected operation type. Required %s but found %s", type.getName(), descriptorClass.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context type.getName() (line: 192) MethodCallExprContext{wrapped=type.getName()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/parameters/BuildProgressListenerAdapter.java
Cannot solve method call getParentDescriptor(descriptor.getParentId()) java.lang.RuntimeException: Method 'getParentId' cannot be resolved in context descriptor.getParentId() (line: 198) MethodCallExprContext{wrapped=descriptor.getParentId()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/parameters/BuildProgressListenerAdapter.java
Cannot solve method call toJvmTestKind(jvmTestDescriptor.getTestKind()) java.lang.RuntimeException: Method 'getTestKind' cannot be resolved in context jvmTestDescriptor.getTestKind() (line: 202) MethodCallExprContext{wrapped=jvmTestDescriptor.getTestKind()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/parameters/BuildProgressListenerAdapter.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call getParentDescriptor(descriptor.getParentId()) java.lang.RuntimeException: Method 'getParentId' cannot be resolved in context descriptor.getParentId() (line: 219) MethodCallExprContext{wrapped=descriptor.getParentId()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/parameters/BuildProgressListenerAdapter.java
Cannot solve method call getParentDescriptor(descriptor.getParentId()) java.lang.RuntimeException: Method 'getParentId' cannot be resolved in context descriptor.getParentId() (line: 224) MethodCallExprContext{wrapped=descriptor.getParentId()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/parameters/BuildProgressListenerAdapter.java
Cannot solve method call toFailures(result.getFailures()) java.lang.RuntimeException: Method 'getFailures' cannot be resolved in context result.getFailures() (line: 247) MethodCallExprContext{wrapped=result.getFailures()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/parameters/BuildProgressListenerAdapter.java
Cannot solve method call toFailures(result.getFailures()) java.lang.RuntimeException: Method 'getFailures' cannot be resolved in context result.getFailures() (line: 259) MethodCallExprContext{wrapped=result.getFailures()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/parameters/BuildProgressListenerAdapter.java
Cannot solve method call toFailures(result.getFailures()) java.lang.RuntimeException: Method 'getFailures' cannot be resolved in context result.getFailures() (line: 269) MethodCallExprContext{wrapped=result.getFailures()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/parameters/BuildProgressListenerAdapter.java
Method 'getModule' cannot be resolved in context registry.getModule("gradle-launcher") (line: 264) MethodCallExprContext{wrapped=registry.getModule("gradle-launcher")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot solve method call String.format("Could not fetch model of type '%s' using %s.", modelType.getSimpleName(), connection.getDisplayName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context modelType.getSimpleName() (line: 87) MethodCallExprContext{wrapped=modelType.getSimpleName()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/DefaultModelBuilder.java
Cannot solve method call version.compareTo(GradleVersion.version("1.11")) UnsolvedSymbolException{context='Method 'version' with parameterTypes [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=public class GradleVersion implements Comparable<GradleVersion> {

    public static final String URL = "http://www.gradle.org";

    private static final Pattern VERSION_PATTERN = Pattern.compile("((\\d+)(\\.\\d+)+)(-(\\p{Alpha}+)-(\\d+[a-z]?))?(-(SNAPSHOT|\\d{14}([-+]\\d{4})?))?");

    private static final int STAGE_MILESTONE = 0;

    private final String version;

    private final int majorPart;

    private final String buildTime;

    private final String commitId;

    private final Long snapshot;

    private final String versionPart;

    private final Stage stage;

    private static final GradleVersion CURRENT;

    public static final String RESOURCE_NAME = "/org/gradle/build-receipt.properties";

    static {
        URL resource = GradleVersion.class.getResource(RESOURCE_NAME);
        if (resource == null) {
            throw new GradleException(format("Resource '%s' not found.", RESOURCE_NAME));
        }
        InputStream inputStream = null;
        try {
            URLConnection connection = resource.openConnection();
            connection.setUseCaches(false);
            inputStream = connection.getInputStream();
            Properties properties = new Properties();
            properties.load(inputStream);
            String version = properties.get("versionNumber").toString();
            String buildTimestamp = properties.get("buildTimestamp").toString();
            String commitId = properties.get("commitId").toString();
            Date buildTime;
            if ("unknown".equals(buildTimestamp)) {
                buildTime = null;
            } else {
                buildTime = new SimpleDateFormat("yyyyMMddHHmmssZ").parse(buildTimestamp);
            }
            CURRENT = new GradleVersion(version, buildTime, commitId);
        } catch (Exception e) {
            throw new GradleException(format("Could not load version details from resource '%s'.", resource), e);
        } finally {
            if (inputStream != null) {
                uncheckedClose(inputStream);
            }
        }
    }

    public static GradleVersion current() {
        return CURRENT;
    }

    /**
     * Parses the given string into a GradleVersion.
     *
     * @throws IllegalArgumentException On unrecognized version string.
     */
    public static GradleVersion version(String version) throws IllegalArgumentException {
        return new GradleVersion(version, null, null);
    }

    private GradleVersion(String version, Date buildTime, String commitId) {
        this.version = version;
        this.commitId = commitId;
        this.buildTime = buildTime == null ? null : formatBuildTime(buildTime);
        Matcher matcher = VERSION_PATTERN.matcher(version);
        if (!matcher.matches()) {
            throw new IllegalArgumentException(format("'%s' is not a valid Gradle version string (examples: '1.0', '1.0-rc-1')", version));
        }
        versionPart = matcher.group(1);
        majorPart = Integer.parseInt(matcher.group(2), 10);
        if (matcher.group(4) != null) {
            int stageNumber;
            if (matcher.group(5).equals("milestone")) {
                stageNumber = STAGE_MILESTONE;
            } else if (matcher.group(5).equals("preview")) {
                stageNumber = 2;
            } else if (matcher.group(5).equals("rc")) {
                stageNumber = 3;
            } else {
                stageNumber = 1;
            }
            String stageString = matcher.group(6);
            stage = new Stage(stageNumber, stageString);
        } else {
            stage = null;
        }
        if ("snapshot".equals(matcher.group(5))) {
            snapshot = 0L;
        } else if (matcher.group(8) == null) {
            snapshot = null;
        } else if ("SNAPSHOT".equals(matcher.group(8))) {
            snapshot = 0L;
        } else {
            try {
                if (matcher.group(9) != null) {
                    snapshot = new SimpleDateFormat("yyyyMMddHHmmssZ").parse(matcher.group(8)).getTime();
                } else {
                    SimpleDateFormat format = new SimpleDateFormat("yyyyMMddHHmmss");
                    format.setTimeZone(TimeZone.getTimeZone("UTC"));
                    snapshot = format.parse(matcher.group(8)).getTime();
                }
            } catch (ParseException e) {
                throw UncheckedException.throwAsUncheckedException(e);
            }
        }
    }

    private String formatBuildTime(Date buildTime) {
        DateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss z");
        format.setTimeZone(TimeZone.getTimeZone("UTC"));
        return format.format(buildTime);
    }

    @Override
    public String toString() {
        return "Gradle " + version;
    }

    public String getVersion() {
        return version;
    }

    public String getBuildTime() {
        return buildTime;
    }

    public String getRevision() {
        return commitId;
    }

    public boolean isSnapshot() {
        return snapshot != null;
    }

    /**
     * The base version of this version. For pre-release versions, this is the target version.
     *
     * For example, the version base of '1.2-rc-1' is '1.2'.
     *
     * @return The version base
     */
    public GradleVersion getBaseVersion() {
        if (stage == null && snapshot == null) {
            return this;
        }
        return version(versionPart);
    }

    public GradleVersion getNextMajor() {
        if (stage != null && stage.stage == STAGE_MILESTONE) {
            return version(majorPart + ".0");
        }
        return version((majorPart + 1) + ".0");
    }

    public int compareTo(GradleVersion gradleVersion) {
        String[] majorVersionParts = versionPart.split("\\.");
        String[] otherMajorVersionParts = gradleVersion.versionPart.split("\\.");
        for (int i = 0; i < majorVersionParts.length && i < otherMajorVersionParts.length; i++) {
            int part = Integer.parseInt(majorVersionParts[i]);
            int otherPart = Integer.parseInt(otherMajorVersionParts[i]);
            if (part > otherPart) {
                return 1;
            }
            if (otherPart > part) {
                return -1;
            }
        }
        if (majorVersionParts.length > otherMajorVersionParts.length) {
            return 1;
        }
        if (majorVersionParts.length < otherMajorVersionParts.length) {
            return -1;
        }
        if (stage != null && gradleVersion.stage != null) {
            int diff = stage.compareTo(gradleVersion.stage);
            if (diff != 0) {
                return diff;
            }
        }
        if (stage == null && gradleVersion.stage != null) {
            return 1;
        }
        if (stage != null && gradleVersion.stage == null) {
            return -1;
        }
        if (snapshot != null && gradleVersion.snapshot != null) {
            return snapshot.compareTo(gradleVersion.snapshot);
        }
        if (snapshot == null && gradleVersion.snapshot != null) {
            return 1;
        }
        if (snapshot != null && gradleVersion.snapshot == null) {
            return -1;
        }
        return 0;
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) {
            return true;
        }
        if (o == null || o.getClass() != getClass()) {
            return false;
        }
        GradleVersion other = (GradleVersion) o;
        return version.equals(other.version);
    }

    @Override
    public int hashCode() {
        return version.hashCode();
    }

    public boolean isValid() {
        return versionPart != null;
    }

    static final class Stage implements Comparable<Stage> {

        final int stage;

        final int number;

        final Character patchNo;

        Stage(int stage, String number) {
            this.stage = stage;
            Matcher m = Pattern.compile("(\\d+)([a-z])?").matcher(number);
            try {
                m.matches();
                this.number = Integer.parseInt(m.group(1));
            } catch (Exception e) {
                throw new RuntimeException("Invalid stage small number: " + number, e);
            }
            if (m.groupCount() == 2 && m.group(2) != null) {
                this.patchNo = m.group(2).charAt(0);
            } else {
                this.patchNo = '_';
            }
        }

        public int compareTo(Stage other) {
            if (stage > other.stage) {
                return 1;
            }
            if (stage < other.stage) {
                return -1;
            }
            if (number > other.number) {
                return 1;
            }
            if (number < other.number) {
                return -1;
            }
            if (patchNo > other.patchNo) {
                return 1;
            }
            if (patchNo < other.patchNo) {
                return -1;
            }
            return 0;
        }
    }
}}'} /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/connection/ActionAwareConsumerConnection.java
Cannot solve method call executing.add(Thread.currentThread()) UnsolvedSymbolException{context='Method 'currentThread' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Thread}'} /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/connection/LazyConsumerActionExecutor.java
Cannot solve method call executing.remove(Thread.currentThread()) UnsolvedSymbolException{context='Method 'currentThread' with parameterTypes []', name='ReflectionClassDeclaration{clazz=Thread}'} /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/consumer/connection/LazyConsumerActionExecutor.java
Cannot solve method call visit(type.getComponentType(), types) java.lang.RuntimeException: Method 'getComponentType' cannot be resolved in context type.getComponentType() (line: 61) MethodCallExprContext{wrapped=type.getComponentType()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/adapter/TypeInspector.java
Cannot resolve field access null
Cannot solve method call decoration.restrictTo(TYPE_INSPECTOR.getReachableTypes(targetType)) java.lang.RuntimeException: T ? /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/adapter/ProtocolToModelAdapter.java
Cannot solve method call Proxy.newProxyInstance(viewType.getClassLoader(), new Class<?>[] { viewType }, handler) java.lang.RuntimeException: Method 'getClassLoader' cannot be resolved in context viewType.getClassLoader() (line: 155) MethodCallExprContext{wrapped=viewType.getClassLoader()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/adapter/ProtocolToModelAdapter.java
Cannot solve method call String.format("Can't convert '%s' to enum type '%s'", sourceObject, targetType.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context targetType.getSimpleName() (line: 175) MethodCallExprContext{wrapped=targetType.getSimpleName()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/adapter/ProtocolToModelAdapter.java
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call convertedElements.put(convert(targetKeyType, entry.getKey(), decoration, graphDetails), convert(targetValueType, entry.getValue(), decoration, graphDetails)) java.lang.UnsupportedOperationException: Object ? /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/adapter/ProtocolToModelAdapter.java
Cannot resolve field access null
Cannot solve method call queue.addFirst(c.getSuperclass()) java.lang.RuntimeException: Method 'getSuperclass' cannot be resolved in context c.getSuperclass() (line: 567) MethodCallExprContext{wrapped=c.getSuperclass()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/adapter/ProtocolToModelAdapter.java
Cannot resolve field access null
Cannot solve method call methodName.substring(2, methodName.length() - 9) java.lang.RuntimeException: Method 'length' cannot be resolved in context methodName.length() (line: 680) MethodCallExprContext{wrapped=methodName.length()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/adapter/ProtocolToModelAdapter.java
Cannot solve method call String.format("Cannot convert a Collection to type %s.", collectionType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context collectionType.getName() (line: 43) MethodCallExprContext{wrapped=collectionType.getName()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/adapter/CollectionMapper.java
Cannot solve method call String.format("Cannot convert a Map to type %s.", mapType.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context mapType.getName() (line: 53) MethodCallExprContext{wrapped=mapType.getName()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/internal/adapter/CollectionMapper.java
Cannot solve method call String.format("The version of Gradle you are using (%s) does not support building a model of type '%s'. Support for building custom tooling models was added in Gradle 1.6 and is available in all later versions.", targetVersion, modelType.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context modelType.getSimpleName() (line: 52) MethodCallExprContext{wrapped=modelType.getSimpleName()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/model/internal/Exceptions.java
Cannot solve method call String.format("The version of Gradle you are using (%s) does not support building a model of type '%s'. Support for building '%s' models was added in Gradle %s and is available in all later versions.", targetVersion, modelType.getSimpleName(), modelType.getSimpleName(), versionAdded) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context modelType.getSimpleName() (line: 49) MethodCallExprContext{wrapped=modelType.getSimpleName()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/model/internal/Exceptions.java
Cannot solve method call String.format("No model of type '%s' is available in this build.", type.getSimpleName()) java.lang.RuntimeException: Method 'getSimpleName' cannot be resolved in context type.getSimpleName() (line: 57) MethodCallExprContext{wrapped=type.getSimpleName()}. Parameter types: [] /repo/subprojects/tooling-api/src/main/java/org/gradle/tooling/model/internal/Exceptions.java
Cannot resolve field access null
Cannot solve name expression ProtocolConstants
Cannot solve method call setHasReceivedBuildCompleteNotification() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/foundation/ipc/gradle/TaskListServerProtocol.java
Cannot solve name expression ProtocolConstants
Cannot solve method call setHasReceivedBuildCompleteNotification() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/foundation/ipc/gradle/TaskListServerProtocol.java
Cannot solve name expression executionInteraction
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression ProtocolConstants
Cannot solve method call closeConnection() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/foundation/ipc/gradle/TaskListServerProtocol.java
Cannot solve name expression executionInteraction
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression executionInteraction
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression INIT_SCRIPT_NAME
Cannot solve method call this.extractInitScriptFile(TaskListServerProtocol.class, INIT_SCRIPT_NAME) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/foundation/ipc/gradle/TaskListServerProtocol.java
Cannot solve name expression Logging
Cannot solve name expression continueConnection
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve name expression ProtocolConstants
Cannot solve name expression ProtocolConstants
Cannot solve name expression server
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression continueConnection
Cannot solve name expression waitingOnHandshakeCompletion
Cannot resolve field access null
Cannot resolve field access null
Cannot solve name expression lastMessageReceived
Cannot solve name expression waitingOnHandshakeCompletion
Cannot solve name expression logger
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call handleMessageReceived(message) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/foundation/ipc/gradle/AbstractGradleServerProtocol.java
Cannot solve name expression ProtocolConstants
Cannot solve method call addStatus("Invalid handshaking. Stopping connection") java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/foundation/ipc/gradle/AbstractGradleServerProtocol.java
Cannot solve name expression server
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call closeConnection() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/foundation/ipc/gradle/AbstractGradleServerProtocol.java
Cannot solve name expression waitingOnHandshakeCompletion
Cannot solve name expression hasCompletedConnection
Cannot solve method call addStatus("Invalid handshaking. Missing port number. Stopping connection") java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/foundation/ipc/gradle/AbstractGradleServerProtocol.java
Cannot solve name expression server
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call closeConnection() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/foundation/ipc/gradle/AbstractGradleServerProtocol.java
Cannot solve name expression killGradleServerPort
Cannot solve name expression killGradleClientProcotol
Cannot solve name expression killGradleClient
Cannot solve name expression killGradleClientProcotol
Cannot solve name expression killGradleServerPort
Cannot solve name expression killGradleClient
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call handShakeCompleted() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/foundation/ipc/gradle/AbstractGradleServerProtocol.java
Cannot resolve field access null
Cannot solve name expression Jvm
Cannot solve name expression currentDirectory
Cannot solve method call executionInfo.setWorkingDirectory(currentDirectory) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/foundation/ipc/gradle/AbstractGradleServerProtocol.java
Cannot solve method call getGradleExecutableFile() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/foundation/ipc/gradle/AbstractGradleServerProtocol.java
Cannot solve name expression ProtocolConstants
Cannot solve name expression Integer
Cannot solve method call executionCommandLine.add("-D" + ProtocolConstants.PORT_NUMBER_SYSTEM_PROPERTY + "=" + Integer.toString(serverPort)) UnsolvedSymbolException{context='Method 'toString' with parameterTypes [PrimitiveTypeUsage{name='int'}]', name='ReflectionClassDeclaration{clazz=Integer}'} /repo/subprojects/ui/src/main/java/org/gradle/foundation/ipc/gradle/AbstractGradleServerProtocol.java
Cannot solve name expression commandLine
Cannot solve name expression CommandLineAssistant
Cannot solve method call CommandLineAssistant.breakUpCommandLine(commandLine) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/foundation/ipc/gradle/AbstractGradleServerProtocol.java
Cannot solve name expression Arrays
Cannot solve method call getInitScriptFile() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/foundation/ipc/gradle/AbstractGradleServerProtocol.java
Cannot solve name expression DefaultCommandLineConverter
Cannot solve name expression logLevel
Cannot solve method call commandLineAssistant.getLoggingCommandLineConverter().getLogLevelCommandLine(logLevel) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/foundation/ipc/gradle/AbstractGradleServerProtocol.java
Cannot solve name expression stackTraceLevel
Cannot solve method call commandLineAssistant.getLoggingCommandLineConverter().getShowStacktraceCommandLine(stackTraceLevel) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/foundation/ipc/gradle/AbstractGradleServerProtocol.java
Cannot solve method call executionInfo.setCommandLineArguments(executionCommandLine.toArray(new String[0])) java.lang.RuntimeException: String[] T[] /repo/subprojects/ui/src/main/java/org/gradle/foundation/ipc/gradle/AbstractGradleServerProtocol.java
Cannot solve name expression customGradleExecutor
Cannot solve name expression customGradleExecutor
Cannot solve name expression gradleHomeDirectory
Cannot solve name expression File
Cannot solve method call getDefaultGradleExecutableName() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/foundation/ipc/gradle/AbstractGradleServerProtocol.java
Cannot solve name expression OperatingSystem
Cannot solve name expression server
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression hasCompletedConnection
Cannot solve name expression hasReceivedBuildCompleteNotification
Cannot solve name expression commandLine
Cannot solve method call reportClientExit(wasPremature, returnCode, message) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/foundation/ipc/gradle/AbstractGradleServerProtocol.java
Cannot solve name expression logger
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression INIT_SCRIPT_EXTENSION
Cannot solve name expression temporaryFileProvider
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression INIT_SCRIPT_EXTENSION
Cannot solve method call extractResourceAsFile(resourceClass, resourceName + INIT_SCRIPT_EXTENSION, file) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/foundation/ipc/gradle/AbstractGradleServerProtocol.java
Cannot solve name expression logger
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression logger
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression IOUtils
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression logger
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression IOUtils
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression IOUtils
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression gradleHomeDirectory
Cannot solve name expression lastMessageReceived
Cannot solve name expression logger
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve method call killGradle() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/foundation/ipc/gradle/AbstractGradleServerProtocol.java
Cannot solve name expression killGradleClientProcotol
Cannot solve name expression killGradleClientProcotol
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot resolve field access null
Cannot solve name expression ProtocolConstants
Cannot solve method call setHasReceivedBuildCompleteNotification() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/foundation/ipc/gradle/ExecuteGradleCommandServerProtocol.java
Cannot solve name expression ProtocolConstants
Cannot solve name expression executionInteraction
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression ProtocolConstants
Cannot solve name expression executionInteraction
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression ProtocolConstants
Cannot solve name expression executionInteraction
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression ProtocolConstants
Cannot solve name expression executionInteraction
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression ProtocolConstants
Cannot solve method call closeConnection() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/foundation/ipc/gradle/ExecuteGradleCommandServerProtocol.java
Cannot solve name expression executionInteraction
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression executionInteraction
expected either zero type arguments or has many as defined in the declaration (0). Found 1
Cannot solve name expression INIT_SCRIPT_NAME
Cannot solve method call extractInitScriptFile(ExecuteGradleCommandServerProtocol.class, INIT_SCRIPT_NAME) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/foundation/ipc/gradle/ExecuteGradleCommandServerProtocol.java
Cannot solve method call notifyClientExited(-1, e.getMessage()) java.lang.RuntimeException: Method 'getMessage' cannot be resolved in context e.getMessage() (line: 109) MethodCallExprContext{wrapped=e.getMessage()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/foundation/ipc/basic/ProcessLauncherServer.java
Cannot solve method call protocol.getExecutionInfo(getPort()) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/foundation/ipc/basic/ProcessLauncherServer.java
Cannot solve method call protocol.aboutToKillProcess() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/foundation/ipc/basic/ProcessLauncherServer.java
Cannot solve method call protocol.clientExited(result, output) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/foundation/ipc/basic/ProcessLauncherServer.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Method 'substring' cannot be resolved in context matchedText.substring(prefixIndex, realPathEnd) (line: 86) MethodCallExprContext{wrapped=matchedText.substring(prefixIndex, realPathEnd)}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}]
Cannot solve method call Character.isWhitespace(matchedText.charAt(index)) java.lang.RuntimeException: Method 'charAt' cannot be resolved in context matchedText.charAt(index) (line: 114) MethodCallExprContext{wrapped=matchedText.charAt(index)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/ui/src/main/java/org/gradle/foundation/output/definitions/ExtensionFileLinkDefinition.java
Method 'append' cannot be resolved in context builder.append('\\') (line: 81) MethodCallExprContext{wrapped=builder.append('\\')}. Parameter types: [PrimitiveTypeUsage{name='char'}]
Method 'substring' cannot be resolved in context matchedText.substring(prefixIndex, realPathEnd) (line: 118) MethodCallExprContext{wrapped=matchedText.substring(prefixIndex, realPathEnd)}. Parameter types: [PrimitiveTypeUsage{name='int'}, PrimitiveTypeUsage{name='int'}]
Cannot solve method call Character.isWhitespace(matchedText.charAt(index)) java.lang.RuntimeException: Method 'charAt' cannot be resolved in context matchedText.charAt(index) (line: 141) MethodCallExprContext{wrapped=matchedText.charAt(index)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/ui/src/main/java/org/gradle/foundation/output/definitions/PrefixedFileLinkDefinition.java
Cannot solve method call textAfterPath.substring(lineDelimterIndex + lineNumberDelimiter.length()) java.lang.RuntimeException: Method 'length' cannot be resolved in context lineNumberDelimiter.length() (line: 152) MethodCallExprContext{wrapped=lineNumberDelimiter.length()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/foundation/output/definitions/PrefixedFileLinkDefinition.java
Cannot solve method call matchedText.substring(prefix.length(), indexOfPeriod) java.lang.RuntimeException: Method 'length' cannot be resolved in context prefix.length() (line: 58) MethodCallExprContext{wrapped=prefix.length()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/foundation/output/definitions/TestReportFileLinkDefinition.java
Error calculating the type of parameter prefix.length() of method call matchedText.substring(prefix.length(), indexOfPeriod)
Cannot solve method call fileLinkDefinitions.addAll(complexFileLinkDefinitions.values()) java.lang.RuntimeException: Method 'values' cannot be resolved in context complexFileLinkDefinitions.values() (line: 127) MethodCallExprContext{wrapped=complexFileLinkDefinitions.values()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/foundation/output/FileLinkDefinitionLord.java
Cannot solve method call fileLinkDefinitions.addAll(extensionFileLinkDefinitions.values()) java.lang.RuntimeException: Method 'values' cannot be resolved in context extensionFileLinkDefinitions.values() (line: 128) MethodCallExprContext{wrapped=extensionFileLinkDefinitions.values()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/foundation/output/FileLinkDefinitionLord.java
Method 'keySet' cannot be resolved in context map.keySet() (line: 156) MethodCallExprContext{wrapped=map.keySet()}. Parameter types: []
Method 'append' cannot be resolved in context criteria.append("(") (line: 187) MethodCallExprContext{wrapped=criteria.append("(")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context criteria.append("(") (line: 187) MethodCallExprContext{wrapped=criteria.append("(")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot resolve field access null
Cannot solve method call ensureFileHasCorrectExtensionAndCase(file, fileFilter.getExtension()) java.lang.RuntimeException: Method 'getExtension' cannot be resolved in context fileFilter.getExtension() (line: 153) MethodCallExprContext{wrapped=fileFilter.getExtension()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/foundation/DOM4JSerializer.java
Cannot resolve field access null
Method 'toLowerCase' cannot be resolved in context name.toLowerCase() (line: 247) MethodCallExprContext{wrapped=name.toLowerCase()}. Parameter types: []
Method 'elements' cannot be resolved in context element.elements() (line: 74) MethodCallExprContext{wrapped=element.elements()}. Parameter types: []
Cannot solve method call name.equals(childElement.attributeValue(NAME_ATTRIBUTE)) java.lang.RuntimeException: Method 'attributeValue' cannot be resolved in context childElement.attributeValue(NAME_ATTRIBUTE) (line: 77) MethodCallExprContext{wrapped=childElement.attributeValue(NAME_ATTRIBUTE)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/foundation/settings/DOM4JSettingsNode.java
Cannot solve method call convertNodes(element.elements()) java.lang.RuntimeException: Method 'elements' cannot be resolved in context element.elements() (line: 85) MethodCallExprContext{wrapped=element.elements()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/foundation/settings/DOM4JSettingsNode.java
Method 'elements' cannot be resolved in context element.elements() (line: 103) MethodCallExprContext{wrapped=element.elements()}. Parameter types: []
Cannot solve method call name.equals(childElement.attributeValue(NAME_ATTRIBUTE)) java.lang.RuntimeException: Method 'attributeValue' cannot be resolved in context childElement.attributeValue(NAME_ATTRIBUTE) (line: 106) MethodCallExprContext{wrapped=childElement.attributeValue(NAME_ATTRIBUTE)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/foundation/settings/DOM4JSettingsNode.java
Cannot solve method call setValueOfChild(name, Integer.toString(value)) UnsolvedSymbolException{context='Method 'toString' with parameterTypes [PrimitiveTypeUsage{name='int'}]', name='ReflectionClassDeclaration{clazz=Integer}'} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/foundation/settings/DOM4JSettingsNode.java
Cannot solve method call setValueOfChild(name, Long.toString(value)) UnsolvedSymbolException{context='Method 'toString' with parameterTypes [PrimitiveTypeUsage{name='long'}]', name='ReflectionClassDeclaration{clazz=Long}'} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/foundation/settings/DOM4JSettingsNode.java
Cannot solve method call setValueOfChild(name, Boolean.toString(value)) UnsolvedSymbolException{context='Method 'toString' with parameterTypes [PrimitiveTypeUsage{name='boolean'}]', name='ReflectionClassDeclaration{clazz=Boolean}'} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/foundation/settings/DOM4JSettingsNode.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Method 'elements' cannot be resolved in context element.elements() (line: 273) MethodCallExprContext{wrapped=element.elements()}. Parameter types: []
Cannot solve field access ShowStacktrace.INTERNAL_EXCEPTIONS
Cannot solve field access LogLevel.LIFECYCLE
Cannot solve method call logger.error("notifying aboutToExecuteCommand() " + e.getMessage()) java.lang.RuntimeException: Method 'getMessage' cannot be resolved in context e.getMessage() (line: 292) MethodCallExprContext{wrapped=e.getMessage()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/foundation/GradlePluginLord.java
Cannot solve method call logger.error("notifying requestExecutionComplete() " + e.getMessage()) java.lang.RuntimeException: Method 'getMessage' cannot be resolved in context e.getMessage() (line: 304) MethodCallExprContext{wrapped=e.getMessage()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/foundation/GradlePluginLord.java
Method 'append' cannot be resolved in context fullCommandLineBuilder.append(' ') (line: 525) MethodCallExprContext{wrapped=fullCommandLineBuilder.append(' ')}. Parameter types: [PrimitiveTypeUsage{name='char'}]
Cannot solve field access ShowStacktrace.INTERNAL_EXCEPTIONS
Method 'getCause' cannot be resolved in context scriptException.getCause() (line: 571) MethodCallExprContext{wrapped=scriptException.getCause()}. Parameter types: []
Cannot solve method call formatter.format("%s", scriptException.getCause().getMessage()) java.lang.RuntimeException: Method 'getCause' cannot be resolved in context scriptException.getCause() (line: 571) MethodCallExprContext{wrapped=scriptException.getCause()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/foundation/GradlePluginLord.java
Cannot solve field access ShowStacktrace.INTERNAL_EXCEPTIONS
Cannot solve field access ShowStacktrace.ALWAYS_FULL
Cannot solve method call getStackTraceAsText(StackTraceUtils.deepSanitize(failure)) UnsolvedSymbolException{context='Solving StackTraceUtils', name='StackTraceUtils', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/foundation/GradlePluginLord.java
Method 'append' cannot be resolved in context builder.append("   ") (line: 599) MethodCallExprContext{wrapped=builder.append("   ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'append' cannot be resolved in context builder.append("   ") (line: 599) MethodCallExprContext{wrapped=builder.append("   ")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Cannot resolve field access null
Cannot solve method call getMessage(throwable.getCause()) java.lang.RuntimeException: Method 'getCause' cannot be resolved in context throwable.getCause() (line: 613) MethodCallExprContext{wrapped=throwable.getCause()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/foundation/GradlePluginLord.java
Empty name expression Cancel
Empty name expression AddSeparately
Empty name expression AddAsSingleCommand
Method 'trim' cannot be resolved in context fullCommandLine.trim() (line: 182) MethodCallExprContext{wrapped=fullCommandLine.trim()}. Parameter types: []
Method 'trim' cannot be resolved in context displayName.trim() (line: 182) MethodCallExprContext{wrapped=displayName.trim()}. Parameter types: []
Method 'trim' cannot be resolved in context editibleFavoriteTask.fullCommandLine.trim() (line: 343) MethodCallExprContext{wrapped=editibleFavoriteTask.fullCommandLine.trim()}. Parameter types: []
Method 'trim' cannot be resolved in context editibleFavoriteTask.displayName.trim() (line: 348) MethodCallExprContext{wrapped=editibleFavoriteTask.displayName.trim()}. Parameter types: []
Method 'elements' cannot be resolved in context parent.elements(tagName) (line: 37) MethodCallExprContext{wrapped=parent.elements(tagName)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'elements' cannot be resolved in context parent.elements(tagName) (line: 51) MethodCallExprContext{wrapped=parent.elements(tagName)}. Parameter types: [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'elements' cannot be resolved in context parent.elements() (line: 68) MethodCallExprContext{wrapped=parent.elements()}. Parameter types: []
Method 'elements' cannot be resolved in context parent.elements() (line: 85) MethodCallExprContext{wrapped=parent.elements()}. Parameter types: []
Cannot solve method call "true".equals(attribute.getValue()) java.lang.RuntimeException: Method 'getValue' cannot be resolved in context attribute.getValue() (line: 111) MethodCallExprContext{wrapped=attribute.getValue()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/foundation/Dom4JUtility.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0) UnsolvedSymbolException{context='unknown', name='VK_ENTER', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/TaskTreeComponent.java
Cannot solve method call tree.registerKeyboardAction(new ActionListener() {

    public void actionPerformed(ActionEvent e) {
        executeFirstSelectedNode(false);
    }
}, KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0), JComponent.WHEN_IN_FOCUSED_WINDOW) java.lang.RuntimeException: Error calculating the type of parameter KeyEvent.VK_ENTER of method call KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0) /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/TaskTreeComponent.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, KeyEvent.CTRL_MASK) UnsolvedSymbolException{context='unknown', name='VK_ENTER', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/TaskTreeComponent.java
Cannot solve method call tree.registerKeyboardAction(new ActionListener() {

    public void actionPerformed(ActionEvent e) {
        executeFirstSelectedNode(true);
    }
}, KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, KeyEvent.CTRL_MASK), JComponent.WHEN_IN_FOCUSED_WINDOW) java.lang.RuntimeException: Error calculating the type of parameter KeyEvent.VK_ENTER of method call KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, KeyEvent.CTRL_MASK) /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/TaskTreeComponent.java
Cannot resolve field access null
Cannot resolve field access null
Method 'getFont' cannot be resolved in context nameRenderer.getFont() (line: 159) MethodCallExprContext{wrapped=nameRenderer.getFont()}. Parameter types: []
Cannot resolve field access null
Cannot solve method call normalFont.deriveFont(Font.BOLD) UnsolvedSymbolException{context='unknown', name='BOLD', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/TaskTreeComponent.java
Cannot solve method call this.descriptionRenderer.setForeground(nameRenderer.getForeground()) java.lang.RuntimeException: Method 'getForeground' cannot be resolved in context nameRenderer.getForeground() (line: 220) MethodCallExprContext{wrapped=nameRenderer.getForeground()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/TaskTreeComponent.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call tree.getRowForLocation(point.x, point.y) UnsolvedSymbolException{context='unknown', name='x', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/TaskTreeComponent.java
Cannot resolve field access null
Cannot solve method call getNodeAtPoint(e.getPoint()) java.lang.RuntimeException: Method 'getPoint' cannot be resolved in context e.getPoint() (line: 265) MethodCallExprContext{wrapped=e.getPoint()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/TaskTreeComponent.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call interaction.rightClick(tree, point.x, point.y) UnsolvedSymbolException{context='unknown', name='x', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/TaskTreeComponent.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call tree.getRowForLocation(point.x, point.y) UnsolvedSymbolException{context='unknown', name='x', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/TaskTreeComponent.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call tree.getPathForLocation(point.x, point.y) UnsolvedSymbolException{context='unknown', name='x', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/TaskTreeComponent.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call mainPanel.add(createOptionsPanel(), BorderLayout.NORTH) UnsolvedSymbolException{context='unknown', name='NORTH', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/filter/ProjectAndTaskFilterDialog.java
Cannot resolve field access null
Cannot solve method call mainPanel.add(createCenterPanel(), BorderLayout.CENTER) UnsolvedSymbolException{context='unknown', name='CENTER', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/filter/ProjectAndTaskFilterDialog.java
Cannot resolve field access null
Cannot solve method call mainPanel.add(createOkCancelPanel(), BorderLayout.SOUTH) UnsolvedSymbolException{context='unknown', name='SOUTH', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/filter/ProjectAndTaskFilterDialog.java
Cannot solve method call dialog.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE) UnsolvedSymbolException{context='unknown', name='DO_NOTHING_ON_CLOSE', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/filter/ProjectAndTaskFilterDialog.java
Cannot resolve field access null
Cannot solve method call projectPanel.add(createProjectPanel(), BorderLayout.CENTER) UnsolvedSymbolException{context='unknown', name='CENTER', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/filter/ProjectAndTaskFilterDialog.java
Cannot resolve field access null
Cannot solve method call taskPanel.add(createTasksPanel(), BorderLayout.CENTER) UnsolvedSymbolException{context='unknown', name='CENTER', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/filter/ProjectAndTaskFilterDialog.java
Method 'getComponent' cannot be resolved in context taskFilterEditorPanel.getComponent() (line: 212) MethodCallExprContext{wrapped=taskFilterEditorPanel.getComponent()}. Parameter types: []
Method 'getComponent' cannot be resolved in context projectFilterEditorPanel.getComponent() (line: 213) MethodCallExprContext{wrapped=projectFilterEditorPanel.getComponent()}. Parameter types: []
Method 'getComponent' cannot be resolved in context taskFilterEditorPanel.getComponent() (line: 271) MethodCallExprContext{wrapped=taskFilterEditorPanel.getComponent()}. Parameter types: []
Method 'getComponent' cannot be resolved in context projectFilterEditorPanel.getComponent() (line: 272) MethodCallExprContext{wrapped=projectFilterEditorPanel.getComponent()}. Parameter types: []
Cannot resolve field access null
Cannot solve method call mainPanel.add(createOptionsPanel(), BorderLayout.NORTH) UnsolvedSymbolException{context='unknown', name='NORTH', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/filter/AbstractFilterEditorPanel.java
Cannot resolve field access null
Cannot solve method call mainPanel.add(createListPanel(), BorderLayout.CENTER) UnsolvedSymbolException{context='unknown', name='CENTER', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/filter/AbstractFilterEditorPanel.java
Cannot resolve field access null
Cannot solve method call setForeground(Color.red) UnsolvedSymbolException{context='unknown', name='red', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/filter/AbstractFilterEditorPanel.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call add(tabbedPane, BorderLayout.CENTER) UnsolvedSymbolException{context='unknown', name='CENTER', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/MainGradlePanel.java
Cannot solve method call scroll.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED) UnsolvedSymbolException{context='unknown', name='HORIZONTAL_SCROLLBAR_AS_NEEDED', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputTextPane.java
Cannot solve method call scroll.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED) UnsolvedSymbolException{context='unknown', name='VERTICAL_SCROLLBAR_AS_NEEDED', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputTextPane.java
Cannot resolve field access null
Cannot solve method call caret.setUpdatePolicy(DefaultCaret.NEVER_UPDATE) UnsolvedSymbolException{context='unknown', name='NEVER_UPDATE', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputTextPane.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call styleContent.addAttribute(fileStyle, StyleConstants.Foreground, Color.blue) UnsolvedSymbolException{context='unknown', name='blue', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputTextPane.java
Cannot solve method call styleContent.addAttribute(SimpleAttributeSet.EMPTY, StyleConstants.FontFamily, font.getName()) java.lang.RuntimeException: Method 'getName' cannot be resolved in context font.getName() (line: 143) MethodCallExprContext{wrapped=font.getName()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputTextPane.java
Cannot solve method call styleContent.addAttribute(attributeSet, StyleConstants.FontSize, font.getSize()) java.lang.RuntimeException: Method 'getSize' cannot be resolved in context font.getSize() (line: 144) MethodCallExprContext{wrapped=font.getSize()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputTextPane.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call popupMenu.show(textPane, point.x, point.y) UnsolvedSymbolException{context='unknown', name='x', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputTextPane.java
Cannot resolve field access null
Cannot solve method call document.remove(0, document.getLength()) java.lang.RuntimeException: Method 'getLength' cannot be resolved in context document.getLength() (line: 267) MethodCallExprContext{wrapped=document.getLength()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputTextPane.java
Cannot solve method call document.insertString(document.getLength(), text, defaultStyle) java.lang.RuntimeException: Method 'getLength' cannot be resolved in context document.getLength() (line: 270) MethodCallExprContext{wrapped=document.getLength()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputTextPane.java
Cannot solve method call document.setCharacterAttributes(0, document.getLength(), defaultStyle, true) java.lang.RuntimeException: Method 'getLength' cannot be resolved in context document.getLength() (line: 414) MethodCallExprContext{wrapped=document.getLength()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputTextPane.java
Cannot resolve field access null
Cannot solve method call mainPanel.add(createCommandLinePanel(), BorderLayout.NORTH) UnsolvedSymbolException{context='unknown', name='NORTH', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/tabs/CommandLineTab.java
Cannot resolve field access null
Cannot solve method call mainPanel.add(Box.createVerticalGlue(), BorderLayout.CENTER) UnsolvedSymbolException{context='unknown', name='CENTER', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/tabs/CommandLineTab.java
Cannot solve method call panel.add(Utility.addLeftJustifiedComponent(new JLabel("Command Line:"))) UnsolvedSymbolException{context='Method 'addLeftJustifiedComponent' with parameterTypes [ReferenceType{javax.swing.JLabel, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * Just some utility functions.
 */
public class Utility {

    private static final Logger LOGGER = Logging.getLogger(Utility.class);

    public static Component addLeftJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(component);
        panel.add(Box.createHorizontalGlue());
        return panel;
    }

    public static Component addRightJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(Box.createHorizontalGlue());
        panel.add(component);
        return panel;
    }

    /**
     * This creates a dialog. I only created this because I was using JDK 1.6, then realized I needed to use 1.5 and one of the most useful features of 1.6 is dialogs taking Windows as parents. This
     * abstracts that so I don't have to make major changes to the code by passing around JFrames and JDialogs explicitly.
     *
     * @param parent the parent window
     * @param isModal true if its modal, false if not.
     * @return a dialog
     */
    public static JDialog createDialog(Window parent, String title, boolean isModal) {
        if (parent instanceof JDialog) {
            return new JDialog((JDialog) parent, title, isModal);
        } else if (parent instanceof JFrame) {
            return new JDialog((JFrame) parent, title, isModal);
        }
        throw new RuntimeException("Unknown window type!");
    }

    /**
     * This uses reflection to set the tab component if we're running under 1.6. It does nothing if you're running under 1.5. This is so you can run this on java 1.6 and get this benefit, but its not
     * required to compile.
     *
     * This is the same as calling JTabbedPane.setTabComponentAt(). It just does so using reflection.
     */
    public static void setTabComponent15Compatible(JTabbedPane tabbedPane, int index, Component component) {
        try {
            Method method = tabbedPane.getClass().getMethod("setTabComponentAt", new Class[] { Integer.TYPE, Component.class });
            method.invoke(tabbedPane, index, component);
        } catch (NoSuchMethodException e) {
        // e.printStackTrace();
        // we're not requiring 1.6, so its not a problem if we don't find the method. We just don't get this feature.
        } catch (Exception e) {
            LOGGER.error("Setting tab component", e);
        }
    }

    /**
     * This creates a button with the specified action, image, and tooltip text. The main issue here is that it doesn't crash if the image is missing (which is just something that happens in real life
     * from time to time). You probably should specify a name on the action just in case.
     *
     * @param resourceClass the calling class. Useful when multiple classloaders are used.
     * @param imageResourceName the image resource
     * @param tooltip the tooltip to display
     * @param action the action to perform
     * @return the button that was created.
     */
    public static JButton createButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JButton button = null;
        if (imageResourceName != null) {
            InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
            if (inputStream != null) {
                try {
                    BufferedImage image = ImageIO.read(inputStream);
                    button = new BorderlessImageButton(action, new ImageIcon(image));
                } catch (IOException e) {
                    LOGGER.error("Reading image " + imageResourceName, e);
                }
            }
        }
        if (button == null) {
            button = new JButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JToggleButton createToggleButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JToggleButton button = null;
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            if (icon != null) {
                button = new BorderlessImageToggleButton(action, icon);
            }
        }
        if (button == null) {
            button = new JToggleButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JMenuItem createMenuItem(Class resourceClass, String name, String imageResourceName, Action action) {
        JMenuItem item = new JMenuItem(action);
        item.setText(name);
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            item.setIcon(icon);
        }
        return item;
    }

    /**
     * this determines if the CTRL key is down based on the modifiers from an event. This actualy needs to be checking for different things. CTRL doesn't meant the same thing on each platform.
     */
    public static boolean isCTRLDown(int eventModifiersEx) {
        return (eventModifiersEx & InputEvent.CTRL_DOWN_MASK) == InputEvent.CTRL_DOWN_MASK;
    }

    public static ImageIcon getImageIcon(Class resourceClass, String imageResourceName) {
        InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
        if (inputStream != null) {
            try {
                BufferedImage image = ImageIO.read(inputStream);
                return new ImageIcon(image);
            } catch (IOException e) {
                LOGGER.error("Reading image " + imageResourceName, e);
            }
        }
        return null;
    }

    /**
     * Scrolls the specified text component so the text between the starting and ending index are visible.
     */
    public static void scrollToText(JTextComponent textComponent, int startingIndex, int endingIndex) {
        try {
            Rectangle startingRectangle = textComponent.modelToView(startingIndex);
            Rectangle endDingRectangle = textComponent.modelToView(endingIndex);
            Rectangle totalBounds = startingRectangle.union(endDingRectangle);
            textComponent.scrollRectToVisible(totalBounds);
            textComponent.repaint();
        } catch (BadLocationException e) {
            e.printStackTrace();
        }
    }
}}'} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/tabs/CommandLineTab.java
Cannot resolve field access null
Cannot solve method call mainPanel.add(createTopPanel(), BorderLayout.NORTH) UnsolvedSymbolException{context='unknown', name='NORTH', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/tabs/TaskTreeTab.java
Cannot resolve field access null
Cannot solve method call mainPanel.add(createTreePanel(), BorderLayout.CENTER) UnsolvedSymbolException{context='unknown', name='CENTER', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/tabs/TaskTreeTab.java
Cannot resolve field access null
Cannot solve method call mainPanel.add(createButtonPanel(), BorderLayout.NORTH) UnsolvedSymbolException{context='unknown', name='NORTH', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/tabs/FavoriteTasksTab.java
Cannot resolve field access null
Cannot solve method call mainPanel.add(createListPanel(), BorderLayout.CENTER) UnsolvedSymbolException{context='unknown', name='CENTER', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/tabs/FavoriteTasksTab.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0) UnsolvedSymbolException{context='unknown', name='VK_ENTER', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/tabs/FavoriteTasksTab.java
Cannot solve method call list.registerKeyboardAction(new ActionListener() {

    public void actionPerformed(ActionEvent e) {
        executeSelectedTasks();
    }
}, KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0), JComponent.WHEN_IN_FOCUSED_WINDOW) java.lang.RuntimeException: Error calculating the type of parameter KeyEvent.VK_ENTER of method call KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0) /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/tabs/FavoriteTasksTab.java
Cannot solve method call Utility.isCTRLDown(e.getModifiersEx()) java.lang.RuntimeException: Method 'getModifiersEx' cannot be resolved in context e.getModifiersEx() (line: 225) MethodCallExprContext{wrapped=e.getModifiersEx()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/tabs/FavoriteTasksTab.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call popupMenu.show(list, point.x, point.y) UnsolvedSymbolException{context='unknown', name='x', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/tabs/FavoriteTasksTab.java
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot resolve field access null
Cannot solve field access SwingEditFavoriteInteraction.SynchronizeType.OnlyIfAlreadySynchronized
Cannot resolve field access null
Cannot solve field access SwingEditFavoriteInteraction.SynchronizeType.OnlyIfAlreadySynchronized
Cannot resolve field access null
Cannot solve field access SwingEditFavoriteInteraction.SynchronizeType.OnlyIfAlreadySynchronized
Cannot resolve field access null
Cannot solve method call expandingPanel.add(Box.createVerticalGlue(), BorderLayout.CENTER) UnsolvedSymbolException{context='unknown', name='CENTER', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/tabs/SetupTab.java
Cannot solve method call "".equals(currentDirectory.trim()) java.lang.RuntimeException: Method 'trim' cannot be resolved in context currentDirectory.trim() (line: 130) MethodCallExprContext{wrapped=currentDirectory.trim()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/tabs/SetupTab.java
Cannot solve method call panel.add(Utility.addLeftJustifiedComponent(new JLabel("Current Directory"))) UnsolvedSymbolException{context='Method 'addLeftJustifiedComponent' with parameterTypes [ReferenceType{javax.swing.JLabel, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * Just some utility functions.
 */
public class Utility {

    private static final Logger LOGGER = Logging.getLogger(Utility.class);

    public static Component addLeftJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(component);
        panel.add(Box.createHorizontalGlue());
        return panel;
    }

    public static Component addRightJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(Box.createHorizontalGlue());
        panel.add(component);
        return panel;
    }

    /**
     * This creates a dialog. I only created this because I was using JDK 1.6, then realized I needed to use 1.5 and one of the most useful features of 1.6 is dialogs taking Windows as parents. This
     * abstracts that so I don't have to make major changes to the code by passing around JFrames and JDialogs explicitly.
     *
     * @param parent the parent window
     * @param isModal true if its modal, false if not.
     * @return a dialog
     */
    public static JDialog createDialog(Window parent, String title, boolean isModal) {
        if (parent instanceof JDialog) {
            return new JDialog((JDialog) parent, title, isModal);
        } else if (parent instanceof JFrame) {
            return new JDialog((JFrame) parent, title, isModal);
        }
        throw new RuntimeException("Unknown window type!");
    }

    /**
     * This uses reflection to set the tab component if we're running under 1.6. It does nothing if you're running under 1.5. This is so you can run this on java 1.6 and get this benefit, but its not
     * required to compile.
     *
     * This is the same as calling JTabbedPane.setTabComponentAt(). It just does so using reflection.
     */
    public static void setTabComponent15Compatible(JTabbedPane tabbedPane, int index, Component component) {
        try {
            Method method = tabbedPane.getClass().getMethod("setTabComponentAt", new Class[] { Integer.TYPE, Component.class });
            method.invoke(tabbedPane, index, component);
        } catch (NoSuchMethodException e) {
        // e.printStackTrace();
        // we're not requiring 1.6, so its not a problem if we don't find the method. We just don't get this feature.
        } catch (Exception e) {
            LOGGER.error("Setting tab component", e);
        }
    }

    /**
     * This creates a button with the specified action, image, and tooltip text. The main issue here is that it doesn't crash if the image is missing (which is just something that happens in real life
     * from time to time). You probably should specify a name on the action just in case.
     *
     * @param resourceClass the calling class. Useful when multiple classloaders are used.
     * @param imageResourceName the image resource
     * @param tooltip the tooltip to display
     * @param action the action to perform
     * @return the button that was created.
     */
    public static JButton createButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JButton button = null;
        if (imageResourceName != null) {
            InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
            if (inputStream != null) {
                try {
                    BufferedImage image = ImageIO.read(inputStream);
                    button = new BorderlessImageButton(action, new ImageIcon(image));
                } catch (IOException e) {
                    LOGGER.error("Reading image " + imageResourceName, e);
                }
            }
        }
        if (button == null) {
            button = new JButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JToggleButton createToggleButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JToggleButton button = null;
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            if (icon != null) {
                button = new BorderlessImageToggleButton(action, icon);
            }
        }
        if (button == null) {
            button = new JToggleButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JMenuItem createMenuItem(Class resourceClass, String name, String imageResourceName, Action action) {
        JMenuItem item = new JMenuItem(action);
        item.setText(name);
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            item.setIcon(icon);
        }
        return item;
    }

    /**
     * this determines if the CTRL key is down based on the modifiers from an event. This actualy needs to be checking for different things. CTRL doesn't meant the same thing on each platform.
     */
    public static boolean isCTRLDown(int eventModifiersEx) {
        return (eventModifiersEx & InputEvent.CTRL_DOWN_MASK) == InputEvent.CTRL_DOWN_MASK;
    }

    public static ImageIcon getImageIcon(Class resourceClass, String imageResourceName) {
        InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
        if (inputStream != null) {
            try {
                BufferedImage image = ImageIO.read(inputStream);
                return new ImageIcon(image);
            } catch (IOException e) {
                LOGGER.error("Reading image " + imageResourceName, e);
            }
        }
        return null;
    }

    /**
     * Scrolls the specified text component so the text between the starting and ending index are visible.
     */
    public static void scrollToText(JTextComponent textComponent, int startingIndex, int endingIndex) {
        try {
            Rectangle startingRectangle = textComponent.modelToView(startingIndex);
            Rectangle endDingRectangle = textComponent.modelToView(endingIndex);
            Rectangle totalBounds = startingRectangle.union(endDingRectangle);
            textComponent.scrollRectToVisible(totalBounds);
            textComponent.repaint();
        } catch (BadLocationException e) {
            e.printStackTrace();
        }
    }
}}'} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/tabs/SetupTab.java
Cannot solve method call panel.add(createSideBySideComponent(currentDirectoryTextField, browseButton)) java.lang.RuntimeException: Method 'createSideBySideComponent' cannot be resolved in context createSideBySideComponent(currentDirectoryTextField, browseButton) (line: 150) MethodCallExprContext{wrapped=createSideBySideComponent(currentDirectoryTextField, browseButton)}. Parameter types: [ReferenceType{javax.swing.JTextField, typeParametersMap=TypeParametersMap{nameToValue={}}}, ReferenceType{javax.swing.JButton, typeParametersMap=TypeParametersMap{nameToValue={}}}] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/tabs/SetupTab.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call panel.add(Utility.addLeftJustifiedComponent(new JLabel("Log Level"))) UnsolvedSymbolException{context='Method 'addLeftJustifiedComponent' with parameterTypes [ReferenceType{javax.swing.JLabel, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * Just some utility functions.
 */
public class Utility {

    private static final Logger LOGGER = Logging.getLogger(Utility.class);

    public static Component addLeftJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(component);
        panel.add(Box.createHorizontalGlue());
        return panel;
    }

    public static Component addRightJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(Box.createHorizontalGlue());
        panel.add(component);
        return panel;
    }

    /**
     * This creates a dialog. I only created this because I was using JDK 1.6, then realized I needed to use 1.5 and one of the most useful features of 1.6 is dialogs taking Windows as parents. This
     * abstracts that so I don't have to make major changes to the code by passing around JFrames and JDialogs explicitly.
     *
     * @param parent the parent window
     * @param isModal true if its modal, false if not.
     * @return a dialog
     */
    public static JDialog createDialog(Window parent, String title, boolean isModal) {
        if (parent instanceof JDialog) {
            return new JDialog((JDialog) parent, title, isModal);
        } else if (parent instanceof JFrame) {
            return new JDialog((JFrame) parent, title, isModal);
        }
        throw new RuntimeException("Unknown window type!");
    }

    /**
     * This uses reflection to set the tab component if we're running under 1.6. It does nothing if you're running under 1.5. This is so you can run this on java 1.6 and get this benefit, but its not
     * required to compile.
     *
     * This is the same as calling JTabbedPane.setTabComponentAt(). It just does so using reflection.
     */
    public static void setTabComponent15Compatible(JTabbedPane tabbedPane, int index, Component component) {
        try {
            Method method = tabbedPane.getClass().getMethod("setTabComponentAt", new Class[] { Integer.TYPE, Component.class });
            method.invoke(tabbedPane, index, component);
        } catch (NoSuchMethodException e) {
        // e.printStackTrace();
        // we're not requiring 1.6, so its not a problem if we don't find the method. We just don't get this feature.
        } catch (Exception e) {
            LOGGER.error("Setting tab component", e);
        }
    }

    /**
     * This creates a button with the specified action, image, and tooltip text. The main issue here is that it doesn't crash if the image is missing (which is just something that happens in real life
     * from time to time). You probably should specify a name on the action just in case.
     *
     * @param resourceClass the calling class. Useful when multiple classloaders are used.
     * @param imageResourceName the image resource
     * @param tooltip the tooltip to display
     * @param action the action to perform
     * @return the button that was created.
     */
    public static JButton createButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JButton button = null;
        if (imageResourceName != null) {
            InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
            if (inputStream != null) {
                try {
                    BufferedImage image = ImageIO.read(inputStream);
                    button = new BorderlessImageButton(action, new ImageIcon(image));
                } catch (IOException e) {
                    LOGGER.error("Reading image " + imageResourceName, e);
                }
            }
        }
        if (button == null) {
            button = new JButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JToggleButton createToggleButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JToggleButton button = null;
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            if (icon != null) {
                button = new BorderlessImageToggleButton(action, icon);
            }
        }
        if (button == null) {
            button = new JToggleButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JMenuItem createMenuItem(Class resourceClass, String name, String imageResourceName, Action action) {
        JMenuItem item = new JMenuItem(action);
        item.setText(name);
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            item.setIcon(icon);
        }
        return item;
    }

    /**
     * this determines if the CTRL key is down based on the modifiers from an event. This actualy needs to be checking for different things. CTRL doesn't meant the same thing on each platform.
     */
    public static boolean isCTRLDown(int eventModifiersEx) {
        return (eventModifiersEx & InputEvent.CTRL_DOWN_MASK) == InputEvent.CTRL_DOWN_MASK;
    }

    public static ImageIcon getImageIcon(Class resourceClass, String imageResourceName) {
        InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
        if (inputStream != null) {
            try {
                BufferedImage image = ImageIO.read(inputStream);
                return new ImageIcon(image);
            } catch (IOException e) {
                LOGGER.error("Reading image " + imageResourceName, e);
            }
        }
        return null;
    }

    /**
     * Scrolls the specified text component so the text between the starting and ending index are visible.
     */
    public static void scrollToText(JTextComponent textComponent, int startingIndex, int endingIndex) {
        try {
            Rectangle startingRectangle = textComponent.modelToView(startingIndex);
            Rectangle endDingRectangle = textComponent.modelToView(endingIndex);
            Rectangle totalBounds = startingRectangle.union(endDingRectangle);
            textComponent.scrollRectToVisible(totalBounds);
            textComponent.repaint();
        } catch (BadLocationException e) {
            e.printStackTrace();
        }
    }
}}'} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/tabs/SetupTab.java
Cannot solve method call panel.add(Utility.addLeftJustifiedComponent(logLevelComboBox)) UnsolvedSymbolException{context='Method 'addLeftJustifiedComponent' with parameterTypes [ReferenceType{javax.swing.JComboBox, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * Just some utility functions.
 */
public class Utility {

    private static final Logger LOGGER = Logging.getLogger(Utility.class);

    public static Component addLeftJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(component);
        panel.add(Box.createHorizontalGlue());
        return panel;
    }

    public static Component addRightJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(Box.createHorizontalGlue());
        panel.add(component);
        return panel;
    }

    /**
     * This creates a dialog. I only created this because I was using JDK 1.6, then realized I needed to use 1.5 and one of the most useful features of 1.6 is dialogs taking Windows as parents. This
     * abstracts that so I don't have to make major changes to the code by passing around JFrames and JDialogs explicitly.
     *
     * @param parent the parent window
     * @param isModal true if its modal, false if not.
     * @return a dialog
     */
    public static JDialog createDialog(Window parent, String title, boolean isModal) {
        if (parent instanceof JDialog) {
            return new JDialog((JDialog) parent, title, isModal);
        } else if (parent instanceof JFrame) {
            return new JDialog((JFrame) parent, title, isModal);
        }
        throw new RuntimeException("Unknown window type!");
    }

    /**
     * This uses reflection to set the tab component if we're running under 1.6. It does nothing if you're running under 1.5. This is so you can run this on java 1.6 and get this benefit, but its not
     * required to compile.
     *
     * This is the same as calling JTabbedPane.setTabComponentAt(). It just does so using reflection.
     */
    public static void setTabComponent15Compatible(JTabbedPane tabbedPane, int index, Component component) {
        try {
            Method method = tabbedPane.getClass().getMethod("setTabComponentAt", new Class[] { Integer.TYPE, Component.class });
            method.invoke(tabbedPane, index, component);
        } catch (NoSuchMethodException e) {
        // e.printStackTrace();
        // we're not requiring 1.6, so its not a problem if we don't find the method. We just don't get this feature.
        } catch (Exception e) {
            LOGGER.error("Setting tab component", e);
        }
    }

    /**
     * This creates a button with the specified action, image, and tooltip text. The main issue here is that it doesn't crash if the image is missing (which is just something that happens in real life
     * from time to time). You probably should specify a name on the action just in case.
     *
     * @param resourceClass the calling class. Useful when multiple classloaders are used.
     * @param imageResourceName the image resource
     * @param tooltip the tooltip to display
     * @param action the action to perform
     * @return the button that was created.
     */
    public static JButton createButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JButton button = null;
        if (imageResourceName != null) {
            InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
            if (inputStream != null) {
                try {
                    BufferedImage image = ImageIO.read(inputStream);
                    button = new BorderlessImageButton(action, new ImageIcon(image));
                } catch (IOException e) {
                    LOGGER.error("Reading image " + imageResourceName, e);
                }
            }
        }
        if (button == null) {
            button = new JButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JToggleButton createToggleButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JToggleButton button = null;
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            if (icon != null) {
                button = new BorderlessImageToggleButton(action, icon);
            }
        }
        if (button == null) {
            button = new JToggleButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JMenuItem createMenuItem(Class resourceClass, String name, String imageResourceName, Action action) {
        JMenuItem item = new JMenuItem(action);
        item.setText(name);
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            item.setIcon(icon);
        }
        return item;
    }

    /**
     * this determines if the CTRL key is down based on the modifiers from an event. This actualy needs to be checking for different things. CTRL doesn't meant the same thing on each platform.
     */
    public static boolean isCTRLDown(int eventModifiersEx) {
        return (eventModifiersEx & InputEvent.CTRL_DOWN_MASK) == InputEvent.CTRL_DOWN_MASK;
    }

    public static ImageIcon getImageIcon(Class resourceClass, String imageResourceName) {
        InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
        if (inputStream != null) {
            try {
                BufferedImage image = ImageIO.read(inputStream);
                return new ImageIcon(image);
            } catch (IOException e) {
                LOGGER.error("Reading image " + imageResourceName, e);
            }
        }
        return null;
    }

    /**
     * Scrolls the specified text component so the text between the starting and ending index are visible.
     */
    public static void scrollToText(JTextComponent textComponent, int startingIndex, int endingIndex) {
        try {
            Rectangle startingRectangle = textComponent.modelToView(startingIndex);
            Rectangle endDingRectangle = textComponent.modelToView(endingIndex);
            Rectangle totalBounds = startingRectangle.union(endDingRectangle);
            textComponent.scrollRectToVisible(totalBounds);
            textComponent.repaint();
        } catch (BadLocationException e) {
            e.printStackTrace();
        }
    }
}}'} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/tabs/SetupTab.java
Cannot solve method call Character.toUpperCase(temp.charAt(0)) java.lang.RuntimeException: Method 'charAt' cannot be resolved in context temp.charAt(0) (line: 285) MethodCallExprContext{wrapped=temp.charAt(0)}. Parameter types: [PrimitiveTypeUsage{name='int'}] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/tabs/SetupTab.java
Cannot solve field access ShowStacktrace.INTERNAL_EXCEPTIONS
Cannot solve field access ShowStacktrace.ALWAYS
Cannot solve field access ShowStacktrace.ALWAYS_FULL
Cannot solve method call panel.add(Utility.addLeftJustifiedComponent(showNoStackTraceRadioButton)) UnsolvedSymbolException{context='Method 'addLeftJustifiedComponent' with parameterTypes [ReferenceType{javax.swing.JRadioButton, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * Just some utility functions.
 */
public class Utility {

    private static final Logger LOGGER = Logging.getLogger(Utility.class);

    public static Component addLeftJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(component);
        panel.add(Box.createHorizontalGlue());
        return panel;
    }

    public static Component addRightJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(Box.createHorizontalGlue());
        panel.add(component);
        return panel;
    }

    /**
     * This creates a dialog. I only created this because I was using JDK 1.6, then realized I needed to use 1.5 and one of the most useful features of 1.6 is dialogs taking Windows as parents. This
     * abstracts that so I don't have to make major changes to the code by passing around JFrames and JDialogs explicitly.
     *
     * @param parent the parent window
     * @param isModal true if its modal, false if not.
     * @return a dialog
     */
    public static JDialog createDialog(Window parent, String title, boolean isModal) {
        if (parent instanceof JDialog) {
            return new JDialog((JDialog) parent, title, isModal);
        } else if (parent instanceof JFrame) {
            return new JDialog((JFrame) parent, title, isModal);
        }
        throw new RuntimeException("Unknown window type!");
    }

    /**
     * This uses reflection to set the tab component if we're running under 1.6. It does nothing if you're running under 1.5. This is so you can run this on java 1.6 and get this benefit, but its not
     * required to compile.
     *
     * This is the same as calling JTabbedPane.setTabComponentAt(). It just does so using reflection.
     */
    public static void setTabComponent15Compatible(JTabbedPane tabbedPane, int index, Component component) {
        try {
            Method method = tabbedPane.getClass().getMethod("setTabComponentAt", new Class[] { Integer.TYPE, Component.class });
            method.invoke(tabbedPane, index, component);
        } catch (NoSuchMethodException e) {
        // e.printStackTrace();
        // we're not requiring 1.6, so its not a problem if we don't find the method. We just don't get this feature.
        } catch (Exception e) {
            LOGGER.error("Setting tab component", e);
        }
    }

    /**
     * This creates a button with the specified action, image, and tooltip text. The main issue here is that it doesn't crash if the image is missing (which is just something that happens in real life
     * from time to time). You probably should specify a name on the action just in case.
     *
     * @param resourceClass the calling class. Useful when multiple classloaders are used.
     * @param imageResourceName the image resource
     * @param tooltip the tooltip to display
     * @param action the action to perform
     * @return the button that was created.
     */
    public static JButton createButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JButton button = null;
        if (imageResourceName != null) {
            InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
            if (inputStream != null) {
                try {
                    BufferedImage image = ImageIO.read(inputStream);
                    button = new BorderlessImageButton(action, new ImageIcon(image));
                } catch (IOException e) {
                    LOGGER.error("Reading image " + imageResourceName, e);
                }
            }
        }
        if (button == null) {
            button = new JButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JToggleButton createToggleButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JToggleButton button = null;
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            if (icon != null) {
                button = new BorderlessImageToggleButton(action, icon);
            }
        }
        if (button == null) {
            button = new JToggleButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JMenuItem createMenuItem(Class resourceClass, String name, String imageResourceName, Action action) {
        JMenuItem item = new JMenuItem(action);
        item.setText(name);
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            item.setIcon(icon);
        }
        return item;
    }

    /**
     * this determines if the CTRL key is down based on the modifiers from an event. This actualy needs to be checking for different things. CTRL doesn't meant the same thing on each platform.
     */
    public static boolean isCTRLDown(int eventModifiersEx) {
        return (eventModifiersEx & InputEvent.CTRL_DOWN_MASK) == InputEvent.CTRL_DOWN_MASK;
    }

    public static ImageIcon getImageIcon(Class resourceClass, String imageResourceName) {
        InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
        if (inputStream != null) {
            try {
                BufferedImage image = ImageIO.read(inputStream);
                return new ImageIcon(image);
            } catch (IOException e) {
                LOGGER.error("Reading image " + imageResourceName, e);
            }
        }
        return null;
    }

    /**
     * Scrolls the specified text component so the text between the starting and ending index are visible.
     */
    public static void scrollToText(JTextComponent textComponent, int startingIndex, int endingIndex) {
        try {
            Rectangle startingRectangle = textComponent.modelToView(startingIndex);
            Rectangle endDingRectangle = textComponent.modelToView(endingIndex);
            Rectangle totalBounds = startingRectangle.union(endDingRectangle);
            textComponent.scrollRectToVisible(totalBounds);
            textComponent.repaint();
        } catch (BadLocationException e) {
            e.printStackTrace();
        }
    }
}}'} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/tabs/SetupTab.java
Cannot solve method call panel.add(Utility.addLeftJustifiedComponent(showStackTrackRadioButton)) UnsolvedSymbolException{context='Method 'addLeftJustifiedComponent' with parameterTypes [ReferenceType{javax.swing.JRadioButton, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * Just some utility functions.
 */
public class Utility {

    private static final Logger LOGGER = Logging.getLogger(Utility.class);

    public static Component addLeftJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(component);
        panel.add(Box.createHorizontalGlue());
        return panel;
    }

    public static Component addRightJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(Box.createHorizontalGlue());
        panel.add(component);
        return panel;
    }

    /**
     * This creates a dialog. I only created this because I was using JDK 1.6, then realized I needed to use 1.5 and one of the most useful features of 1.6 is dialogs taking Windows as parents. This
     * abstracts that so I don't have to make major changes to the code by passing around JFrames and JDialogs explicitly.
     *
     * @param parent the parent window
     * @param isModal true if its modal, false if not.
     * @return a dialog
     */
    public static JDialog createDialog(Window parent, String title, boolean isModal) {
        if (parent instanceof JDialog) {
            return new JDialog((JDialog) parent, title, isModal);
        } else if (parent instanceof JFrame) {
            return new JDialog((JFrame) parent, title, isModal);
        }
        throw new RuntimeException("Unknown window type!");
    }

    /**
     * This uses reflection to set the tab component if we're running under 1.6. It does nothing if you're running under 1.5. This is so you can run this on java 1.6 and get this benefit, but its not
     * required to compile.
     *
     * This is the same as calling JTabbedPane.setTabComponentAt(). It just does so using reflection.
     */
    public static void setTabComponent15Compatible(JTabbedPane tabbedPane, int index, Component component) {
        try {
            Method method = tabbedPane.getClass().getMethod("setTabComponentAt", new Class[] { Integer.TYPE, Component.class });
            method.invoke(tabbedPane, index, component);
        } catch (NoSuchMethodException e) {
        // e.printStackTrace();
        // we're not requiring 1.6, so its not a problem if we don't find the method. We just don't get this feature.
        } catch (Exception e) {
            LOGGER.error("Setting tab component", e);
        }
    }

    /**
     * This creates a button with the specified action, image, and tooltip text. The main issue here is that it doesn't crash if the image is missing (which is just something that happens in real life
     * from time to time). You probably should specify a name on the action just in case.
     *
     * @param resourceClass the calling class. Useful when multiple classloaders are used.
     * @param imageResourceName the image resource
     * @param tooltip the tooltip to display
     * @param action the action to perform
     * @return the button that was created.
     */
    public static JButton createButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JButton button = null;
        if (imageResourceName != null) {
            InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
            if (inputStream != null) {
                try {
                    BufferedImage image = ImageIO.read(inputStream);
                    button = new BorderlessImageButton(action, new ImageIcon(image));
                } catch (IOException e) {
                    LOGGER.error("Reading image " + imageResourceName, e);
                }
            }
        }
        if (button == null) {
            button = new JButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JToggleButton createToggleButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JToggleButton button = null;
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            if (icon != null) {
                button = new BorderlessImageToggleButton(action, icon);
            }
        }
        if (button == null) {
            button = new JToggleButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JMenuItem createMenuItem(Class resourceClass, String name, String imageResourceName, Action action) {
        JMenuItem item = new JMenuItem(action);
        item.setText(name);
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            item.setIcon(icon);
        }
        return item;
    }

    /**
     * this determines if the CTRL key is down based on the modifiers from an event. This actualy needs to be checking for different things. CTRL doesn't meant the same thing on each platform.
     */
    public static boolean isCTRLDown(int eventModifiersEx) {
        return (eventModifiersEx & InputEvent.CTRL_DOWN_MASK) == InputEvent.CTRL_DOWN_MASK;
    }

    public static ImageIcon getImageIcon(Class resourceClass, String imageResourceName) {
        InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
        if (inputStream != null) {
            try {
                BufferedImage image = ImageIO.read(inputStream);
                return new ImageIcon(image);
            } catch (IOException e) {
                LOGGER.error("Reading image " + imageResourceName, e);
            }
        }
        return null;
    }

    /**
     * Scrolls the specified text component so the text between the starting and ending index are visible.
     */
    public static void scrollToText(JTextComponent textComponent, int startingIndex, int endingIndex) {
        try {
            Rectangle startingRectangle = textComponent.modelToView(startingIndex);
            Rectangle endDingRectangle = textComponent.modelToView(endingIndex);
            Rectangle totalBounds = startingRectangle.union(endDingRectangle);
            textComponent.scrollRectToVisible(totalBounds);
            textComponent.repaint();
        } catch (BadLocationException e) {
            e.printStackTrace();
        }
    }
}}'} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/tabs/SetupTab.java
Cannot solve method call panel.add(Utility.addLeftJustifiedComponent(showFullStackTrackRadioButton)) UnsolvedSymbolException{context='Method 'addLeftJustifiedComponent' with parameterTypes [ReferenceType{javax.swing.JRadioButton, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * Just some utility functions.
 */
public class Utility {

    private static final Logger LOGGER = Logging.getLogger(Utility.class);

    public static Component addLeftJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(component);
        panel.add(Box.createHorizontalGlue());
        return panel;
    }

    public static Component addRightJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(Box.createHorizontalGlue());
        panel.add(component);
        return panel;
    }

    /**
     * This creates a dialog. I only created this because I was using JDK 1.6, then realized I needed to use 1.5 and one of the most useful features of 1.6 is dialogs taking Windows as parents. This
     * abstracts that so I don't have to make major changes to the code by passing around JFrames and JDialogs explicitly.
     *
     * @param parent the parent window
     * @param isModal true if its modal, false if not.
     * @return a dialog
     */
    public static JDialog createDialog(Window parent, String title, boolean isModal) {
        if (parent instanceof JDialog) {
            return new JDialog((JDialog) parent, title, isModal);
        } else if (parent instanceof JFrame) {
            return new JDialog((JFrame) parent, title, isModal);
        }
        throw new RuntimeException("Unknown window type!");
    }

    /**
     * This uses reflection to set the tab component if we're running under 1.6. It does nothing if you're running under 1.5. This is so you can run this on java 1.6 and get this benefit, but its not
     * required to compile.
     *
     * This is the same as calling JTabbedPane.setTabComponentAt(). It just does so using reflection.
     */
    public static void setTabComponent15Compatible(JTabbedPane tabbedPane, int index, Component component) {
        try {
            Method method = tabbedPane.getClass().getMethod("setTabComponentAt", new Class[] { Integer.TYPE, Component.class });
            method.invoke(tabbedPane, index, component);
        } catch (NoSuchMethodException e) {
        // e.printStackTrace();
        // we're not requiring 1.6, so its not a problem if we don't find the method. We just don't get this feature.
        } catch (Exception e) {
            LOGGER.error("Setting tab component", e);
        }
    }

    /**
     * This creates a button with the specified action, image, and tooltip text. The main issue here is that it doesn't crash if the image is missing (which is just something that happens in real life
     * from time to time). You probably should specify a name on the action just in case.
     *
     * @param resourceClass the calling class. Useful when multiple classloaders are used.
     * @param imageResourceName the image resource
     * @param tooltip the tooltip to display
     * @param action the action to perform
     * @return the button that was created.
     */
    public static JButton createButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JButton button = null;
        if (imageResourceName != null) {
            InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
            if (inputStream != null) {
                try {
                    BufferedImage image = ImageIO.read(inputStream);
                    button = new BorderlessImageButton(action, new ImageIcon(image));
                } catch (IOException e) {
                    LOGGER.error("Reading image " + imageResourceName, e);
                }
            }
        }
        if (button == null) {
            button = new JButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JToggleButton createToggleButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JToggleButton button = null;
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            if (icon != null) {
                button = new BorderlessImageToggleButton(action, icon);
            }
        }
        if (button == null) {
            button = new JToggleButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JMenuItem createMenuItem(Class resourceClass, String name, String imageResourceName, Action action) {
        JMenuItem item = new JMenuItem(action);
        item.setText(name);
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            item.setIcon(icon);
        }
        return item;
    }

    /**
     * this determines if the CTRL key is down based on the modifiers from an event. This actualy needs to be checking for different things. CTRL doesn't meant the same thing on each platform.
     */
    public static boolean isCTRLDown(int eventModifiersEx) {
        return (eventModifiersEx & InputEvent.CTRL_DOWN_MASK) == InputEvent.CTRL_DOWN_MASK;
    }

    public static ImageIcon getImageIcon(Class resourceClass, String imageResourceName) {
        InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
        if (inputStream != null) {
            try {
                BufferedImage image = ImageIO.read(inputStream);
                return new ImageIcon(image);
            } catch (IOException e) {
                LOGGER.error("Reading image " + imageResourceName, e);
            }
        }
        return null;
    }

    /**
     * Scrolls the specified text component so the text between the starting and ending index are visible.
     */
    public static void scrollToText(JTextComponent textComponent, int startingIndex, int endingIndex) {
        try {
            Rectangle startingRectangle = textComponent.modelToView(startingIndex);
            Rectangle endDingRectangle = textComponent.modelToView(endingIndex);
            Rectangle totalBounds = startingRectangle.union(endDingRectangle);
            textComponent.scrollRectToVisible(totalBounds);
            textComponent.repaint();
        } catch (BadLocationException e) {
            e.printStackTrace();
        }
    }
}}'} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/tabs/SetupTab.java
Cannot solve method call setSelectedStackTraceLevel(ShowStacktrace.valueOf(stackTraceLevel)) UnsolvedSymbolException{context='Method 'valueOf' with parameterTypes [ReferenceType{String, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserEnumDeclaration{wrappedNode=/**
 * Specifies the detail to include in stacktraces.
 */
public enum ShowStacktrace {

    INTERNAL_EXCEPTIONS, ALWAYS, ALWAYS_FULL
}}'} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/tabs/SetupTab.java
Cannot solve field access ShowStacktrace.INTERNAL_EXCEPTIONS
Cannot solve method call panel.add(Utility.addLeftJustifiedComponent(onlyShowOutputOnErrorCheckBox)) UnsolvedSymbolException{context='Method 'addLeftJustifiedComponent' with parameterTypes [ReferenceType{javax.swing.JCheckBox, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * Just some utility functions.
 */
public class Utility {

    private static final Logger LOGGER = Logging.getLogger(Utility.class);

    public static Component addLeftJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(component);
        panel.add(Box.createHorizontalGlue());
        return panel;
    }

    public static Component addRightJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(Box.createHorizontalGlue());
        panel.add(component);
        return panel;
    }

    /**
     * This creates a dialog. I only created this because I was using JDK 1.6, then realized I needed to use 1.5 and one of the most useful features of 1.6 is dialogs taking Windows as parents. This
     * abstracts that so I don't have to make major changes to the code by passing around JFrames and JDialogs explicitly.
     *
     * @param parent the parent window
     * @param isModal true if its modal, false if not.
     * @return a dialog
     */
    public static JDialog createDialog(Window parent, String title, boolean isModal) {
        if (parent instanceof JDialog) {
            return new JDialog((JDialog) parent, title, isModal);
        } else if (parent instanceof JFrame) {
            return new JDialog((JFrame) parent, title, isModal);
        }
        throw new RuntimeException("Unknown window type!");
    }

    /**
     * This uses reflection to set the tab component if we're running under 1.6. It does nothing if you're running under 1.5. This is so you can run this on java 1.6 and get this benefit, but its not
     * required to compile.
     *
     * This is the same as calling JTabbedPane.setTabComponentAt(). It just does so using reflection.
     */
    public static void setTabComponent15Compatible(JTabbedPane tabbedPane, int index, Component component) {
        try {
            Method method = tabbedPane.getClass().getMethod("setTabComponentAt", new Class[] { Integer.TYPE, Component.class });
            method.invoke(tabbedPane, index, component);
        } catch (NoSuchMethodException e) {
        // e.printStackTrace();
        // we're not requiring 1.6, so its not a problem if we don't find the method. We just don't get this feature.
        } catch (Exception e) {
            LOGGER.error("Setting tab component", e);
        }
    }

    /**
     * This creates a button with the specified action, image, and tooltip text. The main issue here is that it doesn't crash if the image is missing (which is just something that happens in real life
     * from time to time). You probably should specify a name on the action just in case.
     *
     * @param resourceClass the calling class. Useful when multiple classloaders are used.
     * @param imageResourceName the image resource
     * @param tooltip the tooltip to display
     * @param action the action to perform
     * @return the button that was created.
     */
    public static JButton createButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JButton button = null;
        if (imageResourceName != null) {
            InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
            if (inputStream != null) {
                try {
                    BufferedImage image = ImageIO.read(inputStream);
                    button = new BorderlessImageButton(action, new ImageIcon(image));
                } catch (IOException e) {
                    LOGGER.error("Reading image " + imageResourceName, e);
                }
            }
        }
        if (button == null) {
            button = new JButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JToggleButton createToggleButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JToggleButton button = null;
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            if (icon != null) {
                button = new BorderlessImageToggleButton(action, icon);
            }
        }
        if (button == null) {
            button = new JToggleButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JMenuItem createMenuItem(Class resourceClass, String name, String imageResourceName, Action action) {
        JMenuItem item = new JMenuItem(action);
        item.setText(name);
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            item.setIcon(icon);
        }
        return item;
    }

    /**
     * this determines if the CTRL key is down based on the modifiers from an event. This actualy needs to be checking for different things. CTRL doesn't meant the same thing on each platform.
     */
    public static boolean isCTRLDown(int eventModifiersEx) {
        return (eventModifiersEx & InputEvent.CTRL_DOWN_MASK) == InputEvent.CTRL_DOWN_MASK;
    }

    public static ImageIcon getImageIcon(Class resourceClass, String imageResourceName) {
        InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
        if (inputStream != null) {
            try {
                BufferedImage image = ImageIO.read(inputStream);
                return new ImageIcon(image);
            } catch (IOException e) {
                LOGGER.error("Reading image " + imageResourceName, e);
            }
        }
        return null;
    }

    /**
     * Scrolls the specified text component so the text between the starting and ending index are visible.
     */
    public static void scrollToText(JTextComponent textComponent, int startingIndex, int endingIndex) {
        try {
            Rectangle startingRectangle = textComponent.modelToView(startingIndex);
            Rectangle endDingRectangle = textComponent.modelToView(endingIndex);
            Rectangle totalBounds = startingRectangle.union(endDingRectangle);
            textComponent.scrollRectToVisible(totalBounds);
            textComponent.repaint();
        } catch (BadLocationException e) {
            e.printStackTrace();
        }
    }
}}'} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/tabs/SetupTab.java
Cannot solve method call panel.add(Utility.addLeftJustifiedComponent(useCustomGradleExecutorCheckBox)) UnsolvedSymbolException{context='Method 'addLeftJustifiedComponent' with parameterTypes [ReferenceType{javax.swing.JCheckBox, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * Just some utility functions.
 */
public class Utility {

    private static final Logger LOGGER = Logging.getLogger(Utility.class);

    public static Component addLeftJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(component);
        panel.add(Box.createHorizontalGlue());
        return panel;
    }

    public static Component addRightJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(Box.createHorizontalGlue());
        panel.add(component);
        return panel;
    }

    /**
     * This creates a dialog. I only created this because I was using JDK 1.6, then realized I needed to use 1.5 and one of the most useful features of 1.6 is dialogs taking Windows as parents. This
     * abstracts that so I don't have to make major changes to the code by passing around JFrames and JDialogs explicitly.
     *
     * @param parent the parent window
     * @param isModal true if its modal, false if not.
     * @return a dialog
     */
    public static JDialog createDialog(Window parent, String title, boolean isModal) {
        if (parent instanceof JDialog) {
            return new JDialog((JDialog) parent, title, isModal);
        } else if (parent instanceof JFrame) {
            return new JDialog((JFrame) parent, title, isModal);
        }
        throw new RuntimeException("Unknown window type!");
    }

    /**
     * This uses reflection to set the tab component if we're running under 1.6. It does nothing if you're running under 1.5. This is so you can run this on java 1.6 and get this benefit, but its not
     * required to compile.
     *
     * This is the same as calling JTabbedPane.setTabComponentAt(). It just does so using reflection.
     */
    public static void setTabComponent15Compatible(JTabbedPane tabbedPane, int index, Component component) {
        try {
            Method method = tabbedPane.getClass().getMethod("setTabComponentAt", new Class[] { Integer.TYPE, Component.class });
            method.invoke(tabbedPane, index, component);
        } catch (NoSuchMethodException e) {
        // e.printStackTrace();
        // we're not requiring 1.6, so its not a problem if we don't find the method. We just don't get this feature.
        } catch (Exception e) {
            LOGGER.error("Setting tab component", e);
        }
    }

    /**
     * This creates a button with the specified action, image, and tooltip text. The main issue here is that it doesn't crash if the image is missing (which is just something that happens in real life
     * from time to time). You probably should specify a name on the action just in case.
     *
     * @param resourceClass the calling class. Useful when multiple classloaders are used.
     * @param imageResourceName the image resource
     * @param tooltip the tooltip to display
     * @param action the action to perform
     * @return the button that was created.
     */
    public static JButton createButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JButton button = null;
        if (imageResourceName != null) {
            InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
            if (inputStream != null) {
                try {
                    BufferedImage image = ImageIO.read(inputStream);
                    button = new BorderlessImageButton(action, new ImageIcon(image));
                } catch (IOException e) {
                    LOGGER.error("Reading image " + imageResourceName, e);
                }
            }
        }
        if (button == null) {
            button = new JButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JToggleButton createToggleButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JToggleButton button = null;
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            if (icon != null) {
                button = new BorderlessImageToggleButton(action, icon);
            }
        }
        if (button == null) {
            button = new JToggleButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JMenuItem createMenuItem(Class resourceClass, String name, String imageResourceName, Action action) {
        JMenuItem item = new JMenuItem(action);
        item.setText(name);
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            item.setIcon(icon);
        }
        return item;
    }

    /**
     * this determines if the CTRL key is down based on the modifiers from an event. This actualy needs to be checking for different things. CTRL doesn't meant the same thing on each platform.
     */
    public static boolean isCTRLDown(int eventModifiersEx) {
        return (eventModifiersEx & InputEvent.CTRL_DOWN_MASK) == InputEvent.CTRL_DOWN_MASK;
    }

    public static ImageIcon getImageIcon(Class resourceClass, String imageResourceName) {
        InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
        if (inputStream != null) {
            try {
                BufferedImage image = ImageIO.read(inputStream);
                return new ImageIcon(image);
            } catch (IOException e) {
                LOGGER.error("Reading image " + imageResourceName, e);
            }
        }
        return null;
    }

    /**
     * Scrolls the specified text component so the text between the starting and ending index are visible.
     */
    public static void scrollToText(JTextComponent textComponent, int startingIndex, int endingIndex) {
        try {
            Rectangle startingRectangle = textComponent.modelToView(startingIndex);
            Rectangle endDingRectangle = textComponent.modelToView(endingIndex);
            Rectangle totalBounds = startingRectangle.union(endDingRectangle);
            textComponent.scrollRectToVisible(totalBounds);
            textComponent.repaint();
        } catch (BadLocationException e) {
            e.printStackTrace();
        }
    }
}}'} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/tabs/SetupTab.java
Cannot resolve field access null
Cannot solve method call customPanelPlaceHolder.add(component, BorderLayout.CENTER) UnsolvedSymbolException{context='unknown', name='CENTER', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/tabs/SetupTab.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call mainPanel.add(tabbedPane, BorderLayout.CENTER) UnsolvedSymbolException{context='unknown', name='CENTER', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanelLord.java
Cannot resolve field access null
Cannot solve method call popupMenu.show(tabbedPane, point.x, e.getPoint().y) UnsolvedSymbolException{context='unknown', name='x', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanelLord.java
Cannot solve method call Utility.setTabComponent15Compatible(tabbedPane, tabbedPane.getTabCount() - 1, outputPanel.getTabHeader()) java.lang.RuntimeException: Method 'getTabHeader' cannot be resolved in context outputPanel.getTabHeader() (line: 183) MethodCallExprContext{wrapped=outputPanel.getTabHeader()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanelLord.java
Cannot solve method call observer.outputTabClosed(outputPanel.getRequest()) java.lang.RuntimeException: Method 'getRequest' cannot be resolved in context outputPanel.getRequest() (line: 337) MethodCallExprContext{wrapped=outputPanel.getRequest()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanelLord.java
Cannot solve method call setupUI() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call setOnlyShowOutputOnErrors(onlyShowOutputOnErrors) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call setOnlyShowOutputOnErrors(false) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call enableAddToFavoritesAppropriately() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call setPending(true) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call showProgress(true) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call getPrefixText() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call appendGradleOutput(getPrefixText()) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call setLayout(new BorderLayout()) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call createSideOptionsPanel() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot resolve field access null
Cannot solve method call add(createSideOptionsPanel(), BorderLayout.WEST) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot resolve field access null
Cannot solve method call add(centerPanel, BorderLayout.CENTER) UnsolvedSymbolException{context='unknown', name='CENTER', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call createGradleOutputPanel() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot resolve field access null
Cannot solve method call centerPanel.add(createGradleOutputPanel(), BorderLayout.CENTER) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call createInfoPanel() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot resolve field access null
Cannot solve method call centerPanel.add(createInfoPanel(), BorderLayout.NORTH) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call createSearchPanel() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot resolve field access null
Cannot solve method call centerPanel.add(createSearchPanel(), BorderLayout.SOUTH) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call getFont() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot resolve field access null
Cannot solve method call gradleOutputTextPanel.add(gradleOutputTextPane.asComponent(), BorderLayout.CENTER) java.lang.RuntimeException: Method 'asComponent' cannot be resolved in context gradleOutputTextPane.asComponent() (line: 200) MethodCallExprContext{wrapped=gradleOutputTextPane.asComponent()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call createStatusPanel() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call panel.add(createStatusPanel()) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call createProgressPanel() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call panel.add(createProgressPanel()) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot resolve field access null
Cannot solve method call progressPanel.add(progressBar, BorderLayout.NORTH) UnsolvedSymbolException{context='unknown', name='NORTH', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot resolve field access null
Cannot solve method call progressPanel.add(progressLabel, BorderLayout.SOUTH) UnsolvedSymbolException{context='unknown', name='SOUTH', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call forciblyShowOutput() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call stop() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call setPinned(!isPinned) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call addToFavorites() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call createLinkNavigationOptions() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call panel.add(createLinkNavigationOptions()) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call getClass() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call goToNextLink() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call Utility.createButton(getClass(), "/org/gradle/gradleplugin/userinterface/swing/generic/next-link.png", "Go to the next link", new AbstractAction() {

    public void actionPerformed(ActionEvent e) {
        goToNextLink();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call getClass() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call goToPreviousLink() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call Utility.createButton(getClass(), "/org/gradle/gradleplugin/userinterface/swing/generic/previous-link.png", "Go to the previous link", new AbstractAction() {

    public void actionPerformed(ActionEvent e) {
        goToPreviousLink();
    }
}) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Method 'getDefaultStyle' cannot be resolved in context gradleOutputTextPane.getDefaultStyle() (line: 354) MethodCallExprContext{wrapped=gradleOutputTextPane.getDefaultStyle()}. Parameter types: []
Cannot resolve field access null
Cannot solve method call styleContent.addAttribute(highlightStyle, StyleConstants.Foreground, Color.white) UnsolvedSymbolException{context='unknown', name='white', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot resolve field access null
Cannot solve method call styleContent.addAttribute(highlightStyle, StyleConstants.Background, Color.orange) UnsolvedSymbolException{context='unknown', name='orange', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot resolve field access null
Cannot solve method call styleContent.addAttribute(emphasizedHighlightStyle, StyleConstants.Foreground, Color.black) UnsolvedSymbolException{context='unknown', name='black', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot resolve field access null
Cannot solve method call styleContent.addAttribute(emphasizedHighlightStyle, StyleConstants.Background, Color.yellow) UnsolvedSymbolException{context='unknown', name='yellow', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call updateLinkNavigationOptions() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call setPending(false) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call setBusy(true) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call setProgress("Starting", 0) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call setPending(false) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call setBusy(false) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call getPrefixText() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot resolve field access null
Cannot solve method call statusLabel.setForeground(Color.red.darker()) UnsolvedSymbolException{context='unknown', name='red', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call appendGradleOutput("\nCompleted Successfully") java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call appendThrowable(throwable) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call updateLinkNavigationOptions() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve field access ShowStacktrace.ALWAYS_FULL
Cannot solve method call appendGradleOutput(output) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call setProgress(currentTaskName, percentComplete) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call setProgress(currentTaskName, percentComplete) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call appendGradleOutput('\n' + message + "\n\nFailed.\n") java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call appendGradleOutput(output) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call stop() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call setPinned(false) java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot resolve field access null
Cannot solve method call enableAddToFavoritesAppropriately() java.lang.IllegalArgumentException: expected either zero type arguments or has many as defined in the declaration (0). Found 1 /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputPanel.java
Cannot solve method call dialog.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE) UnsolvedSymbolException{context='unknown', name='DO_NOTHING_ON_CLOSE', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/SwingAddMultipleFavoritesInteraction.java
Cannot resolve field access null
Cannot solve field access FavoritesEditor.AddMultipleResult.Cancel
Cannot resolve field access null
Cannot solve method call panel.add(createMainPanel(), BorderLayout.CENTER) UnsolvedSymbolException{context='unknown', name='CENTER', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/SwingAddMultipleFavoritesInteraction.java
Cannot resolve field access null
Cannot solve method call panel.add(createButtonPanel(), BorderLayout.SOUTH) UnsolvedSymbolException{context='unknown', name='SOUTH', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/SwingAddMultipleFavoritesInteraction.java
Cannot solve method call panel.add(Utility.addLeftJustifiedComponent(new JLabel("How you do want to add multiple tasks?"))) UnsolvedSymbolException{context='Method 'addLeftJustifiedComponent' with parameterTypes [ReferenceType{javax.swing.JLabel, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * Just some utility functions.
 */
public class Utility {

    private static final Logger LOGGER = Logging.getLogger(Utility.class);

    public static Component addLeftJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(component);
        panel.add(Box.createHorizontalGlue());
        return panel;
    }

    public static Component addRightJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(Box.createHorizontalGlue());
        panel.add(component);
        return panel;
    }

    /**
     * This creates a dialog. I only created this because I was using JDK 1.6, then realized I needed to use 1.5 and one of the most useful features of 1.6 is dialogs taking Windows as parents. This
     * abstracts that so I don't have to make major changes to the code by passing around JFrames and JDialogs explicitly.
     *
     * @param parent the parent window
     * @param isModal true if its modal, false if not.
     * @return a dialog
     */
    public static JDialog createDialog(Window parent, String title, boolean isModal) {
        if (parent instanceof JDialog) {
            return new JDialog((JDialog) parent, title, isModal);
        } else if (parent instanceof JFrame) {
            return new JDialog((JFrame) parent, title, isModal);
        }
        throw new RuntimeException("Unknown window type!");
    }

    /**
     * This uses reflection to set the tab component if we're running under 1.6. It does nothing if you're running under 1.5. This is so you can run this on java 1.6 and get this benefit, but its not
     * required to compile.
     *
     * This is the same as calling JTabbedPane.setTabComponentAt(). It just does so using reflection.
     */
    public static void setTabComponent15Compatible(JTabbedPane tabbedPane, int index, Component component) {
        try {
            Method method = tabbedPane.getClass().getMethod("setTabComponentAt", new Class[] { Integer.TYPE, Component.class });
            method.invoke(tabbedPane, index, component);
        } catch (NoSuchMethodException e) {
        // e.printStackTrace();
        // we're not requiring 1.6, so its not a problem if we don't find the method. We just don't get this feature.
        } catch (Exception e) {
            LOGGER.error("Setting tab component", e);
        }
    }

    /**
     * This creates a button with the specified action, image, and tooltip text. The main issue here is that it doesn't crash if the image is missing (which is just something that happens in real life
     * from time to time). You probably should specify a name on the action just in case.
     *
     * @param resourceClass the calling class. Useful when multiple classloaders are used.
     * @param imageResourceName the image resource
     * @param tooltip the tooltip to display
     * @param action the action to perform
     * @return the button that was created.
     */
    public static JButton createButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JButton button = null;
        if (imageResourceName != null) {
            InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
            if (inputStream != null) {
                try {
                    BufferedImage image = ImageIO.read(inputStream);
                    button = new BorderlessImageButton(action, new ImageIcon(image));
                } catch (IOException e) {
                    LOGGER.error("Reading image " + imageResourceName, e);
                }
            }
        }
        if (button == null) {
            button = new JButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JToggleButton createToggleButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JToggleButton button = null;
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            if (icon != null) {
                button = new BorderlessImageToggleButton(action, icon);
            }
        }
        if (button == null) {
            button = new JToggleButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JMenuItem createMenuItem(Class resourceClass, String name, String imageResourceName, Action action) {
        JMenuItem item = new JMenuItem(action);
        item.setText(name);
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            item.setIcon(icon);
        }
        return item;
    }

    /**
     * this determines if the CTRL key is down based on the modifiers from an event. This actualy needs to be checking for different things. CTRL doesn't meant the same thing on each platform.
     */
    public static boolean isCTRLDown(int eventModifiersEx) {
        return (eventModifiersEx & InputEvent.CTRL_DOWN_MASK) == InputEvent.CTRL_DOWN_MASK;
    }

    public static ImageIcon getImageIcon(Class resourceClass, String imageResourceName) {
        InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
        if (inputStream != null) {
            try {
                BufferedImage image = ImageIO.read(inputStream);
                return new ImageIcon(image);
            } catch (IOException e) {
                LOGGER.error("Reading image " + imageResourceName, e);
            }
        }
        return null;
    }

    /**
     * Scrolls the specified text component so the text between the starting and ending index are visible.
     */
    public static void scrollToText(JTextComponent textComponent, int startingIndex, int endingIndex) {
        try {
            Rectangle startingRectangle = textComponent.modelToView(startingIndex);
            Rectangle endDingRectangle = textComponent.modelToView(endingIndex);
            Rectangle totalBounds = startingRectangle.union(endDingRectangle);
            textComponent.scrollRectToVisible(totalBounds);
            textComponent.repaint();
        } catch (BadLocationException e) {
            e.printStackTrace();
        }
    }
}}'} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/SwingAddMultipleFavoritesInteraction.java
Cannot solve method call panel.add(Utility.addLeftJustifiedComponent(separatelyRadioButton)) UnsolvedSymbolException{context='Method 'addLeftJustifiedComponent' with parameterTypes [ReferenceType{javax.swing.JRadioButton, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * Just some utility functions.
 */
public class Utility {

    private static final Logger LOGGER = Logging.getLogger(Utility.class);

    public static Component addLeftJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(component);
        panel.add(Box.createHorizontalGlue());
        return panel;
    }

    public static Component addRightJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(Box.createHorizontalGlue());
        panel.add(component);
        return panel;
    }

    /**
     * This creates a dialog. I only created this because I was using JDK 1.6, then realized I needed to use 1.5 and one of the most useful features of 1.6 is dialogs taking Windows as parents. This
     * abstracts that so I don't have to make major changes to the code by passing around JFrames and JDialogs explicitly.
     *
     * @param parent the parent window
     * @param isModal true if its modal, false if not.
     * @return a dialog
     */
    public static JDialog createDialog(Window parent, String title, boolean isModal) {
        if (parent instanceof JDialog) {
            return new JDialog((JDialog) parent, title, isModal);
        } else if (parent instanceof JFrame) {
            return new JDialog((JFrame) parent, title, isModal);
        }
        throw new RuntimeException("Unknown window type!");
    }

    /**
     * This uses reflection to set the tab component if we're running under 1.6. It does nothing if you're running under 1.5. This is so you can run this on java 1.6 and get this benefit, but its not
     * required to compile.
     *
     * This is the same as calling JTabbedPane.setTabComponentAt(). It just does so using reflection.
     */
    public static void setTabComponent15Compatible(JTabbedPane tabbedPane, int index, Component component) {
        try {
            Method method = tabbedPane.getClass().getMethod("setTabComponentAt", new Class[] { Integer.TYPE, Component.class });
            method.invoke(tabbedPane, index, component);
        } catch (NoSuchMethodException e) {
        // e.printStackTrace();
        // we're not requiring 1.6, so its not a problem if we don't find the method. We just don't get this feature.
        } catch (Exception e) {
            LOGGER.error("Setting tab component", e);
        }
    }

    /**
     * This creates a button with the specified action, image, and tooltip text. The main issue here is that it doesn't crash if the image is missing (which is just something that happens in real life
     * from time to time). You probably should specify a name on the action just in case.
     *
     * @param resourceClass the calling class. Useful when multiple classloaders are used.
     * @param imageResourceName the image resource
     * @param tooltip the tooltip to display
     * @param action the action to perform
     * @return the button that was created.
     */
    public static JButton createButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JButton button = null;
        if (imageResourceName != null) {
            InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
            if (inputStream != null) {
                try {
                    BufferedImage image = ImageIO.read(inputStream);
                    button = new BorderlessImageButton(action, new ImageIcon(image));
                } catch (IOException e) {
                    LOGGER.error("Reading image " + imageResourceName, e);
                }
            }
        }
        if (button == null) {
            button = new JButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JToggleButton createToggleButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JToggleButton button = null;
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            if (icon != null) {
                button = new BorderlessImageToggleButton(action, icon);
            }
        }
        if (button == null) {
            button = new JToggleButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JMenuItem createMenuItem(Class resourceClass, String name, String imageResourceName, Action action) {
        JMenuItem item = new JMenuItem(action);
        item.setText(name);
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            item.setIcon(icon);
        }
        return item;
    }

    /**
     * this determines if the CTRL key is down based on the modifiers from an event. This actualy needs to be checking for different things. CTRL doesn't meant the same thing on each platform.
     */
    public static boolean isCTRLDown(int eventModifiersEx) {
        return (eventModifiersEx & InputEvent.CTRL_DOWN_MASK) == InputEvent.CTRL_DOWN_MASK;
    }

    public static ImageIcon getImageIcon(Class resourceClass, String imageResourceName) {
        InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
        if (inputStream != null) {
            try {
                BufferedImage image = ImageIO.read(inputStream);
                return new ImageIcon(image);
            } catch (IOException e) {
                LOGGER.error("Reading image " + imageResourceName, e);
            }
        }
        return null;
    }

    /**
     * Scrolls the specified text component so the text between the starting and ending index are visible.
     */
    public static void scrollToText(JTextComponent textComponent, int startingIndex, int endingIndex) {
        try {
            Rectangle startingRectangle = textComponent.modelToView(startingIndex);
            Rectangle endDingRectangle = textComponent.modelToView(endingIndex);
            Rectangle totalBounds = startingRectangle.union(endDingRectangle);
            textComponent.scrollRectToVisible(totalBounds);
            textComponent.repaint();
        } catch (BadLocationException e) {
            e.printStackTrace();
        }
    }
}}'} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/SwingAddMultipleFavoritesInteraction.java
Cannot solve method call panel.add(Utility.addLeftJustifiedComponent(combinedRadioButton)) UnsolvedSymbolException{context='Method 'addLeftJustifiedComponent' with parameterTypes [ReferenceType{javax.swing.JRadioButton, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * Just some utility functions.
 */
public class Utility {

    private static final Logger LOGGER = Logging.getLogger(Utility.class);

    public static Component addLeftJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(component);
        panel.add(Box.createHorizontalGlue());
        return panel;
    }

    public static Component addRightJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(Box.createHorizontalGlue());
        panel.add(component);
        return panel;
    }

    /**
     * This creates a dialog. I only created this because I was using JDK 1.6, then realized I needed to use 1.5 and one of the most useful features of 1.6 is dialogs taking Windows as parents. This
     * abstracts that so I don't have to make major changes to the code by passing around JFrames and JDialogs explicitly.
     *
     * @param parent the parent window
     * @param isModal true if its modal, false if not.
     * @return a dialog
     */
    public static JDialog createDialog(Window parent, String title, boolean isModal) {
        if (parent instanceof JDialog) {
            return new JDialog((JDialog) parent, title, isModal);
        } else if (parent instanceof JFrame) {
            return new JDialog((JFrame) parent, title, isModal);
        }
        throw new RuntimeException("Unknown window type!");
    }

    /**
     * This uses reflection to set the tab component if we're running under 1.6. It does nothing if you're running under 1.5. This is so you can run this on java 1.6 and get this benefit, but its not
     * required to compile.
     *
     * This is the same as calling JTabbedPane.setTabComponentAt(). It just does so using reflection.
     */
    public static void setTabComponent15Compatible(JTabbedPane tabbedPane, int index, Component component) {
        try {
            Method method = tabbedPane.getClass().getMethod("setTabComponentAt", new Class[] { Integer.TYPE, Component.class });
            method.invoke(tabbedPane, index, component);
        } catch (NoSuchMethodException e) {
        // e.printStackTrace();
        // we're not requiring 1.6, so its not a problem if we don't find the method. We just don't get this feature.
        } catch (Exception e) {
            LOGGER.error("Setting tab component", e);
        }
    }

    /**
     * This creates a button with the specified action, image, and tooltip text. The main issue here is that it doesn't crash if the image is missing (which is just something that happens in real life
     * from time to time). You probably should specify a name on the action just in case.
     *
     * @param resourceClass the calling class. Useful when multiple classloaders are used.
     * @param imageResourceName the image resource
     * @param tooltip the tooltip to display
     * @param action the action to perform
     * @return the button that was created.
     */
    public static JButton createButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JButton button = null;
        if (imageResourceName != null) {
            InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
            if (inputStream != null) {
                try {
                    BufferedImage image = ImageIO.read(inputStream);
                    button = new BorderlessImageButton(action, new ImageIcon(image));
                } catch (IOException e) {
                    LOGGER.error("Reading image " + imageResourceName, e);
                }
            }
        }
        if (button == null) {
            button = new JButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JToggleButton createToggleButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JToggleButton button = null;
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            if (icon != null) {
                button = new BorderlessImageToggleButton(action, icon);
            }
        }
        if (button == null) {
            button = new JToggleButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JMenuItem createMenuItem(Class resourceClass, String name, String imageResourceName, Action action) {
        JMenuItem item = new JMenuItem(action);
        item.setText(name);
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            item.setIcon(icon);
        }
        return item;
    }

    /**
     * this determines if the CTRL key is down based on the modifiers from an event. This actualy needs to be checking for different things. CTRL doesn't meant the same thing on each platform.
     */
    public static boolean isCTRLDown(int eventModifiersEx) {
        return (eventModifiersEx & InputEvent.CTRL_DOWN_MASK) == InputEvent.CTRL_DOWN_MASK;
    }

    public static ImageIcon getImageIcon(Class resourceClass, String imageResourceName) {
        InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
        if (inputStream != null) {
            try {
                BufferedImage image = ImageIO.read(inputStream);
                return new ImageIcon(image);
            } catch (IOException e) {
                LOGGER.error("Reading image " + imageResourceName, e);
            }
        }
        return null;
    }

    /**
     * Scrolls the specified text component so the text between the starting and ending index are visible.
     */
    public static void scrollToText(JTextComponent textComponent, int startingIndex, int endingIndex) {
        try {
            Rectangle startingRectangle = textComponent.modelToView(startingIndex);
            Rectangle endDingRectangle = textComponent.modelToView(endingIndex);
            Rectangle totalBounds = startingRectangle.union(endDingRectangle);
            textComponent.scrollRectToVisible(totalBounds);
            textComponent.repaint();
        } catch (BadLocationException e) {
            e.printStackTrace();
        }
    }
}}'} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/SwingAddMultipleFavoritesInteraction.java
Cannot solve method call separateSamplePanel.add(Utility.addLeftJustifiedComponent(separateLine1)) UnsolvedSymbolException{context='Method 'addLeftJustifiedComponent' with parameterTypes [ReferenceType{javax.swing.JLabel, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * Just some utility functions.
 */
public class Utility {

    private static final Logger LOGGER = Logging.getLogger(Utility.class);

    public static Component addLeftJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(component);
        panel.add(Box.createHorizontalGlue());
        return panel;
    }

    public static Component addRightJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(Box.createHorizontalGlue());
        panel.add(component);
        return panel;
    }

    /**
     * This creates a dialog. I only created this because I was using JDK 1.6, then realized I needed to use 1.5 and one of the most useful features of 1.6 is dialogs taking Windows as parents. This
     * abstracts that so I don't have to make major changes to the code by passing around JFrames and JDialogs explicitly.
     *
     * @param parent the parent window
     * @param isModal true if its modal, false if not.
     * @return a dialog
     */
    public static JDialog createDialog(Window parent, String title, boolean isModal) {
        if (parent instanceof JDialog) {
            return new JDialog((JDialog) parent, title, isModal);
        } else if (parent instanceof JFrame) {
            return new JDialog((JFrame) parent, title, isModal);
        }
        throw new RuntimeException("Unknown window type!");
    }

    /**
     * This uses reflection to set the tab component if we're running under 1.6. It does nothing if you're running under 1.5. This is so you can run this on java 1.6 and get this benefit, but its not
     * required to compile.
     *
     * This is the same as calling JTabbedPane.setTabComponentAt(). It just does so using reflection.
     */
    public static void setTabComponent15Compatible(JTabbedPane tabbedPane, int index, Component component) {
        try {
            Method method = tabbedPane.getClass().getMethod("setTabComponentAt", new Class[] { Integer.TYPE, Component.class });
            method.invoke(tabbedPane, index, component);
        } catch (NoSuchMethodException e) {
        // e.printStackTrace();
        // we're not requiring 1.6, so its not a problem if we don't find the method. We just don't get this feature.
        } catch (Exception e) {
            LOGGER.error("Setting tab component", e);
        }
    }

    /**
     * This creates a button with the specified action, image, and tooltip text. The main issue here is that it doesn't crash if the image is missing (which is just something that happens in real life
     * from time to time). You probably should specify a name on the action just in case.
     *
     * @param resourceClass the calling class. Useful when multiple classloaders are used.
     * @param imageResourceName the image resource
     * @param tooltip the tooltip to display
     * @param action the action to perform
     * @return the button that was created.
     */
    public static JButton createButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JButton button = null;
        if (imageResourceName != null) {
            InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
            if (inputStream != null) {
                try {
                    BufferedImage image = ImageIO.read(inputStream);
                    button = new BorderlessImageButton(action, new ImageIcon(image));
                } catch (IOException e) {
                    LOGGER.error("Reading image " + imageResourceName, e);
                }
            }
        }
        if (button == null) {
            button = new JButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JToggleButton createToggleButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JToggleButton button = null;
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            if (icon != null) {
                button = new BorderlessImageToggleButton(action, icon);
            }
        }
        if (button == null) {
            button = new JToggleButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JMenuItem createMenuItem(Class resourceClass, String name, String imageResourceName, Action action) {
        JMenuItem item = new JMenuItem(action);
        item.setText(name);
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            item.setIcon(icon);
        }
        return item;
    }

    /**
     * this determines if the CTRL key is down based on the modifiers from an event. This actualy needs to be checking for different things. CTRL doesn't meant the same thing on each platform.
     */
    public static boolean isCTRLDown(int eventModifiersEx) {
        return (eventModifiersEx & InputEvent.CTRL_DOWN_MASK) == InputEvent.CTRL_DOWN_MASK;
    }

    public static ImageIcon getImageIcon(Class resourceClass, String imageResourceName) {
        InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
        if (inputStream != null) {
            try {
                BufferedImage image = ImageIO.read(inputStream);
                return new ImageIcon(image);
            } catch (IOException e) {
                LOGGER.error("Reading image " + imageResourceName, e);
            }
        }
        return null;
    }

    /**
     * Scrolls the specified text component so the text between the starting and ending index are visible.
     */
    public static void scrollToText(JTextComponent textComponent, int startingIndex, int endingIndex) {
        try {
            Rectangle startingRectangle = textComponent.modelToView(startingIndex);
            Rectangle endDingRectangle = textComponent.modelToView(endingIndex);
            Rectangle totalBounds = startingRectangle.union(endDingRectangle);
            textComponent.scrollRectToVisible(totalBounds);
            textComponent.repaint();
        } catch (BadLocationException e) {
            e.printStackTrace();
        }
    }
}}'} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/SwingAddMultipleFavoritesInteraction.java
Cannot solve method call separateSamplePanel.add(Utility.addLeftJustifiedComponent(separateLine2)) UnsolvedSymbolException{context='Method 'addLeftJustifiedComponent' with parameterTypes [ReferenceType{javax.swing.JLabel, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * Just some utility functions.
 */
public class Utility {

    private static final Logger LOGGER = Logging.getLogger(Utility.class);

    public static Component addLeftJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(component);
        panel.add(Box.createHorizontalGlue());
        return panel;
    }

    public static Component addRightJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(Box.createHorizontalGlue());
        panel.add(component);
        return panel;
    }

    /**
     * This creates a dialog. I only created this because I was using JDK 1.6, then realized I needed to use 1.5 and one of the most useful features of 1.6 is dialogs taking Windows as parents. This
     * abstracts that so I don't have to make major changes to the code by passing around JFrames and JDialogs explicitly.
     *
     * @param parent the parent window
     * @param isModal true if its modal, false if not.
     * @return a dialog
     */
    public static JDialog createDialog(Window parent, String title, boolean isModal) {
        if (parent instanceof JDialog) {
            return new JDialog((JDialog) parent, title, isModal);
        } else if (parent instanceof JFrame) {
            return new JDialog((JFrame) parent, title, isModal);
        }
        throw new RuntimeException("Unknown window type!");
    }

    /**
     * This uses reflection to set the tab component if we're running under 1.6. It does nothing if you're running under 1.5. This is so you can run this on java 1.6 and get this benefit, but its not
     * required to compile.
     *
     * This is the same as calling JTabbedPane.setTabComponentAt(). It just does so using reflection.
     */
    public static void setTabComponent15Compatible(JTabbedPane tabbedPane, int index, Component component) {
        try {
            Method method = tabbedPane.getClass().getMethod("setTabComponentAt", new Class[] { Integer.TYPE, Component.class });
            method.invoke(tabbedPane, index, component);
        } catch (NoSuchMethodException e) {
        // e.printStackTrace();
        // we're not requiring 1.6, so its not a problem if we don't find the method. We just don't get this feature.
        } catch (Exception e) {
            LOGGER.error("Setting tab component", e);
        }
    }

    /**
     * This creates a button with the specified action, image, and tooltip text. The main issue here is that it doesn't crash if the image is missing (which is just something that happens in real life
     * from time to time). You probably should specify a name on the action just in case.
     *
     * @param resourceClass the calling class. Useful when multiple classloaders are used.
     * @param imageResourceName the image resource
     * @param tooltip the tooltip to display
     * @param action the action to perform
     * @return the button that was created.
     */
    public static JButton createButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JButton button = null;
        if (imageResourceName != null) {
            InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
            if (inputStream != null) {
                try {
                    BufferedImage image = ImageIO.read(inputStream);
                    button = new BorderlessImageButton(action, new ImageIcon(image));
                } catch (IOException e) {
                    LOGGER.error("Reading image " + imageResourceName, e);
                }
            }
        }
        if (button == null) {
            button = new JButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JToggleButton createToggleButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JToggleButton button = null;
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            if (icon != null) {
                button = new BorderlessImageToggleButton(action, icon);
            }
        }
        if (button == null) {
            button = new JToggleButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JMenuItem createMenuItem(Class resourceClass, String name, String imageResourceName, Action action) {
        JMenuItem item = new JMenuItem(action);
        item.setText(name);
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            item.setIcon(icon);
        }
        return item;
    }

    /**
     * this determines if the CTRL key is down based on the modifiers from an event. This actualy needs to be checking for different things. CTRL doesn't meant the same thing on each platform.
     */
    public static boolean isCTRLDown(int eventModifiersEx) {
        return (eventModifiersEx & InputEvent.CTRL_DOWN_MASK) == InputEvent.CTRL_DOWN_MASK;
    }

    public static ImageIcon getImageIcon(Class resourceClass, String imageResourceName) {
        InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
        if (inputStream != null) {
            try {
                BufferedImage image = ImageIO.read(inputStream);
                return new ImageIcon(image);
            } catch (IOException e) {
                LOGGER.error("Reading image " + imageResourceName, e);
            }
        }
        return null;
    }

    /**
     * Scrolls the specified text component so the text between the starting and ending index are visible.
     */
    public static void scrollToText(JTextComponent textComponent, int startingIndex, int endingIndex) {
        try {
            Rectangle startingRectangle = textComponent.modelToView(startingIndex);
            Rectangle endDingRectangle = textComponent.modelToView(endingIndex);
            Rectangle totalBounds = startingRectangle.union(endDingRectangle);
            textComponent.scrollRectToVisible(totalBounds);
            textComponent.repaint();
        } catch (BadLocationException e) {
            e.printStackTrace();
        }
    }
}}'} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/SwingAddMultipleFavoritesInteraction.java
Cannot solve method call separateSamplePanel.add(Utility.addLeftJustifiedComponent(separateLine3)) UnsolvedSymbolException{context='Method 'addLeftJustifiedComponent' with parameterTypes [ReferenceType{javax.swing.JLabel, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * Just some utility functions.
 */
public class Utility {

    private static final Logger LOGGER = Logging.getLogger(Utility.class);

    public static Component addLeftJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(component);
        panel.add(Box.createHorizontalGlue());
        return panel;
    }

    public static Component addRightJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(Box.createHorizontalGlue());
        panel.add(component);
        return panel;
    }

    /**
     * This creates a dialog. I only created this because I was using JDK 1.6, then realized I needed to use 1.5 and one of the most useful features of 1.6 is dialogs taking Windows as parents. This
     * abstracts that so I don't have to make major changes to the code by passing around JFrames and JDialogs explicitly.
     *
     * @param parent the parent window
     * @param isModal true if its modal, false if not.
     * @return a dialog
     */
    public static JDialog createDialog(Window parent, String title, boolean isModal) {
        if (parent instanceof JDialog) {
            return new JDialog((JDialog) parent, title, isModal);
        } else if (parent instanceof JFrame) {
            return new JDialog((JFrame) parent, title, isModal);
        }
        throw new RuntimeException("Unknown window type!");
    }

    /**
     * This uses reflection to set the tab component if we're running under 1.6. It does nothing if you're running under 1.5. This is so you can run this on java 1.6 and get this benefit, but its not
     * required to compile.
     *
     * This is the same as calling JTabbedPane.setTabComponentAt(). It just does so using reflection.
     */
    public static void setTabComponent15Compatible(JTabbedPane tabbedPane, int index, Component component) {
        try {
            Method method = tabbedPane.getClass().getMethod("setTabComponentAt", new Class[] { Integer.TYPE, Component.class });
            method.invoke(tabbedPane, index, component);
        } catch (NoSuchMethodException e) {
        // e.printStackTrace();
        // we're not requiring 1.6, so its not a problem if we don't find the method. We just don't get this feature.
        } catch (Exception e) {
            LOGGER.error("Setting tab component", e);
        }
    }

    /**
     * This creates a button with the specified action, image, and tooltip text. The main issue here is that it doesn't crash if the image is missing (which is just something that happens in real life
     * from time to time). You probably should specify a name on the action just in case.
     *
     * @param resourceClass the calling class. Useful when multiple classloaders are used.
     * @param imageResourceName the image resource
     * @param tooltip the tooltip to display
     * @param action the action to perform
     * @return the button that was created.
     */
    public static JButton createButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JButton button = null;
        if (imageResourceName != null) {
            InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
            if (inputStream != null) {
                try {
                    BufferedImage image = ImageIO.read(inputStream);
                    button = new BorderlessImageButton(action, new ImageIcon(image));
                } catch (IOException e) {
                    LOGGER.error("Reading image " + imageResourceName, e);
                }
            }
        }
        if (button == null) {
            button = new JButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JToggleButton createToggleButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JToggleButton button = null;
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            if (icon != null) {
                button = new BorderlessImageToggleButton(action, icon);
            }
        }
        if (button == null) {
            button = new JToggleButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JMenuItem createMenuItem(Class resourceClass, String name, String imageResourceName, Action action) {
        JMenuItem item = new JMenuItem(action);
        item.setText(name);
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            item.setIcon(icon);
        }
        return item;
    }

    /**
     * this determines if the CTRL key is down based on the modifiers from an event. This actualy needs to be checking for different things. CTRL doesn't meant the same thing on each platform.
     */
    public static boolean isCTRLDown(int eventModifiersEx) {
        return (eventModifiersEx & InputEvent.CTRL_DOWN_MASK) == InputEvent.CTRL_DOWN_MASK;
    }

    public static ImageIcon getImageIcon(Class resourceClass, String imageResourceName) {
        InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
        if (inputStream != null) {
            try {
                BufferedImage image = ImageIO.read(inputStream);
                return new ImageIcon(image);
            } catch (IOException e) {
                LOGGER.error("Reading image " + imageResourceName, e);
            }
        }
        return null;
    }

    /**
     * Scrolls the specified text component so the text between the starting and ending index are visible.
     */
    public static void scrollToText(JTextComponent textComponent, int startingIndex, int endingIndex) {
        try {
            Rectangle startingRectangle = textComponent.modelToView(startingIndex);
            Rectangle endDingRectangle = textComponent.modelToView(endingIndex);
            Rectangle totalBounds = startingRectangle.union(endDingRectangle);
            textComponent.scrollRectToVisible(totalBounds);
            textComponent.repaint();
        } catch (BadLocationException e) {
            e.printStackTrace();
        }
    }
}}'} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/SwingAddMultipleFavoritesInteraction.java
Cannot solve method call combinedSamplePanel.add(Utility.addLeftJustifiedComponent(combinedLine1)) UnsolvedSymbolException{context='Method 'addLeftJustifiedComponent' with parameterTypes [ReferenceType{javax.swing.JLabel, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * Just some utility functions.
 */
public class Utility {

    private static final Logger LOGGER = Logging.getLogger(Utility.class);

    public static Component addLeftJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(component);
        panel.add(Box.createHorizontalGlue());
        return panel;
    }

    public static Component addRightJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(Box.createHorizontalGlue());
        panel.add(component);
        return panel;
    }

    /**
     * This creates a dialog. I only created this because I was using JDK 1.6, then realized I needed to use 1.5 and one of the most useful features of 1.6 is dialogs taking Windows as parents. This
     * abstracts that so I don't have to make major changes to the code by passing around JFrames and JDialogs explicitly.
     *
     * @param parent the parent window
     * @param isModal true if its modal, false if not.
     * @return a dialog
     */
    public static JDialog createDialog(Window parent, String title, boolean isModal) {
        if (parent instanceof JDialog) {
            return new JDialog((JDialog) parent, title, isModal);
        } else if (parent instanceof JFrame) {
            return new JDialog((JFrame) parent, title, isModal);
        }
        throw new RuntimeException("Unknown window type!");
    }

    /**
     * This uses reflection to set the tab component if we're running under 1.6. It does nothing if you're running under 1.5. This is so you can run this on java 1.6 and get this benefit, but its not
     * required to compile.
     *
     * This is the same as calling JTabbedPane.setTabComponentAt(). It just does so using reflection.
     */
    public static void setTabComponent15Compatible(JTabbedPane tabbedPane, int index, Component component) {
        try {
            Method method = tabbedPane.getClass().getMethod("setTabComponentAt", new Class[] { Integer.TYPE, Component.class });
            method.invoke(tabbedPane, index, component);
        } catch (NoSuchMethodException e) {
        // e.printStackTrace();
        // we're not requiring 1.6, so its not a problem if we don't find the method. We just don't get this feature.
        } catch (Exception e) {
            LOGGER.error("Setting tab component", e);
        }
    }

    /**
     * This creates a button with the specified action, image, and tooltip text. The main issue here is that it doesn't crash if the image is missing (which is just something that happens in real life
     * from time to time). You probably should specify a name on the action just in case.
     *
     * @param resourceClass the calling class. Useful when multiple classloaders are used.
     * @param imageResourceName the image resource
     * @param tooltip the tooltip to display
     * @param action the action to perform
     * @return the button that was created.
     */
    public static JButton createButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JButton button = null;
        if (imageResourceName != null) {
            InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
            if (inputStream != null) {
                try {
                    BufferedImage image = ImageIO.read(inputStream);
                    button = new BorderlessImageButton(action, new ImageIcon(image));
                } catch (IOException e) {
                    LOGGER.error("Reading image " + imageResourceName, e);
                }
            }
        }
        if (button == null) {
            button = new JButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JToggleButton createToggleButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JToggleButton button = null;
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            if (icon != null) {
                button = new BorderlessImageToggleButton(action, icon);
            }
        }
        if (button == null) {
            button = new JToggleButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JMenuItem createMenuItem(Class resourceClass, String name, String imageResourceName, Action action) {
        JMenuItem item = new JMenuItem(action);
        item.setText(name);
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            item.setIcon(icon);
        }
        return item;
    }

    /**
     * this determines if the CTRL key is down based on the modifiers from an event. This actualy needs to be checking for different things. CTRL doesn't meant the same thing on each platform.
     */
    public static boolean isCTRLDown(int eventModifiersEx) {
        return (eventModifiersEx & InputEvent.CTRL_DOWN_MASK) == InputEvent.CTRL_DOWN_MASK;
    }

    public static ImageIcon getImageIcon(Class resourceClass, String imageResourceName) {
        InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
        if (inputStream != null) {
            try {
                BufferedImage image = ImageIO.read(inputStream);
                return new ImageIcon(image);
            } catch (IOException e) {
                LOGGER.error("Reading image " + imageResourceName, e);
            }
        }
        return null;
    }

    /**
     * Scrolls the specified text component so the text between the starting and ending index are visible.
     */
    public static void scrollToText(JTextComponent textComponent, int startingIndex, int endingIndex) {
        try {
            Rectangle startingRectangle = textComponent.modelToView(startingIndex);
            Rectangle endDingRectangle = textComponent.modelToView(endingIndex);
            Rectangle totalBounds = startingRectangle.union(endDingRectangle);
            textComponent.scrollRectToVisible(totalBounds);
            textComponent.repaint();
        } catch (BadLocationException e) {
            e.printStackTrace();
        }
    }
}}'} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/SwingAddMultipleFavoritesInteraction.java
Cannot resolve field access null
Cannot solve field access FavoritesEditor.AddMultipleResult.AddSeparately
Cannot resolve field access null
Cannot solve field access FavoritesEditor.AddMultipleResult.AddAsSingleCommand
Cannot resolve field access null
Cannot solve field access FavoritesEditor.AddMultipleResult.Cancel
Cannot resolve field access null
Cannot solve field access FavoritesEditor.AddMultipleResult.Cancel
Cannot resolve field access null
Cannot solve method call KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0) UnsolvedSymbolException{context='unknown', name='VK_ESCAPE', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/SwingAddMultipleFavoritesInteraction.java
Cannot solve method call dialog.getRootPane().registerKeyboardAction(new ActionListener() {

    public void actionPerformed(ActionEvent actionEvent) {
        close(FavoritesEditor.AddMultipleResult.Cancel);
    }
}, KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), JComponent.WHEN_IN_FOCUSED_WINDOW) java.lang.RuntimeException: Error calculating the type of parameter KeyEvent.VK_ESCAPE of method call KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0) /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/SwingAddMultipleFavoritesInteraction.java
Cannot solve method call pinnedLabel.setVisible(isPinned()) java.lang.RuntimeException: Method 'isPinned' cannot be resolved in context isPinned() (line: 62) MethodCallExprContext{wrapped=isPinned()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/OutputTab.java
Cannot resolve field access null
Cannot solve method call splitter.setTopComponent(createMainGradlePanel()) java.lang.RuntimeException: Method 'createMainGradlePanel' cannot be resolved in context createMainGradlePanel() (line: 66) MethodCallExprContext{wrapped=createMainGradlePanel()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/SinglePaneUIInstance.java
Cannot solve method call splitter.setBottomComponent(outputPanelLord.getMainPanel()) java.lang.RuntimeException: Method 'getMainPanel' cannot be resolved in context outputPanelLord.getMainPanel() (line: 67) MethodCallExprContext{wrapped=outputPanelLord.getMainPanel()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/SinglePaneUIInstance.java
Cannot resolve field access null
Cannot solve method call PreferencesAssistant.restoreSettings(settings, splitter, SPLITTER_PREFERENCES_ID, SinglePaneUIInstance.class) UnsolvedSymbolException{context='Solving settings', name='settings', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/SinglePaneUIInstance.java
Cannot solve method call PreferencesAssistant.saveSettings(settings, splitter, SPLITTER_PREFERENCES_ID, SinglePaneUIInstance.class) UnsolvedSymbolException{context='Solving settings', name='settings', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/SinglePaneUIInstance.java
Cannot solve method call dialog.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE) UnsolvedSymbolException{context='unknown', name='DO_NOTHING_ON_CLOSE', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/SwingEditFavoriteInteraction.java
Cannot resolve field access null
Cannot solve method call panel.add(createMainPanel(), BorderLayout.CENTER) UnsolvedSymbolException{context='unknown', name='CENTER', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/SwingEditFavoriteInteraction.java
Cannot resolve field access null
Cannot solve method call panel.add(createButtonPanel(), BorderLayout.SOUTH) UnsolvedSymbolException{context='unknown', name='SOUTH', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/SwingEditFavoriteInteraction.java
Cannot solve method call panel.add(Utility.addLeftJustifiedComponent(new JLabel("Command Line"))) UnsolvedSymbolException{context='Method 'addLeftJustifiedComponent' with parameterTypes [ReferenceType{javax.swing.JLabel, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * Just some utility functions.
 */
public class Utility {

    private static final Logger LOGGER = Logging.getLogger(Utility.class);

    public static Component addLeftJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(component);
        panel.add(Box.createHorizontalGlue());
        return panel;
    }

    public static Component addRightJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(Box.createHorizontalGlue());
        panel.add(component);
        return panel;
    }

    /**
     * This creates a dialog. I only created this because I was using JDK 1.6, then realized I needed to use 1.5 and one of the most useful features of 1.6 is dialogs taking Windows as parents. This
     * abstracts that so I don't have to make major changes to the code by passing around JFrames and JDialogs explicitly.
     *
     * @param parent the parent window
     * @param isModal true if its modal, false if not.
     * @return a dialog
     */
    public static JDialog createDialog(Window parent, String title, boolean isModal) {
        if (parent instanceof JDialog) {
            return new JDialog((JDialog) parent, title, isModal);
        } else if (parent instanceof JFrame) {
            return new JDialog((JFrame) parent, title, isModal);
        }
        throw new RuntimeException("Unknown window type!");
    }

    /**
     * This uses reflection to set the tab component if we're running under 1.6. It does nothing if you're running under 1.5. This is so you can run this on java 1.6 and get this benefit, but its not
     * required to compile.
     *
     * This is the same as calling JTabbedPane.setTabComponentAt(). It just does so using reflection.
     */
    public static void setTabComponent15Compatible(JTabbedPane tabbedPane, int index, Component component) {
        try {
            Method method = tabbedPane.getClass().getMethod("setTabComponentAt", new Class[] { Integer.TYPE, Component.class });
            method.invoke(tabbedPane, index, component);
        } catch (NoSuchMethodException e) {
        // e.printStackTrace();
        // we're not requiring 1.6, so its not a problem if we don't find the method. We just don't get this feature.
        } catch (Exception e) {
            LOGGER.error("Setting tab component", e);
        }
    }

    /**
     * This creates a button with the specified action, image, and tooltip text. The main issue here is that it doesn't crash if the image is missing (which is just something that happens in real life
     * from time to time). You probably should specify a name on the action just in case.
     *
     * @param resourceClass the calling class. Useful when multiple classloaders are used.
     * @param imageResourceName the image resource
     * @param tooltip the tooltip to display
     * @param action the action to perform
     * @return the button that was created.
     */
    public static JButton createButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JButton button = null;
        if (imageResourceName != null) {
            InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
            if (inputStream != null) {
                try {
                    BufferedImage image = ImageIO.read(inputStream);
                    button = new BorderlessImageButton(action, new ImageIcon(image));
                } catch (IOException e) {
                    LOGGER.error("Reading image " + imageResourceName, e);
                }
            }
        }
        if (button == null) {
            button = new JButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JToggleButton createToggleButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JToggleButton button = null;
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            if (icon != null) {
                button = new BorderlessImageToggleButton(action, icon);
            }
        }
        if (button == null) {
            button = new JToggleButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JMenuItem createMenuItem(Class resourceClass, String name, String imageResourceName, Action action) {
        JMenuItem item = new JMenuItem(action);
        item.setText(name);
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            item.setIcon(icon);
        }
        return item;
    }

    /**
     * this determines if the CTRL key is down based on the modifiers from an event. This actualy needs to be checking for different things. CTRL doesn't meant the same thing on each platform.
     */
    public static boolean isCTRLDown(int eventModifiersEx) {
        return (eventModifiersEx & InputEvent.CTRL_DOWN_MASK) == InputEvent.CTRL_DOWN_MASK;
    }

    public static ImageIcon getImageIcon(Class resourceClass, String imageResourceName) {
        InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
        if (inputStream != null) {
            try {
                BufferedImage image = ImageIO.read(inputStream);
                return new ImageIcon(image);
            } catch (IOException e) {
                LOGGER.error("Reading image " + imageResourceName, e);
            }
        }
        return null;
    }

    /**
     * Scrolls the specified text component so the text between the starting and ending index are visible.
     */
    public static void scrollToText(JTextComponent textComponent, int startingIndex, int endingIndex) {
        try {
            Rectangle startingRectangle = textComponent.modelToView(startingIndex);
            Rectangle endDingRectangle = textComponent.modelToView(endingIndex);
            Rectangle totalBounds = startingRectangle.union(endDingRectangle);
            textComponent.scrollRectToVisible(totalBounds);
            textComponent.repaint();
        } catch (BadLocationException e) {
            e.printStackTrace();
        }
    }
}}'} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/SwingEditFavoriteInteraction.java
Cannot solve method call panel.add(Utility.addLeftJustifiedComponent(fullCommandLineTextField)) UnsolvedSymbolException{context='Method 'addLeftJustifiedComponent' with parameterTypes [ReferenceType{javax.swing.JTextField, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * Just some utility functions.
 */
public class Utility {

    private static final Logger LOGGER = Logging.getLogger(Utility.class);

    public static Component addLeftJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(component);
        panel.add(Box.createHorizontalGlue());
        return panel;
    }

    public static Component addRightJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(Box.createHorizontalGlue());
        panel.add(component);
        return panel;
    }

    /**
     * This creates a dialog. I only created this because I was using JDK 1.6, then realized I needed to use 1.5 and one of the most useful features of 1.6 is dialogs taking Windows as parents. This
     * abstracts that so I don't have to make major changes to the code by passing around JFrames and JDialogs explicitly.
     *
     * @param parent the parent window
     * @param isModal true if its modal, false if not.
     * @return a dialog
     */
    public static JDialog createDialog(Window parent, String title, boolean isModal) {
        if (parent instanceof JDialog) {
            return new JDialog((JDialog) parent, title, isModal);
        } else if (parent instanceof JFrame) {
            return new JDialog((JFrame) parent, title, isModal);
        }
        throw new RuntimeException("Unknown window type!");
    }

    /**
     * This uses reflection to set the tab component if we're running under 1.6. It does nothing if you're running under 1.5. This is so you can run this on java 1.6 and get this benefit, but its not
     * required to compile.
     *
     * This is the same as calling JTabbedPane.setTabComponentAt(). It just does so using reflection.
     */
    public static void setTabComponent15Compatible(JTabbedPane tabbedPane, int index, Component component) {
        try {
            Method method = tabbedPane.getClass().getMethod("setTabComponentAt", new Class[] { Integer.TYPE, Component.class });
            method.invoke(tabbedPane, index, component);
        } catch (NoSuchMethodException e) {
        // e.printStackTrace();
        // we're not requiring 1.6, so its not a problem if we don't find the method. We just don't get this feature.
        } catch (Exception e) {
            LOGGER.error("Setting tab component", e);
        }
    }

    /**
     * This creates a button with the specified action, image, and tooltip text. The main issue here is that it doesn't crash if the image is missing (which is just something that happens in real life
     * from time to time). You probably should specify a name on the action just in case.
     *
     * @param resourceClass the calling class. Useful when multiple classloaders are used.
     * @param imageResourceName the image resource
     * @param tooltip the tooltip to display
     * @param action the action to perform
     * @return the button that was created.
     */
    public static JButton createButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JButton button = null;
        if (imageResourceName != null) {
            InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
            if (inputStream != null) {
                try {
                    BufferedImage image = ImageIO.read(inputStream);
                    button = new BorderlessImageButton(action, new ImageIcon(image));
                } catch (IOException e) {
                    LOGGER.error("Reading image " + imageResourceName, e);
                }
            }
        }
        if (button == null) {
            button = new JButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JToggleButton createToggleButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JToggleButton button = null;
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            if (icon != null) {
                button = new BorderlessImageToggleButton(action, icon);
            }
        }
        if (button == null) {
            button = new JToggleButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JMenuItem createMenuItem(Class resourceClass, String name, String imageResourceName, Action action) {
        JMenuItem item = new JMenuItem(action);
        item.setText(name);
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            item.setIcon(icon);
        }
        return item;
    }

    /**
     * this determines if the CTRL key is down based on the modifiers from an event. This actualy needs to be checking for different things. CTRL doesn't meant the same thing on each platform.
     */
    public static boolean isCTRLDown(int eventModifiersEx) {
        return (eventModifiersEx & InputEvent.CTRL_DOWN_MASK) == InputEvent.CTRL_DOWN_MASK;
    }

    public static ImageIcon getImageIcon(Class resourceClass, String imageResourceName) {
        InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
        if (inputStream != null) {
            try {
                BufferedImage image = ImageIO.read(inputStream);
                return new ImageIcon(image);
            } catch (IOException e) {
                LOGGER.error("Reading image " + imageResourceName, e);
            }
        }
        return null;
    }

    /**
     * Scrolls the specified text component so the text between the starting and ending index are visible.
     */
    public static void scrollToText(JTextComponent textComponent, int startingIndex, int endingIndex) {
        try {
            Rectangle startingRectangle = textComponent.modelToView(startingIndex);
            Rectangle endDingRectangle = textComponent.modelToView(endingIndex);
            Rectangle totalBounds = startingRectangle.union(endDingRectangle);
            textComponent.scrollRectToVisible(totalBounds);
            textComponent.repaint();
        } catch (BadLocationException e) {
            e.printStackTrace();
        }
    }
}}'} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/SwingEditFavoriteInteraction.java
Cannot solve method call panel.add(Utility.addLeftJustifiedComponent(new JLabel("Display Name"))) UnsolvedSymbolException{context='Method 'addLeftJustifiedComponent' with parameterTypes [ReferenceType{javax.swing.JLabel, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * Just some utility functions.
 */
public class Utility {

    private static final Logger LOGGER = Logging.getLogger(Utility.class);

    public static Component addLeftJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(component);
        panel.add(Box.createHorizontalGlue());
        return panel;
    }

    public static Component addRightJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(Box.createHorizontalGlue());
        panel.add(component);
        return panel;
    }

    /**
     * This creates a dialog. I only created this because I was using JDK 1.6, then realized I needed to use 1.5 and one of the most useful features of 1.6 is dialogs taking Windows as parents. This
     * abstracts that so I don't have to make major changes to the code by passing around JFrames and JDialogs explicitly.
     *
     * @param parent the parent window
     * @param isModal true if its modal, false if not.
     * @return a dialog
     */
    public static JDialog createDialog(Window parent, String title, boolean isModal) {
        if (parent instanceof JDialog) {
            return new JDialog((JDialog) parent, title, isModal);
        } else if (parent instanceof JFrame) {
            return new JDialog((JFrame) parent, title, isModal);
        }
        throw new RuntimeException("Unknown window type!");
    }

    /**
     * This uses reflection to set the tab component if we're running under 1.6. It does nothing if you're running under 1.5. This is so you can run this on java 1.6 and get this benefit, but its not
     * required to compile.
     *
     * This is the same as calling JTabbedPane.setTabComponentAt(). It just does so using reflection.
     */
    public static void setTabComponent15Compatible(JTabbedPane tabbedPane, int index, Component component) {
        try {
            Method method = tabbedPane.getClass().getMethod("setTabComponentAt", new Class[] { Integer.TYPE, Component.class });
            method.invoke(tabbedPane, index, component);
        } catch (NoSuchMethodException e) {
        // e.printStackTrace();
        // we're not requiring 1.6, so its not a problem if we don't find the method. We just don't get this feature.
        } catch (Exception e) {
            LOGGER.error("Setting tab component", e);
        }
    }

    /**
     * This creates a button with the specified action, image, and tooltip text. The main issue here is that it doesn't crash if the image is missing (which is just something that happens in real life
     * from time to time). You probably should specify a name on the action just in case.
     *
     * @param resourceClass the calling class. Useful when multiple classloaders are used.
     * @param imageResourceName the image resource
     * @param tooltip the tooltip to display
     * @param action the action to perform
     * @return the button that was created.
     */
    public static JButton createButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JButton button = null;
        if (imageResourceName != null) {
            InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
            if (inputStream != null) {
                try {
                    BufferedImage image = ImageIO.read(inputStream);
                    button = new BorderlessImageButton(action, new ImageIcon(image));
                } catch (IOException e) {
                    LOGGER.error("Reading image " + imageResourceName, e);
                }
            }
        }
        if (button == null) {
            button = new JButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JToggleButton createToggleButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JToggleButton button = null;
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            if (icon != null) {
                button = new BorderlessImageToggleButton(action, icon);
            }
        }
        if (button == null) {
            button = new JToggleButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JMenuItem createMenuItem(Class resourceClass, String name, String imageResourceName, Action action) {
        JMenuItem item = new JMenuItem(action);
        item.setText(name);
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            item.setIcon(icon);
        }
        return item;
    }

    /**
     * this determines if the CTRL key is down based on the modifiers from an event. This actualy needs to be checking for different things. CTRL doesn't meant the same thing on each platform.
     */
    public static boolean isCTRLDown(int eventModifiersEx) {
        return (eventModifiersEx & InputEvent.CTRL_DOWN_MASK) == InputEvent.CTRL_DOWN_MASK;
    }

    public static ImageIcon getImageIcon(Class resourceClass, String imageResourceName) {
        InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
        if (inputStream != null) {
            try {
                BufferedImage image = ImageIO.read(inputStream);
                return new ImageIcon(image);
            } catch (IOException e) {
                LOGGER.error("Reading image " + imageResourceName, e);
            }
        }
        return null;
    }

    /**
     * Scrolls the specified text component so the text between the starting and ending index are visible.
     */
    public static void scrollToText(JTextComponent textComponent, int startingIndex, int endingIndex) {
        try {
            Rectangle startingRectangle = textComponent.modelToView(startingIndex);
            Rectangle endDingRectangle = textComponent.modelToView(endingIndex);
            Rectangle totalBounds = startingRectangle.union(endDingRectangle);
            textComponent.scrollRectToVisible(totalBounds);
            textComponent.repaint();
        } catch (BadLocationException e) {
            e.printStackTrace();
        }
    }
}}'} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/SwingEditFavoriteInteraction.java
Cannot solve method call panel.add(Utility.addLeftJustifiedComponent(displayNameTextField)) UnsolvedSymbolException{context='Method 'addLeftJustifiedComponent' with parameterTypes [ReferenceType{javax.swing.JTextField, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * Just some utility functions.
 */
public class Utility {

    private static final Logger LOGGER = Logging.getLogger(Utility.class);

    public static Component addLeftJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(component);
        panel.add(Box.createHorizontalGlue());
        return panel;
    }

    public static Component addRightJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(Box.createHorizontalGlue());
        panel.add(component);
        return panel;
    }

    /**
     * This creates a dialog. I only created this because I was using JDK 1.6, then realized I needed to use 1.5 and one of the most useful features of 1.6 is dialogs taking Windows as parents. This
     * abstracts that so I don't have to make major changes to the code by passing around JFrames and JDialogs explicitly.
     *
     * @param parent the parent window
     * @param isModal true if its modal, false if not.
     * @return a dialog
     */
    public static JDialog createDialog(Window parent, String title, boolean isModal) {
        if (parent instanceof JDialog) {
            return new JDialog((JDialog) parent, title, isModal);
        } else if (parent instanceof JFrame) {
            return new JDialog((JFrame) parent, title, isModal);
        }
        throw new RuntimeException("Unknown window type!");
    }

    /**
     * This uses reflection to set the tab component if we're running under 1.6. It does nothing if you're running under 1.5. This is so you can run this on java 1.6 and get this benefit, but its not
     * required to compile.
     *
     * This is the same as calling JTabbedPane.setTabComponentAt(). It just does so using reflection.
     */
    public static void setTabComponent15Compatible(JTabbedPane tabbedPane, int index, Component component) {
        try {
            Method method = tabbedPane.getClass().getMethod("setTabComponentAt", new Class[] { Integer.TYPE, Component.class });
            method.invoke(tabbedPane, index, component);
        } catch (NoSuchMethodException e) {
        // e.printStackTrace();
        // we're not requiring 1.6, so its not a problem if we don't find the method. We just don't get this feature.
        } catch (Exception e) {
            LOGGER.error("Setting tab component", e);
        }
    }

    /**
     * This creates a button with the specified action, image, and tooltip text. The main issue here is that it doesn't crash if the image is missing (which is just something that happens in real life
     * from time to time). You probably should specify a name on the action just in case.
     *
     * @param resourceClass the calling class. Useful when multiple classloaders are used.
     * @param imageResourceName the image resource
     * @param tooltip the tooltip to display
     * @param action the action to perform
     * @return the button that was created.
     */
    public static JButton createButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JButton button = null;
        if (imageResourceName != null) {
            InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
            if (inputStream != null) {
                try {
                    BufferedImage image = ImageIO.read(inputStream);
                    button = new BorderlessImageButton(action, new ImageIcon(image));
                } catch (IOException e) {
                    LOGGER.error("Reading image " + imageResourceName, e);
                }
            }
        }
        if (button == null) {
            button = new JButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JToggleButton createToggleButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JToggleButton button = null;
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            if (icon != null) {
                button = new BorderlessImageToggleButton(action, icon);
            }
        }
        if (button == null) {
            button = new JToggleButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JMenuItem createMenuItem(Class resourceClass, String name, String imageResourceName, Action action) {
        JMenuItem item = new JMenuItem(action);
        item.setText(name);
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            item.setIcon(icon);
        }
        return item;
    }

    /**
     * this determines if the CTRL key is down based on the modifiers from an event. This actualy needs to be checking for different things. CTRL doesn't meant the same thing on each platform.
     */
    public static boolean isCTRLDown(int eventModifiersEx) {
        return (eventModifiersEx & InputEvent.CTRL_DOWN_MASK) == InputEvent.CTRL_DOWN_MASK;
    }

    public static ImageIcon getImageIcon(Class resourceClass, String imageResourceName) {
        InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
        if (inputStream != null) {
            try {
                BufferedImage image = ImageIO.read(inputStream);
                return new ImageIcon(image);
            } catch (IOException e) {
                LOGGER.error("Reading image " + imageResourceName, e);
            }
        }
        return null;
    }

    /**
     * Scrolls the specified text component so the text between the starting and ending index are visible.
     */
    public static void scrollToText(JTextComponent textComponent, int startingIndex, int endingIndex) {
        try {
            Rectangle startingRectangle = textComponent.modelToView(startingIndex);
            Rectangle endDingRectangle = textComponent.modelToView(endingIndex);
            Rectangle totalBounds = startingRectangle.union(endDingRectangle);
            textComponent.scrollRectToVisible(totalBounds);
            textComponent.repaint();
        } catch (BadLocationException e) {
            e.printStackTrace();
        }
    }
}}'} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/SwingEditFavoriteInteraction.java
Cannot solve method call panel.add(Utility.addLeftJustifiedComponent(alwaysShowOutputCheckBox)) UnsolvedSymbolException{context='Method 'addLeftJustifiedComponent' with parameterTypes [ReferenceType{javax.swing.JCheckBox, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='JavaParserClassDeclaration{wrappedNode=/**
 * Just some utility functions.
 */
public class Utility {

    private static final Logger LOGGER = Logging.getLogger(Utility.class);

    public static Component addLeftJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(component);
        panel.add(Box.createHorizontalGlue());
        return panel;
    }

    public static Component addRightJustifiedComponent(Component component) {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.X_AXIS));
        panel.add(Box.createHorizontalGlue());
        panel.add(component);
        return panel;
    }

    /**
     * This creates a dialog. I only created this because I was using JDK 1.6, then realized I needed to use 1.5 and one of the most useful features of 1.6 is dialogs taking Windows as parents. This
     * abstracts that so I don't have to make major changes to the code by passing around JFrames and JDialogs explicitly.
     *
     * @param parent the parent window
     * @param isModal true if its modal, false if not.
     * @return a dialog
     */
    public static JDialog createDialog(Window parent, String title, boolean isModal) {
        if (parent instanceof JDialog) {
            return new JDialog((JDialog) parent, title, isModal);
        } else if (parent instanceof JFrame) {
            return new JDialog((JFrame) parent, title, isModal);
        }
        throw new RuntimeException("Unknown window type!");
    }

    /**
     * This uses reflection to set the tab component if we're running under 1.6. It does nothing if you're running under 1.5. This is so you can run this on java 1.6 and get this benefit, but its not
     * required to compile.
     *
     * This is the same as calling JTabbedPane.setTabComponentAt(). It just does so using reflection.
     */
    public static void setTabComponent15Compatible(JTabbedPane tabbedPane, int index, Component component) {
        try {
            Method method = tabbedPane.getClass().getMethod("setTabComponentAt", new Class[] { Integer.TYPE, Component.class });
            method.invoke(tabbedPane, index, component);
        } catch (NoSuchMethodException e) {
        // e.printStackTrace();
        // we're not requiring 1.6, so its not a problem if we don't find the method. We just don't get this feature.
        } catch (Exception e) {
            LOGGER.error("Setting tab component", e);
        }
    }

    /**
     * This creates a button with the specified action, image, and tooltip text. The main issue here is that it doesn't crash if the image is missing (which is just something that happens in real life
     * from time to time). You probably should specify a name on the action just in case.
     *
     * @param resourceClass the calling class. Useful when multiple classloaders are used.
     * @param imageResourceName the image resource
     * @param tooltip the tooltip to display
     * @param action the action to perform
     * @return the button that was created.
     */
    public static JButton createButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JButton button = null;
        if (imageResourceName != null) {
            InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
            if (inputStream != null) {
                try {
                    BufferedImage image = ImageIO.read(inputStream);
                    button = new BorderlessImageButton(action, new ImageIcon(image));
                } catch (IOException e) {
                    LOGGER.error("Reading image " + imageResourceName, e);
                }
            }
        }
        if (button == null) {
            button = new JButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JToggleButton createToggleButton(Class resourceClass, String imageResourceName, String tooltip, Action action) {
        JToggleButton button = null;
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            if (icon != null) {
                button = new BorderlessImageToggleButton(action, icon);
            }
        }
        if (button == null) {
            button = new JToggleButton(action);
        }
        if (tooltip != null) {
            button.setToolTipText(tooltip);
        }
        return button;
    }

    public static JMenuItem createMenuItem(Class resourceClass, String name, String imageResourceName, Action action) {
        JMenuItem item = new JMenuItem(action);
        item.setText(name);
        if (imageResourceName != null) {
            ImageIcon icon = getImageIcon(resourceClass, imageResourceName);
            item.setIcon(icon);
        }
        return item;
    }

    /**
     * this determines if the CTRL key is down based on the modifiers from an event. This actualy needs to be checking for different things. CTRL doesn't meant the same thing on each platform.
     */
    public static boolean isCTRLDown(int eventModifiersEx) {
        return (eventModifiersEx & InputEvent.CTRL_DOWN_MASK) == InputEvent.CTRL_DOWN_MASK;
    }

    public static ImageIcon getImageIcon(Class resourceClass, String imageResourceName) {
        InputStream inputStream = resourceClass.getResourceAsStream(imageResourceName);
        if (inputStream != null) {
            try {
                BufferedImage image = ImageIO.read(inputStream);
                return new ImageIcon(image);
            } catch (IOException e) {
                LOGGER.error("Reading image " + imageResourceName, e);
            }
        }
        return null;
    }

    /**
     * Scrolls the specified text component so the text between the starting and ending index are visible.
     */
    public static void scrollToText(JTextComponent textComponent, int startingIndex, int endingIndex) {
        try {
            Rectangle startingRectangle = textComponent.modelToView(startingIndex);
            Rectangle endDingRectangle = textComponent.modelToView(endingIndex);
            Rectangle totalBounds = startingRectangle.union(endDingRectangle);
            textComponent.scrollRectToVisible(totalBounds);
            textComponent.repaint();
        } catch (BadLocationException e) {
            e.printStackTrace();
        }
    }
}}'} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/SwingEditFavoriteInteraction.java
Cannot solve field access SynchronizeType.Never
Cannot resolve field access null
Cannot solve method call KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0) UnsolvedSymbolException{context='unknown', name='VK_ESCAPE', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/SwingEditFavoriteInteraction.java
Cannot solve method call dialog.getRootPane().registerKeyboardAction(new ActionListener() {

    public void actionPerformed(ActionEvent actionEvent) {
        close(false);
    }
}, KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), JComponent.WHEN_IN_FOCUSED_WINDOW) java.lang.RuntimeException: Error calculating the type of parameter KeyEvent.VK_ESCAPE of method call KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0) /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/SwingEditFavoriteInteraction.java
Cannot solve method call JOptionPane.showConfirmDialog(SwingUtilities.getWindowAncestor(parent), "The file '" + file.getAbsolutePath() + "' already exists. Overwrite?", "Confirm Overwriting File", JOptionPane.YES_NO_OPTION) UnsolvedSymbolException{context='Method 'getWindowAncestor' with parameterTypes [ReferenceType{Window, typeParametersMap=TypeParametersMap{nameToValue={}}}]', name='ReflectionClassDeclaration{clazz=javax.swing.SwingUtilities}'} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/SwingExportInteraction.java
Cannot resolve field access null
Cannot solve method call mainPanel.add(createMainGradlePanel(), BorderLayout.CENTER) UnsolvedSymbolException{context='unknown', name='CENTER', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/generic/AbstractGradleUIInstance.java
Cannot resolve field access null
Cannot solve method call childNode.setValueOfChildAsInt(WINDOW_X, p.x) UnsolvedSymbolException{context='unknown', name='x', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/common/PreferencesAssistant.java
Cannot resolve field access null
Cannot solve method call childNode.setValueOfChildAsInt(WINDOW_Y, p.y) UnsolvedSymbolException{context='unknown', name='y', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/common/PreferencesAssistant.java
Cannot resolve field access null
Cannot solve method call childNode.setValueOfChildAsInt(WINDOW_WIDTH, size.width) UnsolvedSymbolException{context='unknown', name='width', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/common/PreferencesAssistant.java
Cannot resolve field access null
Cannot solve method call childNode.setValueOfChildAsInt(WINDOW_HEIGHT, size.height) UnsolvedSymbolException{context='unknown', name='height', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/common/PreferencesAssistant.java
Method 'getLocation' cannot be resolved in context window.getLocation() (line: 80) MethodCallExprContext{wrapped=window.getLocation()}. Parameter types: []
Cannot solve method call childNode.getValueOfChildAsInt(WINDOW_X, window.getLocation().x) java.lang.RuntimeException: Method 'getLocation' cannot be resolved in context window.getLocation() (line: 80) MethodCallExprContext{wrapped=window.getLocation()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/common/PreferencesAssistant.java
Method 'getLocation' cannot be resolved in context window.getLocation() (line: 81) MethodCallExprContext{wrapped=window.getLocation()}. Parameter types: []
Cannot solve method call childNode.getValueOfChildAsInt(WINDOW_Y, window.getLocation().y) java.lang.RuntimeException: Method 'getLocation' cannot be resolved in context window.getLocation() (line: 81) MethodCallExprContext{wrapped=window.getLocation()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/common/PreferencesAssistant.java
Method 'getSize' cannot be resolved in context window.getSize() (line: 82) MethodCallExprContext{wrapped=window.getSize()}. Parameter types: []
Cannot solve method call childNode.getValueOfChildAsInt(WINDOW_WIDTH, window.getSize().width) java.lang.RuntimeException: Method 'getSize' cannot be resolved in context window.getSize() (line: 82) MethodCallExprContext{wrapped=window.getSize()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/common/PreferencesAssistant.java
Method 'getSize' cannot be resolved in context window.getSize() (line: 83) MethodCallExprContext{wrapped=window.getSize()}. Parameter types: []
Cannot solve method call childNode.getValueOfChildAsInt(WINDOW_HEIGHT, window.getSize().height) java.lang.RuntimeException: Method 'getSize' cannot be resolved in context window.getSize() (line: 83) MethodCallExprContext{wrapped=window.getSize()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/common/PreferencesAssistant.java
Cannot resolve field access null
Cannot solve method call mainPanel.add(singlePaneUIInstance.getComponent()) java.lang.RuntimeException: Method 'getComponent' cannot be resolved in context singlePaneUIInstance.getComponent() (line: 98) MethodCallExprContext{wrapped=singlePaneUIInstance.getComponent()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/standalone/Application.java
Cannot solve method call frame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE) UnsolvedSymbolException{context='unknown', name='DO_NOTHING_ON_CLOSE', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/standalone/Application.java
Cannot solve method call fileName.substring(indexOfDot + 1, result.length()) java.lang.RuntimeException: Method 'length' cannot be resolved in context result.length() (line: 250) MethodCallExprContext{wrapped=result.length()}. Parameter types: [] /repo/subprojects/ui/src/main/java/org/gradle/gradleplugin/userinterface/swing/standalone/Application.java
Cannot resolve field access null
Cannot solve field access SwingEditFavoriteInteraction.SynchronizeType.OnlyIfAlreadySynchronized
Cannot resolve field access null
Cannot solve field access SwingEditFavoriteInteraction.SynchronizeType.OnlyIfAlreadySynchronized
Cannot solve method call singlePaneUIInstance.initialize(settingsVersionWrapper, alternateUIInteractionVersionWrapper) UnsolvedSymbolException{context='Solving settingsVersionWrapper', name='settingsVersionWrapper', typeSolver=null} /repo/subprojects/ui/src/main/java/org/gradle/openapi/wrappers/ui/SinglePaneUIWrapper.java
Method 'getGradleUI' cannot be resolved in context getGradleUI() (line: 53) MethodCallExprContext{wrapped=getGradleUI()}. Parameter types: []
Method 'getGradleUI' cannot be resolved in context getGradleUI() (line: 53) MethodCallExprContext{wrapped=getGradleUI()}. Parameter types: []
Method 'getGradleUI' cannot be resolved in context getGradleUI() (line: 62) MethodCallExprContext{wrapped=getGradleUI()}. Parameter types: []
Cannot solve method call "https".equals(address.getScheme()) java.lang.RuntimeException: Method 'getScheme' cannot be resolved in context address.getScheme() (line: 102) MethodCallExprContext{wrapped=address.getScheme()}. Parameter types: [] /repo/subprojects/wrapper/src/main/java/org/gradle/wrapper/Download.java
Method 'loadClass' cannot be resolved in context loader.loadClass("javax.xml.bind.DatatypeConverter") (line: 128) MethodCallExprContext{wrapped=loader.loadClass("javax.xml.bind.DatatypeConverter")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'loadClass' cannot be resolved in context loader.loadClass("java.util.Base64") (line: 122) MethodCallExprContext{wrapped=loader.loadClass("java.util.Base64")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'loadClass' cannot be resolved in context loader.loadClass("java.util.Base64$Encoder") (line: 123) MethodCallExprContext{wrapped=loader.loadClass("java.util.Base64$Encoder")}. Parameter types: [ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}]
Method 'getDistribution' cannot be resolved in context configuration.getDistribution() (line: 72) MethodCallExprContext{wrapped=configuration.getDistribution()}. Parameter types: []
Cannot solve method call verifyDownloadChecksum(configuration.getDistribution().toString(), localZipFile, distributionSha256Sum) java.lang.RuntimeException: Method 'getDistribution' cannot be resolved in context configuration.getDistribution() (line: 72) MethodCallExprContext{wrapped=configuration.getDistribution()}. Parameter types: [] /repo/subprojects/wrapper/src/main/java/org/gradle/wrapper/Install.java
Cannot resolve field access null
Cannot resolve field access null
Cannot solve method call System.getProperty("os.name").toLowerCase(Locale.US) UnsolvedSymbolException{context='unknown', name='US', typeSolver=null} /repo/subprojects/wrapper/src/main/java/org/gradle/wrapper/Install.java
Cannot resolve field access null
Cannot solve method call argument.toString().substring(SYSTEM_PROP_PREFIX.length()) java.lang.RuntimeException: Method 'length' cannot be resolved in context SYSTEM_PROP_PREFIX.length() (line: 47) MethodCallExprContext{wrapped=SYSTEM_PROP_PREFIX.length()}. Parameter types: [] /repo/subprojects/wrapper/src/main/java/org/gradle/wrapper/SystemPropertiesHandler.java
